{
  "version": 3,
  "sources": ["../../fast-deep-equal/index.js", "../../chevrotain/src/version.ts", "../../lodash/_isPrototype.js", "../../lodash/_overArg.js", "../../lodash/_nativeKeys.js", "../../lodash/_baseKeys.js", "../../lodash/_freeGlobal.js", "../../lodash/_root.js", "../../lodash/_Symbol.js", "../../lodash/_getRawTag.js", "../../lodash/_objectToString.js", "../../lodash/_baseGetTag.js", "../../lodash/isObject.js", "../../lodash/isFunction.js", "../../lodash/_coreJsData.js", "../../lodash/_isMasked.js", "../../lodash/_toSource.js", "../../lodash/_baseIsNative.js", "../../lodash/_getValue.js", "../../lodash/_getNative.js", "../../lodash/_DataView.js", "../../lodash/_Map.js", "../../lodash/_Promise.js", "../../lodash/_Set.js", "../../lodash/_WeakMap.js", "../../lodash/_getTag.js", "../../lodash/isObjectLike.js", "../../lodash/_baseIsArguments.js", "../../lodash/isArguments.js", "../../lodash/isArray.js", "../../lodash/isLength.js", "../../lodash/isArrayLike.js", "../../lodash/stubFalse.js", "../../lodash/isBuffer.js", "../../lodash/_baseIsTypedArray.js", "../../lodash/_baseUnary.js", "../../lodash/_nodeUtil.js", "../../lodash/isTypedArray.js", "../../lodash/isEmpty.js", "../../lodash/_arrayMap.js", "../../lodash/_listCacheClear.js", "../../lodash/eq.js", "../../lodash/_assocIndexOf.js", "../../lodash/_listCacheDelete.js", "../../lodash/_listCacheGet.js", "../../lodash/_listCacheHas.js", "../../lodash/_listCacheSet.js", "../../lodash/_ListCache.js", "../../lodash/_stackClear.js", "../../lodash/_stackDelete.js", "../../lodash/_stackGet.js", "../../lodash/_stackHas.js", "../../lodash/_nativeCreate.js", "../../lodash/_hashClear.js", "../../lodash/_hashDelete.js", "../../lodash/_hashGet.js", "../../lodash/_hashHas.js", "../../lodash/_hashSet.js", "../../lodash/_Hash.js", "../../lodash/_mapCacheClear.js", "../../lodash/_isKeyable.js", "../../lodash/_getMapData.js", "../../lodash/_mapCacheDelete.js", "../../lodash/_mapCacheGet.js", "../../lodash/_mapCacheHas.js", "../../lodash/_mapCacheSet.js", "../../lodash/_MapCache.js", "../../lodash/_stackSet.js", "../../lodash/_Stack.js", "../../lodash/_setCacheAdd.js", "../../lodash/_setCacheHas.js", "../../lodash/_SetCache.js", "../../lodash/_arraySome.js", "../../lodash/_cacheHas.js", "../../lodash/_equalArrays.js", "../../lodash/_Uint8Array.js", "../../lodash/_mapToArray.js", "../../lodash/_setToArray.js", "../../lodash/_equalByTag.js", "../../lodash/_arrayPush.js", "../../lodash/_baseGetAllKeys.js", "../../lodash/_arrayFilter.js", "../../lodash/stubArray.js", "../../lodash/_getSymbols.js", "../../lodash/_baseTimes.js", "../../lodash/_isIndex.js", "../../lodash/_arrayLikeKeys.js", "../../lodash/keys.js", "../../lodash/_getAllKeys.js", "../../lodash/_equalObjects.js", "../../lodash/_baseIsEqualDeep.js", "../../lodash/_baseIsEqual.js", "../../lodash/_baseIsMatch.js", "../../lodash/_isStrictComparable.js", "../../lodash/_getMatchData.js", "../../lodash/_matchesStrictComparable.js", "../../lodash/_baseMatches.js", "../../lodash/isSymbol.js", "../../lodash/_isKey.js", "../../lodash/memoize.js", "../../lodash/_memoizeCapped.js", "../../lodash/_stringToPath.js", "../../lodash/_baseToString.js", "../../lodash/toString.js", "../../lodash/_castPath.js", "../../lodash/_toKey.js", "../../lodash/_baseGet.js", "../../lodash/get.js", "../../lodash/_baseHasIn.js", "../../lodash/_hasPath.js", "../../lodash/hasIn.js", "../../lodash/_baseMatchesProperty.js", "../../lodash/identity.js", "../../lodash/_baseProperty.js", "../../lodash/_basePropertyDeep.js", "../../lodash/property.js", "../../lodash/_baseIteratee.js", "../../lodash/_createBaseFor.js", "../../lodash/_baseFor.js", "../../lodash/_baseForOwn.js", "../../lodash/_createBaseEach.js", "../../lodash/_baseEach.js", "../../lodash/_baseMap.js", "../../lodash/map.js", "../../lodash/_arrayEach.js", "../../lodash/_castFunction.js", "../../lodash/forEach.js", "../../lodash/_baseValues.js", "../../lodash/values.js", "../../lodash/_baseHas.js", "../../lodash/has.js", "../../lodash/_defineProperty.js", "../../lodash/_baseAssignValue.js", "../../lodash/_assignValue.js", "../../lodash/_copyObject.js", "../../lodash/_baseAssign.js", "../../lodash/_nativeKeysIn.js", "../../lodash/_baseKeysIn.js", "../../lodash/keysIn.js", "../../lodash/_baseAssignIn.js", "../../lodash/_cloneBuffer.js", "../../lodash/_copyArray.js", "../../lodash/_copySymbols.js", "../../lodash/_getPrototype.js", "../../lodash/_getSymbolsIn.js", "../../lodash/_copySymbolsIn.js", "../../lodash/_getAllKeysIn.js", "../../lodash/_initCloneArray.js", "../../lodash/_cloneArrayBuffer.js", "../../lodash/_cloneDataView.js", "../../lodash/_cloneRegExp.js", "../../lodash/_cloneSymbol.js", "../../lodash/_cloneTypedArray.js", "../../lodash/_initCloneByTag.js", "../../lodash/_baseCreate.js", "../../lodash/_initCloneObject.js", "../../lodash/_baseIsMap.js", "../../lodash/isMap.js", "../../lodash/_baseIsSet.js", "../../lodash/isSet.js", "../../lodash/_baseClone.js", "../../lodash/clone.js", "../../@chevrotain/utils/src/print.ts", "../../@chevrotain/utils/src/timer.ts", "../../@chevrotain/utils/src/to-fast-properties.ts", "../../@chevrotain/utils/src/api.ts", "../../lodash/_baseSlice.js", "../../lodash/_trimmedEndIndex.js", "../../lodash/_baseTrim.js", "../../lodash/toNumber.js", "../../lodash/toFinite.js", "../../lodash/toInteger.js", "../../lodash/drop.js", "../../lodash/isString.js", "../../lodash/_baseIsRegExp.js", "../../lodash/isRegExp.js", "../../lodash/_baseSet.js", "../../lodash/_basePickBy.js", "../../lodash/pickBy.js", "../../lodash/_apply.js", "../../lodash/_overRest.js", "../../lodash/constant.js", "../../lodash/_baseSetToString.js", "../../lodash/_shortOut.js", "../../lodash/_setToString.js", "../../lodash/_baseRest.js", "../../lodash/_isIterateeCall.js", "../../lodash/_createAssigner.js", "../../lodash/assign.js", "../../@chevrotain/gast/src/model.ts", "../../@chevrotain/gast/src/visitor.ts", "../../lodash/_baseSome.js", "../../lodash/some.js", "../../lodash/_arrayEvery.js", "../../lodash/_baseEvery.js", "../../lodash/every.js", "../../lodash/_baseFindIndex.js", "../../lodash/_baseIsNaN.js", "../../lodash/_strictIndexOf.js", "../../lodash/_baseIndexOf.js", "../../lodash/includes.js", "../../@chevrotain/gast/src/helpers.ts", "../../@chevrotain/gast/src/api.ts", "../../chevrotain/src/parse/grammar/rest.ts", "../../lodash/_isFlattenable.js", "../../lodash/_baseFlatten.js", "../../lodash/flatten.js", "../../lodash/_arrayIncludes.js", "../../lodash/_arrayIncludesWith.js", "../../lodash/noop.js", "../../lodash/_createSet.js", "../../lodash/_baseUniq.js", "../../lodash/uniq.js", "../../chevrotain/src/parse/grammar/first.ts", "../../chevrotain/src/parse/constants.ts", "../../chevrotain/src/parse/grammar/follow.ts", "../../lodash/isUndefined.js", "../../regexp-to-ast/lib/regexp-to-ast.js", "../../lodash/head.js", "../../lodash/first.js", "../../lodash/compact.js", "../../lodash/_baseFilter.js", "../../lodash/negate.js", "../../lodash/reject.js", "../../lodash/_baseDifference.js", "../../lodash/isArrayLikeObject.js", "../../lodash/difference.js", "../../lodash/indexOf.js", "../../lodash/_createFind.js", "../../lodash/findIndex.js", "../../lodash/find.js", "../../lodash/filter.js", "../../lodash/defaults.js", "../../lodash/_arrayReduce.js", "../../lodash/_baseReduce.js", "../../lodash/reduce.js", "../../chevrotain/src/scan/reg_exp_parser.ts", "../../chevrotain/src/scan/reg_exp.ts", "../../chevrotain/src/scan/lexer.ts", "../../lodash/last.js", "../../chevrotain/src/scan/tokens.ts", "../../chevrotain/src/scan/lexer_errors_public.ts", "../../chevrotain/src/scan/lexer_public.ts", "../../chevrotain/src/scan/tokens_public.ts", "../../chevrotain/src/parse/errors_public.ts", "../../chevrotain/src/parse/grammar/resolver.ts", "../../lodash/_arrayAggregator.js", "../../lodash/_baseAggregator.js", "../../lodash/_createAggregator.js", "../../lodash/groupBy.js", "../../lodash/flatMap.js", "../../lodash/dropRight.js", "../../chevrotain/src/parse/grammar/interpreter.ts", "../../chevrotain/src/parse/grammar/lookahead.ts", "../../chevrotain/src/parse/grammar/checks.ts", "../../chevrotain/src/parse/grammar/gast/gast_resolver_public.ts", "../../chevrotain/src/parse/exceptions_public.ts", "../../chevrotain/src/parse/parser/traits/recoverable.ts", "../../chevrotain/src/parse/grammar/keys.ts", "../../chevrotain/src/parse/grammar/llk_lookahead.ts", "../../chevrotain/src/parse/parser/traits/looksahead.ts", "../../chevrotain/src/parse/cst/cst.ts", "../../chevrotain/src/lang/lang_extensions.ts", "../../chevrotain/src/parse/cst/cst_visitor.ts", "../../chevrotain/src/parse/parser/traits/tree_builder.ts", "../../chevrotain/src/parse/parser/traits/lexer_adapter.ts", "../../chevrotain/src/parse/parser/traits/recognizer_api.ts", "../../chevrotain/src/parse/parser/traits/recognizer_engine.ts", "../../chevrotain/src/parse/parser/traits/error_handler.ts", "../../chevrotain/src/parse/parser/traits/context_assist.ts", "../../chevrotain/src/parse/parser/traits/gast_recorder.ts", "../../chevrotain/src/parse/parser/traits/perf_tracer.ts", "../../chevrotain/src/parse/parser/utils/apply_mixins.ts", "../../chevrotain/src/parse/parser/parser.ts", "../../@chevrotain/cst-dts-gen/src/model.ts", "../../lodash/_castSlice.js", "../../lodash/_hasUnicode.js", "../../lodash/_asciiToArray.js", "../../lodash/_unicodeToArray.js", "../../lodash/_stringToArray.js", "../../lodash/_createCaseFirst.js", "../../lodash/upperFirst.js", "../../@chevrotain/cst-dts-gen/src/generate.ts", "../../@chevrotain/cst-dts-gen/src/api.ts", "../../chevrotain/src/diagrams/render_public.ts", "../../chevrotain/src/api.ts", "../../@react-three/rapier/dist/react-three-rapier.esm.js", "../../use-asset/dist/index.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/MorphBlendMesh.js", "../../@react-three/rapier/node_modules/three-stdlib/math/ConvexHull.js", "../../@react-three/rapier/node_modules/three-stdlib/geometries/ConvexGeometry.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/ConvexObjectBreaker.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/Gyroscope.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/MorphAnimMesh.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/RollerCoaster.js", "../../@babel/runtime/helpers/esm/typeof.js", "../../@babel/runtime/helpers/esm/toPrimitive.js", "../../@babel/runtime/helpers/esm/toPropertyKey.js", "../../@babel/runtime/helpers/esm/defineProperty.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/VolumeSlice.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/Volume.js", "../../@react-three/rapier/node_modules/three-stdlib/renderers/CSS2DRenderer.js", "../../@react-three/rapier/node_modules/three-stdlib/renderers/CSS3DRenderer.js", "../../@react-three/rapier/node_modules/three-stdlib/renderers/Projector.js", "../../@react-three/rapier/node_modules/three-stdlib/renderers/SVGRenderer.js", "../../@react-three/rapier/node_modules/three-stdlib/modifiers/CurveModifier.js", "../../@react-three/rapier/node_modules/three-stdlib/utils/BufferGeometryUtils.js", "../../@react-three/rapier/node_modules/three-stdlib/modifiers/SimplifyModifier.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/constants.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeUtils.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/Node.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/InputNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/UniformNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/ArrayUniformNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/VaryNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/AttributeNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/BypassNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/CodeNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/ConstNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/ContextNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/TempNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/ExpressionNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeAttribute.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeUniform.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeVary.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeVar.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeBuilder.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeFunctionInput.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/PropertyNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/VarNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/BufferNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/Object3DNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/CameraNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/UVNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/TextureNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/ModelNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/utils/JoinNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/utils/SplitNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/math/OperatorNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/math/MathNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/PositionNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/NormalNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/math/CondNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/utils/ArrayElementNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/utils/ConvertNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/ShaderNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/ReflectNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/CubeTextureNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/ReferenceNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/MaterialReferenceNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/MaterialNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/PointUVNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/SkinningNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/display/ColorSpaceNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/display/NormalMapNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/functions/BSDFs.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/utils/TimerNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/utils/OscNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/procedural/CheckerNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/fog/FogNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/fog/FogRangeNode.js", "../../@react-three/rapier/node_modules/three-stdlib/exporters/GLTFExporter.js", "../../@react-three/rapier/node_modules/three-stdlib/exporters/DRACOExporter.js", "../../@react-three/rapier/node_modules/three-stdlib/animation/AnimationClipCreator.js", "../../@react-three/rapier/node_modules/three-stdlib/animation/CCDIKSolver.js", "../../@react-three/rapier/node_modules/three-stdlib/animation/MMDPhysics.js", "../../@react-three/rapier/node_modules/three-stdlib/animation/MMDAnimationHelper.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/Reflector.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/Refractor.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/ShadowMesh.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/Lensflare.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/Water.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/MarchingCubes.js", "../../@react-three/rapier/node_modules/three-stdlib/math/SimplexNoise.js", "../../@react-three/rapier/node_modules/three-stdlib/geometries/LightningStrike.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/LightningStorm.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/ReflectorForSSRPass.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/Sky.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/Water2.js", "../../@react-three/rapier/node_modules/three-stdlib/utils/RoughnessMipmapper.js", "../../@react-three/rapier/node_modules/three-stdlib/utils/SkeletonUtils.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/UnpackDepthRGBAShader.js", "../../@react-three/rapier/node_modules/three-stdlib/utils/ShadowMapViewer.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/BokehShader2.js", "../../@react-three/rapier/node_modules/three-stdlib/math/MeshSurfaceSampler.js", "../../@react-three/rapier/node_modules/three-stdlib/math/OBB.js", "../../@react-three/rapier/node_modules/three-stdlib/math/Capsule.js", "../../@react-three/rapier/node_modules/three-stdlib/math/ColorConverter.js", "../../@react-three/rapier/node_modules/three-stdlib/math/Octree.js", "../../@react-three/rapier/node_modules/three-stdlib/math/Lut.js", "../../@react-three/rapier/node_modules/three-stdlib/controls/experimental/CameraControls.js", "../../@react-three/rapier/node_modules/three-stdlib/controls/FirstPersonControls.js", "../../@react-three/rapier/node_modules/three-stdlib/controls/PointerLockControls.js", "../../@react-three/rapier/node_modules/three-stdlib/controls/ArcballControls.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/Pass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/HalftoneShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SMAAShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/FilmShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/CopyShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SSAOShader.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/SSAOPass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/BokehShader.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/TexturePass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/LuminosityShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ToneMapShader.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/AdaptiveToneMappingPass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/LuminosityHighPassShader.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/UnrealBloomPass.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/CubeTexturePass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SAOShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/SAOPass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/AfterimageShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/DotScreenShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SSRShader.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/SSRPass.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/SSAARenderPass.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/TAARenderPass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ConvolutionShader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/GLTFLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/webxr/OculusHandPointerModel.js", "../../@react-three/rapier/node_modules/three-stdlib/webxr/VRButton.js", "../../@react-three/rapier/node_modules/three-stdlib/libs/MotionControllers.js", "../../@react-three/rapier/node_modules/three-stdlib/webxr/XRHandPrimitiveModel.js", "../../@react-three/rapier/node_modules/three-stdlib/geometries/ParametricGeometry.js", "../../@react-three/rapier/node_modules/three-stdlib/geometries/ParametricGeometries.js", "../../@react-three/rapier/node_modules/three-stdlib/geometries/RoundedBoxGeometry.js", "../../@react-three/rapier/node_modules/three-stdlib/csm/CSMFrustum.js", "../../@react-three/rapier/node_modules/three-stdlib/csm/CSMShader.js", "../../@react-three/rapier/node_modules/three-stdlib/csm/CSM.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ACESFilmicToneMappingShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/BasicShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/BleachBypassShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/BlendShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/BrightnessContrastShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ColorCorrectionShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ColorifyShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/DOFMipMapShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/FXAAShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/FocusShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/FreiChenShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/FresnelShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/GammaCorrectionShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/GodRaysShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/HorizontalBlurShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/HorizontalTiltShiftShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/HueSaturationShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/KaleidoShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/MirrorShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/NormalMapShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ParallaxShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/PixelShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/RGBShiftShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SepiaShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SobelOperatorShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SubsurfaceScatteringShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/TechnicolorShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ToonShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/TriangleBlurShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/VerticalBlurShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/VerticalTiltShiftShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/VignetteShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/VolumeShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/WaterRefractionShader.js", "../../@react-three/rapier/node_modules/three-stdlib/interactive/InteractiveGroup.js", "../../@react-three/rapier/node_modules/three-stdlib/interactive/SelectionHelper.js", "../../@react-three/rapier/node_modules/three-stdlib/interactive/SelectionBox.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/FBXLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/FontLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/XLoader.js", "../../chevrotain/lib_esm/api_esm.mjs", "../../@react-three/rapier/node_modules/three-stdlib/utils/WorkerPool.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/KTX2Loader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/AssimpLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/BasisTextureLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/LDrawLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/lwo/LWO3Parser.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/lwo/LWO2Parser.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/lwo/IFFParser.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/OBJLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/KTXLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/RGBMLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/lines/LineSegmentsGeometry.js", "../../@react-three/rapier/node_modules/three-stdlib/lines/LineMaterial.js", "../../@react-three/rapier/node_modules/three-stdlib/lines/Wireframe.js", "../../@react-three/rapier/node_modules/three-stdlib/lines/LineSegments2.js", "../../@react-three/rapier/node_modules/three-stdlib/helpers/VertexTangentsHelper.js", "../../@react-three/rapier/node_modules/three-stdlib/helpers/VertexNormalsHelper.js", "../../@react-three/rapier/node_modules/three-stdlib/deprecated/Geometry.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/materials/NodeMaterial.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/materials/LineBasicNodeMaterial.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/materials/MeshBasicNodeMaterial.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/materials/MeshStandardNodeMaterial.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/materials/PointsNodeMaterial.js"],
  "sourcesContent": ["'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "// needs a separate module as this is required inside chevrotain productive code\n// and also in the entry point for webpack(api.ts).\n// A separate file avoids cyclic dependencies and webpack errors.\nexport const VERSION = \"10.5.0\"\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n", "/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n", "var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n", "var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n", "/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n", "var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n", "var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n", "var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n", "var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n", "/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n", "var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n", "var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n", "/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n", "var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n", "/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n", "var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n", "var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n", "var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n", "/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n", "var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n", "/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n", "/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n", "var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n", "/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n", "var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n", "var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n", "/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n", "var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n", "var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n", "var baseKeys = require('./_baseKeys'),\n    getTag = require('./_getTag'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLike = require('./isArrayLike'),\n    isBuffer = require('./isBuffer'),\n    isPrototype = require('./_isPrototype'),\n    isTypedArray = require('./isTypedArray');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `value` is an empty object, collection, map, or set.\n *\n * Objects are considered empty if they have no own enumerable string keyed\n * properties.\n *\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n * jQuery-like collections are considered empty if they have a `length` of `0`.\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) &&\n      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n    return !value.length;\n  }\n  var tag = getTag(value);\n  if (tag == mapTag || tag == setTag) {\n    return !value.size;\n  }\n  if (isPrototype(value)) {\n    return !baseKeys(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = isEmpty;\n", "/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n", "/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n", "/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n", "var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n", "var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n", "var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n", "var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n", "var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n", "var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n", "var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n", "/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n", "/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n", "/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n", "var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n", "var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n", "/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n", "var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n", "var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n", "var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n", "var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n", "var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n", "/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n", "var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n", "var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n", "var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n", "var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n", "var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n", "var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n", "var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n", "var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n", "/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n", "/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n", "var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n", "/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n", "/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n", "var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Check that cyclic values are equal.\n  var arrStacked = stack.get(array);\n  var othStacked = stack.get(other);\n  if (arrStacked && othStacked) {\n    return arrStacked == other && othStacked == array;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n", "var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n", "/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n", "/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n", "var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n", "/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n", "var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n", "/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n", "/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n", "var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n", "/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n", "/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n", "var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n", "var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n", "var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n", "var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Check that cyclic values are equal.\n  var objStacked = stack.get(object);\n  var othStacked = stack.get(other);\n  if (objStacked && othStacked) {\n    return objStacked == other && othStacked == object;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n", "var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n", "var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n", "var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n", "var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n", "var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n", "/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n", "var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n", "var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n", "var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n", "var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n", "var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n", "var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n", "var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n", "var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n", "var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n", "var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n", "var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n", "/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n", "var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n", "var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n", "var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n", "/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n", "/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n", "var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n", "var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n", "var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n", "/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n", "var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n", "var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n", "var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n", "var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n", "var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n", "var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    isArray = require('./isArray');\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n", "/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n", "var identity = require('./identity');\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n", "var arrayEach = require('./_arrayEach'),\n    baseEach = require('./_baseEach'),\n    castFunction = require('./_castFunction'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n", "var arrayMap = require('./_arrayMap');\n\n/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  return arrayMap(props, function(key) {\n    return object[key];\n  });\n}\n\nmodule.exports = baseValues;\n", "var baseValues = require('./_baseValues'),\n    keys = require('./keys');\n\n/**\n * Creates an array of the own enumerable string keyed property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return object == null ? [] : baseValues(object, keys(object));\n}\n\nmodule.exports = values;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.has` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHas(object, key) {\n  return object != null && hasOwnProperty.call(object, key);\n}\n\nmodule.exports = baseHas;\n", "var baseHas = require('./_baseHas'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct property of `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = { 'a': { 'b': 2 } };\n * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.has(object, 'a');\n * // => true\n *\n * _.has(object, 'a.b');\n * // => true\n *\n * _.has(object, ['a', 'b']);\n * // => true\n *\n * _.has(other, 'a');\n * // => false\n */\nfunction has(object, path) {\n  return object != null && hasPath(object, path, baseHas);\n}\n\nmodule.exports = has;\n", "var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n", "var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n", "var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n", "var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n", "var copyObject = require('./_copyObject'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n", "/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n", "var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n", "var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n", "var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n", "var root = require('./_root');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n", "/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n", "var copyObject = require('./_copyObject'),\n    getSymbols = require('./_getSymbols');\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n", "var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n", "var arrayPush = require('./_arrayPush'),\n    getPrototype = require('./_getPrototype'),\n    getSymbols = require('./_getSymbols'),\n    stubArray = require('./stubArray');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n", "var copyObject = require('./_copyObject'),\n    getSymbolsIn = require('./_getSymbolsIn');\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n", "var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbolsIn = require('./_getSymbolsIn'),\n    keysIn = require('./keysIn');\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n", "var Uint8Array = require('./_Uint8Array');\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n", "var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n", "/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n", "var Symbol = require('./_Symbol');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n", "var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n", "var cloneArrayBuffer = require('./_cloneArrayBuffer'),\n    cloneDataView = require('./_cloneDataView'),\n    cloneRegExp = require('./_cloneRegExp'),\n    cloneSymbol = require('./_cloneSymbol'),\n    cloneTypedArray = require('./_cloneTypedArray');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n", "var isObject = require('./isObject');\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n", "var baseCreate = require('./_baseCreate'),\n    getPrototype = require('./_getPrototype'),\n    isPrototype = require('./_isPrototype');\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n", "var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n", "var baseIsMap = require('./_baseIsMap'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n", "var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n", "var baseIsSet = require('./_baseIsSet'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n", "var Stack = require('./_Stack'),\n    arrayEach = require('./_arrayEach'),\n    assignValue = require('./_assignValue'),\n    baseAssign = require('./_baseAssign'),\n    baseAssignIn = require('./_baseAssignIn'),\n    cloneBuffer = require('./_cloneBuffer'),\n    copyArray = require('./_copyArray'),\n    copySymbols = require('./_copySymbols'),\n    copySymbolsIn = require('./_copySymbolsIn'),\n    getAllKeys = require('./_getAllKeys'),\n    getAllKeysIn = require('./_getAllKeysIn'),\n    getTag = require('./_getTag'),\n    initCloneArray = require('./_initCloneArray'),\n    initCloneByTag = require('./_initCloneByTag'),\n    initCloneObject = require('./_initCloneObject'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isMap = require('./isMap'),\n    isObject = require('./isObject'),\n    isSet = require('./isSet'),\n    keys = require('./keys'),\n    keysIn = require('./keysIn');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n", "var baseClone = require('./_baseClone');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = clone;\n", "export function PRINT_ERROR(msg: string) {\n  /* istanbul ignore else - can't override global.console in node.js */\n  if (console && console.error) {\n    console.error(`Error: ${msg}`)\n  }\n}\n\nexport function PRINT_WARNING(msg: string) {\n  /* istanbul ignore else - can't override global.console in node.js*/\n  if (console && console.warn) {\n    // TODO: modify docs accordingly\n    console.warn(`Warning: ${msg}`)\n  }\n}\n", "export function timer<T>(func: () => T): { time: number; value: T } {\n  const start = new Date().getTime()\n  const val = func()\n  const end = new Date().getTime()\n  const total = end - start\n  return { time: total, value: val }\n}\n", "// based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\nexport function toFastProperties(toBecomeFast: any) {\n  function FakeConstructor() {}\n\n  // If our object is used as a constructor it would receive\n  FakeConstructor.prototype = toBecomeFast\n  const fakeInstance = new (FakeConstructor as any)()\n\n  function fakeAccess() {\n    return typeof fakeInstance.bar\n  }\n\n  // help V8 understand this is a \"real\" prototype by actually using\n  // the fake instance.\n  fakeAccess()\n  fakeAccess()\n\n  // Always true condition to suppress the Firefox warning of unreachable\n  // code after a return statement.\n  if (1) return toBecomeFast\n\n  // Eval prevents optimization of this method (even though this is dead code)\n  /* istanbul ignore next */\n  // tslint:disable-next-line\n  eval(toBecomeFast)\n}\n", "export { PRINT_WARNING, PRINT_ERROR } from \"./print\"\nexport { timer } from \"./timer\"\nexport { toFastProperties } from \"./to-fast-properties\"\n", "/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n", "/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n", "var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n", "var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n", "var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n", "var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n", "var baseSlice = require('./_baseSlice'),\n    toInteger = require('./toInteger');\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the beginning.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.drop([1, 2, 3]);\n * // => [2, 3]\n *\n * _.drop([1, 2, 3], 2);\n * // => [3]\n *\n * _.drop([1, 2, 3], 5);\n * // => []\n *\n * _.drop([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction drop(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  return baseSlice(array, n < 0 ? 0 : n, length);\n}\n\nmodule.exports = drop;\n", "var baseGetTag = require('./_baseGetTag'),\n    isArray = require('./isArray'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nmodule.exports = isString;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObjectLike(value) && baseGetTag(value) == regexpTag;\n}\n\nmodule.exports = baseIsRegExp;\n", "var baseIsRegExp = require('./_baseIsRegExp'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nmodule.exports = isRegExp;\n", "var assignValue = require('./_assignValue'),\n    castPath = require('./_castPath'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject(object)) {\n    return object;\n  }\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]),\n        newValue = value;\n\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n      return object;\n    }\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject(objValue)\n          ? objValue\n          : (isIndex(path[index + 1]) ? [] : {});\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\nmodule.exports = baseSet;\n", "var baseGet = require('./_baseGet'),\n    baseSet = require('./_baseSet'),\n    castPath = require('./_castPath');\n\n/**\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @param {Function} predicate The function invoked per property.\n * @returns {Object} Returns the new object.\n */\nfunction basePickBy(object, paths, predicate) {\n  var index = -1,\n      length = paths.length,\n      result = {};\n\n  while (++index < length) {\n    var path = paths[index],\n        value = baseGet(object, path);\n\n    if (predicate(value, path)) {\n      baseSet(result, castPath(path, object), value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = basePickBy;\n", "var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    basePickBy = require('./_basePickBy'),\n    getAllKeysIn = require('./_getAllKeysIn');\n\n/**\n * Creates an object composed of the `object` properties `predicate` returns\n * truthy for. The predicate is invoked with two arguments: (value, key).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The source object.\n * @param {Function} [predicate=_.identity] The function invoked per property.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pickBy(object, _.isNumber);\n * // => { 'a': 1, 'c': 3 }\n */\nfunction pickBy(object, predicate) {\n  if (object == null) {\n    return {};\n  }\n  var props = arrayMap(getAllKeysIn(object), function(prop) {\n    return [prop];\n  });\n  predicate = baseIteratee(predicate);\n  return basePickBy(object, props, function(value, path) {\n    return predicate(value, path[0]);\n  });\n}\n\nmodule.exports = pickBy;\n", "/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n", "var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n", "/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n", "var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n", "/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n", "var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n", "var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n", "var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n", "var baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n", "var assignValue = require('./_assignValue'),\n    copyObject = require('./_copyObject'),\n    createAssigner = require('./_createAssigner'),\n    isArrayLike = require('./isArrayLike'),\n    isPrototype = require('./_isPrototype'),\n    keys = require('./keys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own enumerable string keyed properties of source objects to the\n * destination object. Source objects are applied from left to right.\n * Subsequent sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object` and is loosely based on\n * [`Object.assign`](https://mdn.io/Object/assign).\n *\n * @static\n * @memberOf _\n * @since 0.10.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.assignIn\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * function Bar() {\n *   this.c = 3;\n * }\n *\n * Foo.prototype.b = 2;\n * Bar.prototype.d = 4;\n *\n * _.assign({ 'a': 0 }, new Foo, new Bar);\n * // => { 'a': 1, 'c': 3 }\n */\nvar assign = createAssigner(function(object, source) {\n  if (isPrototype(source) || isArrayLike(source)) {\n    copyObject(source, keys(source), object);\n    return;\n  }\n  for (var key in source) {\n    if (hasOwnProperty.call(source, key)) {\n      assignValue(object, key, source[key]);\n    }\n  }\n});\n\nmodule.exports = assign;\n", "import map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport isString from \"lodash/isString\"\nimport isRegExp from \"lodash/isRegExp\"\nimport pickBy from \"lodash/pickBy\"\nimport assign from \"lodash/assign\"\nimport {\n  IGASTVisitor,\n  IProduction,\n  IProductionWithOccurrence,\n  ISerializedGast,\n  TokenType\n} from \"@chevrotain/types\"\n\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction tokenLabel(tokType: TokenType): string {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL\n  } else {\n    return tokType.name\n  }\n}\n\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction hasTokenLabel(\n  obj: TokenType\n): obj is TokenType & Pick<Required<TokenType>, \"LABEL\"> {\n  return isString(obj.LABEL) && obj.LABEL !== \"\"\n}\n\nexport abstract class AbstractProduction<T extends IProduction = IProduction>\n  implements IProduction\n{\n  public get definition(): T[] {\n    return this._definition\n  }\n  public set definition(value: T[]) {\n    this._definition = value\n  }\n\n  constructor(protected _definition: T[]) {}\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n    forEach(this.definition, (prod) => {\n      prod.accept(visitor)\n    })\n  }\n}\n\nexport class NonTerminal\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public nonTerminalName!: string\n  public label?: string\n  public referencedRule!: Rule\n  public idx: number = 1\n\n  constructor(options: {\n    nonTerminalName: string\n    label?: string\n    referencedRule?: Rule\n    idx?: number\n  }) {\n    super([])\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n\n  set definition(definition: IProduction[]) {\n    // immutable\n  }\n\n  get definition(): IProduction[] {\n    if (this.referencedRule !== undefined) {\n      return this.referencedRule.definition\n    }\n    return []\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n    // don't visit children of a reference, we will get cyclic infinite loops if we do so\n  }\n}\n\nexport class Rule extends AbstractProduction {\n  public name!: string\n  public orgText: string = \"\"\n\n  constructor(options: {\n    name: string\n    definition: IProduction[]\n    orgText?: string\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Alternative extends AbstractProduction {\n  public ignoreAmbiguities: boolean = false\n\n  constructor(options: {\n    definition: IProduction[]\n    ignoreAmbiguities?: boolean\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Option\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionMandatory\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionMandatoryWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    separator: TokenType\n    idx?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Repetition\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    idx?: number\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class RepetitionWithSeparator\n  extends AbstractProduction\n  implements IProductionWithOccurrence\n{\n  public separator!: TokenType\n  public idx: number = 1\n  public maxLookahead?: number\n\n  constructor(options: {\n    definition: IProduction[]\n    separator: TokenType\n    idx?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Alternation\n  extends AbstractProduction<Alternative>\n  implements IProductionWithOccurrence\n{\n  public idx: number = 1\n  public ignoreAmbiguities: boolean = false\n  public hasPredicates: boolean = false\n  public maxLookahead?: number\n\n  public get definition(): Alternative[] {\n    return this._definition\n  }\n  public set definition(value: Alternative[]) {\n    this._definition = value\n  }\n\n  constructor(options: {\n    definition: Alternative[]\n    idx?: number\n    ignoreAmbiguities?: boolean\n    hasPredicates?: boolean\n    maxLookahead?: number\n  }) {\n    super(options.definition)\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n}\n\nexport class Terminal implements IProductionWithOccurrence {\n  public terminalType!: TokenType\n  public label?: string\n  public idx: number = 1\n\n  constructor(options: {\n    terminalType: TokenType\n    label?: string\n    idx?: number\n  }) {\n    assign(\n      this,\n      pickBy(options, (v) => v !== undefined)\n    )\n  }\n\n  accept(visitor: IGASTVisitor): void {\n    visitor.visit(this)\n  }\n}\n\nexport interface ISerializedBasic extends ISerializedGast {\n  type:\n    | \"Alternative\"\n    | \"Option\"\n    | \"RepetitionMandatory\"\n    | \"Repetition\"\n    | \"Alternation\"\n  idx?: number\n}\n\nexport interface ISerializedGastRule extends ISerializedGast {\n  type: \"Rule\"\n  name: string\n  orgText: string\n}\n\nexport interface ISerializedNonTerminal extends ISerializedGast {\n  type: \"NonTerminal\"\n  name: string\n  label?: string\n  idx: number\n}\n\nexport interface ISerializedTerminal extends ISerializedGast {\n  type: \"Terminal\"\n  name: string\n  terminalLabel?: string\n  label?: string\n  pattern?: string\n  idx: number\n}\n\nexport interface ISerializedTerminalWithSeparator extends ISerializedGast {\n  type: \"RepetitionMandatoryWithSeparator\" | \"RepetitionWithSeparator\"\n  idx: number\n  separator: ISerializedTerminal\n}\n\nexport type ISerializedGastAny =\n  | ISerializedBasic\n  | ISerializedGastRule\n  | ISerializedNonTerminal\n  | ISerializedTerminal\n  | ISerializedTerminalWithSeparator\n\nexport function serializeGrammar(topRules: Rule[]): ISerializedGast[] {\n  return map(topRules, serializeProduction)\n}\n\nexport function serializeProduction(node: IProduction): ISerializedGast {\n  function convertDefinition(definition: IProduction[]): ISerializedGast[] {\n    return map(definition, serializeProduction)\n  }\n  /* istanbul ignore else */\n  if (node instanceof NonTerminal) {\n    const serializedNonTerminal: ISerializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    }\n\n    if (isString(node.label)) {\n      serializedNonTerminal.label = node.label\n    }\n\n    return serializedNonTerminal\n  } else if (node instanceof Alternative) {\n    return <ISerializedBasic>{\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Option) {\n    return <ISerializedBasic>{\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionMandatory) {\n    return <ISerializedBasic>{\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof RepetitionWithSeparator) {\n    return <ISerializedTerminalWithSeparator>{\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: <ISerializedTerminal>(\n        serializeProduction(new Terminal({ terminalType: node.separator }))\n      ),\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Repetition) {\n    return <ISerializedBasic>{\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Alternation) {\n    return <ISerializedBasic>{\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    }\n  } else if (node instanceof Terminal) {\n    const serializedTerminal = <ISerializedTerminal>{\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel(node.terminalType),\n      idx: node.idx\n    }\n\n    if (isString(node.label)) {\n      serializedTerminal.terminalLabel = node.label\n    }\n\n    const pattern = node.terminalType.PATTERN\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = isRegExp(pattern)\n        ? (<any>pattern).source\n        : pattern\n    }\n\n    return serializedTerminal\n  } else if (node instanceof Rule) {\n    return <ISerializedGastRule>{\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    }\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n", "import {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"./model\"\nimport { IProduction } from \"@chevrotain/types\"\n\nexport abstract class GAstVisitor {\n  public visit(node: IProduction): any {\n    const nodeAny: any = node\n    switch (nodeAny.constructor) {\n      case NonTerminal:\n        return this.visitNonTerminal(nodeAny)\n      case Alternative:\n        return this.visitAlternative(nodeAny)\n      case Option:\n        return this.visitOption(nodeAny)\n      case RepetitionMandatory:\n        return this.visitRepetitionMandatory(nodeAny)\n      case RepetitionMandatoryWithSeparator:\n        return this.visitRepetitionMandatoryWithSeparator(nodeAny)\n      case RepetitionWithSeparator:\n        return this.visitRepetitionWithSeparator(nodeAny)\n      case Repetition:\n        return this.visitRepetition(nodeAny)\n      case Alternation:\n        return this.visitAlternation(nodeAny)\n      case Terminal:\n        return this.visitTerminal(nodeAny)\n      case Rule:\n        return this.visitRule(nodeAny)\n      /* istanbul ignore next */\n      default:\n        throw Error(\"non exhaustive match\")\n    }\n  }\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitNonTerminal(node: NonTerminal): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitAlternative(node: Alternative): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitOption(node: Option): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitRepetition(node: Repetition): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitRepetitionMandatory(node: RepetitionMandatory): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator\n  ): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitAlternation(node: Alternation): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitTerminal(node: Terminal): any {}\n\n  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */\n  public visitRule(node: Rule): any {}\n}\n", "var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.some` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction baseSome(collection, predicate) {\n  var result;\n\n  baseEach(collection, function(value, index, collection) {\n    result = predicate(value, index, collection);\n    return !result;\n  });\n  return !!result;\n}\n\nmodule.exports = baseSome;\n", "var arraySome = require('./_arraySome'),\n    baseIteratee = require('./_baseIteratee'),\n    baseSome = require('./_baseSome'),\n    isArray = require('./isArray'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Checks if `predicate` returns truthy for **any** element of `collection`.\n * Iteration is stopped once `predicate` returns truthy. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n * @example\n *\n * _.some([null, 0, 'yes', false], Boolean);\n * // => true\n *\n * var users = [\n *   { 'user': 'barney', 'active': true },\n *   { 'user': 'fred',   'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.some(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.some(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.some(users, 'active');\n * // => true\n */\nfunction some(collection, predicate, guard) {\n  var func = isArray(collection) ? arraySome : baseSome;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = some;\n", "/**\n * A specialized version of `_.every` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n */\nfunction arrayEvery(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = arrayEvery;\n", "var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.every` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`\n */\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  baseEach(collection, function(value, index, collection) {\n    result = !!predicate(value, index, collection);\n    return result;\n  });\n  return result;\n}\n\nmodule.exports = baseEvery;\n", "var arrayEvery = require('./_arrayEvery'),\n    baseEvery = require('./_baseEvery'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Checks if `predicate` returns truthy for **all** elements of `collection`.\n * Iteration is stopped once `predicate` returns falsey. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * **Note:** This method returns `true` for\n * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n * elements of empty collections.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n * @example\n *\n * _.every([true, 1, null, 'yes'], Boolean);\n * // => false\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.every(users, { 'user': 'barney', 'active': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.every(users, ['active', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.every(users, 'active');\n * // => false\n */\nfunction every(collection, predicate, guard) {\n  var func = isArray(collection) ? arrayEvery : baseEvery;\n  if (guard && isIterateeCall(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = every;\n", "/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n", "/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n", "/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n", "var baseFindIndex = require('./_baseFindIndex'),\n    baseIsNaN = require('./_baseIsNaN'),\n    strictIndexOf = require('./_strictIndexOf');\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n", "var baseIndexOf = require('./_baseIndexOf'),\n    isArrayLike = require('./isArrayLike'),\n    isString = require('./isString'),\n    toInteger = require('./toInteger'),\n    values = require('./values');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Checks if `value` is in `collection`. If `collection` is a string, it's\n * checked for a substring of `value`, otherwise\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * is used for equality comparisons. If `fromIndex` is negative, it's used as\n * the offset from the end of `collection`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n * @returns {boolean} Returns `true` if `value` is found, else `false`.\n * @example\n *\n * _.includes([1, 2, 3], 1);\n * // => true\n *\n * _.includes([1, 2, 3], 1, 2);\n * // => false\n *\n * _.includes({ 'a': 1, 'b': 2 }, 1);\n * // => true\n *\n * _.includes('abcd', 'bc');\n * // => true\n */\nfunction includes(collection, value, fromIndex, guard) {\n  collection = isArrayLike(collection) ? collection : values(collection);\n  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n  var length = collection.length;\n  if (fromIndex < 0) {\n    fromIndex = nativeMax(length + fromIndex, 0);\n  }\n  return isString(collection)\n    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n}\n\nmodule.exports = includes;\n", "import some from \"lodash/some\"\nimport every from \"lodash/every\"\nimport has from \"lodash/has\"\nimport includes from \"lodash/includes\"\nimport {\n  AbstractProduction,\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"./model\"\nimport { GAstVisitor } from \"./visitor\"\nimport { IProduction, IProductionWithOccurrence } from \"@chevrotain/types\"\n\nexport function isSequenceProd(\n  prod: IProduction\n): prod is { definition: IProduction[] } & IProduction {\n  return (\n    prod instanceof Alternative ||\n    prod instanceof Option ||\n    prod instanceof Repetition ||\n    prod instanceof RepetitionMandatory ||\n    prod instanceof RepetitionMandatoryWithSeparator ||\n    prod instanceof RepetitionWithSeparator ||\n    prod instanceof Terminal ||\n    prod instanceof Rule\n  )\n}\n\nexport function isOptionalProd(\n  prod: IProduction,\n  alreadyVisited: NonTerminal[] = []\n): boolean {\n  const isDirectlyOptional =\n    prod instanceof Option ||\n    prod instanceof Repetition ||\n    prod instanceof RepetitionWithSeparator\n  if (isDirectlyOptional) {\n    return true\n  }\n\n  // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n  // empty optional top rule\n  // may be indirectly optional ((A?B?C?) | (D?E?F?))\n  if (prod instanceof Alternation) {\n    // for OR its enough for just one of the alternatives to be optional\n    return some((<Alternation>prod).definition, (subProd: IProduction) => {\n      return isOptionalProd(subProd, alreadyVisited)\n    })\n  } else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n    // avoiding stack overflow due to infinite recursion\n    return false\n  } else if (prod instanceof AbstractProduction) {\n    if (prod instanceof NonTerminal) {\n      alreadyVisited.push(prod)\n    }\n    return every(\n      (<AbstractProduction>prod).definition,\n      (subProd: IProduction) => {\n        return isOptionalProd(subProd, alreadyVisited)\n      }\n    )\n  } else {\n    return false\n  }\n}\n\nexport function isBranchingProd(\n  prod: IProduction\n): prod is { definition: IProduction[] } & IProduction {\n  return prod instanceof Alternation\n}\n\nexport function getProductionDslName(prod: IProductionWithOccurrence): string {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    return \"SUBRULE\"\n  } else if (prod instanceof Option) {\n    return \"OPTION\"\n  } else if (prod instanceof Alternation) {\n    return \"OR\"\n  } else if (prod instanceof RepetitionMandatory) {\n    return \"AT_LEAST_ONE\"\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return \"AT_LEAST_ONE_SEP\"\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return \"MANY_SEP\"\n  } else if (prod instanceof Repetition) {\n    return \"MANY\"\n  } else if (prod instanceof Terminal) {\n    return \"CONSUME\"\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n", "export {\n  Rule,\n  Terminal,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Alternation,\n  Alternative,\n  serializeGrammar,\n  serializeProduction\n} from \"./model\"\n\nexport { GAstVisitor } from \"./visitor\"\n\nexport {\n  getProductionDslName,\n  isOptionalProd,\n  isBranchingProd,\n  isSequenceProd\n} from \"./helpers\"\n", "import drop from \"lodash/drop\"\nimport forEach from \"lodash/forEach\"\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal\n} from \"@chevrotain/gast\"\nimport { IProduction } from \"@chevrotain/types\"\n\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nexport abstract class RestWalker {\n  walk(prod: { definition: IProduction[] }, prevRest: any[] = []): void {\n    forEach(prod.definition, (subProd: IProduction, index) => {\n      const currRest = drop(prod.definition, index + 1)\n      /* istanbul ignore else */\n      if (subProd instanceof NonTerminal) {\n        this.walkProdRef(subProd, currRest, prevRest)\n      } else if (subProd instanceof Terminal) {\n        this.walkTerminal(subProd, currRest, prevRest)\n      } else if (subProd instanceof Alternative) {\n        this.walkFlat(subProd, currRest, prevRest)\n      } else if (subProd instanceof Option) {\n        this.walkOption(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionMandatory) {\n        this.walkAtLeastOne(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        this.walkAtLeastOneSep(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        this.walkManySep(subProd, currRest, prevRest)\n      } else if (subProd instanceof Repetition) {\n        this.walkMany(subProd, currRest, prevRest)\n      } else if (subProd instanceof Alternation) {\n        this.walkOr(subProd, currRest, prevRest)\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    })\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {}\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {}\n\n  walkFlat(\n    flatProd: Alternative,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABCDEF => after the D the rest is EF\n    const fullOrRest = currRest.concat(prevRest)\n    this.walk(flatProd, <any>fullOrRest)\n  }\n\n  walkOption(\n    optionProd: Option,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    const fullOrRest = currRest.concat(prevRest)\n    this.walk(optionProd, <any>fullOrRest)\n  }\n\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    const fullAtLeastOneRest: IProduction[] = [\n      new Option({ definition: atLeastOneProd.definition })\n    ].concat(<any>currRest, <any>prevRest)\n    this.walk(atLeastOneProd, fullAtLeastOneRest)\n  }\n\n  walkAtLeastOneSep(\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    const fullAtLeastOneSepRest = restForRepetitionWithSeparator(\n      atLeastOneSepProd,\n      currRest,\n      prevRest\n    )\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest)\n  }\n\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    const fullManyRest: IProduction[] = [\n      new Option({ definition: manyProd.definition })\n    ].concat(<any>currRest, <any>prevRest)\n    this.walk(manyProd, fullManyRest)\n  }\n\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    const fullManySepRest = restForRepetitionWithSeparator(\n      manySepProd,\n      currRest,\n      prevRest\n    )\n    this.walk(manySepProd, fullManySepRest)\n  }\n\n  walkOr(\n    orProd: Alternation,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n    const fullOrRest = currRest.concat(prevRest)\n    // walk all different alternatives\n    forEach(orProd.definition, (alt) => {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      const prodWrapper = new Alternative({ definition: [alt] })\n      this.walk(prodWrapper, <any>fullOrRest)\n    })\n  }\n}\n\nfunction restForRepetitionWithSeparator(\n  repSepProd: RepetitionWithSeparator,\n  currRest: IProduction[],\n  prevRest: IProduction[]\n) {\n  const repSepRest = [\n    new Option({\n      definition: [\n        new Terminal({ terminalType: repSepProd.separator }) as IProduction\n      ].concat(repSepProd.definition)\n    }) as IProduction\n  ]\n  const fullRepSepRest: IProduction[] = repSepRest.concat(currRest, prevRest)\n  return fullRepSepRest\n}\n", "var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n", "var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n", "var baseFlatten = require('./_baseFlatten');\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nmodule.exports = flatten;\n", "var baseIndexOf = require('./_baseIndexOf');\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\nmodule.exports = arrayIncludes;\n", "/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arrayIncludesWith;\n", "/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n", "var Set = require('./_Set'),\n    noop = require('./noop'),\n    setToArray = require('./_setToArray');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nmodule.exports = createSet;\n", "var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    cacheHas = require('./_cacheHas'),\n    createSet = require('./_createSet'),\n    setToArray = require('./_setToArray');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n", "var baseUniq = require('./_baseUniq');\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each element\n * is kept. The order of result values is determined by the order they occur\n * in the array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length) ? baseUniq(array) : [];\n}\n\nmodule.exports = uniq;\n", "import flatten from \"lodash/flatten\"\nimport uniq from \"lodash/uniq\"\nimport map from \"lodash/map\"\nimport { NonTerminal, Terminal } from \"@chevrotain/gast\"\nimport {\n  isBranchingProd,\n  isOptionalProd,\n  isSequenceProd\n} from \"@chevrotain/gast\"\nimport { IProduction, TokenType } from \"@chevrotain/types\"\n\nexport function first(prod: IProduction): TokenType[] {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first((<NonTerminal>prod).referencedRule)\n  } else if (prod instanceof Terminal) {\n    return firstForTerminal(<Terminal>prod)\n  } else if (isSequenceProd(prod)) {\n    return firstForSequence(prod)\n  } else if (isBranchingProd(prod)) {\n    return firstForBranching(prod)\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function firstForSequence(prod: {\n  definition: IProduction[]\n}): TokenType[] {\n  let firstSet: TokenType[] = []\n  const seq = prod.definition\n  let nextSubProdIdx = 0\n  let hasInnerProdsRemaining = seq.length > nextSubProdIdx\n  let currSubProd\n  // so we enter the loop at least once (if the definition is not empty\n  let isLastInnerProdOptional = true\n  // scan a sequence until it's end or until we have found a NONE optional production in it\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx]\n    isLastInnerProdOptional = isOptionalProd(currSubProd)\n    firstSet = firstSet.concat(first(currSubProd))\n    nextSubProdIdx = nextSubProdIdx + 1\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx\n  }\n\n  return uniq(firstSet)\n}\n\nexport function firstForBranching(prod: {\n  definition: IProduction[]\n}): TokenType[] {\n  const allAlternativesFirsts: TokenType[][] = map(\n    prod.definition,\n    (innerProd) => {\n      return first(innerProd)\n    }\n  )\n  return uniq(flatten<TokenType>(allAlternativesFirsts))\n}\n\nexport function firstForTerminal(terminal: Terminal): TokenType[] {\n  return [terminal.terminalType]\n}\n", "// TODO: can this be removed? where is it used?\nexport const IN = \"_~IN~_\"\n", "import { RestWalker } from \"./rest\"\nimport { first } from \"./first\"\nimport forEach from \"lodash/forEach\"\nimport assign from \"lodash/assign\"\nimport { IN } from \"../constants\"\nimport { Alternative, NonTerminal, Rule, Terminal } from \"@chevrotain/gast\"\nimport { IProduction, TokenType } from \"@chevrotain/types\"\n\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\n// (skipping reference production).\nexport class ResyncFollowsWalker extends RestWalker {\n  public follows: Record<string, TokenType[]> = {}\n\n  constructor(private topProd: Rule) {\n    super()\n  }\n\n  startWalking(): Record<string, TokenType[]> {\n    this.walk(this.topProd)\n    return this.follows\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // do nothing! just like in the public sector after 13:00\n  }\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    const followName =\n      buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\n      this.topProd.name\n    const fullRest: IProduction[] = currRest.concat(prevRest)\n    const restProd = new Alternative({ definition: fullRest })\n    const t_in_topProd_follows = first(restProd)\n    this.follows[followName] = t_in_topProd_follows\n  }\n}\n\nexport function computeAllProdsFollows(\n  topProductions: Rule[]\n): Record<string, TokenType[]> {\n  const reSyncFollows = {}\n\n  forEach(topProductions, (topProd) => {\n    const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking()\n    assign(reSyncFollows, currRefsFollow)\n  })\n  return reSyncFollows\n}\n\nexport function buildBetweenProdsFollowPrefix(\n  inner: Rule,\n  occurenceInParent: number\n): string {\n  return inner.name + occurenceInParent + IN\n}\n\nexport function buildInProdFollowPrefix(terminal: Terminal): string {\n  const terminalName = terminal.terminalType.name\n  return terminalName + terminal.idx + IN\n}\n", "/**\n * Checks if `value` is `undefined`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n * @example\n *\n * _.isUndefined(void 0);\n * // => true\n *\n * _.isUndefined(null);\n * // => false\n */\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\nmodule.exports = isUndefined;\n", ";(function(root, factory) {\n    // istanbul ignore next\n    if (typeof define === \"function\" && define.amd) {\n        // istanbul ignore next\n        define([], factory)\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory()\n    } else {\n        // istanbul ignore next\n        root.regexpToAst = factory()\n    }\n})(\n    typeof self !== \"undefined\"\n        ? // istanbul ignore next\n          self\n        : this,\n    function() {\n        // references\n        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n        function RegExpParser() {}\n\n        RegExpParser.prototype.saveState = function() {\n            return {\n                idx: this.idx,\n                input: this.input,\n                groupIdx: this.groupIdx\n            }\n        }\n\n        RegExpParser.prototype.restoreState = function(newState) {\n            this.idx = newState.idx\n            this.input = newState.input\n            this.groupIdx = newState.groupIdx\n        }\n\n        RegExpParser.prototype.pattern = function(input) {\n            // parser state\n            this.idx = 0\n            this.input = input\n            this.groupIdx = 0\n\n            this.consumeChar(\"/\")\n            var value = this.disjunction()\n            this.consumeChar(\"/\")\n\n            var flags = {\n                type: \"Flags\",\n                loc: { begin: this.idx, end: input.length },\n                global: false,\n                ignoreCase: false,\n                multiLine: false,\n                unicode: false,\n                sticky: false\n            }\n\n            while (this.isRegExpFlag()) {\n                switch (this.popChar()) {\n                    case \"g\":\n                        addFlag(flags, \"global\")\n                        break\n                    case \"i\":\n                        addFlag(flags, \"ignoreCase\")\n                        break\n                    case \"m\":\n                        addFlag(flags, \"multiLine\")\n                        break\n                    case \"u\":\n                        addFlag(flags, \"unicode\")\n                        break\n                    case \"y\":\n                        addFlag(flags, \"sticky\")\n                        break\n                }\n            }\n\n            if (this.idx !== this.input.length) {\n                throw Error(\n                    \"Redundant input: \" + this.input.substring(this.idx)\n                )\n            }\n            return {\n                type: \"Pattern\",\n                flags: flags,\n                value: value,\n                loc: this.loc(0)\n            }\n        }\n\n        RegExpParser.prototype.disjunction = function() {\n            var alts = []\n            var begin = this.idx\n\n            alts.push(this.alternative())\n\n            while (this.peekChar() === \"|\") {\n                this.consumeChar(\"|\")\n                alts.push(this.alternative())\n            }\n\n            return { type: \"Disjunction\", value: alts, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.alternative = function() {\n            var terms = []\n            var begin = this.idx\n\n            while (this.isTerm()) {\n                terms.push(this.term())\n            }\n\n            return { type: \"Alternative\", value: terms, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.term = function() {\n            if (this.isAssertion()) {\n                return this.assertion()\n            } else {\n                return this.atom()\n            }\n        }\n\n        RegExpParser.prototype.assertion = function() {\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"^\":\n                    return {\n                        type: \"StartAnchor\",\n                        loc: this.loc(begin)\n                    }\n                case \"$\":\n                    return { type: \"EndAnchor\", loc: this.loc(begin) }\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.popChar()) {\n                        case \"b\":\n                            return {\n                                type: \"WordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                        case \"B\":\n                            return {\n                                type: \"NonWordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                    }\n                    // istanbul ignore next\n                    throw Error(\"Invalid Assertion Escape\")\n                // '(?=' or '(?!'\n                case \"(\":\n                    this.consumeChar(\"?\")\n\n                    var type\n                    switch (this.popChar()) {\n                        case \"=\":\n                            type = \"Lookahead\"\n                            break\n                        case \"!\":\n                            type = \"NegativeLookahead\"\n                            break\n                    }\n                    ASSERT_EXISTS(type)\n\n                    var disjunction = this.disjunction()\n\n                    this.consumeChar(\")\")\n\n                    return {\n                        type: type,\n                        value: disjunction,\n                        loc: this.loc(begin)\n                    }\n            }\n            // istanbul ignore next\n            ASSERT_NEVER_REACH_HERE()\n        }\n\n        RegExpParser.prototype.quantifier = function(isBacktracking) {\n            var range\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"*\":\n                    range = {\n                        atLeast: 0,\n                        atMost: Infinity\n                    }\n                    break\n                case \"+\":\n                    range = {\n                        atLeast: 1,\n                        atMost: Infinity\n                    }\n                    break\n                case \"?\":\n                    range = {\n                        atLeast: 0,\n                        atMost: 1\n                    }\n                    break\n                case \"{\":\n                    var atLeast = this.integerIncludingZero()\n                    switch (this.popChar()) {\n                        case \"}\":\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atLeast\n                            }\n                            break\n                        case \",\":\n                            var atMost\n                            if (this.isDigit()) {\n                                atMost = this.integerIncludingZero()\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: atMost\n                                }\n                            } else {\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: Infinity\n                                }\n                            }\n                            this.consumeChar(\"}\")\n                            break\n                    }\n                    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n                    // causes severe performance degradations\n                    if (isBacktracking === true && range === undefined) {\n                        return undefined\n                    }\n                    ASSERT_EXISTS(range)\n                    break\n            }\n\n            // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n            // causes severe performance degradations\n            if (isBacktracking === true && range === undefined) {\n                return undefined\n            }\n\n            ASSERT_EXISTS(range)\n\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\")\n                range.greedy = false\n            } else {\n                range.greedy = true\n            }\n\n            range.type = \"Quantifier\"\n            range.loc = this.loc(begin)\n            return range\n        }\n\n        RegExpParser.prototype.atom = function() {\n            var atom\n            var begin = this.idx\n            switch (this.peekChar()) {\n                case \".\":\n                    atom = this.dotAll()\n                    break\n                case \"\\\\\":\n                    atom = this.atomEscape()\n                    break\n                case \"[\":\n                    atom = this.characterClass()\n                    break\n                case \"(\":\n                    atom = this.group()\n                    break\n            }\n\n            if (atom === undefined && this.isPatternCharacter()) {\n                atom = this.patternCharacter()\n            }\n\n            ASSERT_EXISTS(atom)\n\n            atom.loc = this.loc(begin)\n\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier()\n            }\n\n            return atom\n        }\n\n        RegExpParser.prototype.dotAll = function() {\n            this.consumeChar(\".\")\n            return {\n                type: \"Set\",\n                complement: true,\n                value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n            }\n        }\n\n        RegExpParser.prototype.atomEscape = function() {\n            this.consumeChar(\"\\\\\")\n\n            switch (this.peekChar()) {\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    return this.decimalEscapeAtom()\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.decimalEscapeAtom = function() {\n            var value = this.positiveInteger()\n\n            return { type: \"GroupBackReference\", value: value }\n        }\n\n        RegExpParser.prototype.characterClassEscape = function() {\n            var set\n            var complement = false\n            switch (this.popChar()) {\n                case \"d\":\n                    set = digitsCharCodes\n                    break\n                case \"D\":\n                    set = digitsCharCodes\n                    complement = true\n                    break\n                case \"s\":\n                    set = whitespaceCodes\n                    break\n                case \"S\":\n                    set = whitespaceCodes\n                    complement = true\n                    break\n                case \"w\":\n                    set = wordCharCodes\n                    break\n                case \"W\":\n                    set = wordCharCodes\n                    complement = true\n                    break\n            }\n\n            ASSERT_EXISTS(set)\n\n            return { type: \"Set\", value: set, complement: complement }\n        }\n\n        RegExpParser.prototype.controlEscapeAtom = function() {\n            var escapeCode\n            switch (this.popChar()) {\n                case \"f\":\n                    escapeCode = cc(\"\\f\")\n                    break\n                case \"n\":\n                    escapeCode = cc(\"\\n\")\n                    break\n                case \"r\":\n                    escapeCode = cc(\"\\r\")\n                    break\n                case \"t\":\n                    escapeCode = cc(\"\\t\")\n                    break\n                case \"v\":\n                    escapeCode = cc(\"\\v\")\n                    break\n            }\n            ASSERT_EXISTS(escapeCode)\n\n            return { type: \"Character\", value: escapeCode }\n        }\n\n        RegExpParser.prototype.controlLetterEscapeAtom = function() {\n            this.consumeChar(\"c\")\n            var letter = this.popChar()\n            if (/[a-zA-Z]/.test(letter) === false) {\n                throw Error(\"Invalid \")\n            }\n\n            var letterCode = letter.toUpperCase().charCodeAt(0) - 64\n            return { type: \"Character\", value: letterCode }\n        }\n\n        RegExpParser.prototype.nulCharacterAtom = function() {\n            // TODO implement '[lookahead ∉ DecimalDigit]'\n            // TODO: for the deprecated octal escape sequence\n            this.consumeChar(\"0\")\n            return { type: \"Character\", value: cc(\"\\0\") }\n        }\n\n        RegExpParser.prototype.hexEscapeSequenceAtom = function() {\n            this.consumeChar(\"x\")\n            return this.parseHexDigits(2)\n        }\n\n        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {\n            this.consumeChar(\"u\")\n            return this.parseHexDigits(4)\n        }\n\n        RegExpParser.prototype.identityEscapeAtom = function() {\n            // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n            var escapedChar = this.popChar()\n            return { type: \"Character\", value: cc(escapedChar) }\n        }\n\n        RegExpParser.prototype.classPatternCharacterAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \"]\":\n                    throw Error(\"TBD\")\n                default:\n                    var nextChar = this.popChar()\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n\n        RegExpParser.prototype.characterClass = function() {\n            var set = []\n            var complement = false\n            this.consumeChar(\"[\")\n            if (this.peekChar(0) === \"^\") {\n                this.consumeChar(\"^\")\n                complement = true\n            }\n\n            while (this.isClassAtom()) {\n                var from = this.classAtom()\n                var isFromSingleChar = from.type === \"Character\"\n                if (isFromSingleChar && this.isRangeDash()) {\n                    this.consumeChar(\"-\")\n                    var to = this.classAtom()\n                    var isToSingleChar = to.type === \"Character\"\n\n                    // a range can only be used when both sides are single characters\n                    if (isToSingleChar) {\n                        if (to.value < from.value) {\n                            throw Error(\"Range out of order in character class\")\n                        }\n                        set.push({ from: from.value, to: to.value })\n                    } else {\n                        // literal dash\n                        insertToSet(from.value, set)\n                        set.push(cc(\"-\"))\n                        insertToSet(to.value, set)\n                    }\n                } else {\n                    insertToSet(from.value, set)\n                }\n            }\n\n            this.consumeChar(\"]\")\n\n            return { type: \"Set\", complement: complement, value: set }\n        }\n\n        RegExpParser.prototype.classAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"]\":\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                    throw Error(\"TBD\")\n                case \"\\\\\":\n                    return this.classEscape()\n                default:\n                    return this.classPatternCharacterAtom()\n            }\n        }\n\n        RegExpParser.prototype.classEscape = function() {\n            this.consumeChar(\"\\\\\")\n            switch (this.peekChar()) {\n                // Matches a backspace.\n                // (Not to be confused with \\b word boundary outside characterClass)\n                case \"b\":\n                    this.consumeChar(\"b\")\n                    return { type: \"Character\", value: cc(\"\\u0008\") }\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.group = function() {\n            var capturing = true\n            this.consumeChar(\"(\")\n            switch (this.peekChar(0)) {\n                case \"?\":\n                    this.consumeChar(\"?\")\n                    this.consumeChar(\":\")\n                    capturing = false\n                    break\n                default:\n                    this.groupIdx++\n                    break\n            }\n            var value = this.disjunction()\n            this.consumeChar(\")\")\n\n            var groupAst = {\n                type: \"Group\",\n                capturing: capturing,\n                value: value\n            }\n\n            if (capturing) {\n                groupAst.idx = this.groupIdx\n            }\n\n            return groupAst\n        }\n\n        RegExpParser.prototype.positiveInteger = function() {\n            var number = this.popChar()\n\n            // istanbul ignore next - can't ever get here due to previous lookahead checks\n            // still implementing this error checking in case this ever changes.\n            if (decimalPatternNoZero.test(number) === false) {\n                throw Error(\"Expecting a positive integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.integerIncludingZero = function() {\n            var number = this.popChar()\n            if (decimalPattern.test(number) === false) {\n                throw Error(\"Expecting an integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.patternCharacter = function() {\n            var nextChar = this.popChar()\n            switch (nextChar) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"^\":\n                // istanbul ignore next\n                case \"$\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \".\":\n                // istanbul ignore next\n                case \"*\":\n                // istanbul ignore next\n                case \"+\":\n                // istanbul ignore next\n                case \"?\":\n                // istanbul ignore next\n                case \"(\":\n                // istanbul ignore next\n                case \")\":\n                // istanbul ignore next\n                case \"[\":\n                // istanbul ignore next\n                case \"|\":\n                    // istanbul ignore next\n                    throw Error(\"TBD\")\n                default:\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n        RegExpParser.prototype.isRegExpFlag = function() {\n            switch (this.peekChar(0)) {\n                case \"g\":\n                case \"i\":\n                case \"m\":\n                case \"u\":\n                case \"y\":\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isRangeDash = function() {\n            return this.peekChar() === \"-\" && this.isClassAtom(1)\n        }\n\n        RegExpParser.prototype.isDigit = function() {\n            return decimalPattern.test(this.peekChar(0))\n        }\n\n        RegExpParser.prototype.isClassAtom = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n\n            switch (this.peekChar(howMuch)) {\n                case \"]\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.isTerm = function() {\n            return this.isAtom() || this.isAssertion()\n        }\n\n        RegExpParser.prototype.isAtom = function() {\n            if (this.isPatternCharacter()) {\n                return true\n            }\n\n            switch (this.peekChar(0)) {\n                case \".\":\n                case \"\\\\\": // atomEscape\n                case \"[\": // characterClass\n                // TODO: isAtom must be called before isAssertion - disambiguate\n                case \"(\": // group\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isAssertion = function() {\n            switch (this.peekChar(0)) {\n                case \"^\":\n                case \"$\":\n                    return true\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.peekChar(1)) {\n                        case \"b\":\n                        case \"B\":\n                            return true\n                        default:\n                            return false\n                    }\n                // '(?=' or '(?!'\n                case \"(\":\n                    return (\n                        this.peekChar(1) === \"?\" &&\n                        (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\")\n                    )\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isQuantifier = function() {\n            var prevState = this.saveState()\n            try {\n                return this.quantifier(true) !== undefined\n            } catch (e) {\n                return false\n            } finally {\n                this.restoreState(prevState)\n            }\n        }\n\n        RegExpParser.prototype.isPatternCharacter = function() {\n            switch (this.peekChar()) {\n                case \"^\":\n                case \"$\":\n                case \"\\\\\":\n                case \".\":\n                case \"*\":\n                case \"+\":\n                case \"?\":\n                case \"(\":\n                case \")\":\n                case \"[\":\n                case \"|\":\n                case \"/\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.parseHexDigits = function(howMany) {\n            var hexString = \"\"\n            for (var i = 0; i < howMany; i++) {\n                var hexChar = this.popChar()\n                if (hexDigitPattern.test(hexChar) === false) {\n                    throw Error(\"Expecting a HexDecimal digits\")\n                }\n                hexString += hexChar\n            }\n            var charCode = parseInt(hexString, 16)\n            return { type: \"Character\", value: charCode }\n        }\n\n        RegExpParser.prototype.peekChar = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n            return this.input[this.idx + howMuch]\n        }\n\n        RegExpParser.prototype.popChar = function() {\n            var nextChar = this.peekChar(0)\n            this.consumeChar()\n            return nextChar\n        }\n\n        RegExpParser.prototype.consumeChar = function(char) {\n            if (char !== undefined && this.input[this.idx] !== char) {\n                throw Error(\n                    \"Expected: '\" +\n                        char +\n                        \"' but found: '\" +\n                        this.input[this.idx] +\n                        \"' at offset: \" +\n                        this.idx\n                )\n            }\n\n            if (this.idx >= this.input.length) {\n                throw Error(\"Unexpected end of input\")\n            }\n            this.idx++\n        }\n\n        RegExpParser.prototype.loc = function(begin) {\n            return { begin: begin, end: this.idx }\n        }\n\n        // consts and utilities\n        var hexDigitPattern = /[0-9a-fA-F]/\n        var decimalPattern = /[0-9]/\n        var decimalPatternNoZero = /[1-9]/\n\n        function cc(char) {\n            return char.charCodeAt(0)\n        }\n\n        function insertToSet(item, set) {\n            if (item.length !== undefined) {\n                item.forEach(function(subItem) {\n                    set.push(subItem)\n                })\n            } else {\n                set.push(item)\n            }\n        }\n\n        function addFlag(flagObj, flagKey) {\n            if (flagObj[flagKey] === true) {\n                throw \"duplicate flag \" + flagKey\n            }\n\n            flagObj[flagKey] = true\n        }\n\n        function ASSERT_EXISTS(obj) {\n            // istanbul ignore next\n            if (obj === undefined) {\n                throw Error(\"Internal Error - Should never get here!\")\n            }\n        }\n\n        // istanbul ignore next\n        function ASSERT_NEVER_REACH_HERE() {\n            throw Error(\"Internal Error - Should never get here!\")\n        }\n\n        var i\n        var digitsCharCodes = []\n        for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n            digitsCharCodes.push(i)\n        }\n\n        var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes)\n        for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n        var whitespaceCodes = [\n            cc(\" \"),\n            cc(\"\\f\"),\n            cc(\"\\n\"),\n            cc(\"\\r\"),\n            cc(\"\\t\"),\n            cc(\"\\v\"),\n            cc(\"\\t\"),\n            cc(\"\\u00a0\"),\n            cc(\"\\u1680\"),\n            cc(\"\\u2000\"),\n            cc(\"\\u2001\"),\n            cc(\"\\u2002\"),\n            cc(\"\\u2003\"),\n            cc(\"\\u2004\"),\n            cc(\"\\u2005\"),\n            cc(\"\\u2006\"),\n            cc(\"\\u2007\"),\n            cc(\"\\u2008\"),\n            cc(\"\\u2009\"),\n            cc(\"\\u200a\"),\n            cc(\"\\u2028\"),\n            cc(\"\\u2029\"),\n            cc(\"\\u202f\"),\n            cc(\"\\u205f\"),\n            cc(\"\\u3000\"),\n            cc(\"\\ufeff\")\n        ]\n\n        function BaseRegExpVisitor() {}\n\n        BaseRegExpVisitor.prototype.visitChildren = function(node) {\n            for (var key in node) {\n                var child = node[key]\n                /* istanbul ignore else */\n                if (node.hasOwnProperty(key)) {\n                    if (child.type !== undefined) {\n                        this.visit(child)\n                    } else if (Array.isArray(child)) {\n                        child.forEach(function(subChild) {\n                            this.visit(subChild)\n                        }, this)\n                    }\n                }\n            }\n        }\n\n        BaseRegExpVisitor.prototype.visit = function(node) {\n            switch (node.type) {\n                case \"Pattern\":\n                    this.visitPattern(node)\n                    break\n                case \"Flags\":\n                    this.visitFlags(node)\n                    break\n                case \"Disjunction\":\n                    this.visitDisjunction(node)\n                    break\n                case \"Alternative\":\n                    this.visitAlternative(node)\n                    break\n                case \"StartAnchor\":\n                    this.visitStartAnchor(node)\n                    break\n                case \"EndAnchor\":\n                    this.visitEndAnchor(node)\n                    break\n                case \"WordBoundary\":\n                    this.visitWordBoundary(node)\n                    break\n                case \"NonWordBoundary\":\n                    this.visitNonWordBoundary(node)\n                    break\n                case \"Lookahead\":\n                    this.visitLookahead(node)\n                    break\n                case \"NegativeLookahead\":\n                    this.visitNegativeLookahead(node)\n                    break\n                case \"Character\":\n                    this.visitCharacter(node)\n                    break\n                case \"Set\":\n                    this.visitSet(node)\n                    break\n                case \"Group\":\n                    this.visitGroup(node)\n                    break\n                case \"GroupBackReference\":\n                    this.visitGroupBackReference(node)\n                    break\n                case \"Quantifier\":\n                    this.visitQuantifier(node)\n                    break\n            }\n\n            this.visitChildren(node)\n        }\n\n        BaseRegExpVisitor.prototype.visitPattern = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitFlags = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}\n\n        // Assertion\n        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}\n\n        // atoms\n        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitSet = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroup = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}\n\n        return {\n            RegExpParser: RegExpParser,\n            BaseRegExpVisitor: BaseRegExpVisitor,\n            VERSION: \"0.5.0\"\n        }\n    }\n)\n", "/**\n * Gets the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias first\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the first element of `array`.\n * @example\n *\n * _.head([1, 2, 3]);\n * // => 1\n *\n * _.head([]);\n * // => undefined\n */\nfunction head(array) {\n  return (array && array.length) ? array[0] : undefined;\n}\n\nmodule.exports = head;\n", "module.exports = require('./head');\n", "/**\n * Creates an array with all falsey values removed. The values `false`, `null`,\n * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to compact.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.compact([0, 1, false, 2, '', 3]);\n * // => [1, 2, 3]\n */\nfunction compact(array) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = compact;\n", "var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n", "/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that negates the result of the predicate `func`. The\n * `func` predicate is invoked with the `this` binding and arguments of the\n * created function.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Function\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n * @example\n *\n * function isEven(n) {\n *   return n % 2 == 0;\n * }\n *\n * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n * // => [1, 3, 5]\n */\nfunction negate(predicate) {\n  if (typeof predicate != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return function() {\n    var args = arguments;\n    switch (args.length) {\n      case 0: return !predicate.call(this);\n      case 1: return !predicate.call(this, args[0]);\n      case 2: return !predicate.call(this, args[0], args[1]);\n      case 3: return !predicate.call(this, args[0], args[1], args[2]);\n    }\n    return !predicate.apply(this, args);\n  };\n}\n\nmodule.exports = negate;\n", "var arrayFilter = require('./_arrayFilter'),\n    baseFilter = require('./_baseFilter'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray'),\n    negate = require('./negate');\n\n/**\n * The opposite of `_.filter`; this method returns the elements of `collection`\n * that `predicate` does **not** return truthy for.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.filter\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': false },\n *   { 'user': 'fred',   'age': 40, 'active': true }\n * ];\n *\n * _.reject(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.reject(users, { 'age': 40, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.reject(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.reject(users, 'active');\n * // => objects for ['barney']\n */\nfunction reject(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, negate(baseIteratee(predicate, 3)));\n}\n\nmodule.exports = reject;\n", "var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    arrayMap = require('./_arrayMap'),\n    baseUnary = require('./_baseUnary'),\n    cacheHas = require('./_cacheHas');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of methods like `_.difference` without support\n * for excluding multiple arrays or iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Array} values The values to exclude.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n */\nfunction baseDifference(array, values, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      isCommon = true,\n      length = array.length,\n      result = [],\n      valuesLength = values.length;\n\n  if (!length) {\n    return result;\n  }\n  if (iteratee) {\n    values = arrayMap(values, baseUnary(iteratee));\n  }\n  if (comparator) {\n    includes = arrayIncludesWith;\n    isCommon = false;\n  }\n  else if (values.length >= LARGE_ARRAY_SIZE) {\n    includes = cacheHas;\n    isCommon = false;\n    values = new SetCache(values);\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee == null ? value : iteratee(value);\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var valuesIndex = valuesLength;\n      while (valuesIndex--) {\n        if (values[valuesIndex] === computed) {\n          continue outer;\n        }\n      }\n      result.push(value);\n    }\n    else if (!includes(values, computed, comparator)) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseDifference;\n", "var isArrayLike = require('./isArrayLike'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nmodule.exports = isArrayLikeObject;\n", "var baseDifference = require('./_baseDifference'),\n    baseFlatten = require('./_baseFlatten'),\n    baseRest = require('./_baseRest'),\n    isArrayLikeObject = require('./isArrayLikeObject');\n\n/**\n * Creates an array of `array` values not included in the other given arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. The order and references of result values are\n * determined by the first array.\n *\n * **Note:** Unlike `_.pullAll`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {...Array} [values] The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n * @see _.without, _.xor\n * @example\n *\n * _.difference([2, 1], [2, 3]);\n * // => [1]\n */\nvar difference = baseRest(function(array, values) {\n  return isArrayLikeObject(array)\n    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n    : [];\n});\n\nmodule.exports = difference;\n", "var baseIndexOf = require('./_baseIndexOf'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Gets the index at which the first occurrence of `value` is found in `array`\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. If `fromIndex` is negative, it's used as the\n * offset from the end of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n * @example\n *\n * _.indexOf([1, 2, 1, 2], 2);\n * // => 1\n *\n * // Search from the `fromIndex`.\n * _.indexOf([1, 2, 1, 2], 2, 2);\n * // => 3\n */\nfunction indexOf(array, value, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseIndexOf(array, value, index);\n}\n\nmodule.exports = indexOf;\n", "var baseIteratee = require('./_baseIteratee'),\n    isArrayLike = require('./isArrayLike'),\n    keys = require('./keys');\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nmodule.exports = createFind;\n", "var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n", "var createFind = require('./_createFind'),\n    findIndex = require('./findIndex');\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nmodule.exports = find;\n", "var arrayFilter = require('./_arrayFilter'),\n    baseFilter = require('./_baseFilter'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n *\n * // Combining several predicates using `_.overEvery` or `_.overSome`.\n * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n * // => objects for ['fred', 'barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = filter;\n", "var baseRest = require('./_baseRest'),\n    eq = require('./eq'),\n    isIterateeCall = require('./_isIterateeCall'),\n    keysIn = require('./keysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = baseRest(function(object, sources) {\n  object = Object(object);\n\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : undefined;\n\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  while (++index < length) {\n    var source = sources[index];\n    var props = keysIn(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n\n      if (value === undefined ||\n          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        object[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n});\n\nmodule.exports = defaults;\n", "/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n", "/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initAccum\n      ? (initAccum = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseReduce;\n", "var arrayReduce = require('./_arrayReduce'),\n    baseEach = require('./_baseEach'),\n    baseIteratee = require('./_baseIteratee'),\n    baseReduce = require('./_baseReduce'),\n    isArray = require('./isArray');\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3;\n\n  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n}\n\nmodule.exports = reduce;\n", "import {\n  Alternative,\n  Assertion,\n  Atom,\n  Disjunction,\n  RegExpParser,\n  RegExpPattern\n} from \"regexp-to-ast\"\n\nlet regExpAstCache: { [regex: string]: RegExpPattern } = {}\nconst regExpParser = new RegExpParser()\n\n// this should be moved to regexp-to-ast\nexport type ASTNode =\n  | RegExpPattern\n  | Disjunction\n  | Alternative\n  | Assertion\n  | Atom\n\nexport function getRegExpAst(regExp: RegExp): RegExpPattern {\n  const regExpStr = regExp.toString()\n  if (regExpAstCache.hasOwnProperty(regExpStr)) {\n    return regExpAstCache[regExpStr]\n  } else {\n    const regExpAst = regExpParser.pattern(regExpStr)\n    regExpAstCache[regExpStr] = regExpAst\n    return regExpAst\n  }\n}\n\nexport function clearRegExpParserCache() {\n  regExpAstCache = {}\n}\n", "import {\n  Alternative,\n  Atom,\n  BaseRegExpVisitor,\n  Character,\n  Disjunction,\n  Group,\n  Set,\n  Term,\n  VERSION\n} from \"regexp-to-ast\"\nimport isArray from \"lodash/isArray\"\nimport every from \"lodash/every\"\nimport forEach from \"lodash/forEach\"\nimport find from \"lodash/find\"\nimport values from \"lodash/values\"\nimport includes from \"lodash/includes\"\nimport { PRINT_ERROR, PRINT_WARNING } from \"@chevrotain/utils\"\nimport { ASTNode, getRegExpAst } from \"./reg_exp_parser\"\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\"\n\nconst complementErrorMessage =\n  \"Complement Sets are not supported for first char optimization\"\nexport const failedOptimizationPrefixMsg =\n  'Unable to use \"first char\" lexer optimizations:\\n'\n\nexport function getOptimizedStartCodesIndices(\n  regExp: RegExp,\n  ensureOptimizations = false\n): number[] {\n  try {\n    const ast = getRegExpAst(regExp)\n    const firstChars = firstCharOptimizedIndices(\n      ast.value,\n      {},\n      ast.flags.ignoreCase\n    )\n    return firstChars\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\n          `${failedOptimizationPrefixMsg}` +\n            `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n            \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\"\n        )\n      }\n    } else {\n      let msgSuffix = \"\"\n      if (ensureOptimizations) {\n        msgSuffix =\n          \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\"\n      }\n      PRINT_ERROR(\n        `${failedOptimizationPrefixMsg}\\n` +\n          `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n          `\\tUsing the regexp-to-ast library version: ${VERSION}\\n` +\n          \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\n          msgSuffix\n      )\n    }\n  }\n\n  return []\n}\n\nexport function firstCharOptimizedIndices(\n  ast: ASTNode,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean\n): number[] {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (let i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase)\n      }\n      break\n    case \"Alternative\":\n      const terms = ast.value\n      for (let i = 0; i < terms.length; i++) {\n        const term = terms[i]\n\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue\n        }\n\n        const atom = term\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase)\n            break\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage)\n            }\n            forEach(atom.value, (code) => {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase)\n              } else {\n                // range\n                const range = code as any\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to && rangeCode < minOptimizationVal;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= minOptimizationVal) {\n                    const minUnOptVal =\n                      range.from >= minOptimizationVal\n                        ? range.from\n                        : minOptimizationVal\n                    const maxUnOptVal = range.to\n                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal)\n                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal)\n\n                    for (\n                      let currOptIdx = minOptIdx;\n                      currOptIdx <= maxOptIdx;\n                      currOptIdx++\n                    ) {\n                      result[currOptIdx] = currOptIdx\n                    }\n                  }\n                }\n              }\n            })\n            break\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase)\n            break\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\")\n        }\n\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        const isOptionalQuantifier =\n          atom.quantifier !== undefined && atom.quantifier.atLeast === 0\n        if (\n          // A group may be optional due to empty contents /(?:)/\n          // or if everything inside it is optional /((a)?)/\n          (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n          // If this term is not a group it may only be optional if it has an optional quantifier\n          (atom.type !== \"Group\" && isOptionalQuantifier === false)\n        ) {\n          break\n        }\n      }\n      break\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\")\n  }\n\n  // console.log(Object.keys(result).length)\n  return values(result)\n}\n\nfunction addOptimizedIdxToResult(\n  code: number,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean\n) {\n  const optimizedCharIdx = charCodeToOptimizedIndex(code)\n  result[optimizedCharIdx] = optimizedCharIdx\n\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result)\n  }\n}\n\nfunction handleIgnoreCase(\n  code: number,\n  result: { [charCode: number]: number }\n) {\n  const char = String.fromCharCode(code)\n  const upperChar = char.toUpperCase()\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0))\n    result[optimizedCharIdx] = optimizedCharIdx\n  } else {\n    const lowerChar = char.toLowerCase()\n    if (lowerChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0))\n      result[optimizedCharIdx] = optimizedCharIdx\n    }\n  }\n}\n\nfunction findCode(setNode: Set, targetCharCodes: number[]) {\n  return find(setNode.value, (codeOrRange) => {\n    if (typeof codeOrRange === \"number\") {\n      return includes(targetCharCodes, codeOrRange)\n    } else {\n      // range\n      const range = <any>codeOrRange\n      return (\n        find(\n          targetCharCodes,\n          (targetCode) => range.from <= targetCode && targetCode <= range.to\n        ) !== undefined\n      )\n    }\n  })\n}\n\nfunction isWholeOptional(ast: any): boolean {\n  const quantifier = (ast as Atom).quantifier\n  if (quantifier && quantifier.atLeast === 0) {\n    return true\n  }\n\n  if (!ast.value) {\n    return false\n  }\n\n  return isArray(ast.value)\n    ? every(ast.value, isWholeOptional)\n    : isWholeOptional(ast.value)\n}\n\nclass CharCodeFinder extends BaseRegExpVisitor {\n  found: boolean = false\n\n  constructor(private targetCharCodes: number[]) {\n    super()\n  }\n\n  visitChildren(node: ASTNode) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return\n    }\n\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node)\n        return\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node)\n        return\n    }\n\n    super.visitChildren(node)\n  }\n\n  visitCharacter(node: Character) {\n    if (includes(this.targetCharCodes, node.value)) {\n      this.found = true\n    }\n  }\n\n  visitSet(node: Set) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true\n      }\n    }\n  }\n}\n\nexport function canMatchCharCode(\n  charCodes: number[],\n  pattern: RegExp | string\n) {\n  if (pattern instanceof RegExp) {\n    const ast = getRegExpAst(pattern)\n    const charCodeFinder = new CharCodeFinder(charCodes)\n    charCodeFinder.visit(ast)\n    return charCodeFinder.found\n  } else {\n    return (\n      find(<any>pattern, (char) => {\n        return includes(charCodes, (<string>char).charCodeAt(0))\n      }) !== undefined\n    )\n  }\n}\n", "import { BaseRegExpVisitor } from \"regexp-to-ast\"\nimport { IRegExpExec, Lexer, LexerDefinitionErrorType } from \"./lexer_public\"\nimport first from \"lodash/first\"\nimport isEmpty from \"lodash/isEmpty\"\nimport compact from \"lodash/compact\"\nimport isArray from \"lodash/isArray\"\nimport values from \"lodash/values\"\nimport flatten from \"lodash/flatten\"\nimport reject from \"lodash/reject\"\nimport difference from \"lodash/difference\"\nimport indexOf from \"lodash/indexOf\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport isString from \"lodash/isString\"\nimport isFunction from \"lodash/isFunction\"\nimport isUndefined from \"lodash/isUndefined\"\nimport find from \"lodash/find\"\nimport has from \"lodash/has\"\nimport keys from \"lodash/keys\"\nimport isRegExp from \"lodash/isRegExp\"\nimport filter from \"lodash/filter\"\nimport defaults from \"lodash/defaults\"\nimport reduce from \"lodash/reduce\"\nimport includes from \"lodash/includes\"\nimport { PRINT_ERROR } from \"@chevrotain/utils\"\nimport {\n  canMatchCharCode,\n  failedOptimizationPrefixMsg,\n  getOptimizedStartCodesIndices\n} from \"./reg_exp\"\nimport {\n  ILexerDefinitionError,\n  ILineTerminatorsTester,\n  IMultiModeLexerDefinition,\n  IToken,\n  TokenType\n} from \"@chevrotain/types\"\nimport { getRegExpAst } from \"./reg_exp_parser\"\n\nconst PATTERN = \"PATTERN\"\nexport const DEFAULT_MODE = \"defaultMode\"\nexport const MODES = \"modes\"\n\nexport interface IPatternConfig {\n  pattern: IRegExpExec | string\n  longerAlt: number[] | undefined\n  canLineTerminator: boolean\n  isCustom: boolean\n  short: number | false\n  group: string | undefined | false\n  push: string | undefined\n  pop: boolean\n  tokenType: TokenType\n  tokenTypeIdx: number\n}\n\nexport interface IAnalyzeResult {\n  patternIdxToConfig: IPatternConfig[]\n  charCodeToPatternIdxToConfig: { [charCode: number]: IPatternConfig[] }\n  emptyGroups: { [groupName: string]: IToken[] }\n  hasCustom: boolean\n  canBeOptimized: boolean\n}\n\nexport let SUPPORT_STICKY =\n  typeof (<any>new RegExp(\"(?:)\")).sticky === \"boolean\"\n\nexport function disableSticky() {\n  SUPPORT_STICKY = false\n}\n\nexport function enableSticky() {\n  SUPPORT_STICKY = true\n}\n\nexport function analyzeTokenTypes(\n  tokenTypes: TokenType[],\n  options: {\n    positionTracking?: \"full\" | \"onlyStart\" | \"onlyOffset\"\n    ensureOptimizations?: boolean\n    lineTerminatorCharacters?: (number | string)[]\n    // TODO: should `useSticky` be an argument here?\n    useSticky?: boolean\n    safeMode?: boolean\n    tracer?: (msg: string, action: () => void) => void\n  }\n): IAnalyzeResult {\n  options = defaults(options, {\n    useSticky: SUPPORT_STICKY,\n    debug: false as boolean,\n    safeMode: false as boolean,\n    positionTracking: \"full\",\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n    tracer: (msg: string, action: Function) => action()\n  })\n\n  const tracer = options.tracer!\n\n  tracer(\"initCharCodeToOptimizedIndexMap\", () => {\n    initCharCodeToOptimizedIndexMap()\n  })\n\n  let onlyRelevantTypes: TokenType[]\n  tracer(\"Reject Lexer.NA\", () => {\n    onlyRelevantTypes = reject(tokenTypes, (currType) => {\n      return currType[PATTERN] === Lexer.NA\n    })\n  })\n\n  let hasCustom = false\n  let allTransformedPatterns: (IRegExpExec | string)[]\n  tracer(\"Transform Patterns\", () => {\n    hasCustom = false\n    allTransformedPatterns = map(\n      onlyRelevantTypes,\n      (currType): IRegExpExec | string => {\n        const currPattern = currType[PATTERN]\n\n        /* istanbul ignore else */\n        if (isRegExp(currPattern)) {\n          const regExpSource = currPattern.source\n          if (\n            regExpSource.length === 1 &&\n            // only these regExp meta characters which can appear in a length one regExp\n            regExpSource !== \"^\" &&\n            regExpSource !== \"$\" &&\n            regExpSource !== \".\" &&\n            !currPattern.ignoreCase\n          ) {\n            return regExpSource\n          } else if (\n            regExpSource.length === 2 &&\n            regExpSource[0] === \"\\\\\" &&\n            // not a meta character\n            !includes(\n              [\n                \"d\",\n                \"D\",\n                \"s\",\n                \"S\",\n                \"t\",\n                \"r\",\n                \"n\",\n                \"t\",\n                \"0\",\n                \"c\",\n                \"b\",\n                \"B\",\n                \"f\",\n                \"v\",\n                \"w\",\n                \"W\"\n              ],\n              regExpSource[1]\n            )\n          ) {\n            // escaped meta Characters: /\\+/ /\\[/\n            // or redundant escaping: /\\a/\n            // without the escaping \"\\\"\n            return regExpSource[1]\n          } else {\n            return options.useSticky\n              ? addStickyFlag(currPattern)\n              : addStartOfInput(currPattern)\n          }\n        } else if (isFunction(currPattern)) {\n          hasCustom = true\n          // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n          return { exec: currPattern }\n        } else if (typeof currPattern === \"object\") {\n          hasCustom = true\n          // ICustomPattern\n          return currPattern\n        } else if (typeof currPattern === \"string\") {\n          if (currPattern.length === 1) {\n            return currPattern\n          } else {\n            const escapedRegExpString = currPattern.replace(\n              /[\\\\^$.*+?()[\\]{}|]/g,\n              \"\\\\$&\"\n            )\n            const wrappedRegExp = new RegExp(escapedRegExpString)\n            return options.useSticky\n              ? addStickyFlag(wrappedRegExp)\n              : addStartOfInput(wrappedRegExp)\n          }\n        } else {\n          throw Error(\"non exhaustive match\")\n        }\n      }\n    )\n  })\n\n  let patternIdxToType: number[]\n  let patternIdxToGroup: (string | undefined | false)[]\n  let patternIdxToLongerAltIdxArr: (number[] | undefined)[]\n  let patternIdxToPushMode: (string | undefined)[]\n  let patternIdxToPopMode: boolean[]\n  tracer(\"misc mapping\", () => {\n    patternIdxToType = map(\n      onlyRelevantTypes,\n      (currType) => currType.tokenTypeIdx!\n    )\n\n    patternIdxToGroup = map(onlyRelevantTypes, (clazz: any) => {\n      const groupName = clazz.GROUP\n      /* istanbul ignore next */\n      if (groupName === Lexer.SKIPPED) {\n        return undefined\n      } else if (isString(groupName)) {\n        return groupName\n      } else if (isUndefined(groupName)) {\n        return false\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    })\n\n    patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz: any) => {\n      const longerAltType = clazz.LONGER_ALT\n\n      if (longerAltType) {\n        const longerAltIdxArr = isArray(longerAltType)\n          ? map(longerAltType, (type: any) => indexOf(onlyRelevantTypes, type))\n          : [indexOf(onlyRelevantTypes, longerAltType)]\n        return longerAltIdxArr\n      }\n    })\n\n    patternIdxToPushMode = map(\n      onlyRelevantTypes,\n      (clazz: any) => clazz.PUSH_MODE\n    )\n\n    patternIdxToPopMode = map(onlyRelevantTypes, (clazz: any) =>\n      has(clazz, \"POP_MODE\")\n    )\n  })\n\n  let patternIdxToCanLineTerminator: boolean[]\n  tracer(\"Line Terminator Handling\", () => {\n    const lineTerminatorCharCodes = getCharCodes(\n      options.lineTerminatorCharacters!\n    )\n    patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false)\n    if (options.positionTracking !== \"onlyOffset\") {\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\n        if (has(tokType, \"LINE_BREAKS\")) {\n          return !!tokType.LINE_BREAKS\n        } else {\n          return (\n            checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\n            canMatchCharCode(\n              lineTerminatorCharCodes,\n              tokType.PATTERN as RegExp | string\n            )\n          )\n        }\n      })\n    }\n  })\n\n  let patternIdxToIsCustom: boolean[]\n  let patternIdxToShort: (number | false)[]\n  let emptyGroups!: { [groupName: string]: IToken[] }\n  let patternIdxToConfig!: IPatternConfig[]\n  tracer(\"Misc Mapping #2\", () => {\n    patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern)\n    patternIdxToShort = map(allTransformedPatterns, isShortPattern)\n\n    emptyGroups = reduce(\n      onlyRelevantTypes,\n      (acc, clazz: any) => {\n        const groupName = clazz.GROUP\n        if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n          acc[groupName] = []\n        }\n        return acc\n      },\n      {} as { [groupName: string]: IToken[] }\n    )\n\n    patternIdxToConfig = map(\n      allTransformedPatterns,\n      (x, idx): IPatternConfig => {\n        return {\n          pattern: allTransformedPatterns[idx],\n          longerAlt: patternIdxToLongerAltIdxArr[idx],\n          canLineTerminator: patternIdxToCanLineTerminator[idx],\n          isCustom: patternIdxToIsCustom[idx],\n          short: patternIdxToShort[idx],\n          group: patternIdxToGroup[idx],\n          push: patternIdxToPushMode[idx],\n          pop: patternIdxToPopMode[idx],\n          tokenTypeIdx: patternIdxToType[idx],\n          tokenType: onlyRelevantTypes[idx]\n        }\n      }\n    )\n  })\n\n  let canBeOptimized = true\n  let charCodeToPatternIdxToConfig: { [charCode: number]: IPatternConfig[] } =\n    []\n\n  if (!options.safeMode) {\n    tracer(\"First Char Optimization\", () => {\n      charCodeToPatternIdxToConfig = reduce(\n        onlyRelevantTypes,\n        (result, currTokType, idx) => {\n          if (typeof currTokType.PATTERN === \"string\") {\n            const charCode = currTokType.PATTERN.charCodeAt(0)\n            const optimizedIdx = charCodeToOptimizedIndex(charCode)\n            addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx])\n          } else if (isArray(currTokType.START_CHARS_HINT)) {\n            let lastOptimizedIdx: number\n            forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\n              const charCode =\n                typeof charOrInt === \"string\"\n                  ? charOrInt.charCodeAt(0)\n                  : charOrInt\n              const currOptimizedIdx = charCodeToOptimizedIndex(charCode)\n              // Avoid adding the config multiple times\n              /* istanbul ignore else */\n              // - Difficult to check this scenario effects as it is only a performance\n              //   optimization that does not change correctness\n              if (lastOptimizedIdx !== currOptimizedIdx) {\n                lastOptimizedIdx = currOptimizedIdx\n                addToMapOfArrays(\n                  result,\n                  currOptimizedIdx,\n                  patternIdxToConfig[idx]\n                )\n              }\n            })\n          } else if (isRegExp(currTokType.PATTERN)) {\n            if (currTokType.PATTERN.unicode) {\n              canBeOptimized = false\n              if (options.ensureOptimizations) {\n                PRINT_ERROR(\n                  `${failedOptimizationPrefixMsg}` +\n                    `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\n                    \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\"\n                )\n              }\n            } else {\n              const optimizedCodes = getOptimizedStartCodesIndices(\n                currTokType.PATTERN,\n                options.ensureOptimizations\n              )\n              /* istanbul ignore if */\n              // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n              // the first should be a different validation and the second cannot be tested.\n              if (isEmpty(optimizedCodes)) {\n                // we cannot understand what codes may start possible matches\n                // The optimization correctness requires knowing start codes for ALL patterns.\n                // Not actually sure this is an error, no debug message\n                canBeOptimized = false\n              }\n              forEach(optimizedCodes, (code) => {\n                addToMapOfArrays(result, code, patternIdxToConfig[idx])\n              })\n            }\n          } else {\n            if (options.ensureOptimizations) {\n              PRINT_ERROR(\n                `${failedOptimizationPrefixMsg}` +\n                  `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\n                  \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                  \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\"\n              )\n            }\n            canBeOptimized = false\n          }\n\n          return result\n        },\n        [] as { [charCode: number]: IPatternConfig[] }\n      )\n    })\n  }\n\n  return {\n    emptyGroups: emptyGroups,\n    patternIdxToConfig: patternIdxToConfig,\n    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n    hasCustom: hasCustom,\n    canBeOptimized: canBeOptimized\n  }\n}\n\nexport function validatePatterns(\n  tokenTypes: TokenType[],\n  validModesNames: string[]\n): ILexerDefinitionError[] {\n  let errors: ILexerDefinitionError[] = []\n\n  const missingResult = findMissingPatterns(tokenTypes)\n  errors = errors.concat(missingResult.errors)\n\n  const invalidResult = findInvalidPatterns(missingResult.valid)\n  const validTokenTypes = invalidResult.valid\n  errors = errors.concat(invalidResult.errors)\n\n  errors = errors.concat(validateRegExpPattern(validTokenTypes))\n\n  errors = errors.concat(findInvalidGroupType(validTokenTypes))\n\n  errors = errors.concat(\n    findModesThatDoNotExist(validTokenTypes, validModesNames)\n  )\n\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes))\n\n  return errors\n}\n\nfunction validateRegExpPattern(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  let errors: ILexerDefinitionError[] = []\n  const withRegExpPatterns = filter(tokenTypes, (currTokType) =>\n    isRegExp(currTokType[PATTERN])\n  )\n\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns))\n\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns))\n\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns))\n\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns))\n\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns))\n\n  return errors\n}\n\nexport interface ILexerFilterResult {\n  errors: ILexerDefinitionError[]\n  valid: TokenType[]\n}\n\nexport function findMissingPatterns(\n  tokenTypes: TokenType[]\n): ILexerFilterResult {\n  const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\n    return !has(currType, PATTERN)\n  })\n\n  const errors = map(tokenTypesWithMissingPattern, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- missing static 'PATTERN' property\",\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\n      tokenTypes: [currType]\n    }\n  })\n\n  const valid = difference(tokenTypes, tokenTypesWithMissingPattern)\n  return { errors, valid }\n}\n\nexport function findInvalidPatterns(\n  tokenTypes: TokenType[]\n): ILexerFilterResult {\n  const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN]\n    return (\n      !isRegExp(pattern) &&\n      !isFunction(pattern) &&\n      !has(pattern, \"exec\") &&\n      !isString(pattern)\n    )\n  })\n\n  const errors = map(tokenTypesWithInvalidPattern, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' can only be a RegExp, a\" +\n        \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\n      tokenTypes: [currType]\n    }\n  })\n\n  const valid = difference(tokenTypes, tokenTypesWithInvalidPattern)\n  return { errors, valid }\n}\n\nconst end_of_input = /[^\\\\][$]/\n\nexport function findEndOfInputAnchor(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  class EndAnchorFinder extends BaseRegExpVisitor {\n    found = false\n\n    visitEndAnchor(node: unknown) {\n      this.found = true\n    }\n  }\n\n  const invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN\n\n    try {\n      const regexpAst = getRegExpAst(pattern as RegExp)\n      const endAnchorVisitor = new EndAnchorFinder()\n      endAnchorVisitor.visit(regexpAst)\n\n      return endAnchorVisitor.found\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return end_of_input.test((pattern as RegExp).source)\n    }\n  })\n\n  const errors = map(invalidRegex, (currType) => {\n    return {\n      message:\n        \"Unexpected RegExp Anchor Error:\\n\" +\n        \"\\tToken Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n        \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nexport function findEmptyMatchRegExps(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const matchesEmptyString = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN as RegExp\n    return pattern.test(\"\")\n  })\n\n  const errors = map(matchesEmptyString, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' must not match an empty string\",\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nconst start_of_input = /[^\\\\[][\\^]|^\\^/\n\nexport function findStartOfInputAnchor(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  class StartAnchorFinder extends BaseRegExpVisitor {\n    found = false\n\n    visitStartAnchor(node: unknown) {\n      this.found = true\n    }\n  }\n\n  const invalidRegex = filter(tokenTypes, (currType) => {\n    const pattern = currType.PATTERN as RegExp\n    try {\n      const regexpAst = getRegExpAst(pattern)\n      const startAnchorVisitor = new StartAnchorFinder()\n      startAnchorVisitor.visit(regexpAst)\n\n      return startAnchorVisitor.found\n    } catch (e) {\n      // old behavior in case of runtime exceptions with regexp-to-ast.\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n      return start_of_input.test(pattern.source)\n    }\n  })\n\n  const errors = map(invalidRegex, (currType) => {\n    return {\n      message:\n        \"Unexpected RegExp Anchor Error:\\n\" +\n        \"\\tToken Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nexport function findUnsupportedFlags(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const invalidFlags = filter(tokenTypes, (currType) => {\n    const pattern = currType[PATTERN]\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global)\n  })\n\n  const errors = map(invalidFlags, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nexport function findDuplicatePatterns(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const found: TokenType[] = []\n  let identicalPatterns = map(tokenTypes, (outerType: any) => {\n    return reduce(\n      tokenTypes,\n      (result, innerType) => {\n        if (\n          outerType.PATTERN.source === (innerType.PATTERN as RegExp).source &&\n          !includes(found, innerType) &&\n          innerType.PATTERN !== Lexer.NA\n        ) {\n          // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n          // in essence we are creating Equivalence classes on equality relation.\n          found.push(innerType)\n          result.push(innerType)\n          return result\n        }\n        return result\n      },\n      [] as TokenType[]\n    )\n  })\n\n  identicalPatterns = compact(identicalPatterns)\n\n  const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\n    return currIdenticalSet.length > 1\n  })\n\n  const errors = map(duplicatePatterns, (setOfIdentical: any) => {\n    const tokenTypeNames = map(setOfIdentical, (currType: any) => {\n      return currType.name\n    })\n\n    const dupPatternSrc = (<any>first(setOfIdentical)).PATTERN\n    return {\n      message:\n        `The same RegExp pattern ->${dupPatternSrc}<-` +\n        `has been used in all of the following Token Types: ${tokenTypeNames.join(\n          \", \"\n        )} <-`,\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n      tokenTypes: setOfIdentical\n    }\n  })\n\n  return errors\n}\n\nexport function findInvalidGroupType(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const invalidTypes = filter(tokenTypes, (clazz: any) => {\n    if (!has(clazz, \"GROUP\")) {\n      return false\n    }\n    const group = clazz.GROUP\n\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group)\n  })\n\n  const errors = map(invalidTypes, (currType) => {\n    return {\n      message:\n        \"Token Type: ->\" +\n        currType.name +\n        \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n      tokenTypes: [currType]\n    }\n  })\n\n  return errors\n}\n\nexport function findModesThatDoNotExist(\n  tokenTypes: TokenType[],\n  validModes: string[]\n): ILexerDefinitionError[] {\n  const invalidModes = filter(tokenTypes, (clazz: any) => {\n    return (\n      clazz.PUSH_MODE !== undefined && !includes(validModes, clazz.PUSH_MODE)\n    )\n  })\n\n  const errors = map(invalidModes, (tokType) => {\n    const msg =\n      `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\n      `which does not exist`\n    return {\n      message: msg,\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n      tokenTypes: [tokType]\n    }\n  })\n\n  return errors\n}\n\nexport function findUnreachablePatterns(\n  tokenTypes: TokenType[]\n): ILexerDefinitionError[] {\n  const errors: ILexerDefinitionError[] = []\n\n  const canBeTested = reduce(\n    tokenTypes,\n    (result, tokType, idx) => {\n      const pattern = tokType.PATTERN\n\n      if (pattern === Lexer.NA) {\n        return result\n      }\n\n      // a more comprehensive validation for all forms of regExps would require\n      // deeper regExp analysis capabilities\n      if (isString(pattern)) {\n        result.push({ str: pattern, idx, tokenType: tokType })\n      } else if (isRegExp(pattern) && noMetaChar(pattern)) {\n        result.push({ str: pattern.source, idx, tokenType: tokType })\n      }\n      return result\n    },\n    [] as { str: string; idx: number; tokenType: TokenType }[]\n  )\n\n  forEach(tokenTypes, (tokType, testIdx) => {\n    forEach(canBeTested, ({ str, idx, tokenType }) => {\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n        const msg =\n          `Token: ->${tokenType.name}<- can never be matched.\\n` +\n          `Because it appears AFTER the Token Type ->${tokType.name}<-` +\n          `in the lexer's definition.\\n` +\n          `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`\n        errors.push({\n          message: msg,\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n          tokenTypes: [tokType, tokenType]\n        })\n      }\n    })\n  })\n\n  return errors\n}\n\nfunction testTokenType(str: string, pattern: any): boolean {\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    const regExpArray = pattern.exec(str)\n    return regExpArray !== null && regExpArray.index === 0\n  } else if (isFunction(pattern)) {\n    // maintain the API of custom patterns\n    return pattern(str, 0, [], {})\n  } else if (has(pattern, \"exec\")) {\n    // maintain the API of custom patterns\n    return pattern.exec(str, 0, [], {})\n  } else if (typeof pattern === \"string\") {\n    return pattern === str\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nfunction noMetaChar(regExp: RegExp): boolean {\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n  const metaChars = [\n    \".\",\n    \"\\\\\",\n    \"[\",\n    \"]\",\n    \"|\",\n    \"^\",\n    \"$\",\n    \"(\",\n    \")\",\n    \"?\",\n    \"*\",\n    \"+\",\n    \"{\"\n  ]\n  return (\n    find(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined\n  )\n}\n\nexport function addStartOfInput(pattern: RegExp): RegExp {\n  const flags = pattern.ignoreCase ? \"i\" : \"\"\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(`^(?:${pattern.source})`, flags)\n}\n\nexport function addStickyFlag(pattern: RegExp): RegExp {\n  const flags = pattern.ignoreCase ? \"iy\" : \"y\"\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n  return new RegExp(`${pattern.source}`, flags)\n}\n\nexport function performRuntimeChecks(\n  lexerDefinition: IMultiModeLexerDefinition,\n  trackLines: boolean,\n  lineTerminatorCharacters: (number | string)[]\n): ILexerDefinitionError[] {\n  const errors: ILexerDefinitionError[] = []\n\n  // some run time checks to help the end users.\n  if (!has(lexerDefinition, DEFAULT_MODE)) {\n    errors.push({\n      message:\n        \"A MultiMode Lexer cannot be initialized without a <\" +\n        DEFAULT_MODE +\n        \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n    })\n  }\n  if (!has(lexerDefinition, MODES)) {\n    errors.push({\n      message:\n        \"A MultiMode Lexer cannot be initialized without a <\" +\n        MODES +\n        \"> property in its definition\\n\",\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n    })\n  }\n\n  if (\n    has(lexerDefinition, MODES) &&\n    has(lexerDefinition, DEFAULT_MODE) &&\n    !has(lexerDefinition.modes, lexerDefinition.defaultMode)\n  ) {\n    errors.push({\n      message:\n        `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\n        `which does not exist\\n`,\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n    })\n  }\n\n  if (has(lexerDefinition, MODES)) {\n    forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\n      forEach(currModeValue, (currTokType, currIdx) => {\n        if (isUndefined(currTokType)) {\n          errors.push({\n            message:\n              `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\n              `<${currModeName}> at index: <${currIdx}>\\n`,\n            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n          })\n        } else if (has(currTokType, \"LONGER_ALT\")) {\n          const longerAlt = isArray(currTokType.LONGER_ALT)\n            ? currTokType.LONGER_ALT\n            : [currTokType.LONGER_ALT]\n          forEach(longerAlt, (currLongerAlt) => {\n            if (\n              !isUndefined(currLongerAlt) &&\n              !includes(currModeValue, currLongerAlt)\n            ) {\n              errors.push({\n                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\\n`,\n                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n              })\n            }\n          })\n        }\n      })\n    })\n  }\n\n  return errors\n}\n\nexport function performWarningRuntimeChecks(\n  lexerDefinition: IMultiModeLexerDefinition,\n  trackLines: boolean,\n  lineTerminatorCharacters: (number | string)[]\n): ILexerDefinitionError[] {\n  const warnings = []\n  let hasAnyLineBreak = false\n  const allTokenTypes = compact(flatten(values(lexerDefinition.modes)))\n\n  const concreteTokenTypes = reject(\n    allTokenTypes,\n    (currType) => currType[PATTERN] === Lexer.NA\n  )\n  const terminatorCharCodes = getCharCodes(lineTerminatorCharacters)\n  if (trackLines) {\n    forEach(concreteTokenTypes, (tokType) => {\n      const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes)\n      if (currIssue !== false) {\n        const message = buildLineBreakIssueMessage(tokType, currIssue)\n        const warningDescriptor = {\n          message,\n          type: currIssue.issue,\n          tokenType: tokType\n        }\n        warnings.push(warningDescriptor)\n      } else {\n        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n        if (has(tokType, \"LINE_BREAKS\")) {\n          if (tokType.LINE_BREAKS === true) {\n            hasAnyLineBreak = true\n          }\n        } else {\n          if (\n            canMatchCharCode(terminatorCharCodes, tokType.PATTERN as RegExp)\n          ) {\n            hasAnyLineBreak = true\n          }\n        }\n      }\n    })\n  }\n\n  if (trackLines && !hasAnyLineBreak) {\n    warnings.push({\n      message:\n        \"Warning: No LINE_BREAKS Found.\\n\" +\n        \"\\tThis Lexer has been defined to track line and column information,\\n\" +\n        \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\n        \"\\tfor details.\",\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n    })\n  }\n  return warnings\n}\n\nexport function cloneEmptyGroups(emptyGroups: {\n  [groupName: string]: IToken\n}): { [groupName: string]: IToken } {\n  const clonedResult: any = {}\n  const groupKeys = keys(emptyGroups)\n\n  forEach(groupKeys, (currKey) => {\n    const currGroupValue = emptyGroups[currKey]\n\n    /* istanbul ignore else */\n    if (isArray(currGroupValue)) {\n      clonedResult[currKey] = []\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n  })\n\n  return clonedResult\n}\n\n// TODO: refactor to avoid duplication\nexport function isCustomPattern(tokenType: TokenType): boolean {\n  const pattern = tokenType.PATTERN\n  /* istanbul ignore else */\n  if (isRegExp(pattern)) {\n    return false\n  } else if (isFunction(pattern)) {\n    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n    return true\n  } else if (has(pattern, \"exec\")) {\n    // ICustomPattern\n    return true\n  } else if (isString(pattern)) {\n    return false\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function isShortPattern(pattern: any): number | false {\n  if (isString(pattern) && pattern.length === 1) {\n    return pattern.charCodeAt(0)\n  } else {\n    return false\n  }\n}\n\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nexport const LineTerminatorOptimizedTester: ILineTerminatorsTester = {\n  // implements /\\n|\\r\\n?/g.test\n  test: function (text) {\n    const len = text.length\n    for (let i = this.lastIndex; i < len; i++) {\n      const c = text.charCodeAt(i)\n      if (c === 10) {\n        this.lastIndex = i + 1\n        return true\n      } else if (c === 13) {\n        if (text.charCodeAt(i + 1) === 10) {\n          this.lastIndex = i + 2\n        } else {\n          this.lastIndex = i + 1\n        }\n        return true\n      }\n    }\n    return false\n  },\n\n  lastIndex: 0\n}\n\nfunction checkLineBreaksIssues(\n  tokType: TokenType,\n  lineTerminatorCharCodes: number[]\n):\n  | {\n      issue:\n        | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\n        | LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n      errMsg?: string\n    }\n  | false {\n  if (has(tokType, \"LINE_BREAKS\")) {\n    // if the user explicitly declared the line_breaks option we will respect their choice\n    // and assume it is correct.\n    return false\n  } else {\n    /* istanbul ignore else */\n    if (isRegExp(tokType.PATTERN)) {\n      try {\n        // TODO: why is the casting suddenly needed?\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN as RegExp)\n      } catch (e) {\n        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n        return {\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n          errMsg: (e as Error).message\n        }\n      }\n      return false\n    } else if (isString(tokType.PATTERN)) {\n      // string literal patterns can always be analyzed to detect line terminator usage\n      return false\n    } else if (isCustomPattern(tokType)) {\n      // custom token types\n      return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK }\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n  }\n}\n\nexport function buildLineBreakIssueMessage(\n  tokType: TokenType,\n  details: {\n    issue:\n      | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\n      | LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n    errMsg?: string\n  }\n): string {\n  /* istanbul ignore else */\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n    return (\n      \"Warning: unable to identify line terminator usage in pattern.\\n\" +\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n      `\\t Root cause: ${details.errMsg}.\\n` +\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\"\n    )\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n    return (\n      \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\"\n    )\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nfunction getCharCodes(charsOrCodes: (number | string)[]): number[] {\n  const charCodes = map(charsOrCodes, (numOrString) => {\n    if (isString(numOrString)) {\n      return numOrString.charCodeAt(0)\n    } else {\n      return numOrString\n    }\n  })\n\n  return charCodes\n}\n\nfunction addToMapOfArrays<T>(\n  map: Record<number, T[]>,\n  key: number,\n  value: T\n): void {\n  if (map[key] === undefined) {\n    map[key] = [value]\n  } else {\n    map[key].push(value)\n  }\n}\n\nexport const minOptimizationVal = 256\n\n/**\n * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nlet charCodeToOptimizedIdxMap: number[] = []\nexport function charCodeToOptimizedIndex(charCode: number): number {\n  return charCode < minOptimizationVal\n    ? charCode\n    : charCodeToOptimizedIdxMap[charCode]\n}\n\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nfunction initCharCodeToOptimizedIndexMap() {\n  if (isEmpty(charCodeToOptimizedIdxMap)) {\n    charCodeToOptimizedIdxMap = new Array(65536)\n    for (let i = 0; i < 65536; i++) {\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i\n    }\n  }\n}\n", "/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n", "import isEmpty from \"lodash/isEmpty\"\nimport compact from \"lodash/compact\"\nimport isArray from \"lodash/isArray\"\nimport flatten from \"lodash/flatten\"\nimport difference from \"lodash/difference\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport has from \"lodash/has\"\nimport includes from \"lodash/includes\"\nimport clone from \"lodash/clone\"\nimport { IToken, TokenType } from \"@chevrotain/types\"\n\nexport function tokenStructuredMatcher(\n  tokInstance: IToken,\n  tokConstructor: TokenType\n) {\n  const instanceType = tokInstance.tokenTypeIdx\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true\n  } else {\n    return (\n      tokConstructor.isParent === true &&\n      tokConstructor.categoryMatchesMap![instanceType] === true\n    )\n  }\n}\n\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(\n  token: IToken,\n  tokType: TokenType\n) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx\n}\n\nexport let tokenShortNameIdx = 1\nexport const tokenIdxToClass: { [tokenIdx: number]: TokenType } = {}\n\nexport function augmentTokenTypes(tokenTypes: TokenType[]): void {\n  // collect the parent Token Types as well.\n  const tokenTypesAndParents = expandCategories(tokenTypes)\n\n  // add required tokenType and categoryMatches properties\n  assignTokenDefaultProps(tokenTypesAndParents)\n\n  // fill up the categoryMatches\n  assignCategoriesMapProp(tokenTypesAndParents)\n  assignCategoriesTokensProp(tokenTypesAndParents)\n\n  forEach(tokenTypesAndParents, (tokType) => {\n    tokType.isParent = tokType.categoryMatches!.length > 0\n  })\n}\n\nexport function expandCategories(tokenTypes: TokenType[]): TokenType[] {\n  let result = clone(tokenTypes)\n\n  let categories = tokenTypes\n  let searching = true\n  while (searching) {\n    categories = compact(\n      flatten(map(categories, (currTokType) => currTokType.CATEGORIES))\n    )\n\n    const newCategories = difference(categories, result)\n\n    result = result.concat(newCategories)\n\n    if (isEmpty(newCategories)) {\n      searching = false\n    } else {\n      categories = newCategories\n    }\n  }\n  return result\n}\n\nexport function assignTokenDefaultProps(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType\n      ;(<any>currTokType).tokenTypeIdx = tokenShortNameIdx++\n    }\n\n    // CATEGORIES? : TokenType | TokenType[]\n    if (\n      hasCategoriesProperty(currTokType) &&\n      !isArray(currTokType.CATEGORIES)\n      // &&\n      // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES as unknown as TokenType]\n    }\n\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = []\n    }\n\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = []\n    }\n\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {}\n    }\n  })\n}\n\nexport function assignCategoriesTokensProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    // avoid duplications\n    currTokType.categoryMatches = []\n    forEach(currTokType.categoryMatchesMap!, (val, key) => {\n      currTokType.categoryMatches!.push(\n        tokenIdxToClass[key as unknown as number].tokenTypeIdx!\n      )\n    })\n  })\n}\n\nexport function assignCategoriesMapProp(tokenTypes: TokenType[]): void {\n  forEach(tokenTypes, (currTokType) => {\n    singleAssignCategoriesToksMap([], currTokType)\n  })\n}\n\nexport function singleAssignCategoriesToksMap(\n  path: TokenType[],\n  nextNode: TokenType\n): void {\n  forEach(path, (pathNode) => {\n    nextNode.categoryMatchesMap![pathNode.tokenTypeIdx!] = true\n  })\n\n  forEach(nextNode.CATEGORIES, (nextCategory) => {\n    const newPath = path.concat(nextNode)\n    // avoids infinite loops due to cyclic categories.\n    if (!includes(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory)\n    }\n  })\n}\n\nexport function hasShortKeyProperty(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\")\n}\n\nexport function hasCategoriesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"CATEGORIES\")\n}\n\nexport function hasExtendingTokensTypesProperty(tokType: TokenType): boolean {\n  return has(tokType, \"categoryMatches\")\n}\n\nexport function hasExtendingTokensTypesMapProperty(\n  tokType: TokenType\n): boolean {\n  return has(tokType, \"categoryMatchesMap\")\n}\n\nexport function isTokenType(tokType: TokenType): boolean {\n  return has(tokType, \"tokenTypeIdx\")\n}\n", "import { ILexerErrorMessageProvider, IToken } from \"@chevrotain/types\"\n\nexport const defaultLexerErrorProvider: ILexerErrorMessageProvider = {\n  buildUnableToPopLexerModeMessage(token: IToken): string {\n    return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`\n  },\n\n  buildUnexpectedCharactersMessage(\n    fullText: string,\n    startOffset: number,\n    length: number,\n    line?: number,\n    column?: number\n  ): string {\n    return (\n      `unexpected character: ->${fullText.charAt(\n        startOffset\n      )}<- at offset: ${startOffset},` + ` skipped ${length} characters.`\n    )\n  }\n}\n", "import {\n  analyzeTokenTypes,\n  charCodeToOptimizedIndex,\n  cloneEmptyGroups,\n  DEFAULT_MODE,\n  IAnalyzeResult,\n  IPatternConfig,\n  LineTerminatorOptimizedTester,\n  performRuntimeChecks,\n  performWarningRuntimeChecks,\n  SUPPORT_STICKY,\n  validatePatterns\n} from \"./lexer\"\nimport noop from \"lodash/noop\"\nimport isEmpty from \"lodash/isEmpty\"\nimport isArray from \"lodash/isArray\"\nimport last from \"lodash/last\"\nimport reject from \"lodash/reject\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport keys from \"lodash/keys\"\nimport isUndefined from \"lodash/isUndefined\"\nimport identity from \"lodash/identity\"\nimport assign from \"lodash/assign\"\nimport reduce from \"lodash/reduce\"\nimport clone from \"lodash/clone\"\nimport { PRINT_WARNING, timer, toFastProperties } from \"@chevrotain/utils\"\nimport { augmentTokenTypes } from \"./tokens\"\nimport {\n  CustomPatternMatcherFunc,\n  CustomPatternMatcherReturn,\n  ILexerConfig,\n  ILexerDefinitionError,\n  ILexingError,\n  IMultiModeLexerDefinition,\n  IToken,\n  TokenType\n} from \"@chevrotain/types\"\nimport { defaultLexerErrorProvider } from \"./lexer_errors_public\"\nimport { clearRegExpParserCache } from \"./reg_exp_parser\"\n\nexport interface ILexingResult {\n  tokens: IToken[]\n  groups: { [groupName: string]: IToken[] }\n  errors: ILexingError[]\n}\n\nexport enum LexerDefinitionErrorType {\n  MISSING_PATTERN,\n  INVALID_PATTERN,\n  EOI_ANCHOR_FOUND,\n  UNSUPPORTED_FLAGS_FOUND,\n  DUPLICATE_PATTERNS_FOUND,\n  INVALID_GROUP_TYPE_FOUND,\n  PUSH_MODE_DOES_NOT_EXIST,\n  MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n  MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n  MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n  LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n  SOI_ANCHOR_FOUND,\n  EMPTY_MATCH_PATTERN,\n  NO_LINE_BREAKS_FLAGS,\n  UNREACHABLE_PATTERN,\n  IDENTIFY_TERMINATOR,\n  CUSTOM_LINE_BREAK,\n  MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n}\n\nexport interface IRegExpExec {\n  exec: CustomPatternMatcherFunc\n}\n\nconst DEFAULT_LEXER_CONFIG: Required<ILexerConfig> = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false,\n  recoveryEnabled: true\n}\n\nObject.freeze(DEFAULT_LEXER_CONFIG)\n\nexport class Lexer {\n  public static SKIPPED =\n    \"This marks a skipped Token pattern, this means each token identified by it will\" +\n    \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\"\n\n  public static NA = /NOT_APPLICABLE/\n  public lexerDefinitionErrors: ILexerDefinitionError[] = []\n  public lexerDefinitionWarning: ILexerDefinitionError[] = []\n\n  protected patternIdxToConfig: Record<string, IPatternConfig[]> = {}\n  protected charCodeToPatternIdxToConfig: {\n    [modeName: string]: { [charCode: number]: IPatternConfig[] }\n  } = {}\n\n  protected modes: string[] = []\n  protected defaultMode!: string\n  protected emptyGroups: { [groupName: string]: IToken } = {}\n\n  private config: Required<ILexerConfig>\n  private trackStartLines: boolean = true\n  private trackEndLines: boolean = true\n  private hasCustom: boolean = false\n  private canModeBeOptimized: Record<string, boolean> = {}\n\n  private traceInitPerf!: boolean | number\n  private traceInitMaxIdent!: number\n  private traceInitIndent: number\n\n  constructor(\n    protected lexerDefinition: TokenType[] | IMultiModeLexerDefinition,\n    config: ILexerConfig = DEFAULT_LEXER_CONFIG\n  ) {\n    if (typeof config === \"boolean\") {\n      throw Error(\n        \"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n          \"a boolean 2nd argument is no longer supported\"\n      )\n    }\n\n    // todo: defaults func?\n    this.config = assign({}, DEFAULT_LEXER_CONFIG, config) as any\n\n    const traceInitVal = this.config.traceInitPerf\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity\n      this.traceInitPerf = true\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal\n      this.traceInitPerf = true\n    }\n    this.traceInitIndent = -1\n\n    this.TRACE_INIT(\"Lexer Constructor\", () => {\n      let actualDefinition!: IMultiModeLexerDefinition\n      let hasOnlySingleMode = true\n      this.TRACE_INIT(\"Lexer Config handling\", () => {\n        if (\n          this.config.lineTerminatorsPattern ===\n          DEFAULT_LEXER_CONFIG.lineTerminatorsPattern\n        ) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester\n        } else {\n          if (\n            this.config.lineTerminatorCharacters ===\n            DEFAULT_LEXER_CONFIG.lineTerminatorCharacters\n          ) {\n            throw Error(\n              \"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\"\n            )\n          }\n        }\n\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error(\n            '\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.'\n          )\n        }\n\n        this.trackStartLines = /full|onlyStart/i.test(\n          this.config.positionTracking\n        )\n        this.trackEndLines = /full/i.test(this.config.positionTracking)\n\n        // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n        if (isArray(lexerDefinition)) {\n          actualDefinition = {\n            modes: { defaultMode: clone(lexerDefinition) },\n            defaultMode: DEFAULT_MODE\n          }\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false\n          actualDefinition = clone(<IMultiModeLexerDefinition>lexerDefinition)\n        }\n      })\n\n      if (this.config.skipValidations === false) {\n        this.TRACE_INIT(\"performRuntimeChecks\", () => {\n          this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n            performRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters\n            )\n          )\n        })\n\n        this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\n          this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(\n            performWarningRuntimeChecks(\n              actualDefinition,\n              this.trackStartLines,\n              this.config.lineTerminatorCharacters\n            )\n          )\n        })\n      }\n\n      // for extra robustness to avoid throwing an none informative error message\n      actualDefinition.modes = actualDefinition.modes\n        ? actualDefinition.modes\n        : {}\n\n      // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n      forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n        actualDefinition.modes[currModeName] = reject<TokenType>(\n          currModeValue,\n          (currTokType) => isUndefined(currTokType)\n        )\n      })\n\n      const allModeNames = keys(actualDefinition.modes)\n\n      forEach(\n        actualDefinition.modes,\n        (currModDef: TokenType[], currModName) => {\n          this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n            this.modes.push(currModName)\n\n            if (this.config.skipValidations === false) {\n              this.TRACE_INIT(`validatePatterns`, () => {\n                this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n                  validatePatterns(currModDef, allModeNames)\n                )\n              })\n            }\n\n            // If definition errors were encountered, the analysis phase may fail unexpectedly/\n            // Considering a lexer with definition errors may never be used, there is no point\n            // to performing the analysis anyhow...\n            if (isEmpty(this.lexerDefinitionErrors)) {\n              augmentTokenTypes(currModDef)\n\n              let currAnalyzeResult!: IAnalyzeResult\n              this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                  lineTerminatorCharacters:\n                    this.config.lineTerminatorCharacters,\n                  positionTracking: config.positionTracking,\n                  ensureOptimizations: config.ensureOptimizations,\n                  safeMode: config.safeMode,\n                  tracer: this.TRACE_INIT\n                })\n              })\n\n              this.patternIdxToConfig[currModName] =\n                currAnalyzeResult.patternIdxToConfig\n\n              this.charCodeToPatternIdxToConfig[currModName] =\n                currAnalyzeResult.charCodeToPatternIdxToConfig\n\n              this.emptyGroups = assign(\n                {},\n                this.emptyGroups,\n                currAnalyzeResult.emptyGroups\n              ) as any\n\n              this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom\n\n              this.canModeBeOptimized[currModName] =\n                currAnalyzeResult.canBeOptimized\n            }\n          })\n        }\n      )\n\n      this.defaultMode = actualDefinition.defaultMode\n\n      if (\n        !isEmpty(this.lexerDefinitionErrors) &&\n        !this.config.deferDefinitionErrorsHandling\n      ) {\n        const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n          return error.message\n        })\n        const allErrMessagesString = allErrMessages.join(\n          \"-----------------------\\n\"\n        )\n        throw new Error(\n          \"Errors detected in definition of Lexer:\\n\" + allErrMessagesString\n        )\n      }\n\n      // Only print warning if there are no errors, This will avoid pl\n      forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n        PRINT_WARNING(warningDescriptor.message)\n      })\n\n      this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (SUPPORT_STICKY) {\n          this.chopInput = <any>identity\n          this.match = this.matchWithTest\n        } else {\n          this.updateLastIndex = noop\n          this.match = this.matchWithExec\n        }\n\n        if (hasOnlySingleMode) {\n          this.handleModes = noop\n        }\n\n        if (this.trackStartLines === false) {\n          this.computeNewColumn = identity\n        }\n\n        if (this.trackEndLines === false) {\n          this.updateTokenEndLineColumnLocation = noop\n        }\n\n        if (/full/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createFullToken\n        } else if (/onlyStart/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createStartOnlyToken\n        } else if (/onlyOffset/i.test(this.config.positionTracking)) {\n          this.createTokenInstance = this.createOffsetOnlyToken\n        } else {\n          throw Error(\n            `Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`\n          )\n        }\n\n        if (this.hasCustom) {\n          this.addToken = this.addTokenUsingPush\n          this.handlePayload = this.handlePayloadWithCustom\n        } else {\n          this.addToken = this.addTokenUsingMemberAccess\n          this.handlePayload = this.handlePayloadNoCustom\n        }\n      })\n\n      this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\n        const unOptimizedModes = reduce(\n          this.canModeBeOptimized,\n          (cannotBeOptimized, canBeOptimized, modeName) => {\n            if (canBeOptimized === false) {\n              cannotBeOptimized.push(modeName)\n            }\n            return cannotBeOptimized\n          },\n          [] as string[]\n        )\n\n        if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n          throw Error(\n            `Lexer Modes: < ${unOptimizedModes.join(\n              \", \"\n            )} > cannot be optimized.\\n` +\n              '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n              \"\\t Or inspect the console log for details on how to resolve these issues.\"\n          )\n        }\n      })\n\n      this.TRACE_INIT(\"clearRegExpParserCache\", () => {\n        clearRegExpParserCache()\n      })\n\n      this.TRACE_INIT(\"toFastProperties\", () => {\n        toFastProperties(this)\n      })\n    })\n  }\n\n  public tokenize(\n    text: string,\n    initialMode: string = this.defaultMode\n  ): ILexingResult {\n    if (!isEmpty(this.lexerDefinitionErrors)) {\n      const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n        return error.message\n      })\n      const allErrMessagesString = allErrMessages.join(\n        \"-----------------------\\n\"\n      )\n      throw new Error(\n        \"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n          allErrMessagesString\n      )\n    }\n\n    return this.tokenizeInternal(text, initialMode)\n  }\n\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  // this method also used quite a bit of `!` none null assertions because it is too optimized\n  // for `tsc` to always understand it is \"safe\"\n  private tokenizeInternal(text: string, initialMode: string): ILexingResult {\n    let i,\n      j,\n      k,\n      matchAltImage,\n      longerAlt,\n      matchedImage: string | null,\n      payload,\n      altPayload,\n      imageLength,\n      group,\n      tokType,\n      newToken: IToken,\n      errLength,\n      droppedChar,\n      msg,\n      match\n    const orgText = text\n    const orgLength = orgText.length\n    let offset = 0\n    let matchedTokensIndex = 0\n    // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n    const guessedNumberOfTokens = this.hasCustom\n      ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n      : Math.floor(text.length / 10)\n    const matchedTokens = new Array(guessedNumberOfTokens)\n    const errors: ILexingError[] = []\n    let line = this.trackStartLines ? 1 : undefined\n    let column = this.trackStartLines ? 1 : undefined\n    const groups: any = cloneEmptyGroups(this.emptyGroups)\n    const trackLines = this.trackStartLines\n    const lineTerminatorPattern = this.config.lineTerminatorsPattern\n\n    let currModePatternsLength = 0\n    let patternIdxToConfig: IPatternConfig[] = []\n    let currCharCodeToPatternIdxToConfig: {\n      [charCode: number]: IPatternConfig[]\n    } = []\n\n    const modeStack: string[] = []\n\n    const emptyArray: IPatternConfig[] = []\n    Object.freeze(emptyArray)\n    let getPossiblePatterns!: (charCode: number) => IPatternConfig[]\n\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig\n    }\n\n    function getPossiblePatternsOptimized(charCode: number): IPatternConfig[] {\n      const optimizedCharIdx = charCodeToOptimizedIndex(charCode)\n      const possiblePatterns =\n        currCharCodeToPatternIdxToConfig[optimizedCharIdx]\n      if (possiblePatterns === undefined) {\n        return emptyArray\n      } else {\n        return possiblePatterns\n      }\n    }\n\n    const pop_mode = (popToken: IToken) => {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (\n        modeStack.length === 1 &&\n        // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n        // So no error should occur.\n        popToken.tokenType.PUSH_MODE === undefined\n      ) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        const msg =\n          this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(\n            popToken\n          )\n\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine,\n          column: popToken.startColumn,\n          length: popToken.image.length,\n          message: msg\n        })\n      } else {\n        modeStack.pop()\n        const newMode = last(modeStack)!\n        patternIdxToConfig = this.patternIdxToConfig[newMode]\n        currCharCodeToPatternIdxToConfig =\n          this.charCodeToPatternIdxToConfig[newMode]\n        currModePatternsLength = patternIdxToConfig.length\n        const modeCanBeOptimized =\n          this.canModeBeOptimized[newMode] && this.config.safeMode === false\n\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow\n        }\n      }\n    }\n\n    function push_mode(this: Lexer, newMode: string) {\n      modeStack.push(newMode)\n      currCharCodeToPatternIdxToConfig =\n        this.charCodeToPatternIdxToConfig[newMode]\n\n      patternIdxToConfig = this.patternIdxToConfig[newMode]\n      currModePatternsLength = patternIdxToConfig.length\n\n      currModePatternsLength = patternIdxToConfig.length\n      const modeCanBeOptimized =\n        this.canModeBeOptimized[newMode] && this.config.safeMode === false\n\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow\n      }\n    }\n\n    // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n    push_mode.call(this, initialMode)\n\n    let currConfig!: IPatternConfig\n\n    const recoveryEnabled = this.config.recoveryEnabled\n\n    while (offset < orgLength) {\n      matchedImage = null\n\n      const nextCharCode = orgText.charCodeAt(offset)\n      const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode)\n      const chosenPatternsLength = chosenPatternIdxToConfig.length\n\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i]\n        const currPattern = currConfig.pattern\n        payload = null\n\n        // manually in-lined because > 600 chars won't be in-lined in V8\n        const singleCharCode = currConfig.short\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern as string\n          }\n        } else if (currConfig.isCustom === true) {\n          match = (currPattern as IRegExpExec).exec(\n            orgText,\n            offset,\n            matchedTokens,\n            groups\n          )\n          if (match !== null) {\n            matchedImage = match[0]\n            if ((match as CustomPatternMatcherReturn).payload !== undefined) {\n              payload = (match as CustomPatternMatcherReturn).payload\n            }\n          } else {\n            matchedImage = null\n          }\n        } else {\n          this.updateLastIndex(currPattern as RegExp, offset)\n          matchedImage = this.match(currPattern as RegExp, text, offset)\n        }\n\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAlt = currConfig.longerAlt\n          if (longerAlt !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            const longerAltLength = longerAlt.length\n            for (k = 0; k < longerAltLength; k++) {\n              const longerAltConfig = patternIdxToConfig[longerAlt[k]]\n              const longerAltPattern = longerAltConfig.pattern\n              altPayload = null\n\n              // single Char can never be a longer alt so no need to test it.\n              // manually in-lined because > 600 chars won't be in-lined in V8\n              if (longerAltConfig.isCustom === true) {\n                match = (longerAltPattern as IRegExpExec).exec(\n                  orgText,\n                  offset,\n                  matchedTokens,\n                  groups\n                )\n                if (match !== null) {\n                  matchAltImage = match[0]\n                  if (\n                    (match as CustomPatternMatcherReturn).payload !== undefined\n                  ) {\n                    altPayload = (match as CustomPatternMatcherReturn).payload\n                  }\n                } else {\n                  matchAltImage = null\n                }\n              } else {\n                this.updateLastIndex(longerAltPattern as RegExp, offset)\n                matchAltImage = this.match(\n                  longerAltPattern as RegExp,\n                  text,\n                  offset\n                )\n              }\n\n              if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                matchedImage = matchAltImage\n                payload = altPayload\n                currConfig = longerAltConfig\n                // Exit the loop early after matching one of the longer alternatives\n                // The first matched alternative takes precedence\n                break\n              }\n            }\n          }\n          break\n        }\n      }\n\n      // successful match\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length\n        group = currConfig.group\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx\n          // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n          newToken = this.createTokenInstance(\n            matchedImage,\n            offset,\n            tokType,\n            currConfig.tokenType,\n            line,\n            column,\n            imageLength\n          )\n\n          this.handlePayload(newToken, payload)\n\n          // TODO: optimize NOOP in case there are no special groups?\n          if (group === false) {\n            matchedTokensIndex = this.addToken(\n              matchedTokens,\n              matchedTokensIndex,\n              newToken\n            )\n          } else {\n            groups[group].push(newToken)\n          }\n        }\n        text = this.chopInput(text, imageLength)\n        offset = offset + imageLength\n\n        // TODO: with newlines the column may be assigned twice\n        column = this.computeNewColumn(column!, imageLength)\n\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          let numOfLTsInMatch = 0\n          let foundTerminator\n          let lastLTEndOffset: number\n          lineTerminatorPattern.lastIndex = 0\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage)\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1\n              numOfLTsInMatch++\n            }\n          } while (foundTerminator === true)\n\n          if (numOfLTsInMatch !== 0) {\n            line = line! + numOfLTsInMatch\n            column = imageLength - lastLTEndOffset!\n            this.updateTokenEndLineColumnLocation(\n              newToken!,\n              group!,\n              lastLTEndOffset!,\n              numOfLTsInMatch,\n              line,\n              column,\n              imageLength\n            )\n          }\n        }\n        // will be NOOP if no modes present\n        this.handleModes(currConfig, pop_mode, push_mode, newToken!)\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        const errorStartOffset = offset\n        const errorLine = line\n        const errorColumn = column\n        let foundResyncPoint = recoveryEnabled === false\n\n        while (foundResyncPoint === false && offset < orgLength) {\n          // Identity Func (when sticky flag is enabled)\n          text = this.chopInput(text, 1)\n          offset++\n          for (j = 0; j < currModePatternsLength; j++) {\n            const currConfig = patternIdxToConfig[j]\n            const currPattern = currConfig.pattern\n\n            // manually in-lined because > 600 chars won't be in-lined in V8\n            const singleCharCode = currConfig.short\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true\n              }\n            } else if (currConfig.isCustom === true) {\n              foundResyncPoint =\n                (currPattern as IRegExpExec).exec(\n                  orgText,\n                  offset,\n                  matchedTokens,\n                  groups\n                ) !== null\n            } else {\n              this.updateLastIndex(currPattern as RegExp, offset)\n              foundResyncPoint = (currPattern as RegExp).exec(text) !== null\n            }\n\n            if (foundResyncPoint === true) {\n              break\n            }\n          }\n        }\n\n        errLength = offset - errorStartOffset\n        // at this point we either re-synced or reached the end of the input text\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(\n          orgText,\n          errorStartOffset,\n          errLength,\n          errorLine,\n          errorColumn\n        )\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        })\n\n        if (recoveryEnabled === false) {\n          break\n        }\n      }\n    }\n\n    // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex\n    }\n\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors\n    }\n  }\n\n  private handleModes(\n    config: IPatternConfig,\n    pop_mode: (tok: IToken) => void,\n    push_mode: (this: Lexer, pushMode: string) => void,\n    newToken: IToken\n  ) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      const pushMode = config.push\n      pop_mode(newToken)\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode)\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push)\n    }\n  }\n\n  private chopInput(text: string, length: number): string {\n    return text.substring(length)\n  }\n\n  private updateLastIndex(regExp: RegExp, newLastIndex: number): void {\n    regExp.lastIndex = newLastIndex\n  }\n\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n  private updateTokenEndLineColumnLocation(\n    newToken: IToken,\n    group: string | false,\n    lastLTIdx: number,\n    numOfLTsInMatch: number,\n    line: number,\n    column: number,\n    imageLength: number\n  ): void {\n    let lastCharIsLT, fixForEndingInLT\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1\n      fixForEndingInLT = lastCharIsLT ? -1 : 0\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT\n        // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n        newToken.endColumn = column - 1 + -fixForEndingInLT\n      }\n      // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n    }\n  }\n\n  private computeNewColumn(oldColumn: number, imageLength: number) {\n    return oldColumn + imageLength\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private createTokenInstance!: (...args: any[]) => IToken\n\n  private createOffsetOnlyToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType\n  ) {\n    return {\n      image,\n      startOffset,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  private createStartOnlyToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType,\n    startLine: number,\n    startColumn: number\n  ) {\n    return {\n      image,\n      startOffset,\n      startLine,\n      startColumn,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  private createFullToken(\n    image: string,\n    startOffset: number,\n    tokenTypeIdx: number,\n    tokenType: TokenType,\n    startLine: number,\n    startColumn: number,\n    imageLength: number\n  ): IToken {\n    return {\n      image,\n      startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine,\n      endLine: startLine,\n      startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx,\n      tokenType\n    }\n  }\n\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\n  /* istanbul ignore next - place holder */\n  private addToken!: (\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken\n  ) => number\n\n  private addTokenUsingPush(\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken\n  ): number {\n    tokenVector.push(tokenToAdd)\n    return index\n  }\n\n  private addTokenUsingMemberAccess(\n    tokenVector: IToken[],\n    index: number,\n    tokenToAdd: IToken\n  ): number {\n    tokenVector[index] = tokenToAdd\n    index++\n    return index\n  }\n\n  // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\n  private handlePayload: (token: IToken, payload: any) => void\n\n  private handlePayloadNoCustom(token: IToken, payload: any): void {}\n\n  private handlePayloadWithCustom(token: IToken, payload: any): void {\n    if (payload !== null) {\n      token.payload = payload\n    }\n  }\n\n  // place holder to be replaced with chosen alternative at runtime\n  private match!: (\n    pattern: RegExp,\n    text: string,\n    offset: number\n  ) => string | null\n\n  private matchWithTest(\n    pattern: RegExp,\n    text: string,\n    offset: number\n  ): string | null {\n    const found = pattern.test(text)\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex)\n    }\n    return null\n  }\n\n  private matchWithExec(pattern: RegExp, text: string): string | null {\n    const regExpArray = pattern.exec(text)\n    return regExpArray !== null ? regExpArray[0] : null\n  }\n\n  // Duplicated from the parser's perf trace trait to allow future extraction\n  // of the lexer to a separate package.\n  TRACE_INIT = <T>(phaseDesc: string, phaseImpl: () => T): T => {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\")\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`)\n      }\n      const { time, value } = timer(phaseImpl)\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      const traceMethod = time > 10 ? console.warn : console.log\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n      }\n      this.traceInitIndent--\n      return value\n    } else {\n      return phaseImpl()\n    }\n  }\n}\n", "import isString from \"lodash/isString\"\nimport has from \"lodash/has\"\nimport isUndefined from \"lodash/isUndefined\"\nimport { Lexer } from \"./lexer_public\"\nimport { augmentTokenTypes, tokenStructuredMatcher } from \"./tokens\"\nimport { IToken, ITokenConfig, TokenType } from \"@chevrotain/types\"\n\nexport function tokenLabel(tokType: TokenType): string {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL\n  } else {\n    return tokType.name\n  }\n}\n\nexport function tokenName(tokType: TokenType): string {\n  return tokType.name\n}\n\nexport function hasTokenLabel(\n  obj: TokenType\n): obj is TokenType & Pick<Required<TokenType>, \"LABEL\"> {\n  return isString(obj.LABEL) && obj.LABEL !== \"\"\n}\n\nconst PARENT = \"parent\"\nconst CATEGORIES = \"categories\"\nconst LABEL = \"label\"\nconst GROUP = \"group\"\nconst PUSH_MODE = \"push_mode\"\nconst POP_MODE = \"pop_mode\"\nconst LONGER_ALT = \"longer_alt\"\nconst LINE_BREAKS = \"line_breaks\"\nconst START_CHARS_HINT = \"start_chars_hint\"\n\nexport function createToken(config: ITokenConfig): TokenType {\n  return createTokenInternal(config)\n}\n\nfunction createTokenInternal(config: ITokenConfig): TokenType {\n  const pattern = config.pattern\n\n  const tokenType: TokenType = <any>{}\n  tokenType.name = config.name\n\n  if (!isUndefined(pattern)) {\n    tokenType.PATTERN = pattern\n  }\n\n  if (has(config, PARENT)) {\n    throw (\n      \"The parent property is no longer supported.\\n\" +\n      \"See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\"\n    )\n  }\n\n  if (has(config, CATEGORIES)) {\n    // casting to ANY as this will be fixed inside `augmentTokenTypes``\n    tokenType.CATEGORIES = <any>config[CATEGORIES]\n  }\n\n  augmentTokenTypes([tokenType])\n\n  if (has(config, LABEL)) {\n    tokenType.LABEL = config[LABEL]\n  }\n\n  if (has(config, GROUP)) {\n    tokenType.GROUP = config[GROUP]\n  }\n\n  if (has(config, POP_MODE)) {\n    tokenType.POP_MODE = config[POP_MODE]\n  }\n\n  if (has(config, PUSH_MODE)) {\n    tokenType.PUSH_MODE = config[PUSH_MODE]\n  }\n\n  if (has(config, LONGER_ALT)) {\n    tokenType.LONGER_ALT = config[LONGER_ALT]\n  }\n\n  if (has(config, LINE_BREAKS)) {\n    tokenType.LINE_BREAKS = config[LINE_BREAKS]\n  }\n\n  if (has(config, START_CHARS_HINT)) {\n    tokenType.START_CHARS_HINT = config[START_CHARS_HINT]\n  }\n\n  return tokenType\n}\n\nexport const EOF = createToken({ name: \"EOF\", pattern: Lexer.NA })\naugmentTokenTypes([EOF])\n\nexport function createTokenInstance(\n  tokType: TokenType,\n  image: string,\n  startOffset: number,\n  endOffset: number,\n  startLine: number,\n  endLine: number,\n  startColumn: number,\n  endColumn: number\n): IToken {\n  return {\n    image,\n    startOffset,\n    endOffset,\n    startLine,\n    endLine,\n    startColumn,\n    endColumn,\n    tokenTypeIdx: (<any>tokType).tokenTypeIdx,\n    tokenType: tokType\n  }\n}\n\nexport function tokenMatcher(token: IToken, tokType: TokenType): boolean {\n  return tokenStructuredMatcher(token, tokType)\n}\n", "import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public\"\nimport first from \"lodash/first\"\nimport map from \"lodash/map\"\nimport reduce from \"lodash/reduce\"\nimport { Alternation, NonTerminal, Rule, Terminal } from \"@chevrotain/gast\"\nimport { getProductionDslName } from \"@chevrotain/gast\"\nimport {\n  IParserErrorMessageProvider,\n  IProductionWithOccurrence,\n  TokenType\n} from \"@chevrotain/types\"\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider\n} from \"./grammar/types\"\n\nexport const defaultParserErrorProvider: IParserErrorMessageProvider = {\n  buildMismatchTokenMessage({ expected, actual, previous, ruleName }): string {\n    const hasLabel = hasTokenLabel(expected)\n    const expectedMsg = hasLabel\n      ? `--> ${tokenLabel(expected)} <--`\n      : `token of type --> ${expected.name} <--`\n\n    const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`\n\n    return msg\n  },\n\n  buildNotAllInputParsedMessage({ firstRedundant, ruleName }): string {\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image\n  },\n\n  buildNoViableAltMessage({\n    expectedPathsPerAlt,\n    actual,\n    previous,\n    customUserDescription,\n    ruleName\n  }): string {\n    const errPrefix = \"Expecting: \"\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual)!.image\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix\n    } else {\n      const allLookAheadPaths = reduce(\n        expectedPathsPerAlt,\n        (result, currAltPaths) => result.concat(currAltPaths),\n        [] as TokenType[][]\n      )\n      const nextValidTokenSequences = map(\n        allLookAheadPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \", \"\n          )}]`\n      )\n      const nextValidSequenceItems = map(\n        nextValidTokenSequences,\n        (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`\n      )\n      const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\n        \"\\n\"\n      )}`\n\n      return errPrefix + calculatedDescription + errSuffix\n    }\n  },\n\n  buildEarlyExitMessage({\n    expectedIterationPaths,\n    actual,\n    customUserDescription,\n    ruleName\n  }): string {\n    const errPrefix = \"Expecting: \"\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    const actualText = first(actual)!.image\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix\n    } else {\n      const nextValidTokenSequences = map(\n        expectedIterationPaths,\n        (currPath) =>\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\n            \",\"\n          )}]`\n      )\n      const calculatedDescription =\n        `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n        `<${nextValidTokenSequences.join(\" ,\")}>`\n\n      return errPrefix + calculatedDescription + errSuffix\n    }\n  }\n}\n\nObject.freeze(defaultParserErrorProvider)\n\nexport const defaultGrammarResolverErrorProvider: IGrammarResolverErrorMessageProvider =\n  {\n    buildRuleNotFoundError(\n      topLevelRule: Rule,\n      undefinedRule: NonTerminal\n    ): string {\n      const msg =\n        \"Invalid grammar, reference to a rule which is not defined: ->\" +\n        undefinedRule.nonTerminalName +\n        \"<-\\n\" +\n        \"inside top level rule: ->\" +\n        topLevelRule.name +\n        \"<-\"\n      return msg\n    }\n  }\n\nexport const defaultGrammarValidatorErrorProvider: IGrammarValidatorErrorMessageProvider =\n  {\n    buildDuplicateFoundError(\n      topLevelRule: Rule,\n      duplicateProds: IProductionWithOccurrence[]\n    ): string {\n      function getExtraProductionArgument(\n        prod: IProductionWithOccurrence\n      ): string {\n        if (prod instanceof Terminal) {\n          return prod.terminalType.name\n        } else if (prod instanceof NonTerminal) {\n          return prod.nonTerminalName\n        } else {\n          return \"\"\n        }\n      }\n\n      const topLevelName = topLevelRule.name\n      const duplicateProd = first(duplicateProds)!\n      const index = duplicateProd.idx\n      const dslName = getProductionDslName(duplicateProd)\n      const extraArgument = getExtraProductionArgument(duplicateProd)\n\n      const hasExplicitIndex = index > 0\n      let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${\n        extraArgument ? `with argument: ->${extraArgument}<-` : \"\"\n      }\n                  appears more than once (${\n                    duplicateProds.length\n                  } times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `\n\n      // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n      msg = msg.replace(/[ \\t]+/g, \" \")\n      msg = msg.replace(/\\s\\s+/g, \"\\n\")\n\n      return msg\n    },\n\n    buildNamespaceConflictError(rule: Rule): string {\n      const errMsg =\n        `Namespace conflict found in grammar.\\n` +\n        `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n        `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n        `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n        `and Non-Terminal names start with a lower case letter.`\n\n      return errMsg\n    },\n\n    buildAlternationPrefixAmbiguityError(options: {\n      topLevelRule: Rule\n      prefixPath: TokenType[]\n      ambiguityIndices: number[]\n      alternation: Alternation\n    }): string {\n      const pathMsg = map(options.prefixPath, (currTok) =>\n        tokenLabel(currTok)\n      ).join(\", \")\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx\n      const errMsg =\n        `Ambiguous alternatives: <${options.ambiguityIndices.join(\n          \" ,\"\n        )}> due to common lookahead prefix\\n` +\n        `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n        `For Further details.`\n\n      return errMsg\n    },\n\n    buildAlternationAmbiguityError(options: {\n      topLevelRule: Rule\n      prefixPath: TokenType[]\n      ambiguityIndices: number[]\n      alternation: Alternation\n    }): string {\n      const pathMsg = map(options.prefixPath, (currtok) =>\n        tokenLabel(currtok)\n      ).join(\", \")\n      const occurrence =\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx\n      let currMessage =\n        `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\n          \" ,\"\n        )}> in <OR${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`\n\n      currMessage =\n        currMessage +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n        `For Further details.`\n      return currMessage\n    },\n\n    buildEmptyRepetitionError(options: {\n      topLevelRule: Rule\n      repetition: IProductionWithOccurrence\n    }): string {\n      let dslName = getProductionDslName(options.repetition)\n      if (options.repetition.idx !== 0) {\n        dslName += options.repetition.idx\n      }\n\n      const errMsg =\n        `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n        `This could lead to an infinite loop.`\n\n      return errMsg\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options: {\n      tokenType: TokenType\n      expectedPattern: RegExp\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\"\n    },\n\n    buildEmptyAlternationError(options: {\n      topLevelRule: Rule\n      alternation: Alternation\n      emptyChoiceIdx: number\n    }): string {\n      const errMsg =\n        `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n        ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n        `Only the last alternative may be an empty alternative.`\n\n      return errMsg\n    },\n\n    buildTooManyAlternativesError(options: {\n      topLevelRule: Rule\n      alternation: Alternation\n    }): string {\n      const errMsg =\n        `An Alternation cannot have more than 256 alternatives:\\n` +\n        `<OR${options.alternation.idx}> inside <${\n          options.topLevelRule.name\n        }> Rule.\\n has ${\n          options.alternation.definition.length + 1\n        } alternatives.`\n\n      return errMsg\n    },\n\n    buildLeftRecursionError(options: {\n      topLevelRule: Rule\n      leftRecursionPath: Rule[]\n    }): string {\n      const ruleName = options.topLevelRule.name\n      const pathNames = map(\n        options.leftRecursionPath,\n        (currRule) => currRule.name\n      )\n      const leftRecursivePath = `${ruleName} --> ${pathNames\n        .concat([ruleName])\n        .join(\" --> \")}`\n      const errMsg =\n        `Left Recursion found in grammar.\\n` +\n        `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n        `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n        ` To fix this refactor your grammar to remove the left recursion.\\n` +\n        `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`\n\n      return errMsg\n    },\n\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options: {\n      topLevelRule: Rule\n      expectedPattern: RegExp\n    }): string {\n      /* istanbul ignore next */\n      return \"deprecated\"\n    },\n\n    buildDuplicateRuleNameError(options: {\n      topLevelRule: Rule | string\n      grammarName: string\n    }): string {\n      let ruleName\n      if (options.topLevelRule instanceof Rule) {\n        ruleName = options.topLevelRule.name\n      } else {\n        ruleName = options.topLevelRule\n      }\n\n      const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`\n\n      return errMsg\n    }\n  }\n", "import {\n  IParserUnresolvedRefDefinitionError,\n  ParserDefinitionErrorType\n} from \"../parser/parser\"\nimport forEach from \"lodash/forEach\"\nimport values from \"lodash/values\"\nimport { NonTerminal, Rule } from \"@chevrotain/gast\"\nimport { GAstVisitor } from \"@chevrotain/gast\"\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IParserDefinitionError\n} from \"./types\"\n\nexport function resolveGrammar(\n  topLevels: Record<string, Rule>,\n  errMsgProvider: IGrammarResolverErrorMessageProvider\n): IParserDefinitionError[] {\n  const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider)\n  refResolver.resolveRefs()\n  return refResolver.errors\n}\n\nexport class GastRefResolverVisitor extends GAstVisitor {\n  public errors: IParserUnresolvedRefDefinitionError[] = []\n  private currTopLevel: Rule\n\n  constructor(\n    private nameToTopRule: Record<string, Rule>,\n    private errMsgProvider: IGrammarResolverErrorMessageProvider\n  ) {\n    super()\n  }\n\n  public resolveRefs(): void {\n    forEach(values(this.nameToTopRule), (prod) => {\n      this.currTopLevel = prod\n      prod.accept(this)\n    })\n  }\n\n  public visitNonTerminal(node: NonTerminal): void {\n    const ref = this.nameToTopRule[node.nonTerminalName]\n\n    if (!ref) {\n      const msg = this.errMsgProvider.buildRuleNotFoundError(\n        this.currTopLevel,\n        node\n      )\n      this.errors.push({\n        message: msg,\n        type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n        ruleName: this.currTopLevel.name,\n        unresolvedRefName: node.nonTerminalName\n      })\n    } else {\n      node.referencedRule = ref\n    }\n  }\n}\n", "/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayAggregator;\n", "var baseEach = require('./_baseEach');\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseAggregator;\n", "var arrayAggregator = require('./_arrayAggregator'),\n    baseAggregator = require('./_baseAggregator'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\nmodule.exports = createAggregator;\n", "var baseAssignValue = require('./_baseAssignValue'),\n    createAggregator = require('./_createAggregator');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\n\nmodule.exports = groupBy;\n", "var baseFlatten = require('./_baseFlatten'),\n    map = require('./map');\n\n/**\n * Creates a flattened array of values by running each element in `collection`\n * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n * with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * function duplicate(n) {\n *   return [n, n];\n * }\n *\n * _.flatMap([1, 2], duplicate);\n * // => [1, 1, 2, 2]\n */\nfunction flatMap(collection, iteratee) {\n  return baseFlatten(map(collection, iteratee), 1);\n}\n\nmodule.exports = flatMap;\n", "var baseSlice = require('./_baseSlice'),\n    toInteger = require('./toInteger');\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the end.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.dropRight([1, 2, 3]);\n * // => [1, 2]\n *\n * _.dropRight([1, 2, 3], 2);\n * // => [1]\n *\n * _.dropRight([1, 2, 3], 5);\n * // => []\n *\n * _.dropRight([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction dropRight(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : toInteger(n);\n  n = length - n;\n  return baseSlice(array, 0, n < 0 ? 0 : n);\n}\n\nmodule.exports = dropRight;\n", "import { RestWalker } from \"./rest\"\nimport _first from \"lodash/first\"\nimport isEmpty from \"lodash/isEmpty\"\nimport dropRight from \"lodash/dropRight\"\nimport drop from \"lodash/drop\"\nimport last from \"lodash/last\"\nimport forEach from \"lodash/forEach\"\nimport clone from \"lodash/clone\"\nimport { first } from \"./first\"\nimport { TokenMatcher } from \"../parser/parser\"\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"@chevrotain/gast\"\nimport {\n  IGrammarPath,\n  IProduction,\n  ISyntacticContentAssistPath,\n  IToken,\n  ITokenGrammarPath,\n  TokenType\n} from \"@chevrotain/types\"\n\nexport abstract class AbstractNextPossibleTokensWalker extends RestWalker {\n  protected possibleTokTypes: TokenType[] = []\n  protected ruleStack: string[]\n  protected occurrenceStack: number[]\n\n  protected nextProductionName = \"\"\n  protected nextProductionOccurrence = 0\n  protected found = false\n  protected isAtEndOfPath = false\n\n  constructor(protected topProd: Rule, protected path: IGrammarPath) {\n    super()\n  }\n\n  startWalking(): TokenType[] {\n    this.found = false\n\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\")\n    }\n\n    // immutable for the win\n    this.ruleStack = clone(this.path.ruleStack).reverse() // intelij bug requires assertion\n    this.occurrenceStack = clone(this.path.occurrenceStack).reverse() // intelij bug requires assertion\n\n    // already verified that the first production is valid, we now seek the 2nd production\n    this.ruleStack.pop()\n    this.occurrenceStack.pop()\n\n    this.updateExpectedNext()\n    this.walk(this.topProd)\n\n    return this.possibleTokTypes\n  }\n\n  walk(\n    prod: { definition: IProduction[] },\n    prevRest: IProduction[] = []\n  ): void {\n    // stop scanning once we found the path\n    if (!this.found) {\n      super.walk(prod, prevRest)\n    }\n  }\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // found the next production, need to keep walking in it\n    if (\n      refProd.referencedRule.name === this.nextProductionName &&\n      refProd.idx === this.nextProductionOccurrence\n    ) {\n      const fullRest = currRest.concat(prevRest)\n      this.updateExpectedNext()\n      this.walk(refProd.referencedRule, <any>fullRest)\n    }\n  }\n\n  updateExpectedNext(): void {\n    // need to consume the Terminal\n    if (isEmpty(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\"\n      this.nextProductionOccurrence = 0\n      this.isAtEndOfPath = true\n    } else {\n      this.nextProductionName = this.ruleStack.pop()!\n      this.nextProductionOccurrence = this.occurrenceStack.pop()!\n    }\n  }\n}\n\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n  private nextTerminalName = \"\"\n  private nextTerminalOccurrence = 0\n\n  constructor(topProd: Rule, protected path: ITokenGrammarPath) {\n    super(topProd, path)\n    this.nextTerminalName = this.path.lastTok.name\n    this.nextTerminalOccurrence = this.path.lastTokOccurrence\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      this.isAtEndOfPath &&\n      terminal.terminalType.name === this.nextTerminalName &&\n      terminal.idx === this.nextTerminalOccurrence &&\n      !this.found\n    ) {\n      const fullRest = currRest.concat(prevRest)\n      const restProd = new Alternative({ definition: fullRest })\n      this.possibleTokTypes = first(restProd)\n      this.found = true\n    }\n  }\n}\n\nexport type AlternativesFirstTokens = TokenType[][]\n\nexport interface IFirstAfterRepetition {\n  token: TokenType | undefined\n  occurrence: number | undefined\n  isEndOfRule: boolean | undefined\n}\n\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n  protected result: IFirstAfterRepetition = {\n    token: undefined,\n    occurrence: undefined,\n    isEndOfRule: undefined\n  }\n\n  constructor(protected topRule: Rule, protected occurrence: number) {\n    super()\n  }\n\n  startWalking(): IFirstAfterRepetition {\n    this.walk(this.topRule)\n    return this.result\n  }\n}\n\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (manyProd.idx === this.occurrence) {\n      const firstAfterMany = _first(currRest.concat(prevRest))\n      this.result.isEndOfRule = firstAfterMany === undefined\n      if (firstAfterMany instanceof Terminal) {\n        this.result.token = firstAfterMany.terminalType\n        this.result.occurrence = firstAfterMany.idx\n      }\n    } else {\n      super.walkMany(manyProd, currRest, prevRest)\n    }\n  }\n}\n\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (manySepProd.idx === this.occurrence) {\n      const firstAfterManySep = _first(currRest.concat(prevRest))\n      this.result.isEndOfRule = firstAfterManySep === undefined\n      if (firstAfterManySep instanceof Terminal) {\n        this.result.token = firstAfterManySep.terminalType\n        this.result.occurrence = firstAfterManySep.idx\n      }\n    } else {\n      super.walkManySep(manySepProd, currRest, prevRest)\n    }\n  }\n}\n\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (atLeastOneProd.idx === this.occurrence) {\n      const firstAfterAtLeastOne = _first(currRest.concat(prevRest))\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined\n      if (firstAfterAtLeastOne instanceof Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType\n        this.result.occurrence = firstAfterAtLeastOne.idx\n      }\n    } else {\n      super.walkAtLeastOne(atLeastOneProd, currRest, prevRest)\n    }\n  }\n}\n\n// TODO: reduce code duplication in the AfterWalkers\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n  walkAtLeastOneSep(\n    atleastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      const firstAfterfirstAfterAtLeastOneSep = _first(\n        currRest.concat(prevRest)\n      )\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx\n      }\n    } else {\n      super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest)\n    }\n  }\n}\n\nexport interface PartialPathAndSuffixes {\n  partialPath: TokenType[]\n  suffixDef: IProduction[]\n}\n\nexport function possiblePathsFrom(\n  targetDef: IProduction[],\n  maxLength: number,\n  currPath: TokenType[] = []\n): PartialPathAndSuffixes[] {\n  // avoid side effects\n  currPath = clone(currPath)\n  let result: PartialPathAndSuffixes[] = []\n  let i = 0\n\n  // TODO: avoid inner funcs\n  function remainingPathWith(nextDef: IProduction[]) {\n    return nextDef.concat(drop(targetDef, i + 1))\n  }\n\n  // TODO: avoid inner funcs\n  function getAlternativesForProd(definition: IProduction[]) {\n    const alternatives = possiblePathsFrom(\n      remainingPathWith(definition),\n      maxLength,\n      currPath\n    )\n    return result.concat(alternatives)\n  }\n\n  /**\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n   * following (rest) of the targetDef.\n   *\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n   * the optional production.\n   */\n  while (currPath.length < maxLength && i < targetDef.length) {\n    const prod = targetDef[i]\n\n    /* istanbul ignore else */\n    if (prod instanceof Alternative) {\n      return getAlternativesForProd(prod.definition)\n    } else if (prod instanceof NonTerminal) {\n      return getAlternativesForProd(prod.definition)\n    } else if (prod instanceof Option) {\n      result = getAlternativesForProd(prod.definition)\n    } else if (prod instanceof RepetitionMandatory) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ])\n      return getAlternativesForProd(newDef)\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      const newDef = [\n        new Alternative({ definition: prod.definition }),\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition\n          )\n        })\n      ]\n      return getAlternativesForProd(newDef)\n    } else if (prod instanceof RepetitionWithSeparator) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\n            <any>prod.definition\n          )\n        })\n      ])\n      result = getAlternativesForProd(newDef)\n    } else if (prod instanceof Repetition) {\n      const newDef = prod.definition.concat([\n        new Repetition({\n          definition: prod.definition\n        })\n      ])\n      result = getAlternativesForProd(newDef)\n    } else if (prod instanceof Alternation) {\n      forEach(prod.definition, (currAlt) => {\n        // TODO: this is a limited check for empty alternatives\n        //   It would prevent a common case of infinite loops during parser initialization.\n        //   However **in-directly** empty alternatives may still cause issues.\n        if (isEmpty(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition)\n        }\n      })\n      return result\n    } else if (prod instanceof Terminal) {\n      currPath.push(prod.terminalType)\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n\n    i++\n  }\n  result.push({\n    partialPath: currPath,\n    suffixDef: drop(targetDef, i)\n  })\n\n  return result\n}\n\ninterface IPathToExamine {\n  idx: number\n  def: IProduction[]\n  ruleStack: string[]\n  occurrenceStack: number[]\n}\n\nexport function nextPossibleTokensAfter(\n  initialDef: IProduction[],\n  tokenVector: IToken[],\n  tokMatcher: TokenMatcher,\n  maxLookAhead: number\n): ISyntacticContentAssistPath[] {\n  const EXIT_NON_TERMINAL: any = \"EXIT_NONE_TERMINAL\"\n  // to avoid creating a new Array each time.\n  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL]\n  const EXIT_ALTERNATIVE: any = \"EXIT_ALTERNATIVE\"\n  let foundCompletePath = false\n\n  const tokenVectorLength = tokenVector.length\n  const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1\n\n  const result: ISyntacticContentAssistPath[] = []\n\n  const possiblePaths: IPathToExamine[] = []\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  })\n\n  while (!isEmpty(possiblePaths)) {\n    const currPath = possiblePaths.pop()!\n\n    // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (\n        foundCompletePath &&\n        last(possiblePaths)!.idx <= minimalAlternativesIndex\n      ) {\n        // remove irrelevant alternative\n        possiblePaths.pop()\n      }\n      continue\n    }\n\n    const currDef = currPath.def\n    const currIdx = currPath.idx\n    const currRuleStack = currPath.ruleStack\n    const currOccurrenceStack = currPath.occurrenceStack\n\n    // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n    if (isEmpty(currDef)) {\n      continue\n    }\n\n    const prod = currDef[0]\n    /* istanbul ignore else */\n    if (prod === EXIT_NON_TERMINAL) {\n      const nextPath = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: dropRight(currRuleStack),\n        occurrenceStack: dropRight(currOccurrenceStack)\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        const nextIdx = currIdx + 1\n        const actualToken = tokenVector[nextIdx]\n        if (tokMatcher!(actualToken, prod.terminalType)) {\n          const nextPath = {\n            idx: nextIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          }\n          possiblePaths.push(nextPath)\n        }\n        // end of the line\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        })\n        foundCompletePath = true\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    } else if (prod instanceof NonTerminal) {\n      const newRuleStack = clone(currRuleStack)\n      newRuleStack.push(prod.nonTerminalName)\n\n      const newOccurrenceStack = clone(currOccurrenceStack)\n      newOccurrenceStack.push(prod.idx)\n\n      const nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWithout)\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE)\n\n      const nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWith)\n    } else if (prod instanceof RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const secondIteration = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      })\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef))\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      })\n      const secondIteration = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx\n      })\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef))\n      const nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPath)\n    } else if (prod instanceof RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWithout)\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE)\n\n      const separatorGast = new Terminal({\n        terminalType: prod.separator\n      })\n      const nthRepetition = new Repetition({\n        definition: [<any>separatorGast].concat(prod.definition),\n        idx: prod.idx\n      })\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWith)\n    } else if (prod instanceof Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      const nextPathWithout = {\n        idx: currIdx,\n        def: drop(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWithout)\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\n      possiblePaths.push(EXIT_ALTERNATIVE)\n\n      // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n      const nthRepetition = new Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      })\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n      const nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      }\n      possiblePaths.push(nextPathWith)\n    } else if (prod instanceof Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (let i = prod.definition.length - 1; i >= 0; i--) {\n        const currAlt: any = prod.definition[i]\n        const currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        }\n        possiblePaths.push(currAltPath)\n        possiblePaths.push(EXIT_ALTERNATIVE)\n      }\n    } else if (prod instanceof Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat(drop(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      })\n    } else if (prod instanceof Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(\n        expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack)\n      )\n    } else {\n      throw Error(\"non exhaustive match\")\n    }\n  }\n  return result\n}\n\nfunction expandTopLevelRule(\n  topRule: Rule,\n  currIdx: number,\n  currRuleStack: string[],\n  currOccurrenceStack: number[]\n): IPathToExamine {\n  const newRuleStack = clone(currRuleStack)\n  newRuleStack.push(topRule.name)\n\n  const newCurrOccurrenceStack = clone(currOccurrenceStack)\n  // top rule is always assumed to have been called with occurrence index 1\n  newCurrOccurrenceStack.push(1)\n\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  }\n}\n", "import isEmpty from \"lodash/isEmpty\"\nimport flatten from \"lodash/flatten\"\nimport every from \"lodash/every\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport has from \"lodash/has\"\nimport reduce from \"lodash/reduce\"\nimport { possiblePathsFrom } from \"./interpreter\"\nimport { RestWalker } from \"./rest\"\nimport { Predicate, TokenMatcher } from \"../parser/parser\"\nimport {\n  tokenStructuredMatcher,\n  tokenStructuredMatcherNoCategories\n} from \"../../scan/tokens\"\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator\n} from \"@chevrotain/gast\"\nimport { GAstVisitor } from \"@chevrotain/gast\"\nimport {\n  IOrAlt,\n  IProduction,\n  IProductionWithOccurrence,\n  LookaheadSequence,\n  LookaheadProductionType,\n  Rule,\n  TokenType,\n  BaseParser\n} from \"@chevrotain/types\"\n\nexport enum PROD_TYPE {\n  OPTION,\n  REPETITION,\n  REPETITION_MANDATORY,\n  REPETITION_MANDATORY_WITH_SEPARATOR,\n  REPETITION_WITH_SEPARATOR,\n  ALTERNATION\n}\n\nexport function getProdType(\n  prod: IProduction | LookaheadProductionType\n): PROD_TYPE {\n  /* istanbul ignore else */\n  if (prod instanceof Option || prod === \"Option\") {\n    return PROD_TYPE.OPTION\n  } else if (prod instanceof Repetition || prod === \"Repetition\") {\n    return PROD_TYPE.REPETITION\n  } else if (\n    prod instanceof RepetitionMandatory ||\n    prod === \"RepetitionMandatory\"\n  ) {\n    return PROD_TYPE.REPETITION_MANDATORY\n  } else if (\n    prod instanceof RepetitionMandatoryWithSeparator ||\n    prod === \"RepetitionMandatoryWithSeparator\"\n  ) {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR\n  } else if (\n    prod instanceof RepetitionWithSeparator ||\n    prod === \"RepetitionWithSeparator\"\n  ) {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR\n  } else if (prod instanceof Alternation || prod === \"Alternation\") {\n    return PROD_TYPE.ALTERNATION\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n}\n\nexport function getLookaheadPaths(options: {\n  occurrence: number\n  rule: Rule\n  prodType: LookaheadProductionType\n  maxLookahead: number\n}): LookaheadSequence[] {\n  const { occurrence, rule, prodType, maxLookahead } = options\n  const type = getProdType(prodType)\n  if (type === PROD_TYPE.ALTERNATION) {\n    return getLookaheadPathsForOr(occurrence, rule, maxLookahead)\n  } else {\n    return getLookaheadPathsForOptionalProd(\n      occurrence,\n      rule,\n      type,\n      maxLookahead\n    )\n  }\n}\n\nexport function buildLookaheadFuncForOr(\n  occurrence: number,\n  ruleGrammar: Rule,\n  maxLookahead: number,\n  hasPredicates: boolean,\n  dynamicTokensEnabled: boolean,\n  laFuncBuilder: Function\n): (orAlts?: IOrAlt<any>[]) => number | undefined {\n  const lookAheadPaths = getLookaheadPathsForOr(\n    occurrence,\n    ruleGrammar,\n    maxLookahead\n  )\n\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n    ? tokenStructuredMatcherNoCategories\n    : tokenStructuredMatcher\n\n  return laFuncBuilder(\n    lookAheadPaths,\n    hasPredicates,\n    tokenMatcher,\n    dynamicTokensEnabled\n  )\n}\n\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nexport function buildLookaheadFuncForOptionalProd(\n  occurrence: number,\n  ruleGrammar: Rule,\n  k: number,\n  dynamicTokensEnabled: boolean,\n  prodType: PROD_TYPE,\n  lookaheadBuilder: (\n    lookAheadSequence: LookaheadSequence,\n    tokenMatcher: TokenMatcher,\n    dynamicTokensEnabled: boolean\n  ) => () => boolean\n): () => boolean {\n  const lookAheadPaths = getLookaheadPathsForOptionalProd(\n    occurrence,\n    ruleGrammar,\n    prodType,\n    k\n  )\n\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n    ? tokenStructuredMatcherNoCategories\n    : tokenStructuredMatcher\n\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled)\n}\n\nexport type Alternative = TokenType[][]\n\nexport function buildAlternativesLookAheadFunc(\n  alts: LookaheadSequence[],\n  hasPredicates: boolean,\n  tokenMatcher: TokenMatcher,\n  dynamicTokensEnabled: boolean\n): (orAlts: IOrAlt<any>[]) => number | undefined {\n  const numOfAlts = alts.length\n  const areAllOneTokenLookahead = every(alts, (currAlt) => {\n    return every(currAlt, (currPath) => {\n      return currPath.length === 1\n    })\n  })\n\n  // This version takes into account the predicates as well.\n  if (hasPredicates) {\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (\n      this: BaseParser,\n      orAlts: IOrAlt<any>[]\n    ): number | undefined {\n      // unfortunately the predicates must be extracted every single time\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n      const predicates: (Predicate | undefined)[] = map(\n        orAlts,\n        (currAlt) => currAlt.GATE\n      )\n\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t]\n        const currNumOfPaths = currAlt.length\n\n        const currPredicate = predicates[t]\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\n          // if the predicate does not match there is no point in checking the paths\n          continue\n        }\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j]\n          const currPathLength = currPath.length\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1)\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined\n    }\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n    const singleTokenAlts = map(alts, (currAlt) => {\n      return flatten(currAlt)\n    })\n\n    const choiceToAlt = reduce(\n      singleTokenAlts,\n      (result, currAlt, idx) => {\n        forEach(currAlt, (currTokType) => {\n          if (!has(result, currTokType.tokenTypeIdx!)) {\n            result[currTokType.tokenTypeIdx!] = idx\n          }\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\n            if (!has(result, currExtendingType)) {\n              result[currExtendingType] = idx\n            }\n          })\n        })\n        return result\n      },\n      {} as Record<number, number>\n    )\n\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (this: BaseParser): number {\n      const nextToken = this.LA(1)\n      return choiceToAlt[nextToken.tokenTypeIdx]\n    }\n  } else {\n    // optimized lookahead without needing to check the predicates at all.\n    // this causes code duplication which is intentional to improve performance.\n    /**\n     * @returns {number} - The chosen alternative index\n     */\n    return function (this: BaseParser): number | undefined {\n      for (let t = 0; t < numOfAlts; t++) {\n        const currAlt = alts[t]\n        const currNumOfPaths = currAlt.length\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n          const currPath = currAlt[j]\n          const currPathLength = currPath.length\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1)\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath\n            }\n          }\n          // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n          return t\n        }\n        // none of the paths for the current alternative matched\n        // try the next alternative\n      }\n      // none of the alternatives could be matched\n      return undefined\n    }\n  }\n}\n\nexport function buildSingleAlternativeLookaheadFunction(\n  alt: LookaheadSequence,\n  tokenMatcher: TokenMatcher,\n  dynamicTokensEnabled: boolean\n): () => boolean {\n  const areAllOneTokenLookahead = every(alt, (currPath) => {\n    return currPath.length === 1\n  })\n\n  const numOfPaths = alt.length\n\n  // optimized (common) case of all the lookaheads paths requiring only\n  // a single token lookahead.\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    const singleTokensTypes = flatten(alt)\n\n    if (\n      singleTokensTypes.length === 1 &&\n      isEmpty((<any>singleTokensTypes[0]).categoryMatches)\n    ) {\n      const expectedTokenType = singleTokensTypes[0]\n      const expectedTokenUniqueKey = (<any>expectedTokenType).tokenTypeIdx\n\n      return function (this: BaseParser): boolean {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey\n      }\n    } else {\n      const choiceToAlt = reduce(\n        singleTokensTypes,\n        (result, currTokType, idx) => {\n          result[currTokType.tokenTypeIdx!] = true\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\n            result[currExtendingType] = true\n          })\n          return result\n        },\n        [] as boolean[]\n      )\n\n      return function (this: BaseParser): boolean {\n        const nextToken = this.LA(1)\n        return choiceToAlt[nextToken.tokenTypeIdx] === true\n      }\n    }\n  } else {\n    return function (this: BaseParser): boolean {\n      nextPath: for (let j = 0; j < numOfPaths; j++) {\n        const currPath = alt[j]\n        const currPathLength = currPath.length\n        for (let i = 0; i < currPathLength; i++) {\n          const nextToken = this.LA(i + 1)\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\n            // mismatch in current path\n            // try the next pth\n            continue nextPath\n          }\n        }\n        // found a full path that matches.\n        return true\n      }\n\n      // none of the paths matched\n      return false\n    }\n  }\n}\n\nclass RestDefinitionFinderWalker extends RestWalker {\n  private restDef: IProduction[]\n\n  constructor(\n    private topProd: Rule,\n    private targetOccurrence: number,\n    private targetProdType: PROD_TYPE\n  ) {\n    super()\n  }\n\n  startWalking(): IProduction[] {\n    this.walk(this.topProd)\n    return this.restDef\n  }\n\n  private checkIsTarget(\n    node: IProductionWithOccurrence,\n    expectedProdType: PROD_TYPE,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): boolean {\n    if (\n      node.idx === this.targetOccurrence &&\n      this.targetProdType === expectedProdType\n    ) {\n      this.restDef = currRest.concat(prevRest)\n      return true\n    }\n    // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n    return false\n  }\n\n  walkOption(\n    optionProd: Option,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      super.walkOption(optionProd, currRest, prevRest)\n    }\n  }\n\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(\n        atLeastOneProd,\n        PROD_TYPE.REPETITION_MANDATORY,\n        currRest,\n        prevRest\n      )\n    ) {\n      super.walkOption(atLeastOneProd, currRest, prevRest)\n    }\n  }\n\n  walkAtLeastOneSep(\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(\n        atLeastOneSepProd,\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n        currRest,\n        prevRest\n      )\n    ) {\n      super.walkOption(atLeastOneSepProd, currRest, prevRest)\n    }\n  }\n\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)\n    ) {\n      super.walkOption(manyProd, currRest, prevRest)\n    }\n  }\n\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    if (\n      !this.checkIsTarget(\n        manySepProd,\n        PROD_TYPE.REPETITION_WITH_SEPARATOR,\n        currRest,\n        prevRest\n      )\n    ) {\n      super.walkOption(manySepProd, currRest, prevRest)\n    }\n  }\n}\n\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nclass InsideDefinitionFinderVisitor extends GAstVisitor {\n  public result: IProduction[] = []\n\n  constructor(\n    private targetOccurrence: number,\n    private targetProdType: PROD_TYPE,\n    private targetRef?: any\n  ) {\n    super()\n  }\n\n  private checkIsTarget(\n    node: { definition: IProduction[] } & IProductionWithOccurrence,\n    expectedProdName: PROD_TYPE\n  ): void {\n    if (\n      node.idx === this.targetOccurrence &&\n      this.targetProdType === expectedProdName &&\n      (this.targetRef === undefined || node === this.targetRef)\n    ) {\n      this.result = node.definition\n    }\n  }\n\n  public visitOption(node: Option): void {\n    this.checkIsTarget(node, PROD_TYPE.OPTION)\n  }\n\n  public visitRepetition(node: Repetition): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION)\n  }\n\n  public visitRepetitionMandatory(node: RepetitionMandatory): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator\n  ): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)\n  }\n\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): void {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR)\n  }\n\n  public visitAlternation(node: Alternation): void {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION)\n  }\n}\n\nfunction initializeArrayOfArrays(size: number): any[][] {\n  const result = new Array(size)\n  for (let i = 0; i < size; i++) {\n    result[i] = []\n  }\n  return result\n}\n\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path: TokenType[]): string[] {\n  let keys = [\"\"]\n  for (let i = 0; i < path.length; i++) {\n    const tokType = path[i]\n    const longerKeys = []\n    for (let j = 0; j < keys.length; j++) {\n      const currShorterKey = keys[j]\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx)\n      for (let t = 0; t < tokType.categoryMatches!.length; t++) {\n        const categoriesKeySuffix = \"_\" + tokType.categoryMatches![t]\n        longerKeys.push(currShorterKey + categoriesKeySuffix)\n      }\n    }\n    keys = longerKeys\n  }\n  return keys\n}\n\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(\n  altKnownPathsKeys: Record<string, boolean>[],\n  searchPathKeys: string[],\n  idx: number\n): boolean {\n  for (\n    let currAltIdx = 0;\n    currAltIdx < altKnownPathsKeys.length;\n    currAltIdx++\n  ) {\n    // We only want to test vs the other alternatives\n    if (currAltIdx === idx) {\n      continue\n    }\n    const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx]\n    for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      const searchKey = searchPathKeys[searchIdx]\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false\n      }\n    }\n  }\n  // None of the SearchPathKeys were found in any of the other alternatives\n  return true\n}\n\nexport function lookAheadSequenceFromAlternatives(\n  altsDefs: IProduction[],\n  k: number\n): LookaheadSequence[] {\n  const partialAlts = map(altsDefs, (currAlt) =>\n    possiblePathsFrom([currAlt], 1)\n  )\n  const finalResult = initializeArrayOfArrays(partialAlts.length)\n  const altsHashes = map(partialAlts, (currAltPaths) => {\n    const dict: { [key: string]: boolean } = {}\n    forEach(currAltPaths, (item) => {\n      const keys = pathToHashKeys(item.partialPath)\n      forEach(keys, (currKey) => {\n        dict[currKey] = true\n      })\n    })\n    return dict\n  })\n  let newData = partialAlts\n\n  // maxLookahead loop\n  for (let pathLength = 1; pathLength <= k; pathLength++) {\n    const currDataset = newData\n    newData = initializeArrayOfArrays(currDataset.length)\n\n    // alternatives loop\n    for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      const currAltPathsAndSuffixes = currDataset[altIdx]\n      // paths in current alternative loop\n      for (\n        let currPathIdx = 0;\n        currPathIdx < currAltPathsAndSuffixes.length;\n        currPathIdx++\n      ) {\n        const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath\n        const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef\n        const prefixKeys = pathToHashKeys(currPathPrefix)\n        const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx)\n        // End of the line for this path.\n        if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n          const currAltResult = finalResult[altIdx]\n          // TODO: Can we implement a containsPath using Maps/Dictionaries?\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix)\n            // Update all new  keys for the current path.\n            for (let j = 0; j < prefixKeys.length; j++) {\n              const currKey = prefixKeys[j]\n              altsHashes[altIdx][currKey] = true\n            }\n          }\n        }\n        // Expand longer paths\n        else {\n          const newPartialPathsAndSuffixes = possiblePathsFrom(\n            suffixDef,\n            pathLength + 1,\n            currPathPrefix\n          )\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes)\n\n          // Update keys for new known paths\n          forEach(newPartialPathsAndSuffixes, (item) => {\n            const prefixKeys = pathToHashKeys(item.partialPath)\n            forEach(prefixKeys, (key) => {\n              altsHashes[altIdx][key] = true\n            })\n          })\n        }\n      }\n    }\n  }\n\n  return finalResult\n}\n\nexport function getLookaheadPathsForOr(\n  occurrence: number,\n  ruleGrammar: Rule,\n  k: number,\n  orProd?: Alternation\n): LookaheadSequence[] {\n  const visitor = new InsideDefinitionFinderVisitor(\n    occurrence,\n    PROD_TYPE.ALTERNATION,\n    orProd\n  )\n  ruleGrammar.accept(visitor)\n  return lookAheadSequenceFromAlternatives(visitor.result, k)\n}\n\nexport function getLookaheadPathsForOptionalProd(\n  occurrence: number,\n  ruleGrammar: Rule,\n  prodType: PROD_TYPE,\n  k: number\n): LookaheadSequence[] {\n  const insideDefVisitor = new InsideDefinitionFinderVisitor(\n    occurrence,\n    prodType\n  )\n  ruleGrammar.accept(insideDefVisitor)\n  const insideDef = insideDefVisitor.result\n\n  const afterDefWalker = new RestDefinitionFinderWalker(\n    ruleGrammar,\n    occurrence,\n    prodType\n  )\n  const afterDef = afterDefWalker.startWalking()\n\n  const insideFlat = new AlternativeGAST({ definition: insideDef })\n  const afterFlat = new AlternativeGAST({ definition: afterDef })\n\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k)\n}\n\nexport function containsPath(\n  alternative: Alternative,\n  searchPath: TokenType[]\n): boolean {\n  compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n    const otherPath = alternative[i]\n    if (otherPath.length !== searchPath.length) {\n      continue\n    }\n    for (let j = 0; j < otherPath.length; j++) {\n      const searchTok = searchPath[j]\n      const otherTok = otherPath[j]\n\n      const matchingTokens =\n        searchTok === otherTok ||\n        otherTok.categoryMatchesMap![searchTok.tokenTypeIdx!] !== undefined\n      if (matchingTokens === false) {\n        continue compareOtherPath\n      }\n    }\n    return true\n  }\n\n  return false\n}\n\nexport function isStrictPrefixOfPath(\n  prefix: TokenType[],\n  other: TokenType[]\n): boolean {\n  return (\n    prefix.length < other.length &&\n    every(prefix, (tokType, idx) => {\n      const otherTokType = other[idx]\n      return (\n        tokType === otherTokType ||\n        otherTokType.categoryMatchesMap![tokType.tokenTypeIdx!]\n      )\n    })\n  )\n}\n\nexport function areTokenCategoriesNotUsed(\n  lookAheadPaths: LookaheadSequence[]\n): boolean {\n  return every(lookAheadPaths, (singleAltPaths) =>\n    every(singleAltPaths, (singlePath) =>\n      every(singlePath, (token) => isEmpty(token.categoryMatches!))\n    )\n  )\n}\n", "import first from \"lodash/first\"\nimport isEmpty from \"lodash/isEmpty\"\nimport drop from \"lodash/drop\"\nimport flatten from \"lodash/flatten\"\nimport filter from \"lodash/filter\"\nimport reject from \"lodash/reject\"\nimport difference from \"lodash/difference\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport groupBy from \"lodash/groupBy\"\nimport reduce from \"lodash/reduce\"\nimport pickBy from \"lodash/pickBy\"\nimport values from \"lodash/values\"\nimport includes from \"lodash/includes\"\nimport flatMap from \"lodash/flatMap\"\nimport clone from \"lodash/clone\"\nimport {\n  IParserAmbiguousAlternativesDefinitionError,\n  IParserDuplicatesDefinitionError,\n  IParserEmptyAlternativeDefinitionError,\n  ParserDefinitionErrorType\n} from \"../parser/parser\"\nimport { getProductionDslName, isOptionalProd } from \"@chevrotain/gast\"\nimport {\n  Alternative,\n  containsPath,\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  getProdType,\n  isStrictPrefixOfPath\n} from \"./lookahead\"\nimport { nextPossibleTokensAfter } from \"./interpreter\"\nimport {\n  Alternation,\n  Alternative as AlternativeGAST,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal\n} from \"@chevrotain/gast\"\nimport { GAstVisitor } from \"@chevrotain/gast\"\nimport {\n  ILookaheadStrategy,\n  IProduction,\n  IProductionWithOccurrence,\n  TokenType,\n  Rule\n} from \"@chevrotain/types\"\nimport {\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError\n} from \"./types\"\nimport dropRight from \"lodash/dropRight\"\nimport compact from \"lodash/compact\"\nimport { tokenStructuredMatcher } from \"../../scan/tokens\"\n\nexport function validateLookahead(options: {\n  lookaheadStrategy: ILookaheadStrategy\n  rules: Rule[]\n  tokenTypes: TokenType[]\n  grammarName: string\n}): IParserDefinitionError[] {\n  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n    rules: options.rules,\n    tokenTypes: options.tokenTypes,\n    grammarName: options.grammarName\n  })\n  return map(lookaheadValidationErrorMessages, (errorMessage) => ({\n    type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION,\n    ...errorMessage\n  }))\n}\n\nexport function validateGrammar(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  grammarName: string\n): IParserDefinitionError[] {\n  const duplicateErrors: IParserDefinitionError[] = flatMap(\n    topLevels,\n    (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider)\n  )\n\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\n    topLevels,\n    tokenTypes,\n    errMsgProvider\n  )\n\n  const tooManyAltsErrors = flatMap(topLevels, (curRule) =>\n    validateTooManyAlts(curRule, errMsgProvider)\n  )\n\n  const duplicateRulesError = flatMap(topLevels, (curRule) =>\n    validateRuleDoesNotAlreadyExist(\n      curRule,\n      topLevels,\n      grammarName,\n      errMsgProvider\n    )\n  )\n\n  return duplicateErrors.concat(\n    termsNamespaceConflictErrors,\n    tooManyAltsErrors,\n    duplicateRulesError\n  )\n}\n\nfunction validateDuplicateProductions(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDuplicatesDefinitionError[] {\n  const collectorVisitor = new OccurrenceValidationCollector()\n  topLevelRule.accept(collectorVisitor)\n  const allRuleProductions = collectorVisitor.allProductions\n\n  const productionGroups = groupBy(\n    allRuleProductions,\n    identifyProductionForDuplicates\n  )\n\n  const duplicates: any = pickBy(productionGroups, (currGroup) => {\n    return currGroup.length > 1\n  })\n\n  const errors = map(values(duplicates), (currDuplicates: any) => {\n    const firstProd: any = first(currDuplicates)\n    const msg = errMsgProvider.buildDuplicateFoundError(\n      topLevelRule,\n      currDuplicates\n    )\n    const dslName = getProductionDslName(firstProd)\n    const defError: IParserDuplicatesDefinitionError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    }\n\n    const param = getExtraProductionArgument(firstProd)\n    if (param) {\n      defError.parameter = param\n    }\n\n    return defError\n  })\n  return errors\n}\n\nexport function identifyProductionForDuplicates(\n  prod: IProductionWithOccurrence\n): string {\n  return `${getProductionDslName(prod)}_#_${\n    prod.idx\n  }_#_${getExtraProductionArgument(prod)}`\n}\n\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName\n  } else {\n    return \"\"\n  }\n}\n\nexport class OccurrenceValidationCollector extends GAstVisitor {\n  public allProductions: IProductionWithOccurrence[] = []\n\n  public visitNonTerminal(subrule: NonTerminal): void {\n    this.allProductions.push(subrule)\n  }\n\n  public visitOption(option: Option): void {\n    this.allProductions.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.allProductions.push(or)\n  }\n\n  public visitTerminal(terminal: Terminal): void {\n    this.allProductions.push(terminal)\n  }\n}\n\nexport function validateRuleDoesNotAlreadyExist(\n  rule: Rule,\n  allRules: Rule[],\n  className: string,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors = []\n  const occurrences = reduce(\n    allRules,\n    (result, curRule) => {\n      if (curRule.name === rule.name) {\n        return result + 1\n      }\n      return result\n    },\n    0\n  )\n  if (occurrences > 1) {\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    })\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    })\n  }\n\n  return errors\n}\n\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(\n  ruleName: string,\n  definedRulesNames: string[],\n  className: string\n): IParserDefinitionError[] {\n  const errors = []\n  let errMsg\n\n  if (!includes(definedRulesNames, ruleName)) {\n    errMsg =\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n      `as it is not defined in any of the super grammars `\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    })\n  }\n\n  return errors\n}\n\nexport function validateNoLeftRecursion(\n  topRule: Rule,\n  currRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\n  path: Rule[] = []\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition)\n  if (isEmpty(nextNonTerminals)) {\n    return []\n  } else {\n    const ruleName = topRule.name\n    const foundLeftRecursion = includes(nextNonTerminals, topRule)\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      })\n    }\n\n    // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n    const validNextSteps = difference(nextNonTerminals, path.concat([topRule]))\n    const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n      const newPath = clone(path)\n      newPath.push(currRefRule)\n      return validateNoLeftRecursion(\n        topRule,\n        currRefRule,\n        errMsgProvider,\n        newPath\n      )\n    })\n\n    return errors.concat(errorsFromNextSteps)\n  }\n}\n\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\n  let result: Rule[] = []\n  if (isEmpty(definition)) {\n    return result\n  }\n  const firstProd = first(definition)\n\n  /* istanbul ignore else */\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule)\n  } else if (\n    firstProd instanceof AlternativeGAST ||\n    firstProd instanceof Option ||\n    firstProd instanceof RepetitionMandatory ||\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\n    firstProd instanceof RepetitionWithSeparator ||\n    firstProd instanceof Repetition\n  ) {\n    result = result.concat(\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition)\n    )\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = flatten(\n      map(firstProd.definition, (currSubDef) =>\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition)\n      )\n    )\n  } else if (firstProd instanceof Terminal) {\n    // nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\")\n  }\n\n  const isFirstOptional = isOptionalProd(firstProd)\n  const hasMore = definition.length > 1\n  if (isFirstOptional && hasMore) {\n    const rest = drop(definition)\n    return result.concat(getFirstNoneTerminal(rest))\n  } else {\n    return result\n  }\n}\n\nclass OrCollector extends GAstVisitor {\n  public alternations: Alternation[] = []\n\n  public visitAlternation(node: Alternation): void {\n    this.alternations.push(node)\n  }\n}\n\nexport function validateEmptyOrAlternative(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserEmptyAlternativeDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = flatMap<Alternation, IParserEmptyAlternativeDefinitionError>(\n    ors,\n    (currOr) => {\n      const exceptLast = dropRight(currOr.definition)\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n        const possibleFirstInAlt = nextPossibleTokensAfter(\n          [currAlternative],\n          [],\n          tokenStructuredMatcher,\n          1\n        )\n        if (isEmpty(possibleFirstInAlt)) {\n          return [\n            {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1\n            }\n          ]\n        } else {\n          return []\n        }\n      })\n    }\n  )\n\n  return errors\n}\n\nexport function validateAmbiguousAlternationAlternatives(\n  topLevelRule: Rule,\n  globalMaxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  let ors = orCollector.alternations\n\n  // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true)\n\n  const errors = flatMap(ors, (currOr: Alternation) => {\n    const currOccurrence = currOr.idx\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead\n    const alternatives = getLookaheadPathsForOr(\n      currOccurrence,\n      topLevelRule,\n      actualMaxLookahead,\n      currOr\n    )\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider\n    )\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n      alternatives,\n      currOr,\n      topLevelRule,\n      errMsgProvider\n    )\n\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors)\n  })\n\n  return errors\n}\n\nexport class RepetitionCollector extends GAstVisitor {\n  public allProductions: (IProductionWithOccurrence & {\n    maxLookahead?: number\n  })[] = []\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.allProductions.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.allProductions.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.allProductions.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.allProductions.push(many)\n  }\n}\n\nexport function validateTooManyAlts(\n  topLevelRule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const orCollector = new OrCollector()\n  topLevelRule.accept(orCollector)\n  const ors = orCollector.alternations\n\n  const errors = flatMap(ors, (currOr) => {\n    if (currOr.definition.length > 255) {\n      return [\n        {\n          message: errMsgProvider.buildTooManyAlternativesError({\n            topLevelRule: topLevelRule,\n            alternation: currOr\n          }),\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx\n        }\n      ]\n    } else {\n      return []\n    }\n  })\n\n  return errors\n}\n\nexport function validateSomeNonEmptyLookaheadPath(\n  topLevelRules: Rule[],\n  maxLookahead: number,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n  forEach(topLevelRules, (currTopRule) => {\n    const collectorVisitor = new RepetitionCollector()\n    currTopRule.accept(collectorVisitor)\n    const allRuleProductions = collectorVisitor.allProductions\n    forEach(allRuleProductions, (currProd) => {\n      const prodType = getProdType(currProd)\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead\n      const currOccurrence = currProd.idx\n      const paths = getLookaheadPathsForOptionalProd(\n        currOccurrence,\n        currTopRule,\n        prodType,\n        actualMaxLookahead\n      )\n      const pathsInsideProduction = paths[0]\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        })\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        })\n      }\n    })\n  })\n\n  return errors\n}\n\nexport interface IAmbiguityDescriptor {\n  alts: number[]\n  path: TokenType[]\n}\n\nfunction checkAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  const foundAmbiguousPaths: Alternative = []\n  const identicalAmbiguities = reduce(\n    alternatives,\n    (result, currAlt, currAltIdx) => {\n      // ignore (skip) ambiguities with this alternative\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n        return result\n      }\n\n      forEach(currAlt, (currPath) => {\n        const altsCurrPathAppearsIn = [currAltIdx]\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n          if (\n            currAltIdx !== currOtherAltIdx &&\n            containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n          ) {\n            altsCurrPathAppearsIn.push(currOtherAltIdx)\n          }\n        })\n\n        if (\n          altsCurrPathAppearsIn.length > 1 &&\n          !containsPath(foundAmbiguousPaths, currPath)\n        ) {\n          foundAmbiguousPaths.push(currPath)\n          result.push({\n            alts: altsCurrPathAppearsIn,\n            path: currPath\n          })\n        }\n      })\n      return result\n    },\n    [] as { alts: number[]; path: TokenType[] }[]\n  )\n\n  const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n    const ambgIndices = map(\n      currAmbDescriptor.alts,\n      (currAltIdx) => currAltIdx + 1\n    )\n\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    })\n\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    }\n  })\n\n  return currErrors\n}\n\nexport function checkPrefixAlternativesAmbiguities(\n  alternatives: Alternative[],\n  alternation: Alternation,\n  rule: Rule,\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserAmbiguousAlternativesDefinitionError[] {\n  // flatten\n  const pathsAndIndices = reduce(\n    alternatives,\n    (result, currAlt, idx) => {\n      const currPathsAndIdx = map(currAlt, (currPath) => {\n        return { idx: idx, path: currPath }\n      })\n      return result.concat(currPathsAndIdx)\n    },\n    [] as { idx: number; path: TokenType[] }[]\n  )\n\n  const errors = compact(\n    flatMap(pathsAndIndices, (currPathAndIdx) => {\n      const alternativeGast = alternation.definition[currPathAndIdx.idx]\n      // ignore (skip) ambiguities with this alternative\n      if (alternativeGast.ignoreAmbiguities === true) {\n        return []\n      }\n      const targetIdx = currPathAndIdx.idx\n      const targetPath = currPathAndIdx.path\n\n      const prefixAmbiguitiesPathsAndIndices = filter(\n        pathsAndIndices,\n        (searchPathAndIdx) => {\n          // prefix ambiguity can only be created from lower idx (higher priority) path\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n              true &&\n            searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          )\n        }\n      )\n\n      const currPathPrefixErrors = map(\n        prefixAmbiguitiesPathsAndIndices,\n        (currAmbPathAndIdx): IParserAmbiguousAlternativesDefinitionError => {\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1]\n          const occurrence = alternation.idx === 0 ? \"\" : alternation.idx\n\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path\n          })\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices\n          }\n        }\n      )\n\n      return currPathPrefixErrors\n    })\n  )\n\n  return errors\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(\n  topLevels: Rule[],\n  tokenTypes: TokenType[],\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n): IParserDefinitionError[] {\n  const errors: IParserDefinitionError[] = []\n\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name)\n\n  forEach(topLevels, (currRule) => {\n    const currRuleName = currRule.name\n    if (includes(tokenNames, currRuleName)) {\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule)\n\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      })\n    }\n  })\n\n  return errors\n}\n", "import { Rule } from \"@chevrotain/gast\"\nimport forEach from \"lodash/forEach\"\nimport defaults from \"lodash/defaults\"\nimport { resolveGrammar as orgResolveGrammar } from \"../resolver\"\nimport { validateGrammar as orgValidateGrammar } from \"../checks\"\nimport {\n  defaultGrammarResolverErrorProvider,\n  defaultGrammarValidatorErrorProvider\n} from \"../../errors_public\"\nimport { TokenType } from \"@chevrotain/types\"\nimport {\n  IGrammarResolverErrorMessageProvider,\n  IGrammarValidatorErrorMessageProvider,\n  IParserDefinitionError\n} from \"../types\"\n\ntype ResolveGrammarOpts = {\n  rules: Rule[]\n  errMsgProvider?: IGrammarResolverErrorMessageProvider\n}\nexport function resolveGrammar(\n  options: ResolveGrammarOpts\n): IParserDefinitionError[] {\n  const actualOptions: Required<ResolveGrammarOpts> = defaults(options, {\n    errMsgProvider: defaultGrammarResolverErrorProvider\n  })\n\n  const topRulesTable: { [ruleName: string]: Rule } = {}\n  forEach(options.rules, (rule) => {\n    topRulesTable[rule.name] = rule\n  })\n  return orgResolveGrammar(topRulesTable, actualOptions.errMsgProvider)\n}\n\nexport function validateGrammar(options: {\n  rules: Rule[]\n  tokenTypes: TokenType[]\n  grammarName: string\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\n}): IParserDefinitionError[] {\n  options = defaults(options, {\n    errMsgProvider: defaultGrammarValidatorErrorProvider\n  })\n\n  return orgValidateGrammar(\n    options.rules,\n    options.tokenTypes,\n    options.errMsgProvider,\n    options.grammarName\n  )\n}\n", "import includes from \"lodash/includes\"\nimport {\n  IToken,\n  IRecognitionException,\n  IRecognizerContext\n} from \"@chevrotain/types\"\n\nconst MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\"\nconst NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\"\nconst EARLY_EXIT_EXCEPTION = \"EarlyExitException\"\nconst NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\"\n\nconst RECOGNITION_EXCEPTION_NAMES = [\n  MISMATCHED_TOKEN_EXCEPTION,\n  NO_VIABLE_ALT_EXCEPTION,\n  EARLY_EXIT_EXCEPTION,\n  NOT_ALL_INPUT_PARSED_EXCEPTION\n]\n\nObject.freeze(RECOGNITION_EXCEPTION_NAMES)\n\n// hacks to bypass no support for custom Errors in javascript/typescript\nexport function isRecognitionException(error: Error) {\n  // can't do instanceof on hacked custom js exceptions\n  return includes(RECOGNITION_EXCEPTION_NAMES, error.name)\n}\n\nabstract class RecognitionException\n  extends Error\n  implements IRecognitionException\n{\n  context: IRecognizerContext\n  resyncedTokens: IToken[] = []\n\n  protected constructor(message: string, public token: IToken) {\n    super(message)\n\n    // fix prototype chain when typescript target is ES5\n    Object.setPrototypeOf(this, new.target.prototype)\n\n    /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    }\n  }\n}\n\nexport class MismatchedTokenException extends RecognitionException {\n  constructor(message: string, token: IToken, public previousToken: IToken) {\n    super(message, token)\n    this.name = MISMATCHED_TOKEN_EXCEPTION\n  }\n}\n\nexport class NoViableAltException extends RecognitionException {\n  constructor(message: string, token: IToken, public previousToken: IToken) {\n    super(message, token)\n    this.name = NO_VIABLE_ALT_EXCEPTION\n  }\n}\n\nexport class NotAllInputParsedException extends RecognitionException {\n  constructor(message: string, token: IToken) {\n    super(message, token)\n    this.name = NOT_ALL_INPUT_PARSED_EXCEPTION\n  }\n}\n\nexport class EarlyExitException extends RecognitionException {\n  constructor(message: string, token: IToken, public previousToken: IToken) {\n    super(message, token)\n    this.name = EARLY_EXIT_EXCEPTION\n  }\n}\n", "import {\n  createTokenInstance,\n  EOF,\n  tokenMatcher\n} from \"../../../scan/tokens_public\"\nimport {\n  AbstractNextTerminalAfterProductionWalker,\n  IFirstAfterRepetition\n} from \"../../grammar/interpreter\"\nimport isEmpty from \"lodash/isEmpty\"\nimport dropRight from \"lodash/dropRight\"\nimport flatten from \"lodash/flatten\"\nimport map from \"lodash/map\"\nimport find from \"lodash/find\"\nimport has from \"lodash/has\"\nimport includes from \"lodash/includes\"\nimport clone from \"lodash/clone\"\nimport {\n  IParserConfig,\n  IToken,\n  ITokenGrammarPath,\n  TokenType\n} from \"@chevrotain/types\"\nimport { MismatchedTokenException } from \"../../exceptions_public\"\nimport { IN } from \"../../constants\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\nexport const EOF_FOLLOW_KEY: any = {}\n\nexport interface IFollowKey {\n  ruleName: string\n  idxInCallingRule: number\n  inRule: string\n}\n\nexport const IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\"\n\nexport class InRuleRecoveryException extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = IN_RULE_RECOVERY_EXCEPTION\n  }\n}\n\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nexport class Recoverable {\n  recoveryEnabled: boolean\n  firstAfterRepMap: Record<string, IFirstAfterRepetition>\n  resyncFollows: Record<string, TokenType[]>\n\n  initRecoverable(config: IParserConfig) {\n    this.firstAfterRepMap = {}\n    this.resyncFollows = {}\n\n    this.recoveryEnabled = has(config, \"recoveryEnabled\")\n      ? (config.recoveryEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.recoveryEnabled\n\n    // performance optimization, NOOP will be inlined which\n    // effectively means that this optional feature does not exist\n    // when not used.\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery\n    }\n  }\n\n  public getTokenToInsert(tokType: TokenType): IToken {\n    const tokToInsert = createTokenInstance(\n      tokType,\n      \"\",\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n      NaN\n    )\n    tokToInsert.isInsertedInRecovery = true\n    return tokToInsert\n  }\n\n  public canTokenTypeBeInsertedInRecovery(tokType: TokenType): boolean {\n    return true\n  }\n\n  public canTokenTypeBeDeletedInRecovery(tokType: TokenType): boolean {\n    return true\n  }\n\n  tryInRepetitionRecovery(\n    this: MixedInParser,\n    grammarRule: Function,\n    grammarRuleArgs: any[],\n    lookAheadFunc: () => boolean,\n    expectedTokType: TokenType\n  ): void {\n    // TODO: can the resyncTokenType be cached?\n    const reSyncTokType = this.findReSyncTokenType()\n    const savedLexerState = this.exportLexerState()\n    const resyncedTokens: IToken[] = []\n    let passedResyncPoint = false\n\n    const nextTokenWithoutResync = this.LA(1)\n    let currToken = this.LA(1)\n\n    const generateErrorMessage = () => {\n      const previousToken = this.LA(0)\n      // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n      // the error that would have been thrown\n      const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      })\n      const error = new MismatchedTokenException(\n        msg,\n        nextTokenWithoutResync,\n        this.LA(0)\n      )\n      // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n      error.resyncedTokens = dropRight(resyncedTokens)\n      this.SAVE_ERROR(error)\n    }\n\n    while (!passedResyncPoint) {\n      // re-synced to a point where we can safely exit the repetition/\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage()\n        return // must return here to avoid reverting the inputIdx\n      } else if (lookAheadFunc.call(this)) {\n        // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n        generateErrorMessage()\n        // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n        grammarRule.apply(this, grammarRuleArgs)\n        return // must return here to avoid reverting the inputIdx\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true\n      } else {\n        currToken = this.SKIP_TOKEN()\n        this.addToResyncTokens(currToken, resyncedTokens)\n      }\n    }\n\n    // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n    // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n    // \"between rules\" resync recovery later in the flow.\n    this.importLexerState(savedLexerState)\n  }\n\n  shouldInRepetitionRecoveryBeTried(\n    this: MixedInParser,\n    expectTokAfterLastMatch: TokenType,\n    nextTokIdx: number,\n    notStuck: boolean | undefined\n  ): boolean {\n    // Edge case of arriving from a MANY repetition which is stuck\n    // Attempting recovery in this case could cause an infinite loop\n    if (notStuck === false) {\n      return false\n    }\n\n    // no need to recover, next token is what we expect...\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false\n    }\n\n    // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n    // and prefer some backtracking path that includes recovered errors.\n    if (this.isBackTracking()) {\n      return false\n    }\n\n    // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n    // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n    //noinspection RedundantIfStatementJS\n    if (\n      this.canPerformInRuleRecovery(\n        expectTokAfterLastMatch,\n        this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx)\n      )\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  // Error Recovery functionality\n  getFollowsForInRuleRecovery(\n    this: MixedInParser,\n    tokType: TokenType,\n    tokIdxInRule: number\n  ): TokenType[] {\n    const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule)\n    const follows = this.getNextPossibleTokenTypes(grammarPath)\n    return follows\n  }\n\n  tryInRuleRecovery(\n    this: MixedInParser,\n    expectedTokType: TokenType,\n    follows: TokenType[]\n  ): IToken {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      const tokToInsert = this.getTokenToInsert(expectedTokType)\n      return tokToInsert\n    }\n\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      const nextTok = this.SKIP_TOKEN()\n      this.consumeToken()\n      return nextTok\n    }\n\n    throw new InRuleRecoveryException(\"sad sad panda\")\n  }\n\n  canPerformInRuleRecovery(\n    this: MixedInParser,\n    expectedToken: TokenType,\n    follows: TokenType[]\n  ): boolean {\n    return (\n      this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n      this.canRecoverWithSingleTokenDeletion(expectedToken)\n    )\n  }\n\n  canRecoverWithSingleTokenInsertion(\n    this: MixedInParser,\n    expectedTokType: TokenType,\n    follows: TokenType[]\n  ): boolean {\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false\n    }\n\n    // must know the possible following tokens to perform single token insertion\n    if (isEmpty(follows)) {\n      return false\n    }\n\n    const mismatchedTok = this.LA(1)\n    const isMisMatchedTokInFollows =\n      find(follows, (possibleFollowsTokType: TokenType) => {\n        return this.tokenMatcher(mismatchedTok, possibleFollowsTokType)\n      }) !== undefined\n\n    return isMisMatchedTokInFollows\n  }\n\n  canRecoverWithSingleTokenDeletion(\n    this: MixedInParser,\n    expectedTokType: TokenType\n  ): boolean {\n    if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n      return false\n    }\n\n    const isNextTokenWhatIsExpected = this.tokenMatcher(\n      this.LA(2),\n      expectedTokType\n    )\n    return isNextTokenWhatIsExpected\n  }\n\n  isInCurrentRuleReSyncSet(\n    this: MixedInParser,\n    tokenTypeIdx: TokenType\n  ): boolean {\n    const followKey = this.getCurrFollowKey()\n    const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey)\n    return includes(currentRuleReSyncSet, tokenTypeIdx)\n  }\n\n  findReSyncTokenType(this: MixedInParser): TokenType {\n    const allPossibleReSyncTokTypes = this.flattenFollowSet()\n    // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n    let nextToken = this.LA(1)\n    let k = 2\n    while (true) {\n      const foundMatch = find(allPossibleReSyncTokTypes, (resyncTokType) => {\n        const canMatch = tokenMatcher(nextToken, resyncTokType)\n        return canMatch\n      })\n      if (foundMatch !== undefined) {\n        return foundMatch\n      }\n      nextToken = this.LA(k)\n      k++\n    }\n  }\n\n  getCurrFollowKey(this: MixedInParser): IFollowKey {\n    // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n    if (this.RULE_STACK.length === 1) {\n      return EOF_FOLLOW_KEY\n    }\n    const currRuleShortName = this.getLastExplicitRuleShortName()\n    const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex()\n    const prevRuleShortName = this.getPreviousExplicitRuleShortName()\n\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName)\n    }\n  }\n\n  buildFullFollowKeyStack(this: MixedInParser): IFollowKey[] {\n    const explicitRuleStack = this.RULE_STACK\n    const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK\n\n    return map(explicitRuleStack, (ruleName, idx) => {\n      if (idx === 0) {\n        return EOF_FOLLOW_KEY\n      }\n      return {\n        ruleName: this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n      }\n    })\n  }\n\n  flattenFollowSet(this: MixedInParser): TokenType[] {\n    const followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\n      return this.getFollowSetFromFollowKey(currKey)\n    })\n    return <any>flatten(followStack)\n  }\n\n  getFollowSetFromFollowKey(\n    this: MixedInParser,\n    followKey: IFollowKey\n  ): TokenType[] {\n    if (followKey === EOF_FOLLOW_KEY) {\n      return [EOF]\n    }\n\n    const followName =\n      followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule\n\n    return this.resyncFollows[followName]\n  }\n\n  // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n  addToResyncTokens(\n    this: MixedInParser,\n    token: IToken,\n    resyncTokens: IToken[]\n  ): IToken[] {\n    if (!this.tokenMatcher(token, EOF)) {\n      resyncTokens.push(token)\n    }\n    return resyncTokens\n  }\n\n  reSyncTo(this: MixedInParser, tokType: TokenType): IToken[] {\n    const resyncedTokens: IToken[] = []\n    let nextTok = this.LA(1)\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN()\n      this.addToResyncTokens(nextTok, resyncedTokens)\n    }\n    // the last token is not part of the error.\n    return dropRight(resyncedTokens)\n  }\n\n  attemptInRepetitionRecovery(\n    this: MixedInParser,\n    prodFunc: Function,\n    args: any[],\n    lookaheadFunc: () => boolean,\n    dslMethodIdx: number,\n    prodOccurrence: number,\n    nextToksWalker: typeof AbstractNextTerminalAfterProductionWalker,\n    notStuck?: boolean\n  ): void {\n    // by default this is a NO-OP\n    // The actual implementation is with the function(not method) below\n  }\n\n  getCurrentGrammarPath(\n    this: MixedInParser,\n    tokType: TokenType,\n    tokIdxInRule: number\n  ): ITokenGrammarPath {\n    const pathRuleStack: string[] = this.getHumanReadableRuleStack()\n    const pathOccurrenceStack: number[] = clone(this.RULE_OCCURRENCE_STACK)\n    const grammarPath: any = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule\n    }\n\n    return grammarPath\n  }\n  getHumanReadableRuleStack(this: MixedInParser): string[] {\n    return map(this.RULE_STACK, (currShortName) =>\n      this.shortRuleNameToFullName(currShortName)\n    )\n  }\n}\n\nexport function attemptInRepetitionRecovery(\n  this: MixedInParser,\n  prodFunc: Function,\n  args: any[],\n  lookaheadFunc: () => boolean,\n  dslMethodIdx: number,\n  prodOccurrence: number,\n  nextToksWalker: typeof AbstractNextTerminalAfterProductionWalker,\n  notStuck?: boolean\n): void {\n  const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence)\n  let firstAfterRepInfo = this.firstAfterRepMap[key]\n  if (firstAfterRepInfo === undefined) {\n    const currRuleName = this.getCurrRuleFullName()\n    const ruleGrammar = this.getGAstProductions()[currRuleName]\n    const walker: AbstractNextTerminalAfterProductionWalker =\n      new nextToksWalker(ruleGrammar, prodOccurrence)\n    firstAfterRepInfo = walker.startWalking()\n    this.firstAfterRepMap[key] = firstAfterRepInfo\n  }\n\n  let expectTokAfterLastMatch = firstAfterRepInfo.token\n  let nextTokIdx = firstAfterRepInfo.occurrence\n  const isEndOfRule = firstAfterRepInfo.isEndOfRule\n\n  // special edge case of a TOP most repetition after which the input should END.\n  // this will force an attempt for inRule recovery in that scenario.\n  if (\n    this.RULE_STACK.length === 1 &&\n    isEndOfRule &&\n    expectTokAfterLastMatch === undefined\n  ) {\n    expectTokAfterLastMatch = EOF\n    nextTokIdx = 1\n  }\n\n  // We don't have anything to re-sync to...\n  // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n  if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n    return\n  }\n\n  if (\n    this.shouldInRepetitionRecoveryBeTried(\n      expectTokAfterLastMatch,\n      nextTokIdx,\n      notStuck\n    )\n  ) {\n    // TODO: performance optimization: instead of passing the original args here, we modify\n    // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n    // to avoid searching the cache for it once more.\n    this.tryInRepetitionRecovery(\n      prodFunc,\n      args,\n      lookaheadFunc,\n      expectTokAfterLastMatch\n    )\n  }\n}\n", "// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\n\nexport const BITS_FOR_METHOD_TYPE = 4\nexport const BITS_FOR_OCCURRENCE_IDX = 8\nexport const BITS_FOR_RULE_IDX = 12\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nexport const BITS_FOR_ALT_IDX = 8\n\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\nexport const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX\nexport const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX\nexport const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX\nexport const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX\nexport const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX\nexport const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX\n\n// this actually returns a number, but it is always used as a string (object prop key)\nexport function getKeyForAutomaticLookahead(\n  ruleIdx: number,\n  dslMethodIdx: number,\n  occurrence: number\n): number {\n  return occurrence | dslMethodIdx | ruleIdx\n}\n\nconst BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX\n", "import {\n  ILookaheadStrategy,\n  ILookaheadValidationError,\n  IOrAlt,\n  Rule,\n  TokenType,\n  OptionalProductionType\n} from \"@chevrotain/types\"\nimport flatMap from \"lodash/flatMap\"\nimport isEmpty from \"lodash/isEmpty\"\nimport { defaultGrammarValidatorErrorProvider } from \"../errors_public\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser/parser\"\nimport {\n  validateAmbiguousAlternationAlternatives,\n  validateEmptyOrAlternative,\n  validateNoLeftRecursion,\n  validateSomeNonEmptyLookaheadPath\n} from \"./checks\"\nimport {\n  buildAlternativesLookAheadFunc,\n  buildLookaheadFuncForOptionalProd,\n  buildLookaheadFuncForOr,\n  buildSingleAlternativeLookaheadFunction,\n  getProdType\n} from \"./lookahead\"\nimport { IParserDefinitionError } from \"./types\"\n\nexport class LLkLookaheadStrategy implements ILookaheadStrategy {\n  readonly maxLookahead: number\n\n  constructor(options?: { maxLookahead?: number }) {\n    this.maxLookahead =\n      options?.maxLookahead ?? DEFAULT_PARSER_CONFIG.maxLookahead\n  }\n\n  validate(options: {\n    rules: Rule[]\n    tokenTypes: TokenType[]\n    grammarName: string\n  }): ILookaheadValidationError[] {\n    const leftRecursionErrors = this.validateNoLeftRecursion(options.rules)\n\n    if (isEmpty(leftRecursionErrors)) {\n      const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules)\n      const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(\n        options.rules,\n        this.maxLookahead\n      )\n      const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(\n        options.rules,\n        this.maxLookahead\n      )\n      const allErrors = [\n        ...leftRecursionErrors,\n        ...emptyAltErrors,\n        ...ambiguousAltsErrors,\n        ...emptyRepetitionErrors\n      ]\n      return allErrors\n    }\n    return leftRecursionErrors\n  }\n\n  validateNoLeftRecursion(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateNoLeftRecursion(\n        currTopRule,\n        currTopRule,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateEmptyOrAlternatives(rules: Rule[]): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateEmptyOrAlternative(\n        currTopRule,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateAmbiguousAlternationAlternatives(\n    rules: Rule[],\n    maxLookahead: number\n  ): IParserDefinitionError[] {\n    return flatMap(rules, (currTopRule) =>\n      validateAmbiguousAlternationAlternatives(\n        currTopRule,\n        maxLookahead,\n        defaultGrammarValidatorErrorProvider\n      )\n    )\n  }\n\n  validateSomeNonEmptyLookaheadPath(\n    rules: Rule[],\n    maxLookahead: number\n  ): IParserDefinitionError[] {\n    return validateSomeNonEmptyLookaheadPath(\n      rules,\n      maxLookahead,\n      defaultGrammarValidatorErrorProvider\n    )\n  }\n\n  buildLookaheadForAlternation(options: {\n    prodOccurrence: number\n    rule: Rule\n    maxLookahead: number\n    hasPredicates: boolean\n    dynamicTokensEnabled: boolean\n  }): (orAlts?: IOrAlt<any>[] | undefined) => number | undefined {\n    return buildLookaheadFuncForOr(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.hasPredicates,\n      options.dynamicTokensEnabled,\n      buildAlternativesLookAheadFunc\n    )\n  }\n\n  buildLookaheadForOptional(options: {\n    prodOccurrence: number\n    prodType: OptionalProductionType\n    rule: Rule\n    maxLookahead: number\n    dynamicTokensEnabled: boolean\n  }): () => boolean {\n    return buildLookaheadFuncForOptionalProd(\n      options.prodOccurrence,\n      options.rule,\n      options.maxLookahead,\n      options.dynamicTokensEnabled,\n      getProdType(options.prodType),\n      buildSingleAlternativeLookaheadFunction\n    )\n  }\n}\n", "import forEach from \"lodash/forEach\"\nimport has from \"lodash/has\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\nimport {\n  ILookaheadStrategy,\n  IParserConfig,\n  OptionalProductionType\n} from \"@chevrotain/types\"\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  getKeyForAutomaticLookahead,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX\n} from \"../../grammar/keys\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  Alternation,\n  GAstVisitor,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule\n} from \"@chevrotain/gast\"\nimport { getProductionDslName } from \"@chevrotain/gast\"\nimport { LLkLookaheadStrategy } from \"../../grammar/llk_lookahead\"\n\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nexport class LooksAhead {\n  maxLookahead: number\n  lookAheadFuncsCache: any\n  dynamicTokensEnabled: boolean\n  lookaheadStrategy: ILookaheadStrategy\n\n  initLooksAhead(config: IParserConfig) {\n    this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\n      ? (config.dynamicTokensEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled\n\n    this.maxLookahead = has(config, \"maxLookahead\")\n      ? (config.maxLookahead as number) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.maxLookahead\n\n    this.lookaheadStrategy = has(config, \"lookaheadStrategy\")\n      ? (config.lookaheadStrategy as ILookaheadStrategy) // assumes end user provides the correct config value/type\n      : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead })\n\n    this.lookAheadFuncsCache = new Map()\n  }\n\n  preComputeLookaheadFunctions(this: MixedInParser, rules: Rule[]): void {\n    forEach(rules, (currRule) => {\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n        const {\n          alternation,\n          repetition,\n          option,\n          repetitionMandatory,\n          repetitionMandatoryWithSeparator,\n          repetitionWithSeparator\n        } = collectMethods(currRule)\n\n        forEach(alternation, (currProd) => {\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx\n          this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n              prodOccurrence: currProd.idx,\n              rule: currRule,\n              maxLookahead: currProd.maxLookahead || this.maxLookahead,\n              hasPredicates: currProd.hasPredicates,\n              dynamicTokensEnabled: this.dynamicTokensEnabled\n            })\n\n            const key = getKeyForAutomaticLookahead(\n              this.fullRuleNameToShort[currRule.name],\n              OR_IDX,\n              currProd.idx\n            )\n            this.setLaFuncCache(key, laFunc)\n          })\n        })\n\n        forEach(repetition, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_IDX,\n            \"Repetition\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(option, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            OPTION_IDX,\n            \"Option\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatory, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_IDX,\n            \"RepetitionMandatory\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionMandatoryWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            AT_LEAST_ONE_SEP_IDX,\n            \"RepetitionMandatoryWithSeparator\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n\n        forEach(repetitionWithSeparator, (currProd) => {\n          this.computeLookaheadFunc(\n            currRule,\n            currProd.idx,\n            MANY_SEP_IDX,\n            \"RepetitionWithSeparator\",\n            currProd.maxLookahead,\n            getProductionDslName(currProd)\n          )\n        })\n      })\n    })\n  }\n\n  computeLookaheadFunc(\n    this: MixedInParser,\n    rule: Rule,\n    prodOccurrence: number,\n    prodKey: number,\n    prodType: OptionalProductionType,\n    prodMaxLookahead: number | undefined,\n    dslMethodName: string\n  ): void {\n    this.TRACE_INIT(\n      `${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`,\n      () => {\n        const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n          prodOccurrence,\n          rule,\n          maxLookahead: prodMaxLookahead || this.maxLookahead,\n          dynamicTokensEnabled: this.dynamicTokensEnabled,\n          prodType\n        })\n        const key = getKeyForAutomaticLookahead(\n          this.fullRuleNameToShort[rule.name],\n          prodKey,\n          prodOccurrence\n        )\n        this.setLaFuncCache(key, laFunc)\n      }\n    )\n  }\n\n  // this actually returns a number, but it is always used as a string (object prop key)\n  getKeyForAutomaticLookahead(\n    this: MixedInParser,\n    dslMethodIdx: number,\n    occurrence: number\n  ): number {\n    const currRuleShortName: any = this.getLastExplicitRuleShortName()\n    return getKeyForAutomaticLookahead(\n      currRuleShortName,\n      dslMethodIdx,\n      occurrence\n    )\n  }\n\n  getLaFuncFromCache(this: MixedInParser, key: number): Function {\n    return this.lookAheadFuncsCache.get(key)\n  }\n\n  /* istanbul ignore next */\n  setLaFuncCache(this: MixedInParser, key: number, value: Function): void {\n    this.lookAheadFuncsCache.set(key, value)\n  }\n}\n\nclass DslMethodsCollectorVisitor extends GAstVisitor {\n  public dslMethods: {\n    option: Option[]\n    alternation: Alternation[]\n    repetition: Repetition[]\n    repetitionWithSeparator: RepetitionWithSeparator[]\n    repetitionMandatory: RepetitionMandatory[]\n    repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[]\n  } = {\n    option: [],\n    alternation: [],\n    repetition: [],\n    repetitionWithSeparator: [],\n    repetitionMandatory: [],\n    repetitionMandatoryWithSeparator: []\n  }\n\n  reset() {\n    this.dslMethods = {\n      option: [],\n      alternation: [],\n      repetition: [],\n      repetitionWithSeparator: [],\n      repetitionMandatory: [],\n      repetitionMandatoryWithSeparator: []\n    }\n  }\n\n  public visitOption(option: Option): void {\n    this.dslMethods.option.push(option)\n  }\n\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\n    this.dslMethods.repetitionWithSeparator.push(manySep)\n  }\n\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\n    this.dslMethods.repetitionMandatory.push(atLeastOne)\n  }\n\n  public visitRepetitionMandatoryWithSeparator(\n    atLeastOneSep: RepetitionMandatoryWithSeparator\n  ): void {\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep)\n  }\n\n  public visitRepetition(many: Repetition): void {\n    this.dslMethods.repetition.push(many)\n  }\n\n  public visitAlternation(or: Alternation): void {\n    this.dslMethods.alternation.push(or)\n  }\n}\n\nconst collectorVisitor = new DslMethodsCollectorVisitor()\nexport function collectMethods(rule: Rule): {\n  option: Option[]\n  alternation: Alternation[]\n  repetition: Repetition[]\n  repetitionWithSeparator: RepetitionWithSeparator[]\n  repetitionMandatory: RepetitionMandatory[]\n  repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[]\n} {\n  collectorVisitor.reset()\n  rule.accept(collectorVisitor)\n  const dslMethods = collectorVisitor.dslMethods\n  // avoid uncleaned references\n  collectorVisitor.reset()\n  return <any>dslMethods\n}\n", "import { CstNode, CstNodeLocation, IToken } from \"@chevrotain/types\"\n\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(\n  currNodeLocation: CstNodeLocation,\n  newLocationInfo: Required<Pick<IToken, \"startOffset\" | \"endOffset\">>\n): void {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (both start/end offsets exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n  }\n  // Once the startOffset has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset! < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n  }\n}\n\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(\n  currNodeLocation: CstNodeLocation,\n  newLocationInfo: CstNodeLocation\n): void {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (all start/end props exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset\n    currNodeLocation.startColumn = newLocationInfo.startColumn\n    currNodeLocation.startLine = newLocationInfo.startLine\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n    currNodeLocation.endColumn = newLocationInfo.endColumn\n    currNodeLocation.endLine = newLocationInfo.endLine\n  }\n  // Once the start props has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset! < newLocationInfo.endOffset! === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n    currNodeLocation.endColumn = newLocationInfo.endColumn\n    currNodeLocation.endLine = newLocationInfo.endLine\n  }\n}\n\nexport function addTerminalToCst(\n  node: CstNode,\n  token: IToken,\n  tokenTypeName: string\n): void {\n  if (node.children[tokenTypeName] === undefined) {\n    node.children[tokenTypeName] = [token]\n  } else {\n    node.children[tokenTypeName].push(token)\n  }\n}\n\nexport function addNoneTerminalToCst(\n  node: CstNode,\n  ruleName: string,\n  ruleResult: any\n): void {\n  if (node.children[ruleName] === undefined) {\n    node.children[ruleName] = [ruleResult]\n  } else {\n    node.children[ruleName].push(ruleResult)\n  }\n}\n", "const NAME = \"name\"\n\nexport function defineNameProp(obj: {}, nameValue: string): void {\n  Object.defineProperty(obj, NAME, {\n    enumerable: false,\n    configurable: true,\n    writable: false,\n    value: nameValue\n  })\n}\n", "import isEmpty from \"lodash/isEmpty\"\nimport compact from \"lodash/compact\"\nimport isArray from \"lodash/isArray\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport filter from \"lodash/filter\"\nimport keys from \"lodash/keys\"\nimport isFunction from \"lodash/isFunction\"\nimport isUndefined from \"lodash/isUndefined\"\nimport { defineNameProp } from \"../../lang/lang_extensions\"\nimport { CstNode, ICstVisitor } from \"@chevrotain/types\"\n\nexport function defaultVisit<IN>(ctx: any, param: IN): void {\n  const childrenNames = keys(ctx)\n  const childrenNamesLength = childrenNames.length\n  for (let i = 0; i < childrenNamesLength; i++) {\n    const currChildName = childrenNames[i]\n    const currChildArray = ctx[currChildName]\n    const currChildArrayLength = currChildArray.length\n    for (let j = 0; j < currChildArrayLength; j++) {\n      const currChild: any = currChildArray[j]\n      // distinction between Tokens Children and CstNode children\n      if (currChild.tokenTypeIdx === undefined) {\n        this[currChild.name](currChild.children, param)\n      }\n    }\n  }\n  // defaultVisit does not support generic out param\n}\n\nexport function createBaseSemanticVisitorConstructor(\n  grammarName: string,\n  ruleNames: string[]\n): {\n  new (...args: any[]): ICstVisitor<any, any>\n} {\n  const derivedConstructor: any = function () {}\n\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\")\n\n  const semanticProto = {\n    visit: function (cstNode: CstNode | CstNode[], param: any) {\n      // enables writing more concise visitor methods when CstNode has only a single child\n      if (isArray(cstNode)) {\n        // A CST Node's children dictionary can never have empty arrays as values\n        // If a key is defined there will be at least one element in the corresponding value array.\n        cstNode = cstNode[0]\n      }\n\n      // enables passing optional CstNodes concisely.\n      if (isUndefined(cstNode)) {\n        return undefined\n      }\n\n      return this[cstNode.name](cstNode.children, param)\n    },\n\n    validateVisitor: function () {\n      const semanticDefinitionErrors = validateVisitor(this, ruleNames)\n      if (!isEmpty(semanticDefinitionErrors)) {\n        const errorMessages = map(\n          semanticDefinitionErrors,\n          (currDefError) => currDefError.msg\n        )\n        throw Error(\n          `Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\n            `${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")}`\n        )\n      }\n    }\n  }\n\n  derivedConstructor.prototype = semanticProto\n  derivedConstructor.prototype.constructor = derivedConstructor\n\n  derivedConstructor._RULE_NAMES = ruleNames\n\n  return derivedConstructor\n}\n\nexport function createBaseVisitorConstructorWithDefaults(\n  grammarName: string,\n  ruleNames: string[],\n  baseConstructor: Function\n): {\n  new (...args: any[]): ICstVisitor<any, any>\n} {\n  const derivedConstructor: any = function () {}\n\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\")\n\n  const withDefaultsProto = Object.create(baseConstructor.prototype)\n  forEach(ruleNames, (ruleName) => {\n    withDefaultsProto[ruleName] = defaultVisit\n  })\n\n  derivedConstructor.prototype = withDefaultsProto\n  derivedConstructor.prototype.constructor = derivedConstructor\n\n  return derivedConstructor\n}\n\nexport enum CstVisitorDefinitionError {\n  REDUNDANT_METHOD,\n  MISSING_METHOD\n}\n\nexport interface IVisitorDefinitionError {\n  msg: string\n  type: CstVisitorDefinitionError\n  methodName: string\n}\n\nexport function validateVisitor(\n  visitorInstance: ICstVisitor<unknown, unknown>,\n  ruleNames: string[]\n): IVisitorDefinitionError[] {\n  const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames)\n\n  return missingErrors\n}\n\nexport function validateMissingCstMethods(\n  visitorInstance: ICstVisitor<unknown, unknown>,\n  ruleNames: string[]\n): IVisitorDefinitionError[] {\n  const missingRuleNames = filter(ruleNames, (currRuleName) => {\n    return isFunction((visitorInstance as any)[currRuleName]) === false\n  })\n\n  const errors: IVisitorDefinitionError[] = map(\n    missingRuleNames,\n    (currRuleName) => {\n      return {\n        msg: `Missing visitor method: <${currRuleName}> on ${<any>(\n          visitorInstance.constructor.name\n        )} CST Visitor.`,\n        type: CstVisitorDefinitionError.MISSING_METHOD,\n        methodName: currRuleName\n      }\n    }\n  )\n\n  return compact<IVisitorDefinitionError>(errors)\n}\n", "import {\n  addNoneTerminalToCst,\n  addTerminalToCst,\n  setNodeLocationFull,\n  setNodeLocationOnlyOffset\n} from \"../../cst/cst\"\nimport noop from \"lodash/noop\"\nimport has from \"lodash/has\"\nimport keys from \"lodash/keys\"\nimport isUndefined from \"lodash/isUndefined\"\nimport {\n  createBaseSemanticVisitorConstructor,\n  createBaseVisitorConstructorWithDefaults\n} from \"../../cst/cst_visitor\"\nimport {\n  CstNode,\n  CstNodeLocation,\n  ICstVisitor,\n  IParserConfig,\n  IToken,\n  nodeLocationTrackingOptions\n} from \"@chevrotain/types\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\n/**\n * This trait is responsible for the CST building logic.\n */\nexport class TreeBuilder {\n  outputCst: boolean\n  CST_STACK: CstNode[]\n  baseCstVisitorConstructor: Function\n  baseCstVisitorWithDefaultsConstructor: Function\n\n  // dynamically assigned Methods\n  setNodeLocationFromNode: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation\n  ) => void\n  setNodeLocationFromToken: (\n    nodeLocation: CstNodeLocation,\n    locationInformation: CstNodeLocation\n  ) => void\n  cstPostRule: (this: MixedInParser, ruleCstNode: CstNode) => void\n\n  setInitialNodeLocation: (cstNode: CstNode) => void\n  nodeLocationTracking: nodeLocationTrackingOptions\n\n  initTreeBuilder(this: MixedInParser, config: IParserConfig) {\n    this.CST_STACK = []\n\n    // outputCst is no longer exposed/defined in the pubic API\n    this.outputCst = (config as any).outputCst\n\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\n      ? (config.nodeLocationTracking as nodeLocationTrackingOptions) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.nodeLocationTracking\n\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = noop\n      this.cstFinallyStateUpdate = noop\n      this.cstPostTerminal = noop\n      this.cstPostNonTerminal = noop\n      this.cstPostRule = noop\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull\n          this.setNodeLocationFromNode = setNodeLocationFull\n          this.cstPostRule = noop\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery\n        } else {\n          this.setNodeLocationFromToken = noop\n          this.setNodeLocationFromNode = noop\n          this.cstPostRule = this.cstPostRuleFull\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = <any>setNodeLocationOnlyOffset\n          this.setNodeLocationFromNode = <any>setNodeLocationOnlyOffset\n          this.cstPostRule = noop\n          this.setInitialNodeLocation =\n            this.setInitialNodeLocationOnlyOffsetRecovery\n        } else {\n          this.setNodeLocationFromToken = noop\n          this.setNodeLocationFromNode = noop\n          this.cstPostRule = this.cstPostRuleOnlyOffset\n          this.setInitialNodeLocation =\n            this.setInitialNodeLocationOnlyOffsetRegular\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = noop\n        this.setNodeLocationFromNode = noop\n        this.cstPostRule = noop\n        this.setInitialNodeLocation = noop\n      } else {\n        throw Error(\n          `Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`\n        )\n      }\n    }\n  }\n\n  setInitialNodeLocationOnlyOffsetRecovery(\n    this: MixedInParser,\n    cstNode: any\n  ): void {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    }\n  }\n\n  setInitialNodeLocationOnlyOffsetRegular(\n    this: MixedInParser,\n    cstNode: any\n  ): void {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    }\n  }\n\n  setInitialNodeLocationFullRecovery(this: MixedInParser, cstNode: any): void {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    }\n  }\n\n  /**\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n\n     * @param cstNode\n     */\n  setInitialNodeLocationFullRegular(this: MixedInParser, cstNode: any): void {\n    const nextToken = this.LA(1)\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    }\n  }\n\n  cstInvocationStateUpdate(this: MixedInParser, fullRuleName: string): void {\n    const cstNode: CstNode = {\n      name: fullRuleName,\n      children: Object.create(null)\n    }\n\n    this.setInitialNodeLocation(cstNode)\n    this.CST_STACK.push(cstNode)\n  }\n\n  cstFinallyStateUpdate(this: MixedInParser): void {\n    this.CST_STACK.pop()\n  }\n\n  cstPostRuleFull(this: MixedInParser, ruleCstNode: CstNode): void {\n    // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n    const prevToken = this.LA(0) as Required<CstNodeLocation>\n    const loc = ruleCstNode.location as Required<CstNodeLocation>\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset\n      loc.endLine = prevToken.endLine\n      loc.endColumn = prevToken.endColumn\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN\n      loc.startLine = NaN\n      loc.startColumn = NaN\n    }\n  }\n\n  cstPostRuleOnlyOffset(this: MixedInParser, ruleCstNode: CstNode): void {\n    const prevToken = this.LA(0)\n    // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n    const loc = ruleCstNode.location!\n\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN\n    }\n  }\n\n  cstPostTerminal(\n    this: MixedInParser,\n    key: string,\n    consumedToken: IToken\n  ): void {\n    const rootCst = this.CST_STACK[this.CST_STACK.length - 1]\n    addTerminalToCst(rootCst, consumedToken, key)\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromToken(rootCst.location!, <any>consumedToken)\n  }\n\n  cstPostNonTerminal(\n    this: MixedInParser,\n    ruleCstResult: CstNode,\n    ruleName: string\n  ): void {\n    const preCstNode = this.CST_STACK[this.CST_STACK.length - 1]\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult)\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromNode(preCstNode.location!, ruleCstResult.location!)\n  }\n\n  getBaseCstVisitorConstructor<IN = any, OUT = any>(\n    this: MixedInParser\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>\n  } {\n    if (isUndefined(this.baseCstVisitorConstructor)) {\n      const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(\n        this.className,\n        keys(this.gastProductionsCache)\n      )\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor\n      return newBaseCstVisitorConstructor\n    }\n\n    return <any>this.baseCstVisitorConstructor\n  }\n\n  getBaseCstVisitorConstructorWithDefaults<IN = any, OUT = any>(\n    this: MixedInParser\n  ): {\n    new (...args: any[]): ICstVisitor<IN, OUT>\n  } {\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      const newConstructor = createBaseVisitorConstructorWithDefaults(\n        this.className,\n        keys(this.gastProductionsCache),\n        this.getBaseCstVisitorConstructor()\n      )\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor\n      return newConstructor\n    }\n\n    return <any>this.baseCstVisitorWithDefaultsConstructor\n  }\n\n  getLastExplicitRuleShortName(this: MixedInParser): number {\n    const ruleStack = this.RULE_STACK\n    return ruleStack[ruleStack.length - 1]\n  }\n\n  getPreviousExplicitRuleShortName(this: MixedInParser): number {\n    const ruleStack = this.RULE_STACK\n    return ruleStack[ruleStack.length - 2]\n  }\n\n  getLastExplicitRuleOccurrenceIndex(this: MixedInParser): number {\n    const occurrenceStack = this.RULE_OCCURRENCE_STACK\n    return occurrenceStack[occurrenceStack.length - 1]\n  }\n}\n", "import { END_OF_FILE } from \"../parser\"\nimport { IToken } from \"@chevrotain/types\"\nimport { MixedInParser } from \"./parser_traits\"\n\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nexport class LexerAdapter {\n  tokVector: IToken[]\n  tokVectorLength: number\n  currIdx: number\n\n  initLexerAdapter() {\n    this.tokVector = []\n    this.tokVectorLength = 0\n    this.currIdx = -1\n  }\n\n  set input(newInput: IToken[]) {\n    // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n    if (this.selfAnalysisDone !== true) {\n      throw Error(\n        `Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`\n      )\n    }\n    // @ts-ignore - `this parameter` not supported in setters/getters\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n    this.reset()\n    this.tokVector = newInput\n    this.tokVectorLength = newInput.length\n  }\n\n  get input(): IToken[] {\n    return this.tokVector\n  }\n\n  // skips a token and returns the next token\n  SKIP_TOKEN(this: MixedInParser): IToken {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken()\n      return this.LA(1)\n    } else {\n      return END_OF_FILE\n    }\n  }\n\n  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n  LA(this: MixedInParser, howMuch: number): IToken {\n    const soughtIdx = this.currIdx + howMuch\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return END_OF_FILE\n    } else {\n      return this.tokVector[soughtIdx]\n    }\n  }\n\n  consumeToken(this: MixedInParser) {\n    this.currIdx++\n  }\n\n  exportLexerState(this: MixedInParser): number {\n    return this.currIdx\n  }\n\n  importLexerState(this: MixedInParser, newState: number) {\n    this.currIdx = newState\n  }\n\n  resetLexerState(this: MixedInParser): void {\n    this.currIdx = -1\n  }\n\n  moveToTerminatedState(this: MixedInParser): void {\n    this.currIdx = this.tokVector.length - 1\n  }\n\n  getLexerPosition(this: MixedInParser): number {\n    return this.exportLexerState()\n  }\n}\n", "import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IRuleConfig,\n  ISerializedGast,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType\n} from \"@chevrotain/types\"\nimport values from \"lodash/values\"\nimport includes from \"lodash/includes\"\nimport { isRecognitionException } from \"../../exceptions_public\"\nimport { DEFAULT_RULE_CONFIG, ParserDefinitionErrorType } from \"../parser\"\nimport { defaultGrammarValidatorErrorProvider } from \"../../errors_public\"\nimport { validateRuleIsOverridden } from \"../../grammar/checks\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { Rule, serializeGrammar } from \"@chevrotain/gast\"\nimport { IParserDefinitionError } from \"../../grammar/types\"\nimport { ParserMethodInternal } from \"../types\"\n\n/**\n * This trait is responsible for implementing the public API\n * for defining Chevrotain parsers, i.e:\n * - CONSUME\n * - RULE\n * - OPTION\n * - ...\n */\nexport class RecognizerApi {\n  ACTION<T>(this: MixedInParser, impl: () => T): T {\n    return impl.call(this)\n  }\n\n  consume(\n    this: MixedInParser,\n    idx: number,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, idx, options)\n  }\n\n  subrule<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    idx: number,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, idx, options)\n  }\n\n  option<OUT>(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, idx)\n  }\n\n  or(\n    this: MixedInParser,\n    idx: number,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>\n  ): any {\n    return this.orInternal(altsOrOpts, idx)\n  }\n\n  many(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>\n  ): void {\n    return this.manyInternal(idx, actionORMethodDef)\n  }\n\n  atLeastOne(\n    this: MixedInParser,\n    idx: number,\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>\n  ): void {\n    return this.atLeastOneInternal(idx, actionORMethodDef)\n  }\n\n  CONSUME(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 0, options)\n  }\n\n  CONSUME1(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 1, options)\n  }\n\n  CONSUME2(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 2, options)\n  }\n\n  CONSUME3(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 3, options)\n  }\n\n  CONSUME4(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 4, options)\n  }\n\n  CONSUME5(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 5, options)\n  }\n\n  CONSUME6(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 6, options)\n  }\n\n  CONSUME7(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 7, options)\n  }\n\n  CONSUME8(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 8, options)\n  }\n\n  CONSUME9(\n    this: MixedInParser,\n    tokType: TokenType,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    return this.consumeInternal(tokType, 9, options)\n  }\n\n  SUBRULE<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 0, options)\n  }\n\n  SUBRULE1<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 1, options)\n  }\n\n  SUBRULE2<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 2, options)\n  }\n\n  SUBRULE3<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 3, options)\n  }\n\n  SUBRULE4<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 4, options)\n  }\n\n  SUBRULE5<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 5, options)\n  }\n\n  SUBRULE6<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 6, options)\n  }\n\n  SUBRULE7<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 7, options)\n  }\n\n  SUBRULE8<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 8, options)\n  }\n\n  SUBRULE9<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    return this.subruleInternal(ruleToCall, 9, options)\n  }\n\n  OPTION<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 0)\n  }\n\n  OPTION1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 1)\n  }\n\n  OPTION2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 2)\n  }\n\n  OPTION3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 3)\n  }\n\n  OPTION4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 4)\n  }\n\n  OPTION5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 5)\n  }\n\n  OPTION6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 6)\n  }\n\n  OPTION7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 7)\n  }\n\n  OPTION8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 8)\n  }\n\n  OPTION9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): OUT | undefined {\n    return this.optionInternal(actionORMethodDef, 9)\n  }\n\n  OR<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 0)\n  }\n\n  OR1<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 1)\n  }\n\n  OR2<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 2)\n  }\n\n  OR3<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 3)\n  }\n\n  OR4<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 4)\n  }\n\n  OR5<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 5)\n  }\n\n  OR6<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 6)\n  }\n\n  OR7<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 7)\n  }\n\n  OR8<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 8)\n  }\n\n  OR9<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>\n  ): T {\n    return this.orInternal(altsOrOpts, 9)\n  }\n\n  MANY<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(0, actionORMethodDef)\n  }\n\n  MANY1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(1, actionORMethodDef)\n  }\n\n  MANY2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(2, actionORMethodDef)\n  }\n\n  MANY3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(3, actionORMethodDef)\n  }\n\n  MANY4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(4, actionORMethodDef)\n  }\n\n  MANY5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(5, actionORMethodDef)\n  }\n\n  MANY6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(6, actionORMethodDef)\n  }\n\n  MANY7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(7, actionORMethodDef)\n  }\n\n  MANY8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(8, actionORMethodDef)\n  }\n\n  MANY9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    this.manyInternal(9, actionORMethodDef)\n  }\n\n  MANY_SEP<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(0, options)\n  }\n\n  MANY_SEP1<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(1, options)\n  }\n\n  MANY_SEP2<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(2, options)\n  }\n\n  MANY_SEP3<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(3, options)\n  }\n\n  MANY_SEP4<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(4, options)\n  }\n\n  MANY_SEP5<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(5, options)\n  }\n\n  MANY_SEP6<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(6, options)\n  }\n\n  MANY_SEP7<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(7, options)\n  }\n\n  MANY_SEP8<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(8, options)\n  }\n\n  MANY_SEP9<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\n    this.manySepFirstInternal(9, options)\n  }\n\n  AT_LEAST_ONE<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(0, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE1<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    return this.atLeastOneInternal(1, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE2<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(2, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE3<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(3, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE4<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(4, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE5<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(5, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE6<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(6, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE7<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(7, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE8<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(8, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE9<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    this.atLeastOneInternal(9, actionORMethodDef)\n  }\n\n  AT_LEAST_ONE_SEP<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(0, options)\n  }\n\n  AT_LEAST_ONE_SEP1<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(1, options)\n  }\n\n  AT_LEAST_ONE_SEP2<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(2, options)\n  }\n\n  AT_LEAST_ONE_SEP3<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(3, options)\n  }\n\n  AT_LEAST_ONE_SEP4<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(4, options)\n  }\n\n  AT_LEAST_ONE_SEP5<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(5, options)\n  }\n\n  AT_LEAST_ONE_SEP6<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(6, options)\n  }\n\n  AT_LEAST_ONE_SEP7<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(7, options)\n  }\n\n  AT_LEAST_ONE_SEP8<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(8, options)\n  }\n\n  AT_LEAST_ONE_SEP9<OUT>(\n    this: MixedInParser,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    this.atLeastOneSepFirstInternal(9, options)\n  }\n\n  RULE<T>(\n    this: MixedInParser,\n    name: string,\n    implementation: (...implArgs: any[]) => T,\n    config: IRuleConfig<T> = DEFAULT_RULE_CONFIG\n  ): (idxInCallingRule?: number, ...args: any[]) => T | any {\n    if (includes(this.definedRulesNames, name)) {\n      const errMsg =\n        defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n          topLevelRule: name,\n          grammarName: this.className\n        })\n\n      const error = {\n        message: errMsg,\n        type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n        ruleName: name\n      }\n      this.definitionErrors.push(error)\n    }\n\n    this.definedRulesNames.push(name)\n\n    const ruleImplementation = this.defineRule(name, implementation, config)\n    ;(this as any)[name] = ruleImplementation\n    return ruleImplementation\n  }\n\n  OVERRIDE_RULE<T>(\n    this: MixedInParser,\n    name: string,\n    impl: (...implArgs: any[]) => T,\n    config: IRuleConfig<T> = DEFAULT_RULE_CONFIG\n  ): (idxInCallingRule?: number, ...args: any[]) => T {\n    const ruleErrors: IParserDefinitionError[] = validateRuleIsOverridden(\n      name,\n      this.definedRulesNames,\n      this.className\n    )\n    this.definitionErrors = this.definitionErrors.concat(ruleErrors)\n\n    const ruleImplementation = this.defineRule(name, impl, config)\n    ;(this as any)[name] = ruleImplementation\n    return ruleImplementation\n  }\n\n  BACKTRACK<T>(\n    this: MixedInParser,\n    grammarRule: (...args: any[]) => T,\n    args?: any[]\n  ): () => boolean {\n    return function () {\n      // save org state\n      this.isBackTrackingStack.push(1)\n      const orgState = this.saveRecogState()\n      try {\n        grammarRule.apply(this, args)\n        // if no exception was thrown we have succeed parsing the rule.\n        return true\n      } catch (e) {\n        if (isRecognitionException(e)) {\n          return false\n        } else {\n          throw e\n        }\n      } finally {\n        this.reloadRecogState(orgState)\n        this.isBackTrackingStack.pop()\n      }\n    }\n  }\n\n  // GAST export APIs\n  public getGAstProductions(this: MixedInParser): Record<string, Rule> {\n    return this.gastProductionsCache\n  }\n\n  public getSerializedGastProductions(this: MixedInParser): ISerializedGast[] {\n    return serializeGrammar(values(this.gastProductionsCache))\n  }\n}\n", "import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IRuleConfig,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  ParserMethod,\n  SubruleMethodOpts,\n  TokenType,\n  TokenTypeDictionary,\n  TokenVocabulary\n} from \"@chevrotain/types\"\nimport isEmpty from \"lodash/isEmpty\"\nimport isArray from \"lodash/isArray\"\nimport flatten from \"lodash/flatten\"\nimport every from \"lodash/every\"\nimport uniq from \"lodash/uniq\"\nimport isObject from \"lodash/isObject\"\nimport has from \"lodash/has\"\nimport values from \"lodash/values\"\nimport reduce from \"lodash/reduce\"\nimport clone from \"lodash/clone\"\nimport {\n  AT_LEAST_ONE_IDX,\n  AT_LEAST_ONE_SEP_IDX,\n  BITS_FOR_METHOD_TYPE,\n  BITS_FOR_OCCURRENCE_IDX,\n  MANY_IDX,\n  MANY_SEP_IDX,\n  OPTION_IDX,\n  OR_IDX\n} from \"../../grammar/keys\"\nimport {\n  isRecognitionException,\n  MismatchedTokenException,\n  NotAllInputParsedException\n} from \"../../exceptions_public\"\nimport { PROD_TYPE } from \"../../grammar/lookahead\"\nimport {\n  AbstractNextTerminalAfterProductionWalker,\n  NextTerminalAfterAtLeastOneSepWalker,\n  NextTerminalAfterAtLeastOneWalker,\n  NextTerminalAfterManySepWalker,\n  NextTerminalAfterManyWalker\n} from \"../../grammar/interpreter\"\nimport { DEFAULT_RULE_CONFIG, IParserState, TokenMatcher } from \"../parser\"\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable\"\nimport { EOF } from \"../../../scan/tokens_public\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  augmentTokenTypes,\n  isTokenType,\n  tokenStructuredMatcher,\n  tokenStructuredMatcherNoCategories\n} from \"../../../scan/tokens\"\nimport { Rule } from \"@chevrotain/gast\"\nimport { ParserMethodInternal } from \"../types\"\n\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nexport class RecognizerEngine {\n  isBackTrackingStack: boolean[]\n  className: string\n  RULE_STACK: number[]\n  RULE_OCCURRENCE_STACK: number[]\n  definedRulesNames: string[]\n  tokensMap: { [fqn: string]: TokenType }\n  gastProductionsCache: Record<string, Rule>\n  shortRuleNameToFull: Record<string, string>\n  fullRuleNameToShort: Record<string, number>\n  // The shortName Index must be coded \"after\" the first 8bits to enable building unique lookahead keys\n  ruleShortNameIdx: number\n  tokenMatcher: TokenMatcher\n  subruleIdx: number\n\n  initRecognizerEngine(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfig\n  ) {\n    this.className = this.constructor.name\n    // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n    this.shortRuleNameToFull = {}\n    this.fullRuleNameToShort = {}\n    this.ruleShortNameIdx = 256\n    this.tokenMatcher = tokenStructuredMatcherNoCategories\n    this.subruleIdx = 0\n\n    this.definedRulesNames = []\n    this.tokensMap = {}\n    this.isBackTrackingStack = []\n    this.RULE_STACK = []\n    this.RULE_OCCURRENCE_STACK = []\n    this.gastProductionsCache = {}\n\n    if (has(config, \"serializedGrammar\")) {\n      throw Error(\n        \"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n          \"\\tFor Further details.\"\n      )\n    }\n\n    if (isArray(tokenVocabulary)) {\n      // This only checks for Token vocabularies provided as arrays.\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n      // rather than all edge cases of empty Token vocabularies.\n      if (isEmpty(tokenVocabulary as any[])) {\n        throw Error(\n          \"A Token Vocabulary cannot be empty.\\n\" +\n            \"\\tNote that the first argument for the parser constructor\\n\" +\n            \"\\tis no longer a Token vector (since v4.0).\"\n        )\n      }\n\n      if (typeof (tokenVocabulary as any[])[0].startOffset === \"number\") {\n        throw Error(\n          \"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n            \"\\tFor Further details.\"\n        )\n      }\n    }\n\n    if (isArray(tokenVocabulary)) {\n      this.tokensMap = reduce(\n        tokenVocabulary,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType\n          return acc\n        },\n        {} as { [tokenName: string]: TokenType }\n      )\n    } else if (\n      has(tokenVocabulary, \"modes\") &&\n      every(flatten(values((<any>tokenVocabulary).modes)), isTokenType)\n    ) {\n      const allTokenTypes = flatten(values((<any>tokenVocabulary).modes))\n      const uniqueTokens = uniq(allTokenTypes)\n      this.tokensMap = <any>reduce(\n        uniqueTokens,\n        (acc, tokType: TokenType) => {\n          acc[tokType.name] = tokType\n          return acc\n        },\n        {} as { [tokenName: string]: TokenType }\n      )\n    } else if (isObject(tokenVocabulary)) {\n      this.tokensMap = clone(tokenVocabulary as TokenTypeDictionary)\n    } else {\n      throw new Error(\n        \"<tokensDictionary> argument must be An Array of Token constructors,\" +\n          \" A dictionary of Token constructors or an IMultiModeLexerDefinition\"\n      )\n    }\n\n    // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n    // parsed with a clear error message (\"expecting EOF but found ...\")\n    this.tokensMap[\"EOF\"] = EOF\n\n    const allTokenTypes = has(tokenVocabulary, \"modes\")\n      ? flatten(values((<any>tokenVocabulary).modes))\n      : values(tokenVocabulary)\n    const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) =>\n      isEmpty(tokenConstructor.categoryMatches)\n    )\n\n    this.tokenMatcher = noTokenCategoriesUsed\n      ? tokenStructuredMatcherNoCategories\n      : tokenStructuredMatcher\n\n    // Because ES2015+ syntax should be supported for creating Token classes\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n    augmentTokenTypes(values(this.tokensMap))\n  }\n\n  defineRule<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleName: string,\n    impl: (...args: ARGS) => R,\n    config: IRuleConfig<R>\n  ): ParserMethodInternal<ARGS, R> {\n    if (this.selfAnalysisDone) {\n      throw Error(\n        `Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n          `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`\n      )\n    }\n    const resyncEnabled: boolean = has(config, \"resyncEnabled\")\n      ? (config.resyncEnabled as boolean) // assumes end user provides the correct config value/type\n      : DEFAULT_RULE_CONFIG.resyncEnabled\n    const recoveryValueFunc = has(config, \"recoveryValueFunc\")\n      ? (config.recoveryValueFunc as () => R) // assumes end user provides the correct config value/type\n      : DEFAULT_RULE_CONFIG.recoveryValueFunc\n\n    // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n    const shortName =\n      this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX)\n\n    this.ruleShortNameIdx++\n    this.shortRuleNameToFull[shortName] = ruleName\n    this.fullRuleNameToShort[ruleName] = shortName\n\n    let invokeRuleWithTry: ParserMethod<ARGS, R>\n\n    // Micro optimization, only check the condition **once** on rule definition\n    // instead of **every single** rule invocation.\n    if (this.outputCst === true) {\n      invokeRuleWithTry = function invokeRuleWithTry(\n        this: MixedInParser,\n        ...args: ARGS\n      ): R {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx)\n          impl.apply(this, args)\n          const cst = this.CST_STACK[this.CST_STACK.length - 1]\n          this.cstPostRule(cst)\n          return cst as unknown as R\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc) as R\n        } finally {\n          this.ruleFinallyStateUpdate()\n        }\n      }\n    } else {\n      invokeRuleWithTry = function invokeRuleWithTryCst(\n        this: MixedInParser,\n        ...args: ARGS\n      ): R {\n        try {\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx)\n          return impl.apply(this, args)\n        } catch (e) {\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc) as R\n        } finally {\n          this.ruleFinallyStateUpdate()\n        }\n      }\n    }\n\n    const wrappedGrammarRule: ParserMethodInternal<ARGS, R> = Object.assign(\n      invokeRuleWithTry as any,\n      { ruleName, originalGrammarAction: impl }\n    )\n\n    return wrappedGrammarRule\n  }\n\n  invokeRuleCatch(\n    this: MixedInParser,\n    e: Error,\n    resyncEnabledConfig: boolean,\n    recoveryValueFunc: Function\n  ): unknown {\n    const isFirstInvokedRule = this.RULE_STACK.length === 1\n    // note the reSync is always enabled for the first rule invocation, because we must always be able to\n    // reSync with EOF and just output some INVALID ParseTree\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n    // path is really the most valid one\n    const reSyncEnabled =\n      resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled\n\n    if (isRecognitionException(e)) {\n      const recogError: any = e\n      if (reSyncEnabled) {\n        const reSyncTokType = this.findReSyncTokenType()\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType)\n          if (this.outputCst) {\n            const partialCstResult: any =\n              this.CST_STACK[this.CST_STACK.length - 1]\n            partialCstResult.recoveredNode = true\n            return partialCstResult\n          } else {\n            return recoveryValueFunc(e)\n          }\n        } else {\n          if (this.outputCst) {\n            const partialCstResult: any =\n              this.CST_STACK[this.CST_STACK.length - 1]\n            partialCstResult.recoveredNode = true\n            recogError.partialCstResult = partialCstResult\n          }\n          // to be handled Further up the call stack\n          throw recogError\n        }\n      } else if (isFirstInvokedRule) {\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n        this.moveToTerminatedState()\n        // the parser should never throw one of its own errors outside its flow.\n        // even if error recovery is disabled\n        return recoveryValueFunc(e)\n      } else {\n        // to be recovered Further up the call stack\n        throw recogError\n      }\n    } else {\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n      throw e\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternal<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number\n  ): OUT | undefined {\n    const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence)\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key)\n  }\n\n  optionInternalLogic<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number,\n    key: number\n  ): OUT | undefined {\n    let lookAheadFunc = this.getLaFuncFromCache(key)\n    let action: GrammarAction<OUT>\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF\n      const predicate = actionORMethodDef.GATE\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    if (lookAheadFunc.call(this) === true) {\n      return action.call(this)\n    }\n    return undefined\n  }\n\n  atLeastOneInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_IDX,\n      prodOccurrence\n    )\n    return this.atLeastOneInternalLogic(\n      prodOccurrence,\n      actionORMethodDef,\n      laKey\n    )\n  }\n\n  atLeastOneInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\n    key: number\n  ): void {\n    let lookAheadFunc = this.getLaFuncFromCache(key)\n    let action\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF\n      const predicate = actionORMethodDef.GATE\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookAheadFunc\n        lookAheadFunc = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    if ((<Function>lookAheadFunc).call(this) === true) {\n      let notStuck = this.doSingleRepetition(action)\n      while (\n        (<Function>lookAheadFunc).call(this) === true &&\n        notStuck === true\n      ) {\n        notStuck = this.doSingleRepetition(action)\n      }\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY,\n        (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).ERR_MSG\n      )\n    }\n\n    // note that while it may seem that this can cause an error because by using a recursive call to\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.atLeastOneInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookAheadFunc,\n      AT_LEAST_ONE_IDX,\n      prodOccurrence,\n      NextTerminalAfterAtLeastOneWalker\n    )\n  }\n\n  atLeastOneSepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence\n    )\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey)\n  }\n\n  atLeastOneSepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>,\n    key: number\n  ): void {\n    const action = options.DEF\n    const separator = options.SEP\n\n    const firstIterationLookaheadFunc = this.getLaFuncFromCache(key)\n\n    // 1st iteration\n    if (firstIterationLookaheadFunc.call(this) === true) {\n      ;(<GrammarAction<OUT>>action).call(this)\n\n      //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n      //  because it is only needed in error recovery scenarios.\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator)\n      }\n\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator)\n        // No need for checking infinite loop here due to consuming the separator.\n        ;(<GrammarAction<OUT>>action).call(this)\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterAtLeastOneSepWalker\n        ],\n        separatorLookAheadFunc,\n        AT_LEAST_ONE_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterAtLeastOneSepWalker\n      )\n    } else {\n      throw this.raiseEarlyExitException(\n        prodOccurrence,\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n        options.ERR_MSG\n      )\n    }\n  }\n\n  manyInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence)\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey)\n  }\n\n  manyInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    key: number\n  ) {\n    let lookaheadFunction = this.getLaFuncFromCache(key)\n    let action\n    if (typeof actionORMethodDef !== \"function\") {\n      action = actionORMethodDef.DEF\n      const predicate = actionORMethodDef.GATE\n      // predicate present\n      if (predicate !== undefined) {\n        const orgLookaheadFunction = lookaheadFunction\n        lookaheadFunction = () => {\n          return predicate.call(this) && orgLookaheadFunction.call(this)\n        }\n      }\n    } else {\n      action = actionORMethodDef\n    }\n\n    let notStuck = true\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\n      notStuck = this.doSingleRepetition(action)\n    }\n\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    this.attemptInRepetitionRecovery(\n      this.manyInternal,\n      [prodOccurrence, actionORMethodDef],\n      <any>lookaheadFunction,\n      MANY_IDX,\n      prodOccurrence,\n      NextTerminalAfterManyWalker,\n      // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n      // An infinite loop cannot occur as:\n      // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n      notStuck\n    )\n  }\n\n  manySepFirstInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>\n  ): void {\n    const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence)\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey)\n  }\n\n  manySepFirstInternalLogic<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    options: ManySepMethodOpts<OUT>,\n    key: number\n  ): void {\n    const action = options.DEF\n    const separator = options.SEP\n    const firstIterationLaFunc = this.getLaFuncFromCache(key)\n\n    // 1st iteration\n    if (firstIterationLaFunc.call(this) === true) {\n      action.call(this)\n\n      const separatorLookAheadFunc = () => {\n        return this.tokenMatcher(this.LA(1), separator)\n      }\n      // 2nd..nth iterations\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator)\n        // No need for checking infinite loop here due to consuming the separator.\n        action.call(this)\n      }\n\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [\n          prodOccurrence,\n          separator,\n          separatorLookAheadFunc,\n          action,\n          NextTerminalAfterManySepWalker\n        ],\n        separatorLookAheadFunc,\n        MANY_SEP_IDX,\n        prodOccurrence,\n        NextTerminalAfterManySepWalker\n      )\n    }\n  }\n\n  repetitionSepSecondInternal<OUT>(\n    this: MixedInParser,\n    prodOccurrence: number,\n    separator: TokenType,\n    separatorLookAheadFunc: () => boolean,\n    action: GrammarAction<OUT>,\n    nextTerminalAfterWalker: typeof AbstractNextTerminalAfterProductionWalker\n  ): void {\n    while (separatorLookAheadFunc()) {\n      // note that this CONSUME will never enter recovery because\n      // the separatorLookAheadFunc checks that the separator really does exist.\n      this.CONSUME(separator)\n      action.call(this)\n    }\n\n    // we can only arrive to this function after an error\n    // has occurred (hence the name 'second') so the following\n    // IF will always be entered, its possible to remove it...\n    // however it is kept to avoid confusion and be consistent.\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n    /* istanbul ignore else */\n    this.attemptInRepetitionRecovery(\n      this.repetitionSepSecondInternal,\n      [\n        prodOccurrence,\n        separator,\n        separatorLookAheadFunc,\n        action,\n        nextTerminalAfterWalker\n      ],\n      separatorLookAheadFunc,\n      AT_LEAST_ONE_SEP_IDX,\n      prodOccurrence,\n      nextTerminalAfterWalker\n    )\n  }\n\n  doSingleRepetition(this: MixedInParser, action: Function): any {\n    const beforeIteration = this.getLexerPosition()\n    action.call(this)\n    const afterIteration = this.getLexerPosition()\n\n    // This boolean will indicate if this repetition progressed\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\n    return afterIteration > beforeIteration\n  }\n\n  orInternal<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number\n  ): T {\n    const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence)\n    const alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF\n\n    const laFunc = this.getLaFuncFromCache(laKey)\n    const altIdxToTake = laFunc.call(this, alts)\n    if (altIdxToTake !== undefined) {\n      const chosenAlternative: any = alts[altIdxToTake]\n      return chosenAlternative.ALT.call(this)\n    }\n    this.raiseNoAltException(\n      occurrence,\n      (altsOrOpts as OrMethodOpts<unknown>).ERR_MSG\n    )\n  }\n\n  ruleFinallyStateUpdate(this: MixedInParser): void {\n    this.RULE_STACK.pop()\n    this.RULE_OCCURRENCE_STACK.pop()\n\n    // NOOP when cst is disabled\n    this.cstFinallyStateUpdate()\n\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n      const firstRedundantTok = this.LA(1)\n      const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n        firstRedundant: firstRedundantTok,\n        ruleName: this.getCurrRuleFullName()\n      })\n      this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok))\n    }\n  }\n\n  subruleInternal<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    idx: number,\n    options?: SubruleMethodOpts<ARGS>\n  ): R {\n    let ruleResult\n    try {\n      const args = options !== undefined ? options.ARGS : undefined\n      this.subruleIdx = idx\n      ruleResult = ruleToCall.apply(this, args)\n      this.cstPostNonTerminal(\n        ruleResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : ruleToCall.ruleName\n      )\n      return ruleResult\n    } catch (e) {\n      throw this.subruleInternalError(e, options, ruleToCall.ruleName)\n    }\n  }\n\n  subruleInternalError(\n    this: MixedInParser,\n    e: any,\n    options: SubruleMethodOpts<unknown[]> | undefined,\n    ruleName: string\n  ): void {\n    if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n      this.cstPostNonTerminal(\n        e.partialCstResult,\n        options !== undefined && options.LABEL !== undefined\n          ? options.LABEL\n          : ruleName\n      )\n\n      delete e.partialCstResult\n    }\n    throw e\n  }\n\n  consumeInternal(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    options: ConsumeMethodOpts | undefined\n  ): IToken {\n    let consumedToken!: IToken\n    try {\n      const nextToken = this.LA(1)\n      if (this.tokenMatcher(nextToken, tokType) === true) {\n        this.consumeToken()\n        consumedToken = nextToken\n      } else {\n        this.consumeInternalError(tokType, nextToken, options)\n      }\n    } catch (eFromConsumption) {\n      consumedToken = this.consumeInternalRecovery(\n        tokType,\n        idx,\n        eFromConsumption\n      )\n    }\n\n    this.cstPostTerminal(\n      options !== undefined && options.LABEL !== undefined\n        ? options.LABEL\n        : tokType.name,\n      consumedToken\n    )\n    return consumedToken\n  }\n\n  consumeInternalError(\n    this: MixedInParser,\n    tokType: TokenType,\n    nextToken: IToken,\n    options: ConsumeMethodOpts | undefined\n  ): void {\n    let msg\n    const previousToken = this.LA(0)\n    if (options !== undefined && options.ERR_MSG) {\n      msg = options.ERR_MSG\n    } else {\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: tokType,\n        actual: nextToken,\n        previous: previousToken,\n        ruleName: this.getCurrRuleFullName()\n      })\n    }\n    throw this.SAVE_ERROR(\n      new MismatchedTokenException(msg, nextToken, previousToken)\n    )\n  }\n\n  consumeInternalRecovery(\n    this: MixedInParser,\n    tokType: TokenType,\n    idx: number,\n    eFromConsumption: Error\n  ): IToken {\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\n    if (\n      this.recoveryEnabled &&\n      // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n      eFromConsumption.name === \"MismatchedTokenException\" &&\n      !this.isBackTracking()\n    ) {\n      const follows = this.getFollowsForInRuleRecovery(<any>tokType, idx)\n      try {\n        return this.tryInRuleRecovery(<any>tokType, follows)\n      } catch (eFromInRuleRecovery) {\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n          // failed in RuleRecovery.\n          // throw the original error in order to trigger reSync error recovery\n          throw eFromConsumption\n        } else {\n          throw eFromInRuleRecovery\n        }\n      }\n    } else {\n      throw eFromConsumption\n    }\n  }\n\n  saveRecogState(this: MixedInParser): IParserState {\n    // errors is a getter which will clone the errors array\n    const savedErrors = this.errors\n    const savedRuleStack = clone(this.RULE_STACK)\n    return {\n      errors: savedErrors,\n      lexerState: this.exportLexerState(),\n      RULE_STACK: savedRuleStack,\n      CST_STACK: this.CST_STACK\n    }\n  }\n\n  reloadRecogState(this: MixedInParser, newState: IParserState) {\n    this.errors = newState.errors\n    this.importLexerState(newState.lexerState)\n    this.RULE_STACK = newState.RULE_STACK\n  }\n\n  ruleInvocationStateUpdate(\n    this: MixedInParser,\n    shortName: number,\n    fullName: string,\n    idxInCallingRule: number\n  ): void {\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule)\n    this.RULE_STACK.push(shortName)\n    // NOOP when cst is disabled\n    this.cstInvocationStateUpdate(fullName)\n  }\n\n  isBackTracking(this: MixedInParser): boolean {\n    return this.isBackTrackingStack.length !== 0\n  }\n\n  getCurrRuleFullName(this: MixedInParser): string {\n    const shortName = this.getLastExplicitRuleShortName()\n    return this.shortRuleNameToFull[shortName]\n  }\n\n  shortRuleNameToFullName(this: MixedInParser, shortName: number) {\n    return this.shortRuleNameToFull[shortName]\n  }\n\n  public isAtEndOfInput(this: MixedInParser): boolean {\n    return this.tokenMatcher(this.LA(1), EOF)\n  }\n\n  public reset(this: MixedInParser): void {\n    this.resetLexerState()\n    this.subruleIdx = 0\n    this.isBackTrackingStack = []\n    this.errors = []\n    this.RULE_STACK = []\n    // TODO: extract a specific reset for TreeBuilder trait\n    this.CST_STACK = []\n    this.RULE_OCCURRENCE_STACK = []\n  }\n}\n", "import {\n  IParserConfig,\n  IParserErrorMessageProvider,\n  IRecognitionException\n} from \"@chevrotain/types\"\nimport {\n  EarlyExitException,\n  isRecognitionException,\n  NoViableAltException\n} from \"../../exceptions_public\"\nimport has from \"lodash/has\"\nimport clone from \"lodash/clone\"\nimport {\n  getLookaheadPathsForOptionalProd,\n  getLookaheadPathsForOr,\n  PROD_TYPE\n} from \"../../grammar/lookahead\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class ErrorHandler {\n  _errors: IRecognitionException[]\n  errorMessageProvider: IParserErrorMessageProvider\n\n  initErrorHandler(config: IParserConfig) {\n    this._errors = []\n    this.errorMessageProvider = has(config, \"errorMessageProvider\")\n      ? (config.errorMessageProvider as IParserErrorMessageProvider) // assumes end user provides the correct config value/type\n      : DEFAULT_PARSER_CONFIG.errorMessageProvider\n  }\n\n  SAVE_ERROR(\n    this: MixedInParser,\n    error: IRecognitionException\n  ): IRecognitionException {\n    if (isRecognitionException(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK)\n      }\n      this._errors.push(error)\n      return error\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\")\n    }\n  }\n\n  get errors(): IRecognitionException[] {\n    return clone(this._errors)\n  }\n\n  set errors(newErrors: IRecognitionException[]) {\n    this._errors = newErrors\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseEarlyExitException(\n    this: MixedInParser,\n    occurrence: number,\n    prodType: PROD_TYPE,\n    userDefinedErrMsg: string | undefined\n  ): never {\n    const ruleName = this.getCurrRuleFullName()\n    const ruleGrammar = this.getGAstProductions()[ruleName]\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(\n      occurrence,\n      ruleGrammar,\n      prodType,\n      this.maxLookahead\n    )\n    const insideProdPaths = lookAheadPathsPerAlternative[0]\n    const actualTokens = []\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i))\n    }\n    const msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName\n    })\n\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)))\n  }\n\n  // TODO: consider caching the error message computed information\n  raiseNoAltException(\n    this: MixedInParser,\n    occurrence: number,\n    errMsgTypes: string | undefined\n  ): never {\n    const ruleName = this.getCurrRuleFullName()\n    const ruleGrammar = this.getGAstProductions()[ruleName]\n    // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOr(\n      occurrence,\n      ruleGrammar,\n      this.maxLookahead\n    )\n\n    const actualTokens = []\n    for (let i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i))\n    }\n    const previousToken = this.LA(0)\n\n    const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    })\n\n    throw this.SAVE_ERROR(\n      new NoViableAltException(errMsg, this.LA(1), previousToken)\n    )\n  }\n}\n", "import {\n  ISyntacticContentAssistPath,\n  IToken,\n  ITokenGrammarPath,\n  TokenType\n} from \"@chevrotain/types\"\nimport {\n  NextAfterTokenWalker,\n  nextPossibleTokensAfter\n} from \"../../grammar/interpreter\"\nimport first from \"lodash/first\"\nimport isUndefined from \"lodash/isUndefined\"\nimport { MixedInParser } from \"./parser_traits\"\n\nexport class ContentAssist {\n  initContentAssist() {}\n\n  public computeContentAssist(\n    this: MixedInParser,\n    startRuleName: string,\n    precedingInput: IToken[]\n  ): ISyntacticContentAssistPath[] {\n    const startRuleGast = this.gastProductionsCache[startRuleName]\n\n    if (isUndefined(startRuleGast)) {\n      throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`)\n    }\n\n    return nextPossibleTokensAfter(\n      [startRuleGast],\n      precedingInput,\n      this.tokenMatcher,\n      this.maxLookahead\n    )\n  }\n\n  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n  // TODO: should this be more explicitly part of the public API?\n  public getNextPossibleTokenTypes(\n    this: MixedInParser,\n    grammarPath: ITokenGrammarPath\n  ): TokenType[] {\n    const topRuleName = first(grammarPath.ruleStack)!\n    const gastProductions = this.getGAstProductions()\n    const topProduction = gastProductions[topRuleName]\n    const nextPossibleTokenTypes = new NextAfterTokenWalker(\n      topProduction,\n      grammarPath\n    ).startWalking()\n    return nextPossibleTokenTypes\n  }\n}\n", "import {\n  AtLeastOneSepMethodOpts,\n  ConsumeMethodOpts,\n  CstNode,\n  DSLMethodOpts,\n  DSLMethodOptsWithErr,\n  GrammarAction,\n  IOrAlt,\n  IParserConfig,\n  IProduction,\n  IToken,\n  ManySepMethodOpts,\n  OrMethodOpts,\n  SubruleMethodOpts,\n  TokenType\n} from \"@chevrotain/types\"\nimport peek from \"lodash/last\"\nimport isArray from \"lodash/isArray\"\nimport some from \"lodash/some\"\nimport forEach from \"lodash/forEach\"\nimport isFunction from \"lodash/isFunction\"\nimport has from \"lodash/has\"\nimport { MixedInParser } from \"./parser_traits\"\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"@chevrotain/gast\"\nimport { Lexer } from \"../../../scan/lexer_public\"\nimport { augmentTokenTypes, hasShortKeyProperty } from \"../../../scan/tokens\"\nimport { createToken, createTokenInstance } from \"../../../scan/tokens_public\"\nimport { END_OF_FILE } from \"../parser\"\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys\"\nimport { ParserMethodInternal } from \"../types\"\n\ntype ProdWithDef = IProduction & { definition?: IProduction[] }\nconst RECORDING_NULL_OBJECT = {\n  description: \"This Object indicates the Parser is during Recording Phase\"\n}\nObject.freeze(RECORDING_NULL_OBJECT)\n\nconst HANDLE_SEPARATOR = true\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1\n\nconst RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA })\naugmentTokenTypes([RFT])\nconst RECORDING_PHASE_TOKEN = createTokenInstance(\n  RFT,\n  \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n  -1,\n  -1,\n  -1,\n  -1,\n  -1,\n  -1\n)\nObject.freeze(RECORDING_PHASE_TOKEN)\n\nconst RECORDING_PHASE_CSTNODE: CstNode = {\n  name:\n    \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n  children: {}\n}\n\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nexport class GastRecorder {\n  recordingProdStack: ProdWithDef[]\n  RECORDING_PHASE: boolean\n\n  initGastRecorder(this: MixedInParser, config: IParserConfig): void {\n    this.recordingProdStack = []\n    this.RECORDING_PHASE = false\n  }\n\n  enableRecording(this: MixedInParser): void {\n    this.RECORDING_PHASE = true\n\n    this.TRACE_INIT(\"Enable Recording\", () => {\n      /**\n       * Warning Dark Voodoo Magic upcoming!\n       * We are \"replacing\" the public parsing DSL methods API\n       * With **new** alternative implementations on the Parser **instance**\n       *\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n       *   implementations directly instead.\n       */\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\"\n        this[`CONSUME${idx}` as \"CONSUME\"] = function (arg1, arg2) {\n          return this.consumeInternalRecord(arg1, i, arg2)\n        }\n        this[`SUBRULE${idx}` as \"SUBRULE\"] = function (arg1, arg2) {\n          return this.subruleInternalRecord(arg1, i, arg2) as any\n        }\n        this[`OPTION${idx}` as \"OPTION\"] = function (arg1) {\n          return this.optionInternalRecord(arg1, i)\n        }\n        this[`OR${idx}` as \"OR\"] = function (arg1) {\n          return this.orInternalRecord(arg1, i)\n        }\n        this[`MANY${idx}` as \"MANY\"] = function (arg1) {\n          this.manyInternalRecord(i, arg1)\n        }\n        this[`MANY_SEP${idx}` as \"MANY_SEP\"] = function (arg1) {\n          this.manySepFirstInternalRecord(i, arg1)\n        }\n        this[`AT_LEAST_ONE${idx}` as \"AT_LEAST_ONE\"] = function (arg1) {\n          this.atLeastOneInternalRecord(i, arg1)\n        }\n        this[`AT_LEAST_ONE_SEP${idx}` as \"AT_LEAST_ONE_SEP\"] = function (arg1) {\n          this.atLeastOneSepFirstInternalRecord(i, arg1)\n        }\n      }\n\n      // DSL methods with the idx(suffix) as an argument\n      this[`consume`] = function (idx, arg1, arg2) {\n        return this.consumeInternalRecord(arg1, idx, arg2)\n      }\n      this[`subrule`] = function (idx, arg1, arg2) {\n        return this.subruleInternalRecord(arg1, idx, arg2) as any\n      }\n      this[`option`] = function (idx, arg1) {\n        return this.optionInternalRecord(arg1, idx)\n      }\n      this[`or`] = function (idx, arg1) {\n        return this.orInternalRecord(arg1, idx)\n      }\n      this[`many`] = function (idx, arg1) {\n        this.manyInternalRecord(idx, arg1)\n      }\n      this[`atLeastOne`] = function (idx, arg1) {\n        this.atLeastOneInternalRecord(idx, arg1)\n      }\n\n      this.ACTION = this.ACTION_RECORD\n      this.BACKTRACK = this.BACKTRACK_RECORD\n      this.LA = this.LA_RECORD\n    })\n  }\n\n  disableRecording(this: MixedInParser) {\n    this.RECORDING_PHASE = false\n    // By deleting these **instance** properties, any future invocation\n    // will be deferred to the original methods on the **prototype** object\n    // This seems to get rid of any incorrect optimizations that V8 may\n    // do during the recording phase.\n    this.TRACE_INIT(\"Deleting Recording methods\", () => {\n      const that: any = this\n\n      for (let i = 0; i < 10; i++) {\n        const idx = i > 0 ? i : \"\"\n        delete that[`CONSUME${idx}`]\n        delete that[`SUBRULE${idx}`]\n        delete that[`OPTION${idx}`]\n        delete that[`OR${idx}`]\n        delete that[`MANY${idx}`]\n        delete that[`MANY_SEP${idx}`]\n        delete that[`AT_LEAST_ONE${idx}`]\n        delete that[`AT_LEAST_ONE_SEP${idx}`]\n      }\n\n      delete that[`consume`]\n      delete that[`subrule`]\n      delete that[`option`]\n      delete that[`or`]\n      delete that[`many`]\n      delete that[`atLeastOne`]\n\n      delete that.ACTION\n      delete that.BACKTRACK\n      delete that.LA\n    })\n  }\n\n  //   Parser methods are called inside an ACTION?\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n  // @ts-expect-error -- noop place holder\n  ACTION_RECORD<T>(this: MixedInParser, impl: () => T): T {\n    // NO-OP during recording\n  }\n\n  // Executing backtracking logic will break our recording logic assumptions\n  BACKTRACK_RECORD<T>(\n    grammarRule: (...args: any[]) => T,\n    args?: any[]\n  ): () => boolean {\n    return () => true\n  }\n\n  // LA is part of the official API and may be used for custom lookahead logic\n  // by end users who may forget to wrap it in ACTION or inside a GATE\n  LA_RECORD(howMuch: number): IToken {\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n    // On LA return EOF at the end of the input so an infinite loop may occur.\n    return END_OF_FILE\n  }\n\n  topLevelRuleRecord(name: string, def: Function): Rule {\n    try {\n      const newTopLevelRule = new Rule({ definition: [], name: name })\n      newTopLevelRule.name = name\n      this.recordingProdStack.push(newTopLevelRule)\n      def.call(this)\n      this.recordingProdStack.pop()\n      return newTopLevelRule\n    } catch (originalError) {\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\n        try {\n          originalError.message =\n            originalError.message +\n            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\"\n        } catch (mutabilityError) {\n          // We may not be able to modify the original error object\n          throw originalError\n        }\n      }\n      throw originalError\n    }\n  }\n\n  // Implementation of parsing DSL\n  optionInternalRecord<OUT>(\n    this: MixedInParser,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\n    occurrence: number\n  ): OUT {\n    return recordProd.call(this, Option, actionORMethodDef, occurrence)\n  }\n\n  atLeastOneInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>\n  ): void {\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence)\n  }\n\n  atLeastOneSepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: AtLeastOneSepMethodOpts<OUT>\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionMandatoryWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR\n    )\n  }\n\n  manyInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>\n  ): void {\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence)\n  }\n\n  manySepFirstInternalRecord<OUT>(\n    this: MixedInParser,\n    occurrence: number,\n    options: ManySepMethodOpts<OUT>\n  ): void {\n    recordProd.call(\n      this,\n      RepetitionWithSeparator,\n      options,\n      occurrence,\n      HANDLE_SEPARATOR\n    )\n  }\n\n  orInternalRecord<T>(\n    this: MixedInParser,\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\n    occurrence: number\n  ): T {\n    return recordOrProd.call(this, altsOrOpts, occurrence)\n  }\n\n  subruleInternalRecord<ARGS extends unknown[], R>(\n    this: MixedInParser,\n    ruleToCall: ParserMethodInternal<ARGS, R>,\n    occurrence: number,\n    options?: SubruleMethodOpts<ARGS>\n  ): R | CstNode {\n    assertMethodIdxIsValid(occurrence)\n    if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n      const error: any = new Error(\n        `<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a Parser method reference but got: <${JSON.stringify(\n            ruleToCall\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`\n      )\n      error.KNOWN_RECORDER_ERROR = true\n      throw error\n    }\n\n    const prevProd: any = peek(this.recordingProdStack)\n    const ruleName = ruleToCall.ruleName\n    const newNoneTerminal = new NonTerminal({\n      idx: occurrence,\n      nonTerminalName: ruleName,\n      label: options?.LABEL,\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n      referencedRule: undefined\n    })\n    prevProd.definition.push(newNoneTerminal)\n\n    return this.outputCst ? RECORDING_PHASE_CSTNODE : <any>RECORDING_NULL_OBJECT\n  }\n\n  consumeInternalRecord(\n    this: MixedInParser,\n    tokType: TokenType,\n    occurrence: number,\n    options?: ConsumeMethodOpts\n  ): IToken {\n    assertMethodIdxIsValid(occurrence)\n    if (!hasShortKeyProperty(tokType)) {\n      const error: any = new Error(\n        `<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n          ` expecting a TokenType reference but got: <${JSON.stringify(\n            tokType\n          )}>` +\n          `\\n inside top level rule: <${\n            (<Rule>this.recordingProdStack[0]).name\n          }>`\n      )\n      error.KNOWN_RECORDER_ERROR = true\n      throw error\n    }\n    const prevProd: any = peek(this.recordingProdStack)\n    const newNoneTerminal = new Terminal({\n      idx: occurrence,\n      terminalType: tokType,\n      label: options?.LABEL\n    })\n    prevProd.definition.push(newNoneTerminal)\n\n    return RECORDING_PHASE_TOKEN\n  }\n}\n\nfunction recordProd(\n  prodConstructor: any,\n  mainProdArg: any,\n  occurrence: number,\n  handleSep: boolean = false\n): any {\n  assertMethodIdxIsValid(occurrence)\n  const prevProd: any = peek(this.recordingProdStack)\n  const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF\n\n  const newProd = new prodConstructor({ definition: [], idx: occurrence })\n  if (handleSep) {\n    newProd.separator = mainProdArg.SEP\n  }\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n  }\n\n  this.recordingProdStack.push(newProd)\n  grammarAction.call(this)\n  prevProd.definition.push(newProd)\n  this.recordingProdStack.pop()\n\n  return RECORDING_NULL_OBJECT\n}\n\nfunction recordOrProd(mainProdArg: any, occurrence: number): any {\n  assertMethodIdxIsValid(occurrence)\n  const prevProd: any = peek(this.recordingProdStack)\n  // Only an array of alternatives\n  const hasOptions = isArray(mainProdArg) === false\n  const alts: IOrAlt<unknown>[] =\n    hasOptions === false ? mainProdArg : mainProdArg.DEF\n\n  const newOrProd = new Alternation({\n    definition: [],\n    idx: occurrence,\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n  })\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n  }\n\n  const hasPredicates = some(alts, (currAlt: any) => isFunction(currAlt.GATE))\n  newOrProd.hasPredicates = hasPredicates\n\n  prevProd.definition.push(newOrProd)\n\n  forEach(alts, (currAlt) => {\n    const currAltFlat = new Alternative({ definition: [] })\n    newOrProd.definition.push(currAltFlat)\n    if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES as boolean // assumes end user provides the correct config value/type\n    }\n    // **implicit** ignoreAmbiguities due to usage of gate\n    else if (has(currAlt, \"GATE\")) {\n      currAltFlat.ignoreAmbiguities = true\n    }\n    this.recordingProdStack.push(currAltFlat)\n    currAlt.ALT.call(this)\n    this.recordingProdStack.pop()\n  })\n  return RECORDING_NULL_OBJECT\n}\n\nfunction getIdxSuffix(idx: number): string {\n  return idx === 0 ? \"\" : `${idx}`\n}\n\nfunction assertMethodIdxIsValid(idx: number): void {\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\n    const error: any = new Error(\n      // The stack trace will contain all the needed details\n      `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n        `Idx value must be a none negative value smaller than ${\n          MAX_METHOD_IDX + 1\n        }`\n    )\n    error.KNOWN_RECORDER_ERROR = true\n    throw error\n  }\n}\n", "import { IParserConfig } from \"@chevrotain/types\"\nimport has from \"lodash/has\"\nimport { timer } from \"@chevrotain/utils\"\nimport { MixedInParser } from \"./parser_traits\"\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nexport class PerformanceTracer {\n  traceInitPerf: boolean | number\n  traceInitMaxIdent: number\n  traceInitIndent: number\n\n  initPerformanceTracer(config: IParserConfig) {\n    if (has(config, \"traceInitPerf\")) {\n      const userTraceInitPerf = config.traceInitPerf\n      const traceIsNumber = typeof userTraceInitPerf === \"number\"\n      this.traceInitMaxIdent = traceIsNumber\n        ? <number>userTraceInitPerf\n        : Infinity\n      this.traceInitPerf = traceIsNumber\n        ? userTraceInitPerf > 0\n        : (userTraceInitPerf as boolean) // assumes end user provides the correct config value/type\n    } else {\n      this.traceInitMaxIdent = 0\n      this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf\n    }\n\n    this.traceInitIndent = -1\n  }\n\n  TRACE_INIT<T>(this: MixedInParser, phaseDesc: string, phaseImpl: () => T): T {\n    // No need to optimize this using NOOP pattern because\n    // It is not called in a hot spot...\n    if (this.traceInitPerf === true) {\n      this.traceInitIndent++\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\")\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        console.log(`${indent}--> <${phaseDesc}>`)\n      }\n      const { time, value } = timer(phaseImpl)\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n      const traceMethod = time > 10 ? console.warn : console.log\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n      }\n      this.traceInitIndent--\n      return value\n    } else {\n      return phaseImpl()\n    }\n  }\n}\n", "export function applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach((baseCtor) => {\n    const baseProto = baseCtor.prototype\n    Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n      if (propName === \"constructor\") {\n        return\n      }\n\n      const basePropDescriptor = Object.getOwnPropertyDescriptor(\n        baseProto,\n        propName\n      )\n      // Handle Accessors\n      if (\n        basePropDescriptor &&\n        (basePropDescriptor.get || basePropDescriptor.set)\n      ) {\n        Object.defineProperty(\n          derivedCtor.prototype,\n          propName,\n          basePropDescriptor\n        )\n      } else {\n        derivedCtor.prototype[propName] = baseCtor.prototype[propName]\n      }\n    })\n  })\n}\n", "import isEmpty from \"lodash/isEmpty\"\nimport map from \"lodash/map\"\nimport forEach from \"lodash/forEach\"\nimport values from \"lodash/values\"\nimport has from \"lodash/has\"\nimport clone from \"lodash/clone\"\nimport { toFastProperties } from \"@chevrotain/utils\"\nimport { computeAllProdsFollows } from \"../grammar/follow\"\nimport { createTokenInstance, EOF } from \"../../scan/tokens_public\"\nimport {\n  defaultGrammarValidatorErrorProvider,\n  defaultParserErrorProvider\n} from \"../errors_public\"\nimport {\n  resolveGrammar,\n  validateGrammar\n} from \"../grammar/gast/gast_resolver_public\"\nimport {\n  CstNode,\n  IParserConfig,\n  IRecognitionException,\n  IRuleConfig,\n  IToken,\n  TokenType,\n  TokenVocabulary\n} from \"@chevrotain/types\"\nimport { Recoverable } from \"./traits/recoverable\"\nimport { LooksAhead } from \"./traits/looksahead\"\nimport { TreeBuilder } from \"./traits/tree_builder\"\nimport { LexerAdapter } from \"./traits/lexer_adapter\"\nimport { RecognizerApi } from \"./traits/recognizer_api\"\nimport { RecognizerEngine } from \"./traits/recognizer_engine\"\n\nimport { ErrorHandler } from \"./traits/error_handler\"\nimport { MixedInParser } from \"./traits/parser_traits\"\nimport { ContentAssist } from \"./traits/context_assist\"\nimport { GastRecorder } from \"./traits/gast_recorder\"\nimport { PerformanceTracer } from \"./traits/perf_tracer\"\nimport { applyMixins } from \"./utils/apply_mixins\"\nimport { IParserDefinitionError } from \"../grammar/types\"\nimport { Rule } from \"@chevrotain/gast\"\nimport { IParserConfigInternal, ParserMethodInternal } from \"./types\"\nimport { validateLookahead } from \"../grammar/checks\"\n\nexport const END_OF_FILE = createTokenInstance(\n  EOF,\n  \"\",\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n  NaN,\n  NaN\n)\nObject.freeze(END_OF_FILE)\n\nexport type TokenMatcher = (token: IToken, tokType: TokenType) => boolean\n\nexport const DEFAULT_PARSER_CONFIG: Required<\n  Omit<IParserConfigInternal, \"lookaheadStrategy\">\n> = Object.freeze({\n  recoveryEnabled: false,\n  maxLookahead: 3,\n  dynamicTokensEnabled: false,\n  outputCst: true,\n  errorMessageProvider: defaultParserErrorProvider,\n  nodeLocationTracking: \"none\",\n  traceInitPerf: false,\n  skipValidations: false\n})\n\nexport const DEFAULT_RULE_CONFIG: Required<IRuleConfig<any>> = Object.freeze({\n  recoveryValueFunc: () => undefined,\n  resyncEnabled: true\n})\n\nexport enum ParserDefinitionErrorType {\n  INVALID_RULE_NAME = 0,\n  DUPLICATE_RULE_NAME = 1,\n  INVALID_RULE_OVERRIDE = 2,\n  DUPLICATE_PRODUCTIONS = 3,\n  UNRESOLVED_SUBRULE_REF = 4,\n  LEFT_RECURSION = 5,\n  NONE_LAST_EMPTY_ALT = 6,\n  AMBIGUOUS_ALTS = 7,\n  CONFLICT_TOKENS_RULES_NAMESPACE = 8,\n  INVALID_TOKEN_NAME = 9,\n  NO_NON_EMPTY_LOOKAHEAD = 10,\n  AMBIGUOUS_PREFIX_ALTS = 11,\n  TOO_MANY_ALTS = 12,\n  CUSTOM_LOOKAHEAD_VALIDATION = 13\n}\n\nexport interface IParserDuplicatesDefinitionError\n  extends IParserDefinitionError {\n  dslName: string\n  occurrence: number\n  parameter?: string\n}\n\nexport interface IParserEmptyAlternativeDefinitionError\n  extends IParserDefinitionError {\n  occurrence: number\n  alternative: number\n}\n\nexport interface IParserAmbiguousAlternativesDefinitionError\n  extends IParserDefinitionError {\n  occurrence: number | string\n  alternatives: number[]\n}\n\nexport interface IParserUnresolvedRefDefinitionError\n  extends IParserDefinitionError {\n  unresolvedRefName: string\n}\n\nexport interface IParserState {\n  errors: IRecognitionException[]\n  lexerState: any\n  RULE_STACK: number[]\n  CST_STACK: CstNode[]\n}\n\nexport type Predicate = () => boolean\n\nexport function EMPTY_ALT(): () => undefined\nexport function EMPTY_ALT<T>(value: T): () => T\nexport function EMPTY_ALT(value: any = undefined) {\n  return function () {\n    return value\n  }\n}\n\nexport class Parser {\n  // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n  // (normally during the parser's constructor).\n  // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n  // for example: duplicate rule names, referencing an unresolved subrule, ect...\n  // This flag should not be enabled during normal usage, it is used in special situations, for example when\n  // needing to display the parser definition errors in some GUI(online playground).\n  static DEFER_DEFINITION_ERRORS_HANDLING: boolean = false\n\n  /**\n   *  @deprecated use the **instance** method with the same name instead\n   */\n  static performSelfAnalysis(parserInstance: Parser): void {\n    throw Error(\n      \"The **static** `performSelfAnalysis` method has been deprecated.\" +\n        \"\\t\\nUse the **instance** method with the same name instead.\"\n    )\n  }\n\n  public performSelfAnalysis(this: MixedInParser): void {\n    this.TRACE_INIT(\"performSelfAnalysis\", () => {\n      let defErrorsMsgs\n\n      this.selfAnalysisDone = true\n      const className = this.className\n\n      this.TRACE_INIT(\"toFastProps\", () => {\n        // Without this voodoo magic the parser would be x3-x4 slower\n        // It seems it is better to invoke `toFastProperties` **before**\n        // Any manipulations of the `this` object done during the recording phase.\n        toFastProperties(this)\n      })\n\n      this.TRACE_INIT(\"Grammar Recording\", () => {\n        try {\n          this.enableRecording()\n          // Building the GAST\n          forEach(this.definedRulesNames, (currRuleName) => {\n            const wrappedRule = (this as any)[\n              currRuleName\n            ] as ParserMethodInternal<unknown[], unknown>\n            const originalGrammarAction = wrappedRule[\"originalGrammarAction\"]\n            let recordedRuleGast!: Rule\n            this.TRACE_INIT(`${currRuleName} Rule`, () => {\n              recordedRuleGast = this.topLevelRuleRecord(\n                currRuleName,\n                originalGrammarAction\n              )\n            })\n            this.gastProductionsCache[currRuleName] = recordedRuleGast\n          })\n        } finally {\n          this.disableRecording()\n        }\n      })\n\n      let resolverErrors: IParserDefinitionError[] = []\n      this.TRACE_INIT(\"Grammar Resolving\", () => {\n        resolverErrors = resolveGrammar({\n          rules: values(this.gastProductionsCache)\n        })\n        this.definitionErrors = this.definitionErrors.concat(resolverErrors)\n      })\n\n      this.TRACE_INIT(\"Grammar Validations\", () => {\n        // only perform additional grammar validations IFF no resolving errors have occurred.\n        // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n        if (isEmpty(resolverErrors) && this.skipValidations === false) {\n          const validationErrors = validateGrammar({\n            rules: values(this.gastProductionsCache),\n            tokenTypes: values(this.tokensMap),\n            errMsgProvider: defaultGrammarValidatorErrorProvider,\n            grammarName: className\n          })\n          const lookaheadValidationErrors = validateLookahead({\n            lookaheadStrategy: this.lookaheadStrategy,\n            rules: values(this.gastProductionsCache),\n            tokenTypes: values(this.tokensMap),\n            grammarName: className\n          })\n          this.definitionErrors = this.definitionErrors.concat(\n            validationErrors,\n            lookaheadValidationErrors\n          )\n        }\n      })\n\n      // this analysis may fail if the grammar is not perfectly valid\n      if (isEmpty(this.definitionErrors)) {\n        // The results of these computations are not needed unless error recovery is enabled.\n        if (this.recoveryEnabled) {\n          this.TRACE_INIT(\"computeAllProdsFollows\", () => {\n            const allFollows = computeAllProdsFollows(\n              values(this.gastProductionsCache)\n            )\n            this.resyncFollows = allFollows\n          })\n        }\n\n        this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\n          this.lookaheadStrategy.initialize?.({\n            rules: values(this.gastProductionsCache)\n          })\n          this.preComputeLookaheadFunctions(values(this.gastProductionsCache))\n        })\n      }\n\n      if (\n        !Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n        !isEmpty(this.definitionErrors)\n      ) {\n        defErrorsMsgs = map(\n          this.definitionErrors,\n          (defError) => defError.message\n        )\n        throw new Error(\n          `Parser Definition Errors detected:\\n ${defErrorsMsgs.join(\n            \"\\n-------------------------------\\n\"\n          )}`\n        )\n      }\n    })\n  }\n\n  definitionErrors: IParserDefinitionError[] = []\n  selfAnalysisDone = false\n  protected skipValidations: boolean\n\n  constructor(tokenVocabulary: TokenVocabulary, config: IParserConfig) {\n    const that: MixedInParser = this as any\n    that.initErrorHandler(config)\n    that.initLexerAdapter()\n    that.initLooksAhead(config)\n    that.initRecognizerEngine(tokenVocabulary, config)\n    that.initRecoverable(config)\n    that.initTreeBuilder(config)\n    that.initContentAssist()\n    that.initGastRecorder(config)\n    that.initPerformanceTracer(config)\n\n    if (has(config, \"ignoredIssues\")) {\n      throw new Error(\n        \"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\n          \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\n          \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\n          \"For further details.\"\n      )\n    }\n\n    this.skipValidations = has(config, \"skipValidations\")\n      ? (config.skipValidations as boolean) // casting assumes the end user passing the correct type\n      : DEFAULT_PARSER_CONFIG.skipValidations\n  }\n}\n\napplyMixins(Parser, [\n  Recoverable,\n  LooksAhead,\n  TreeBuilder,\n  LexerAdapter,\n  RecognizerEngine,\n  RecognizerApi,\n  ErrorHandler,\n  ContentAssist,\n  GastRecorder,\n  PerformanceTracer\n])\n\nexport class CstParser extends Parser {\n  constructor(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfigInternal = DEFAULT_PARSER_CONFIG\n  ) {\n    const configClone = clone(config)\n    configClone.outputCst = true\n    super(tokenVocabulary, configClone)\n  }\n}\n\nexport class EmbeddedActionsParser extends Parser {\n  constructor(\n    tokenVocabulary: TokenVocabulary,\n    config: IParserConfigInternal = DEFAULT_PARSER_CONFIG\n  ) {\n    const configClone = clone(config)\n    configClone.outputCst = false\n    super(tokenVocabulary, configClone)\n  }\n}\n", "import type {\n  Alternation,\n  Alternative,\n  IProduction,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal,\n  TokenType\n} from \"@chevrotain/types\"\nimport { NonTerminal, GAstVisitor } from \"@chevrotain/gast\"\nimport map from \"lodash/map\"\nimport flatten from \"lodash/flatten\"\nimport values from \"lodash/values\"\nimport some from \"lodash/some\"\nimport groupBy from \"lodash/groupBy\"\nimport assign from \"lodash/assign\"\n\nexport function buildModel(\n  productions: Record<string, Rule>\n): CstNodeTypeDefinition[] {\n  const generator = new CstNodeDefinitionGenerator()\n  const allRules = values(productions)\n  return map(allRules, (rule) => generator.visitRule(rule))\n}\n\nexport type CstNodeTypeDefinition = {\n  name: string\n  properties: PropertyTypeDefinition[]\n}\n\nexport type PropertyTypeDefinition = {\n  name: string\n  type: PropertyArrayType\n  optional: boolean\n}\n\nexport type PropertyArrayType =\n  | TokenArrayType\n  | RuleArrayType\n  | (TokenArrayType | RuleArrayType)[]\n\nexport type TokenArrayType = { kind: \"token\" }\nexport type RuleArrayType = {\n  kind: \"rule\"\n  name: string\n}\n\nclass CstNodeDefinitionGenerator extends GAstVisitor {\n  visitRule(node: Rule): CstNodeTypeDefinition {\n    const rawElements = this.visitEach(node.definition)\n\n    const grouped = groupBy(rawElements, (el) => el.propertyName)\n    const properties = map(grouped, (group, propertyName) => {\n      const allNullable = !some(group, (el) => !el.canBeNull)\n\n      // In an alternation with a label a property name can have\n      // multiple types.\n      let propertyType: PropertyArrayType = group[0].type\n      if (group.length > 1) {\n        propertyType = map(group, (g) => g.type)\n      }\n\n      return {\n        name: propertyName,\n        type: propertyType,\n        optional: allNullable\n      } as PropertyTypeDefinition\n    })\n\n    return {\n      name: node.name,\n      properties: properties\n    }\n  }\n\n  visitAlternative(node: Alternative) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true })\n  }\n\n  visitOption(node: Option) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true })\n  }\n\n  visitRepetition(node: Repetition) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true })\n  }\n\n  visitRepetitionMandatory(node: RepetitionMandatory) {\n    return this.visitEach(node.definition)\n  }\n\n  visitRepetitionMandatoryWithSeparator(\n    node: RepetitionMandatoryWithSeparator\n  ) {\n    return this.visitEach(node.definition).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator)\n    })\n  }\n\n  visitRepetitionWithSeparator(node: RepetitionWithSeparator) {\n    return this.visitEachAndOverrideWith(node.definition, {\n      canBeNull: true\n    }).concat({\n      propertyName: node.separator.name,\n      canBeNull: true,\n      type: getType(node.separator)\n    })\n  }\n\n  visitAlternation(node: Alternation) {\n    return this.visitEachAndOverrideWith(node.definition, { canBeNull: true })\n  }\n\n  visitTerminal(node: Terminal): PropertyTupleElement[] {\n    return [\n      {\n        propertyName: node.label || node.terminalType.name,\n        canBeNull: false,\n        type: getType(node)\n      }\n    ]\n  }\n\n  visitNonTerminal(node: NonTerminal): PropertyTupleElement[] {\n    return [\n      {\n        propertyName: node.label || node.nonTerminalName,\n        canBeNull: false,\n        type: getType(node)\n      }\n    ]\n  }\n\n  private visitEachAndOverrideWith(\n    definition: IProduction[],\n    override: Partial<PropertyTupleElement>\n  ) {\n    return map(\n      this.visitEach(definition),\n      (definition) => assign({}, definition, override) as PropertyTupleElement\n    )\n  }\n\n  private visitEach(definition: IProduction[]) {\n    return flatten<PropertyTupleElement>(\n      map(\n        definition,\n        (definition) => this.visit(definition) as PropertyTupleElement[]\n      )\n    )\n  }\n}\n\ntype PropertyTupleElement = {\n  propertyName: string\n  canBeNull: boolean\n  type: TokenArrayType | RuleArrayType\n}\n\nfunction getType(\n  production: Terminal | NonTerminal | TokenType\n): TokenArrayType | RuleArrayType {\n  if (production instanceof NonTerminal) {\n    return {\n      kind: \"rule\",\n      name: production.referencedRule.name\n    }\n  }\n\n  return { kind: \"token\" }\n}\n", "var baseSlice = require('./_baseSlice');\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\nmodule.exports = castSlice;\n", "/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\nmodule.exports = hasUnicode;\n", "/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\nmodule.exports = asciiToArray;\n", "/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange + ']',\n    rsCombo = '[' + rsComboRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\nmodule.exports = unicodeToArray;\n", "var asciiToArray = require('./_asciiToArray'),\n    hasUnicode = require('./_hasUnicode'),\n    unicodeToArray = require('./_unicodeToArray');\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\nmodule.exports = stringToArray;\n", "var castSlice = require('./_castSlice'),\n    hasUnicode = require('./_hasUnicode'),\n    stringToArray = require('./_stringToArray'),\n    toString = require('./toString');\n\n/**\n * Creates a function like `_.lowerFirst`.\n *\n * @private\n * @param {string} methodName The name of the `String` case method to use.\n * @returns {Function} Returns the new case function.\n */\nfunction createCaseFirst(methodName) {\n  return function(string) {\n    string = toString(string);\n\n    var strSymbols = hasUnicode(string)\n      ? stringToArray(string)\n      : undefined;\n\n    var chr = strSymbols\n      ? strSymbols[0]\n      : string.charAt(0);\n\n    var trailing = strSymbols\n      ? castSlice(strSymbols, 1).join('')\n      : string.slice(1);\n\n    return chr[methodName]() + trailing;\n  };\n}\n\nmodule.exports = createCaseFirst;\n", "var createCaseFirst = require('./_createCaseFirst');\n\n/**\n * Converts the first character of `string` to upper case.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category String\n * @param {string} [string=''] The string to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.upperFirst('fred');\n * // => 'Fred'\n *\n * _.upperFirst('FRED');\n * // => 'FRED'\n */\nvar upperFirst = createCaseFirst('toUpperCase');\n\nmodule.exports = upperFirst;\n", "import flatten from \"lodash/flatten\"\nimport isArray from \"lodash/isArray\"\nimport map from \"lodash/map\"\nimport reduce from \"lodash/reduce\"\nimport uniq from \"lodash/uniq\"\nimport upperFirst from \"lodash/upperFirst\"\nimport { GenerateDtsOptions } from \"@chevrotain/types\"\nimport {\n  CstNodeTypeDefinition,\n  PropertyTypeDefinition,\n  PropertyArrayType,\n  TokenArrayType,\n  RuleArrayType\n} from \"./model\"\n\nexport function genDts(\n  model: CstNodeTypeDefinition[],\n  options: Required<GenerateDtsOptions>\n): string {\n  let contentParts: string[] = []\n\n  contentParts = contentParts.concat(\n    `import type { CstNode, ICstVisitor, IToken } from \"chevrotain\";`\n  )\n\n  contentParts = contentParts.concat(\n    flatten(map(model, (node) => genCstNodeTypes(node)))\n  )\n\n  if (options.includeVisitorInterface) {\n    contentParts = contentParts.concat(\n      genVisitor(options.visitorInterfaceName, model)\n    )\n  }\n\n  return contentParts.join(\"\\n\\n\") + \"\\n\"\n}\n\nfunction genCstNodeTypes(node: CstNodeTypeDefinition) {\n  const nodeCstInterface = genNodeInterface(node)\n  const nodeChildrenInterface = genNodeChildrenType(node)\n\n  return [nodeCstInterface, nodeChildrenInterface]\n}\n\nfunction genNodeInterface(node: CstNodeTypeDefinition) {\n  const nodeInterfaceName = getNodeInterfaceName(node.name)\n  const childrenTypeName = getNodeChildrenTypeName(node.name)\n\n  return `export interface ${nodeInterfaceName} extends CstNode {\n  name: \"${node.name}\";\n  children: ${childrenTypeName};\n}`\n}\n\nfunction genNodeChildrenType(node: CstNodeTypeDefinition) {\n  const typeName = getNodeChildrenTypeName(node.name)\n\n  return `export type ${typeName} = {\n  ${map(node.properties, (property) => genChildProperty(property)).join(\"\\n  \")}\n};`\n}\n\nfunction genChildProperty(prop: PropertyTypeDefinition) {\n  const typeName = buildTypeString(prop.type)\n  return `${prop.name}${prop.optional ? \"?\" : \"\"}: ${typeName}[];`\n}\n\nfunction genVisitor(name: string, nodes: CstNodeTypeDefinition[]) {\n  return `export interface ${name}<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ${map(nodes, (node) => genVisitorFunction(node)).join(\"\\n  \")}\n}`\n}\n\nfunction genVisitorFunction(node: CstNodeTypeDefinition) {\n  const childrenTypeName = getNodeChildrenTypeName(node.name)\n  return `${node.name}(children: ${childrenTypeName}, param?: IN): OUT;`\n}\n\nfunction buildTypeString(type: PropertyArrayType) {\n  if (isArray(type)) {\n    const typeNames = uniq(map(type, (t) => getTypeString(t)))\n    const typeString = reduce(typeNames, (sum, t) => sum + \" | \" + t)\n    return \"(\" + typeString + \")\"\n  } else {\n    return getTypeString(type)\n  }\n}\n\nfunction getTypeString(type: TokenArrayType | RuleArrayType) {\n  if (type.kind === \"token\") {\n    return \"IToken\"\n  }\n  return getNodeInterfaceName(type.name)\n}\n\nfunction getNodeInterfaceName(ruleName: string) {\n  return upperFirst(ruleName) + \"CstNode\"\n}\n\nfunction getNodeChildrenTypeName(ruleName: string) {\n  return upperFirst(ruleName) + \"CstChildren\"\n}\n", "import { Rule, GenerateDtsOptions } from \"@chevrotain/types\"\nimport { buildModel } from \"./model\"\nimport { genDts } from \"./generate\"\n\nconst defaultOptions: Required<GenerateDtsOptions> = {\n  includeVisitorInterface: true,\n  visitorInterfaceName: \"ICstNodeVisitor\"\n}\n\nexport function generateCstDts(\n  productions: Record<string, Rule>,\n  options?: GenerateDtsOptions\n): string {\n  const effectiveOptions = {\n    ...defaultOptions,\n    ...options\n  }\n\n  const model = buildModel(productions)\n\n  return genDts(model, effectiveOptions)\n}\n", "import { VERSION } from \"../version\"\nimport { ISerializedGast } from \"@chevrotain/types\"\n\nexport function createSyntaxDiagramsCode(\n  grammar: ISerializedGast[],\n  {\n    resourceBase = `https://unpkg.com/chevrotain@${VERSION}/diagrams/`,\n    css = `https://unpkg.com/chevrotain@${VERSION}/diagrams/diagrams.css`\n  }: {\n    resourceBase?: string\n    css?: string\n  } = {}\n) {\n  const header = `\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n`\n  const cssHtml = `\n<link rel='stylesheet' href='${css}'>\n`\n\n  const scripts = `\n<script src='${resourceBase}vendor/railroad-diagrams.js'></script>\n<script src='${resourceBase}src/diagrams_builder.js'></script>\n<script src='${resourceBase}src/diagrams_behavior.js'></script>\n<script src='${resourceBase}src/main.js'></script>\n`\n  const diagramsDiv = `\n<div id=\"diagrams\" align=\"center\"></div>    \n`\n  const serializedGrammar = `\n<script>\n    window.serializedGrammar = ${JSON.stringify(grammar, null, \"  \")};\n</script>\n`\n\n  const initLogic = `\n<script>\n    var diagramsDiv = document.getElementById(\"diagrams\");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n`\n  return (\n    header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic\n  )\n}\n", "/* istanbul ignore file - tricky to import some things from this module during testing */\n\n// semantic version\nexport { VERSION } from \"./version\"\n\nexport {\n  CstParser,\n  EmbeddedActionsParser,\n  ParserDefinitionErrorType,\n  EMPTY_ALT\n} from \"./parse/parser/parser\"\n\nexport { Lexer, LexerDefinitionErrorType } from \"./scan/lexer_public\"\n\n// Tokens utilities\nexport {\n  createToken,\n  createTokenInstance,\n  EOF,\n  tokenLabel,\n  tokenMatcher,\n  tokenName\n} from \"./scan/tokens_public\"\n\n// Lookahead\n\nexport { getLookaheadPaths } from \"./parse/grammar/lookahead\"\n\nexport { LLkLookaheadStrategy } from \"./parse/grammar/llk_lookahead\"\n\n// Other Utilities\n\nexport { defaultParserErrorProvider } from \"./parse/errors_public\"\n\nexport {\n  EarlyExitException,\n  isRecognitionException,\n  MismatchedTokenException,\n  NotAllInputParsedException,\n  NoViableAltException\n} from \"./parse/exceptions_public\"\n\nexport { defaultLexerErrorProvider } from \"./scan/lexer_errors_public\"\n\n// grammar reflection API\nexport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Rule,\n  Terminal\n} from \"@chevrotain/gast\"\n\n// GAST Utilities\n\nexport {\n  serializeGrammar,\n  serializeProduction,\n  GAstVisitor\n} from \"@chevrotain/gast\"\n\nexport { generateCstDts } from \"@chevrotain/cst-dts-gen\"\n\n/* istanbul ignore next */\nexport function clearCache() {\n  console.warn(\n    \"The clearCache function was 'soft' removed from the Chevrotain API.\" +\n      \"\\n\\t It performs no action other than printing this message.\" +\n      \"\\n\\t Please avoid using it as it will be completely removed in the future\"\n  )\n}\n\nexport { createSyntaxDiagramsCode } from \"./diagrams/render_public\"\n\nexport class Parser {\n  constructor() {\n    throw new Error(\n      \"The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.\\t\\n\" +\n        \"See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0\"\n    )\n  }\n}\n", "import { ActiveEvents, ColliderDesc, EventQueue, RigidBodyDesc } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport React, { useRef, useEffect, memo, useMemo, useContext, useState, createContext, useCallback, forwardRef, Fragment } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, BufferAttribute, MathUtils, DynamicDrawUsage } from 'three';\nimport { useAsset } from 'use-asset';\nimport { mergeVertices } from 'three-stdlib';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nnew Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst tupleToObject = (tuple, keys) => {\n  return keys.reduce((obj, key, i) => {\n    obj[key] = tuple[i];\n    return obj;\n  }, {});\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n\n  if (Array.isArray(v)) {\n    return v;\n  }\n\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = useRef();\n\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n\n  return ref.current.value;\n}\n\nconst useRaf = callback => {\n  const cb = useRef(callback);\n  const raf = useRef(0);\n  const lastFrame = useRef(0);\n  useEffect(() => {\n    cb.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\n\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  useFrame((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\n\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\n\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/React.createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/React.createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\n\nvar FrameStepper$1 = /*#__PURE__*/memo(FrameStepper);\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice(); // Heightfield uses a vector\n\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  } // Trimesh and convex scale the vertices\n\n\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  } // Prepfill with some extra\n\n\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale); // @ts-ignore\n\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\n\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setDensity(options.density);\n    return;\n  }\n\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setMass(options.mass);\n    return;\n  }\n\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\n\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n\n  if (state) {\n    var _state$worldParent;\n\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n\n    _matrix4.copy(state.object.matrixWorld);\n\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n\n    _matrix4.decompose(_position, _rotation, _scale);\n\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider, // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    }); // handle mass separately, because the assignments\n    // are exclusive.\n\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\n\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\n\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n\n      childColliderProps.push(colliderProps);\n    }\n  };\n\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    const collider = getCollider();\n\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n\n  return rest;\n};\n\nconst useMutableCallback = fn => {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n}; // External hooks\n\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\n\n\nconst useRapier = () => {\n  return useContext(rapierContext);\n};\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\n\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\n\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n}; // Internal hooks\n\n/**\n * @internal\n */\n\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\n\nconst Debug = /*#__PURE__*/memo(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    mesh.geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    mesh.geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n\n      return Reflect.get(instance, prop);\n    },\n\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n\n      return Reflect.set(instance, prop, value);\n    }\n\n  };\n  const proxy = new Proxy({}, handler);\n\n  const reset = () => {\n    instance = undefined;\n  };\n  /**\n   * Return the proxy and a reset function\n   */\n\n\n  return {\n    proxy,\n    reset\n  };\n};\n\nconst rapierContext = /*#__PURE__*/createContext(undefined);\n\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\n\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    maxStabilizationIterations = 1,\n    maxVelocityFrictionIterations = 8,\n    maxVelocityIterations = 4,\n    predictionDistance = 0.002,\n    erp = 0.8\n  } = props;\n  const rapier = useAsset(importRapier);\n  const {\n    invalidate\n  } = useThree();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  useEffect(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []); // Update mutable props\n\n  useEffect(() => {\n    worldProxy.gravity = vectorArrayToVector3(gravity);\n    worldProxy.integrationParameters.maxStabilizationIterations = maxStabilizationIterations;\n    worldProxy.integrationParameters.maxVelocityFrictionIterations = maxVelocityFrictionIterations;\n    worldProxy.integrationParameters.maxVelocityIterations = maxVelocityIterations;\n    worldProxy.integrationParameters.predictionDistance = predictionDistance;\n    worldProxy.integrationParameters.erp = erp;\n  }, [worldProxy, ...gravity, maxStabilizationIterations, maxVelocityIterations, maxVelocityFrictionIterations, predictionDistance, erp]);\n  const getSourceFromColliderHandle = useCallback(handle => {\n    var _collider$parent;\n\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = useCallback(dt => {\n    const world = worldProxy;\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n\n    const timeStepVariable = timeStep === \"vary\";\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.5);\n\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue); // Trigger afterStep callbacks\n\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep; // Update meshes\n\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n\n        state.isSleeping = rigidBody.isSleeping();\n      }\n\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      } // New states\n\n\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale); // Apply previous tick position\n\n\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      } // Get new position\n\n\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n          /* Collider events */\n\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      } // Sensor Intersections\n\n\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2()); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = useMemo(() => ({\n    rapier,\n    world: worldProxy,\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = useCallback(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/React.createElement(Debug, null), children);\n};\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\n * Initiate an instance and return a safe getter\n */\n\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = useRef();\n  const getInstance = useCallback(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n\n    return ref.current;\n  }, dependencyList);\n  useEffect(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n\n    const destroy = () => destroyFn(instance);\n\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\n\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Vector3(x, y, z);\n};\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\n\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new Quaternion(x, y, z, w);\n};\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\n\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Euler(x, y, z);\n};\n\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = useRef(defaultValue); // Update the forwarded ref when the inner ref changes\n\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n\n    return forwardedRef;\n  }\n\n  return innerRef;\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(forwardedRef);\n  const objectRef = useRef(null); // We spread the props out here to make sure that the ref is updated when the props change.\n\n  const immutablePropArray = immutableColliderOptions.flatMap(key => Array.isArray(props[key]) ? [...props[key]] : props[key]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n\n    if (typeof forwardedRef == \"function\") {\n      forwardedRef(collider);\n    }\n\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  useEffect(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n}));\n\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\n\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type); // Apply immutable options\n\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n\n  const state = states.get(rigidBody.handle);\n\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\nconst _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\n\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    type,\n    position,\n    rotation,\n    scale,\n    quaternion,\n    transformState\n  } = props,\n        objectProps = _objectWithoutProperties(props, _excluded$1);\n\n  const objectRef = useRef(null);\n  const rigidBodyRef = useForwardedRef(forwardedRef);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions); // Provide a way to eagerly create rigidbody\n\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n\n    if (typeof forwardedRef === \"function\") {\n      forwardedRef(rigidBody);\n    }\n\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray); // Only provide a object state after the ref has been set\n\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n}));\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\n\nconst _excluded = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const rigidBodiesRef = useForwardedRef(forwardedRef, []);\n  const objectRef = useRef(null);\n  const instanceWrapperRef = useRef(null);\n\n  const {\n    // instanced props\n    children,\n    instances,\n    colliderNodes = [],\n    // wrapper object props\n    position,\n    rotation,\n    quaternion,\n    scale\n  } = props,\n        rigidBodyProps = _objectWithoutProperties(props, _excluded);\n\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n\n    return undefined;\n  };\n\n  useEffect(() => {\n    const instancedMesh = getInstancedMesh();\n\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []); // Update the RigidBodyStates whenever the instances change\n\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n\n    return state;\n  };\n\n  return /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/React.createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => rigidBodiesRef.current[index] = body,\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/React.createElement(React.Fragment, null, colliderNodes.map((node, index) => /*#__PURE__*/React.createElement(Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n}));\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\n\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef();\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\n\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vectorArrayToVector3(body1Anchor), tupleToObject(body1LocalFrame, [\"x\", \"y\", \"z\", \"w\"]), vectorArrayToVector3(body2Anchor), tupleToObject(body2LocalFrame, [\"x\", \"y\", \"z\", \"w\"])));\n};\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor)));\n};\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis));\n\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n\n  return useImpulseJoint(body1, body2, params);\n};\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis));\n\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\n\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundConeCollider, RoundCuboidCollider, RoundCylinderCollider, TrimeshCollider, euler, interactionGroups, quat, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useSphericalJoint, vec3 };\n", "import deepEqual from 'fast-deep-equal';\n\nconst globalCache = [];\n\nfunction handleAsset(fn, cache, args, lifespan = 0, preload = false) {\n  for (const entry of cache) {\n    // Find a match\n    if (deepEqual(args, entry.args)) {\n      // If we're pre-loading and the element is present, just return\n      if (preload) return; // If an error occurred, throw\n\n      if (entry.error) throw entry.error; // If a response was successful, return\n\n      if (entry.response) return entry.response; // If the promise is still unresolved, throw\n\n      throw entry.promise;\n    }\n  } // The request is new or has changed.\n\n\n  const entry = {\n    args,\n    promise: // Make the promise request.\n    fn(...args) // Response can't be undefined or else the loop above wouldn't be able to return it\n    // This is for promises that do not return results (delays for instance)\n    .then(response => entry.response = response != null ? response : true).catch(e => entry.error = e != null ? e : 'unknown error').then(() => {\n      if (lifespan > 0) {\n        setTimeout(() => {\n          const index = cache.indexOf(entry);\n          if (index !== -1) cache.splice(index, 1);\n        }, lifespan);\n      }\n    })\n  };\n  cache.push(entry);\n  if (!preload) throw entry.promise;\n}\n\nfunction clear(cache, ...args) {\n  if (args === undefined || args.length === 0) cache.splice(0, cache.length);else {\n    const entry = cache.find(entry => deepEqual(args, entry.args));\n\n    if (entry) {\n      const index = cache.indexOf(entry);\n      if (index !== -1) cache.splice(index, 1);\n    }\n  }\n}\n\nfunction createAsset(fn, lifespan = 0) {\n  const cache = [];\n  return {\n    /**\n     * @throws Suspense Promise if asset is not yet ready\n     * @throws Error if the promise rejected for some reason\n     */\n    read: (...args) => handleAsset(fn, cache, args, lifespan),\n    preload: (...args) => void handleAsset(fn, cache, args, lifespan, true),\n    clear: (...args) => clear(cache, ...args),\n    peek: (...args) => {\n      var _cache$find;\n\n      return (_cache$find = cache.find(entry => deepEqual(args, entry.args))) == null ? void 0 : _cache$find.response;\n    }\n  };\n}\n\nfunction useAsset(fn, ...args) {\n  return handleAsset(fn, globalCache, args, useAsset.lifespan);\n}\n\nuseAsset.lifespan = 0;\n\nuseAsset.clear = (...args) => clear(globalCache, ...args);\n\nuseAsset.preload = (fn, ...args) => void handleAsset(fn, globalCache, args, useAsset.lifespan, true);\n\nuseAsset.peek = (...args) => {\n  var _globalCache$find;\n\n  return (_globalCache$find = globalCache.find(entry => deepEqual(args, entry.args))) == null ? void 0 : _globalCache$find.response;\n};\n\nexport { createAsset, useAsset };\n", "import { Mesh, MathUtils } from 'three';\n\nvar MorphBlendMesh = function (geometry, material) {\n  Mesh.call(this, geometry, material);\n  this.animationsMap = {};\n  this.animationsList = []; // prepare default animation\n  // (all frames played together in 1 second)\n\n  var numFrames = Object.keys(this.morphTargetDictionary).length;\n  var name = '__default';\n  var startFrame = 0;\n  var endFrame = numFrames - 1;\n  var fps = numFrames / 1;\n  this.createAnimation(name, startFrame, endFrame, fps);\n  this.setAnimationWeight(name, 1);\n};\n\nMorphBlendMesh.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: MorphBlendMesh,\n  createAnimation: function (name, start, end, fps) {\n    var animation = {\n      start: start,\n      end: end,\n      length: end - start + 1,\n      fps: fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  },\n  autoCreateAnimations: function (fps) {\n    var pattern = /([a-z]+)_?(\\d+)/i;\n    var firstAnimation,\n        frameRanges = {};\n    var i = 0;\n\n    for (let key in this.morphTargetDictionary) {\n      var chunks = key.match(pattern);\n\n      if (chunks && chunks.length > 1) {\n        var name = chunks[1];\n        if (!frameRanges[name]) frameRanges[name] = {\n          start: Infinity,\n          end: -Infinity\n        };\n        var range = frameRanges[name];\n        if (i < range.start) range.start = i;\n        if (i > range.end) range.end = i;\n        if (!firstAnimation) firstAnimation = name;\n      }\n\n      i++;\n    }\n\n    for (let name in frameRanges) {\n      var range = frameRanges[name];\n      this.createAnimation(name, range.start, range.end, fps);\n    }\n\n    this.firstAnimation = firstAnimation;\n  },\n  setAnimationDirectionForward: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  },\n  setAnimationDirectionBackward: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  },\n  setAnimationFPS: function (name, fps) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  },\n  setAnimationDuration: function (name, duration) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  },\n  setAnimationWeight: function (name, weight) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.weight = weight;\n    }\n  },\n  setAnimationTime: function (name, time) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = time;\n    }\n  },\n  getAnimationTime: function (name) {\n    var time = 0;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      time = animation.time;\n    }\n\n    return time;\n  },\n  getAnimationDuration: function (name) {\n    var duration = -1;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      duration = animation.duration;\n    }\n\n    return duration;\n  },\n  playAnimation: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\n    }\n  },\n  stopAnimation: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.active = false;\n    }\n  },\n  update: function (delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      var animation = this.animationsList[i];\n      if (!animation.active) continue;\n      var frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0) animation.time += animation.duration;\n      }\n\n      var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      var weight = animation.weight;\n\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n\n      var mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards) mix = 1 - mix;\n\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n});\n\nexport { MorphBlendMesh };\n", "import { Vector3, Line3, Plane, Triangle } from 'three';\n\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nconst Visible = 0;\nconst Deleted = 1;\n\nconst _v1 = new Vector3();\n\nconst _line3 = new Line3();\n\nconst _plane = new Plane();\n\nconst _closestPoint = new Vector3();\n\nconst _triangle = new Triangle();\n\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1;\n    this.faces = []; // the generated faces of the convex hull\n\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\n  }\n\n  setFromPoints(points) {\n    // The algorithm needs at least four points.\n    if (points.length >= 4) {\n      this.makeEmpty();\n\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n\n      this.compute();\n    }\n\n    return this;\n  }\n\n  setFromObject(object) {\n    const points = [];\n    object.updateMatrixWorld(true);\n    object.traverse(function (node) {\n      const geometry = node.geometry;\n\n      if (geometry !== undefined) {\n        if (geometry.isGeometry) {\n          console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');\n          return;\n        } else if (geometry.isBufferGeometry) {\n          const attribute = geometry.attributes.position;\n\n          if (attribute !== undefined) {\n            for (let i = 0, l = attribute.count; i < l; i++) {\n              const point = new Vector3();\n              point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n              points.push(point);\n            }\n          }\n        }\n      }\n    });\n    return this.setFromPoints(points);\n  }\n\n  containsPoint(point) {\n    const faces = this.faces;\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]; // compute signed distance and check on what half space the point lies\n\n      if (face.distanceToPoint(point) > this.tolerance) return false;\n    }\n\n    return true;\n  }\n\n  intersectRay(ray, target) {\n    // based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n    const faces = this.faces;\n    let tNear = -Infinity;\n    let tFar = Infinity;\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]; // interpret faces as planes for the further computation\n\n      const vN = face.distanceToPoint(ray.origin);\n      const vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n      // the ray is turned away or parallel to the plane, there is no intersection\n\n      if (vN > 0 && vD >= 0) return null; // compute the distance from the ray’s origin to the intersection with the plane\n\n      const t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point\n      // lies \"behind\" the origin\n\n      if (t <= 0) continue; // now categorized plane as front-facing or back-facing\n\n      if (vD > 0) {\n        //  plane faces away from the ray, so this plane is a back-face\n        tFar = Math.min(t, tFar);\n      } else {\n        // front-face\n        tNear = Math.max(t, tNear);\n      }\n\n      if (tNear > tFar) {\n        // if tNear ever is greater than tFar, the ray must miss the convex hull\n        return null;\n      }\n    } // evaluate intersection point\n    // always try tNear first since its the closer intersection point\n\n\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target);\n    } else {\n      ray.at(tFar, target);\n    }\n\n    return target;\n  }\n\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null;\n  }\n\n  makeEmpty() {\n    this.faces = [];\n    this.vertices = [];\n    return this;\n  } // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n\n  addVertexToFace(vertex, face) {\n    vertex.face = face;\n\n    if (face.outside === null) {\n      this.assigned.append(vertex);\n    } else {\n      this.assigned.insertBefore(face.outside, vertex);\n    }\n\n    face.outside = vertex;\n    return this;\n  } // Removes a vertex from the 'assigned' list of vertices and from the given face\n\n\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      // fix face.outside link\n      if (vertex.next !== null && vertex.next.face === face) {\n        // face has at least 2 outside vertices, move the 'outside' reference\n        face.outside = vertex.next;\n      } else {\n        // vertex was the only outside vertex that face had\n        face.outside = null;\n      }\n    }\n\n    this.assigned.remove(vertex);\n    return this;\n  } // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n\n\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      // reference to the first and last vertex of this face\n      const start = face.outside;\n      let end = face.outside;\n\n      while (end.next !== null && end.next.face === face) {\n        end = end.next;\n      }\n\n      this.assigned.removeSubList(start, end); // fix references\n\n      start.prev = end.next = null;\n      face.outside = null;\n      return start;\n    }\n  } // Removes all the visible vertices that 'face' is able to see\n\n\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face);\n\n    if (faceVertices !== undefined) {\n      if (absorbingFace === undefined) {\n        // mark the vertices to be reassigned to some other face\n        this.unassigned.appendChain(faceVertices);\n      } else {\n        // if there's an absorbing face try to assign as many vertices as possible to it\n        let vertex = faceVertices;\n\n        do {\n          // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n          // will be changed by upcoming method calls\n          const nextVertex = vertex.next;\n          const distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'\n\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace);\n          } else {\n            this.unassigned.append(vertex);\n          } // now assign next vertex\n\n\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n    }\n\n    return this;\n  } // Reassigns as many vertices as possible from the unassigned list to the new faces\n\n\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first();\n\n      do {\n        // buffer 'next' reference, see .deleteFaceVertices()\n        const nextVertex = vertex.next;\n        let maxDistance = this.tolerance;\n        let maxFace = null;\n\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i];\n\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point);\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              maxFace = face;\n            }\n\n            if (maxDistance > 1000 * this.tolerance) break;\n          }\n        } // 'maxFace' can be null e.g. if there are identical vertices\n\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n\n        vertex = nextVertex;\n      } while (vertex !== null);\n    }\n\n    return this;\n  } // Computes the extremes of a simplex which will be the initial hull\n\n\n  computeExtremes() {\n    const min = new Vector3();\n    const max = new Vector3();\n    const minVertices = [];\n    const maxVertices = []; // initially assume that the first vertex is the min/max\n\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0];\n    }\n\n    min.copy(this.vertices[0].point);\n    max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i];\n      const point = vertex.point; // update the min coordinates\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j));\n          minVertices[j] = vertex;\n        }\n      } // update the max coordinates\n\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j));\n          maxVertices[j] = vertex;\n        }\n      }\n    } // use min/max vectors to compute an optimal epsilon\n\n\n    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n    return {\n      min: minVertices,\n      max: maxVertices\n    };\n  } // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n\n\n  computeInitialHull() {\n    const vertices = this.vertices;\n    const extremes = this.computeExtremes();\n    const min = extremes.min;\n    const max = extremes.max; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n    // (max.x - min.x)\n    // (max.y - min.y)\n    // (max.z - min.z)\n\n    let maxDistance = 0;\n    let index = 0;\n\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        index = i;\n      }\n    }\n\n    const v0 = min[index];\n    const v1 = max[index];\n    let v2;\n    let v3; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n    maxDistance = 0;\n\n    _line3.set(v0.point, v1.point);\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n\n        const distance = _closestPoint.distanceToSquared(vertex.point);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v2 = vertex;\n        }\n      }\n    } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\n    maxDistance = -1;\n\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point));\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          v3 = vertex;\n        }\n      }\n    }\n\n    const faces = [];\n\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n      }\n    } else {\n      // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3)); // join face[ i ] with face[ i + 1 ]\n\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n      }\n    } // the initial hull is the tetrahedron\n\n\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i]);\n    } // initial assignment of vertices to the faces of the tetrahedron\n\n\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i];\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance;\n        let maxFace = null;\n\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            maxFace = this.faces[j];\n          }\n        }\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace);\n        }\n      }\n    }\n\n    return this;\n  } // Removes inactive faces\n\n\n  reindexFaces() {\n    const activeFaces = [];\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n\n      if (face.mark === Visible) {\n        activeFaces.push(face);\n      }\n    }\n\n    this.faces = activeFaces;\n    return this;\n  } // Finds the next vertex to create faces with the current hull\n\n\n  nextVertexToAdd() {\n    // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex,\n          maxDistance = 0; // grap the first available face and start with the first visible vertex of that face\n\n      const eyeFace = this.assigned.first().face;\n      let vertex = eyeFace.outside; // now calculate the farthest vertex that face can see\n\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          eyeVertex = vertex;\n        }\n\n        vertex = vertex.next;\n      } while (vertex !== null && vertex.face === eyeFace);\n\n      return eyeVertex;\n    }\n  } // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n\n\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    // moves face's vertices to the 'unassigned' vertex list\n    this.deleteFaceVertices(face);\n    face.mark = Deleted;\n    let edge;\n\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0);\n    } else {\n      // start from the next edge since 'crossEdge' was already analyzed\n      // (actually 'crossEdge.twin' was the edge who called this method recursively)\n      edge = crossEdge.next;\n    }\n\n    do {\n      const twinEdge = edge.twin;\n      const oppositeFace = twinEdge.face;\n\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          // the opposite face can see the vertex, so proceed with next edge\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n        } else {\n          // the opposite face can't see the vertex, so this edge is part of the horizon\n          horizon.push(edge);\n        }\n      }\n\n      edge = edge.next;\n    } while (edge !== crossEdge);\n\n    return this;\n  } // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    // all the half edges are created in ccw order thus the face is always pointing outside the hull\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n    this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n    face.getEdge(-1).setTwin(horizonEdge.twin);\n    return face.getEdge(0); // the half edge whose vertex is the eyeVertex\n  } //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n\n\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = [];\n    let firstSideEdge = null;\n    let previousSideEdge = null;\n\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i]; // returns the right side edge\n\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge;\n      } else {\n        // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n        sideEdge.next.setTwin(previousSideEdge);\n      }\n\n      this.newFaces.push(sideEdge.face);\n      previousSideEdge = sideEdge;\n    } // perform final join of new faces\n\n\n    firstSideEdge.next.setTwin(previousSideEdge);\n    return this;\n  } // Adds a vertex to the hull\n\n\n  addVertexToHull(eyeVertex) {\n    const horizon = [];\n    this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n    this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces\n\n    this.resolveUnassignedPoints(this.newFaces);\n    return this;\n  }\n\n  cleanup() {\n    this.assigned.clear();\n    this.unassigned.clear();\n    this.newFaces = [];\n    return this;\n  }\n\n  compute() {\n    let vertex;\n    this.computeInitialHull(); // add all available vertices gradually to the hull\n\n    while ((vertex = this.nextVertexToAdd()) !== undefined) {\n      this.addVertexToHull(vertex);\n    }\n\n    this.reindexFaces();\n    this.cleanup();\n    return this;\n  }\n\n} //\n\n\nclass Face {\n  constructor() {\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0; // signed distance from face to the origin\n\n    this.outside = null; // reference to a vertex in a vertex list this face can see\n\n    this.mark = Visible;\n    this.edge = null;\n  }\n\n  static create(a, b, c) {\n    const face = new Face();\n    const e0 = new HalfEdge(a, face);\n    const e1 = new HalfEdge(b, face);\n    const e2 = new HalfEdge(c, face); // join edges\n\n    e0.next = e2.prev = e1;\n    e1.next = e0.prev = e2;\n    e2.next = e1.prev = e0; // main half edge reference\n\n    face.edge = e0;\n    return face.compute();\n  }\n\n  getEdge(i) {\n    let edge = this.edge;\n\n    while (i > 0) {\n      edge = edge.next;\n      i--;\n    }\n\n    while (i < 0) {\n      edge = edge.prev;\n      i++;\n    }\n\n    return edge;\n  }\n\n  compute() {\n    const a = this.edge.tail();\n    const b = this.edge.head();\n    const c = this.edge.next.head();\n\n    _triangle.set(a.point, b.point, c.point);\n\n    _triangle.getNormal(this.normal);\n\n    _triangle.getMidpoint(this.midpoint);\n\n    this.area = _triangle.getArea();\n    this.constant = this.normal.dot(this.midpoint);\n    return this;\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant;\n  }\n\n} // Entity for a Doubly-Connected Edge List (DCEL).\n\n\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n\n  head() {\n    return this.vertex;\n  }\n\n  tail() {\n    return this.prev ? this.prev.vertex : null;\n  }\n\n  length() {\n    const head = this.head();\n    const tail = this.tail();\n\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point);\n    }\n\n    return -1;\n  }\n\n  lengthSquared() {\n    const head = this.head();\n    const tail = this.tail();\n\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point);\n    }\n\n    return -1;\n  }\n\n  setTwin(edge) {\n    this.twin = edge;\n    edge.twin = this;\n    return this;\n  }\n\n} // A vertex as a double linked list node.\n\n\nclass VertexNode {\n  constructor(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null; // the face that is able to see this vertex\n  }\n\n} // A double linked list that contains vertex nodes.\n\n\nclass VertexList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  first() {\n    return this.head;\n  }\n\n  last() {\n    return this.tail;\n  }\n\n  clear() {\n    this.head = this.tail = null;\n    return this;\n  } // Inserts a vertex before the target vertex\n\n\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev;\n    vertex.next = target;\n\n    if (vertex.prev === null) {\n      this.head = vertex;\n    } else {\n      vertex.prev.next = vertex;\n    }\n\n    target.prev = vertex;\n    return this;\n  } // Inserts a vertex after the target vertex\n\n\n  insertAfter(target, vertex) {\n    vertex.prev = target;\n    vertex.next = target.next;\n\n    if (vertex.next === null) {\n      this.tail = vertex;\n    } else {\n      vertex.next.prev = vertex;\n    }\n\n    target.next = vertex;\n    return this;\n  } // Appends a vertex to the end of the linked list\n\n\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n\n    vertex.prev = this.tail;\n    vertex.next = null; // the tail has no subsequent vertex\n\n    this.tail = vertex;\n    return this;\n  } // Appends a chain of vertices where 'vertex' is the head.\n\n\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex;\n    } else {\n      this.tail.next = vertex;\n    }\n\n    vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain\n\n    while (vertex.next !== null) {\n      vertex = vertex.next;\n    }\n\n    this.tail = vertex;\n    return this;\n  } // Removes a vertex from the linked list\n\n\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next;\n    } else {\n      vertex.prev.next = vertex.next;\n    }\n\n    if (vertex.next === null) {\n      this.tail = vertex.prev;\n    } else {\n      vertex.next.prev = vertex.prev;\n    }\n\n    return this;\n  } // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next;\n    } else {\n      a.prev.next = b.next;\n    }\n\n    if (b.next === null) {\n      this.tail = a.prev;\n    } else {\n      b.next.prev = a.prev;\n    }\n\n    return this;\n  }\n\n  isEmpty() {\n    return this.head === null;\n  }\n\n}\n\nexport { ConvexHull };\n", "import { BufferGeometry, Float32BufferAttribute } from 'three';\nimport { ConvexHull } from '../math/ConvexHull.js';\n\nclass ConvexGeometry extends BufferGeometry {\n  constructor(points = []) {\n    super(); // buffers\n\n    const vertices = [];\n    const normals = [];\n\n    if (ConvexHull === undefined) {\n      console.error('THREE.ConvexGeometry: ConvexGeometry relies on ConvexHull');\n    }\n\n    const convexHull = new ConvexHull().setFromPoints(points); // generate vertices and normals\n\n    const faces = convexHull.faces;\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      let edge = face.edge; // we move along a doubly-connected edge list to access all face points (see HalfEdge docs)\n\n      do {\n        const point = edge.head().point;\n        vertices.push(point.x, point.y, point.z);\n        normals.push(face.normal.x, face.normal.y, face.normal.z);\n        edge = edge.next;\n      } while (edge !== face.edge);\n    } // build geometry\n\n\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  }\n\n}\n\nexport { ConvexGeometry };\n", "import { Line3, Plane, Vector3, Mesh } from 'three';\nimport { ConvexGeometry } from '../geometries/ConvexGeometry.js';\n\n/**\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\n *\n * Usage:\n *\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\n *\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\n *\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\n *\n * Requisites for the object:\n *\n *  - Mesh object must have a BufferGeometry (not Geometry) and a Material\n *\n *  - Vertex normals must be planar (not smoothed)\n *\n *  - The geometry must be convex (this is not checked in the library). You can create convex\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\n *  can also be used.\n *\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\n * Use with caution and read the code when using with other libs.\n *\n * @param {double} minSizeForBreak Min size a debris can have to break.\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\n *\n */\n\nvar ConvexObjectBreaker = function (minSizeForBreak, smallDelta) {\n  this.minSizeForBreak = minSizeForBreak || 1.4;\n  this.smallDelta = smallDelta || 0.0001;\n  this.tempLine1 = new Line3();\n  this.tempPlane1 = new Plane();\n  this.tempPlane2 = new Plane();\n  this.tempPlane_Cut = new Plane();\n  this.tempCM1 = new Vector3();\n  this.tempCM2 = new Vector3();\n  this.tempVector3 = new Vector3();\n  this.tempVector3_2 = new Vector3();\n  this.tempVector3_3 = new Vector3();\n  this.tempVector3_P0 = new Vector3();\n  this.tempVector3_P1 = new Vector3();\n  this.tempVector3_P2 = new Vector3();\n  this.tempVector3_N0 = new Vector3();\n  this.tempVector3_N1 = new Vector3();\n  this.tempVector3_AB = new Vector3();\n  this.tempVector3_CB = new Vector3();\n  this.tempResultObjects = {\n    object1: null,\n    object2: null\n  };\n  this.segments = [];\n  var n = 30 * 30;\n\n  for (let i = 0; i < n; i++) this.segments[i] = false;\n};\n\nConvexObjectBreaker.prototype = {\n  constructor: ConvexObjectBreaker,\n  prepareBreakableObject: function (object, mass, velocity, angularVelocity, breakable) {\n    // object is a Object3d (normally a Mesh), must have a BufferGeometry, and it must be convex.\n    // Its material property is propagated to its children (sub-pieces)\n    // mass must be > 0\n    if (!object.geometry.isBufferGeometry) {\n      console.error('THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.');\n    }\n\n    var userData = object.userData;\n    userData.mass = mass;\n    userData.velocity = velocity.clone();\n    userData.angularVelocity = angularVelocity.clone();\n    userData.breakable = breakable;\n  },\n\n  /*\n   * @param {int} maxRadialIterations Iterations for radial cuts.\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n   *\n   * Returns the array of pieces\n   */\n  subdivideByImpact: function (object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n    var debris = [];\n    var tempPlane1 = this.tempPlane1;\n    var tempPlane2 = this.tempPlane2;\n    this.tempVector3.addVectors(pointOfImpact, normal);\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\n    var maxTotalIterations = maxRandomIterations + maxRadialIterations;\n    var scope = this;\n\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n        debris.push(subObject);\n        return;\n      }\n\n      var angle = Math.PI;\n\n      if (numIterations === 0) {\n        tempPlane2.normal.copy(tempPlane1.normal);\n        tempPlane2.constant = tempPlane1.constant;\n      } else {\n        if (numIterations <= maxRadialIterations) {\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle; // Rotate tempPlane2 at impact point around normal axis and the angle\n\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\n        } else {\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI; // Rotate tempPlane2 at object position around normal axis and the angle\n\n          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\n          scope.tempVector3_3.copy(normal).add(subObject.position);\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\n        }\n      } // Perform the cut\n\n\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\n      var obj1 = scope.tempResultObjects.object1;\n      var obj2 = scope.tempResultObjects.object2;\n\n      if (obj1) {\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1);\n      }\n\n      if (obj2) {\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1);\n      }\n    }\n\n    subdivideRadial(object, 0, 2 * Math.PI, 0);\n    return debris;\n  },\n  cutByPlane: function (object, plane, output) {\n    // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n    // object2 can be null if the plane doesn't cut the object.\n    // object1 can be null only in case of internal error\n    // Returned value is number of pieces, 0 for error.\n    var geometry = object.geometry;\n    var coords = geometry.attributes.position.array;\n    var normals = geometry.attributes.normal.array;\n    var numPoints = coords.length / 3;\n    var numFaces = numPoints / 3;\n    var indices = geometry.getIndex();\n\n    if (indices) {\n      indices = indices.array;\n      numFaces = indices.length / 3;\n    }\n\n    function getVertexIndex(faceIdx, vert) {\n      // vert = 0, 1 or 2.\n      var idx = faceIdx * 3 + vert;\n      return indices ? indices[idx] : idx;\n    }\n\n    var points1 = [];\n    var points2 = [];\n    var delta = this.smallDelta; // Reset segments mark\n\n    var numPointPairs = numPoints * numPoints;\n\n    for (let i = 0; i < numPointPairs; i++) this.segments[i] = false;\n\n    var p0 = this.tempVector3_P0;\n    var p1 = this.tempVector3_P1;\n    var n0 = this.tempVector3_N0;\n    var n1 = this.tempVector3_N1; // Iterate through the faces to mark edges shared by coplanar faces\n\n    for (let i = 0; i < numFaces - 1; i++) {\n      var a1 = getVertexIndex(i, 0);\n      var b1 = getVertexIndex(i, 1);\n      var c1 = getVertexIndex(i, 2); // Assuming all 3 vertices have the same normal\n\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\n\n      for (let j = i + 1; j < numFaces; j++) {\n        var a2 = getVertexIndex(j, 0);\n        var b2 = getVertexIndex(j, 1);\n        var c2 = getVertexIndex(j, 2); // Assuming all 3 vertices have the same normal\n\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\n        var coplanar = 1 - n0.dot(n1) < delta;\n\n        if (coplanar) {\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[a1 * numPoints + b1] = true;\n              this.segments[b1 * numPoints + a1] = true;\n            } else {\n              this.segments[c1 * numPoints + a1] = true;\n              this.segments[a1 * numPoints + c1] = true;\n            }\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n            this.segments[c1 * numPoints + b1] = true;\n            this.segments[b1 * numPoints + c1] = true;\n          }\n        }\n      }\n    } // Transform the plane to object local space\n\n\n    var localPlane = this.tempPlane_Cut;\n    object.updateMatrix();\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane); // Iterate through the faces adding points to both pieces\n\n    for (let i = 0; i < numFaces; i++) {\n      var va = getVertexIndex(i, 0);\n      var vb = getVertexIndex(i, 1);\n      var vc = getVertexIndex(i, 2);\n\n      for (let segment = 0; segment < 3; segment++) {\n        var i0 = segment === 0 ? va : segment === 1 ? vb : vc;\n        var i1 = segment === 0 ? vb : segment === 1 ? vc : va;\n        var segmentState = this.segments[i0 * numPoints + i1];\n        if (segmentState) continue; // The segment already has been processed in another face\n        // Mark segment as processed (also inverted segment)\n\n        this.segments[i0 * numPoints + i1] = true;\n        this.segments[i1 * numPoints + i0] = true;\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]); // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\n        var mark0 = 0;\n        var d = localPlane.distanceToPoint(p0);\n\n        if (d > delta) {\n          mark0 = 2;\n          points2.push(p0.clone());\n        } else if (d < -delta) {\n          mark0 = 1;\n          points1.push(p0.clone());\n        } else {\n          mark0 = 3;\n          points1.push(p0.clone());\n          points2.push(p0.clone());\n        } // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\n\n        var mark1 = 0;\n        var d = localPlane.distanceToPoint(p1);\n\n        if (d > delta) {\n          mark1 = 2;\n          points2.push(p1.clone());\n        } else if (d < -delta) {\n          mark1 = 1;\n          points1.push(p1.clone());\n        } else {\n          mark1 = 3;\n          points1.push(p1.clone());\n          points2.push(p1.clone());\n        }\n\n        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\n          // Intersection of segment with the plane\n          this.tempLine1.start.copy(p0);\n          this.tempLine1.end.copy(p1);\n          var intersection = new Vector3();\n          intersection = localPlane.intersectLine(this.tempLine1, intersection);\n\n          if (intersection === undefined) {\n            // Shouldn't happen\n            console.error('Internal error: segment does not intersect plane.');\n            output.segmentedObject1 = null;\n            output.segmentedObject2 = null;\n            return 0;\n          }\n\n          points1.push(intersection);\n          points2.push(intersection.clone());\n        }\n      }\n    } // Calculate debris mass (very fast and imprecise):\n\n\n    var newMass = object.userData.mass * 0.5; // Calculate debris Center of Mass (again fast and imprecise)\n\n    this.tempCM1.set(0, 0, 0);\n    var radius1 = 0;\n    var numPoints1 = points1.length;\n\n    if (numPoints1 > 0) {\n      for (let i = 0; i < numPoints1; i++) this.tempCM1.add(points1[i]);\n\n      this.tempCM1.divideScalar(numPoints1);\n\n      for (let i = 0; i < numPoints1; i++) {\n        var p = points1[i];\n        p.sub(this.tempCM1);\n        radius1 = Math.max(radius1, p.x, p.y, p.z);\n      }\n\n      this.tempCM1.add(object.position);\n    }\n\n    this.tempCM2.set(0, 0, 0);\n    var radius2 = 0;\n    var numPoints2 = points2.length;\n\n    if (numPoints2 > 0) {\n      for (let i = 0; i < numPoints2; i++) this.tempCM2.add(points2[i]);\n\n      this.tempCM2.divideScalar(numPoints2);\n\n      for (let i = 0; i < numPoints2; i++) {\n        var p = points2[i];\n        p.sub(this.tempCM2);\n        radius2 = Math.max(radius2, p.x, p.y, p.z);\n      }\n\n      this.tempCM2.add(object.position);\n    }\n\n    var object1 = null;\n    var object2 = null;\n    var numObjects = 0;\n\n    if (numPoints1 > 4) {\n      object1 = new Mesh(new ConvexGeometry(points1), object.material);\n      object1.position.copy(this.tempCM1);\n      object1.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\n      numObjects++;\n    }\n\n    if (numPoints2 > 4) {\n      object2 = new Mesh(new ConvexGeometry(points2), object.material);\n      object2.position.copy(this.tempCM2);\n      object2.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\n      numObjects++;\n    }\n\n    output.object1 = object1;\n    output.object2 = object2;\n    return numObjects;\n  }\n};\n\nConvexObjectBreaker.transformFreeVector = function (v, m) {\n  // input:\n  // vector interpreted as a free vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n      y = v.y,\n      z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[4] * y + e[8] * z;\n  v.y = e[1] * x + e[5] * y + e[9] * z;\n  v.z = e[2] * x + e[6] * y + e[10] * z;\n  return v;\n};\n\nConvexObjectBreaker.transformFreeVectorInverse = function (v, m) {\n  // input:\n  // vector interpreted as a free vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n      y = v.y,\n      z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[1] * y + e[2] * z;\n  v.y = e[4] * x + e[5] * y + e[6] * z;\n  v.z = e[8] * x + e[9] * y + e[10] * z;\n  return v;\n};\n\nConvexObjectBreaker.transformTiedVectorInverse = function (v, m) {\n  // input:\n  // vector interpreted as a tied (ordinary) vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n      y = v.y,\n      z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\n  v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\n  v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\n  return v;\n};\n\nConvexObjectBreaker.transformPlaneToLocalSpace = function () {\n  var v1 = new Vector3();\n  return function transformPlaneToLocalSpace(plane, m, resultPlane) {\n    resultPlane.normal.copy(plane.normal);\n    resultPlane.constant = plane.constant;\n    var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v1), m);\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m); // recalculate constant (like in setFromNormalAndCoplanarPoint)\n\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal);\n  };\n}();\n\nexport { ConvexObjectBreaker };\n", "import { Object3D, Vector3, Quaternion } from 'three';\n\nvar Gyroscope = function () {\n  Object3D.call(this);\n};\n\nGyroscope.prototype = Object.create(Object3D.prototype);\nGyroscope.prototype.constructor = Gyroscope;\n\nGyroscope.prototype.updateMatrixWorld = function () {\n  var translationObject = new Vector3();\n  var quaternionObject = new Quaternion();\n  var scaleObject = new Vector3();\n  var translationWorld = new Vector3();\n  var quaternionWorld = new Quaternion();\n  var scaleWorld = new Vector3();\n  return function updateMatrixWorld(force) {\n    this.matrixAutoUpdate && this.updateMatrix(); // update matrixWorld\n\n    if (this.matrixWorldNeedsUpdate || force) {\n      if (this.parent !== null) {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n        this.matrixWorld.decompose(translationWorld, quaternionWorld, scaleWorld);\n        this.matrix.decompose(translationObject, quaternionObject, scaleObject);\n        this.matrixWorld.compose(translationWorld, quaternionObject, scaleWorld);\n      } else {\n        this.matrixWorld.copy(this.matrix);\n      }\n\n      this.matrixWorldNeedsUpdate = false;\n      force = true;\n    } // update children\n\n\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      this.children[i].updateMatrixWorld(force);\n    }\n  };\n}();\n\nexport { Gyroscope };\n", "import { Mesh, AnimationMixer, AnimationClip } from 'three';\n\nvar MorphAnimMesh = function (geometry, material) {\n  Mesh.call(this, geometry, material);\n  this.type = 'MorphAnimMesh';\n  this.mixer = new AnimationMixer(this);\n  this.activeAction = null;\n};\n\nMorphAnimMesh.prototype = Object.create(Mesh.prototype);\nMorphAnimMesh.prototype.constructor = MorphAnimMesh;\n\nMorphAnimMesh.prototype.setDirectionForward = function () {\n  this.mixer.timeScale = 1.0;\n};\n\nMorphAnimMesh.prototype.setDirectionBackward = function () {\n  this.mixer.timeScale = -1.0;\n};\n\nMorphAnimMesh.prototype.playAnimation = function (label, fps) {\n  if (this.activeAction) {\n    this.activeAction.stop();\n    this.activeAction = null;\n  }\n\n  var clip = AnimationClip.findByName(this, label);\n\n  if (clip) {\n    var action = this.mixer.clipAction(clip);\n    action.timeScale = clip.tracks.length * fps / clip.duration;\n    this.activeAction = action.play();\n  } else {\n    throw new Error('THREE.MorphAnimMesh: animations[' + label + '] undefined in .playAnimation()');\n  }\n};\n\nMorphAnimMesh.prototype.updateAnimation = function (delta) {\n  this.mixer.update(delta);\n};\n\nMorphAnimMesh.prototype.copy = function (source) {\n  Mesh.prototype.copy.call(this, source);\n  this.mixer = new AnimationMixer(this);\n  return this;\n};\n\nexport { MorphAnimMesh };\n", "import { BufferGeometry, Vector3, Quaternion, BufferAttribute, Raycaster } from 'three';\n\nvar RollerCoasterGeometry = function (curve, divisions) {\n  BufferGeometry.call(this);\n  var vertices = [];\n  var normals = [];\n  var colors = [];\n  var color1 = [1, 1, 1];\n  var color2 = [1, 1, 0];\n  var up = new Vector3(0, 1, 0);\n  var forward = new Vector3();\n  var right = new Vector3();\n  var quaternion = new Quaternion();\n  var prevQuaternion = new Quaternion();\n  prevQuaternion.setFromAxisAngle(up, Math.PI / 2);\n  var point = new Vector3();\n  var prevPoint = new Vector3();\n  prevPoint.copy(curve.getPointAt(0)); // shapes\n\n  var step = [new Vector3(-0.225, 0, 0), new Vector3(0, -0.05, 0), new Vector3(0, -0.175, 0), new Vector3(0, -0.05, 0), new Vector3(0.225, 0, 0), new Vector3(0, -0.175, 0)];\n  var PI2 = Math.PI * 2;\n  var sides = 5;\n  var tube1 = [];\n\n  for (let i = 0; i < sides; i++) {\n    var angle = i / sides * PI2;\n    tube1.push(new Vector3(Math.sin(angle) * 0.06, Math.cos(angle) * 0.06, 0));\n  }\n\n  var sides = 6;\n  var tube2 = [];\n\n  for (let i = 0; i < sides; i++) {\n    var angle = i / sides * PI2;\n    tube2.push(new Vector3(Math.sin(angle) * 0.025, Math.cos(angle) * 0.025, 0));\n  }\n\n  var vector = new Vector3();\n  var normal = new Vector3();\n\n  function drawShape(shape, color) {\n    normal.set(0, 0, -1).applyQuaternion(quaternion);\n\n    for (let j = 0; j < shape.length; j++) {\n      vector.copy(shape[j]);\n      vector.applyQuaternion(quaternion);\n      vector.add(point);\n      vertices.push(vector.x, vector.y, vector.z);\n      normals.push(normal.x, normal.y, normal.z);\n      colors.push(color[0], color[1], color[2]);\n    }\n\n    normal.set(0, 0, 1).applyQuaternion(quaternion);\n\n    for (let j = shape.length - 1; j >= 0; j--) {\n      vector.copy(shape[j]);\n      vector.applyQuaternion(quaternion);\n      vector.add(point);\n      vertices.push(vector.x, vector.y, vector.z);\n      normals.push(normal.x, normal.y, normal.z);\n      colors.push(color[0], color[1], color[2]);\n    }\n  }\n\n  var vector1 = new Vector3();\n  var vector2 = new Vector3();\n  var vector3 = new Vector3();\n  var vector4 = new Vector3();\n  var normal1 = new Vector3();\n  var normal2 = new Vector3();\n  var normal3 = new Vector3();\n  var normal4 = new Vector3();\n\n  function extrudeShape(shape, offset, color) {\n    for (let j = 0, jl = shape.length; j < jl; j++) {\n      var point1 = shape[j];\n      var point2 = shape[(j + 1) % jl];\n      vector1.copy(point1).add(offset);\n      vector1.applyQuaternion(quaternion);\n      vector1.add(point);\n      vector2.copy(point2).add(offset);\n      vector2.applyQuaternion(quaternion);\n      vector2.add(point);\n      vector3.copy(point2).add(offset);\n      vector3.applyQuaternion(prevQuaternion);\n      vector3.add(prevPoint);\n      vector4.copy(point1).add(offset);\n      vector4.applyQuaternion(prevQuaternion);\n      vector4.add(prevPoint);\n      vertices.push(vector1.x, vector1.y, vector1.z);\n      vertices.push(vector2.x, vector2.y, vector2.z);\n      vertices.push(vector4.x, vector4.y, vector4.z);\n      vertices.push(vector2.x, vector2.y, vector2.z);\n      vertices.push(vector3.x, vector3.y, vector3.z);\n      vertices.push(vector4.x, vector4.y, vector4.z); //\n\n      normal1.copy(point1);\n      normal1.applyQuaternion(quaternion);\n      normal1.normalize();\n      normal2.copy(point2);\n      normal2.applyQuaternion(quaternion);\n      normal2.normalize();\n      normal3.copy(point2);\n      normal3.applyQuaternion(prevQuaternion);\n      normal3.normalize();\n      normal4.copy(point1);\n      normal4.applyQuaternion(prevQuaternion);\n      normal4.normalize();\n      normals.push(normal1.x, normal1.y, normal1.z);\n      normals.push(normal2.x, normal2.y, normal2.z);\n      normals.push(normal4.x, normal4.y, normal4.z);\n      normals.push(normal2.x, normal2.y, normal2.z);\n      normals.push(normal3.x, normal3.y, normal3.z);\n      normals.push(normal4.x, normal4.y, normal4.z);\n      colors.push(color[0], color[1], color[2]);\n      colors.push(color[0], color[1], color[2]);\n      colors.push(color[0], color[1], color[2]);\n      colors.push(color[0], color[1], color[2]);\n      colors.push(color[0], color[1], color[2]);\n      colors.push(color[0], color[1], color[2]);\n    }\n  }\n\n  var offset = new Vector3();\n\n  for (let i = 1; i <= divisions; i++) {\n    point.copy(curve.getPointAt(i / divisions));\n    up.set(0, 1, 0);\n    forward.subVectors(point, prevPoint).normalize();\n    right.crossVectors(up, forward).normalize();\n    up.crossVectors(forward, right);\n    var angle = Math.atan2(forward.x, forward.z);\n    quaternion.setFromAxisAngle(up, angle);\n\n    if (i % 2 === 0) {\n      drawShape(step, color2);\n    }\n\n    extrudeShape(tube1, offset.set(0, -0.125, 0), color2);\n    extrudeShape(tube2, offset.set(0.2, 0, 0), color1);\n    extrudeShape(tube2, offset.set(-0.2, 0, 0), color1);\n    prevPoint.copy(point);\n    prevQuaternion.copy(quaternion);\n  } // console.log( vertices.length );\n\n\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\n  this.setAttribute('normal', new BufferAttribute(new Float32Array(normals), 3));\n  this.setAttribute('color', new BufferAttribute(new Float32Array(colors), 3));\n};\n\nRollerCoasterGeometry.prototype = Object.create(BufferGeometry.prototype);\n\nvar RollerCoasterLiftersGeometry = function (curve, divisions) {\n  BufferGeometry.call(this);\n  var vertices = [];\n  var normals = [];\n  var quaternion = new Quaternion();\n  var up = new Vector3(0, 1, 0);\n  var point = new Vector3();\n  var tangent = new Vector3(); // shapes\n\n  var tube1 = [new Vector3(0, 0.05, -0.05), new Vector3(0, 0.05, 0.05), new Vector3(0, -0.05, 0)];\n  var tube2 = [new Vector3(-0.05, 0, 0.05), new Vector3(-0.05, 0, -0.05), new Vector3(0.05, 0, 0)];\n  var tube3 = [new Vector3(0.05, 0, -0.05), new Vector3(0.05, 0, 0.05), new Vector3(-0.05, 0, 0)];\n  var vector1 = new Vector3();\n  var vector2 = new Vector3();\n  var vector3 = new Vector3();\n  var vector4 = new Vector3();\n  var normal1 = new Vector3();\n  var normal2 = new Vector3();\n  var normal3 = new Vector3();\n  var normal4 = new Vector3();\n\n  function extrudeShape(shape, fromPoint, toPoint) {\n    for (let j = 0, jl = shape.length; j < jl; j++) {\n      var point1 = shape[j];\n      var point2 = shape[(j + 1) % jl];\n      vector1.copy(point1);\n      vector1.applyQuaternion(quaternion);\n      vector1.add(fromPoint);\n      vector2.copy(point2);\n      vector2.applyQuaternion(quaternion);\n      vector2.add(fromPoint);\n      vector3.copy(point2);\n      vector3.applyQuaternion(quaternion);\n      vector3.add(toPoint);\n      vector4.copy(point1);\n      vector4.applyQuaternion(quaternion);\n      vector4.add(toPoint);\n      vertices.push(vector1.x, vector1.y, vector1.z);\n      vertices.push(vector2.x, vector2.y, vector2.z);\n      vertices.push(vector4.x, vector4.y, vector4.z);\n      vertices.push(vector2.x, vector2.y, vector2.z);\n      vertices.push(vector3.x, vector3.y, vector3.z);\n      vertices.push(vector4.x, vector4.y, vector4.z); //\n\n      normal1.copy(point1);\n      normal1.applyQuaternion(quaternion);\n      normal1.normalize();\n      normal2.copy(point2);\n      normal2.applyQuaternion(quaternion);\n      normal2.normalize();\n      normal3.copy(point2);\n      normal3.applyQuaternion(quaternion);\n      normal3.normalize();\n      normal4.copy(point1);\n      normal4.applyQuaternion(quaternion);\n      normal4.normalize();\n      normals.push(normal1.x, normal1.y, normal1.z);\n      normals.push(normal2.x, normal2.y, normal2.z);\n      normals.push(normal4.x, normal4.y, normal4.z);\n      normals.push(normal2.x, normal2.y, normal2.z);\n      normals.push(normal3.x, normal3.y, normal3.z);\n      normals.push(normal4.x, normal4.y, normal4.z);\n    }\n  }\n\n  var fromPoint = new Vector3();\n  var toPoint = new Vector3();\n\n  for (let i = 1; i <= divisions; i++) {\n    point.copy(curve.getPointAt(i / divisions));\n    tangent.copy(curve.getTangentAt(i / divisions));\n    var angle = Math.atan2(tangent.x, tangent.z);\n    quaternion.setFromAxisAngle(up, angle); //\n\n    if (point.y > 10) {\n      fromPoint.set(-0.75, -0.35, 0);\n      fromPoint.applyQuaternion(quaternion);\n      fromPoint.add(point);\n      toPoint.set(0.75, -0.35, 0);\n      toPoint.applyQuaternion(quaternion);\n      toPoint.add(point);\n      extrudeShape(tube1, fromPoint, toPoint);\n      fromPoint.set(-0.7, -0.3, 0);\n      fromPoint.applyQuaternion(quaternion);\n      fromPoint.add(point);\n      toPoint.set(-0.7, -point.y, 0);\n      toPoint.applyQuaternion(quaternion);\n      toPoint.add(point);\n      extrudeShape(tube2, fromPoint, toPoint);\n      fromPoint.set(0.7, -0.3, 0);\n      fromPoint.applyQuaternion(quaternion);\n      fromPoint.add(point);\n      toPoint.set(0.7, -point.y, 0);\n      toPoint.applyQuaternion(quaternion);\n      toPoint.add(point);\n      extrudeShape(tube3, fromPoint, toPoint);\n    } else {\n      fromPoint.set(0, -0.2, 0);\n      fromPoint.applyQuaternion(quaternion);\n      fromPoint.add(point);\n      toPoint.set(0, -point.y, 0);\n      toPoint.applyQuaternion(quaternion);\n      toPoint.add(point);\n      extrudeShape(tube3, fromPoint, toPoint);\n    }\n  }\n\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\n  this.setAttribute('normal', new BufferAttribute(new Float32Array(normals), 3));\n};\n\nRollerCoasterLiftersGeometry.prototype = Object.create(BufferGeometry.prototype);\n\nvar RollerCoasterShadowGeometry = function (curve, divisions) {\n  BufferGeometry.call(this);\n  var vertices = [];\n  var up = new Vector3(0, 1, 0);\n  var forward = new Vector3();\n  var quaternion = new Quaternion();\n  var prevQuaternion = new Quaternion();\n  prevQuaternion.setFromAxisAngle(up, Math.PI / 2);\n  var point = new Vector3();\n  var prevPoint = new Vector3();\n  prevPoint.copy(curve.getPointAt(0));\n  prevPoint.y = 0;\n  var vector1 = new Vector3();\n  var vector2 = new Vector3();\n  var vector3 = new Vector3();\n  var vector4 = new Vector3();\n\n  for (let i = 1; i <= divisions; i++) {\n    point.copy(curve.getPointAt(i / divisions));\n    point.y = 0;\n    forward.subVectors(point, prevPoint);\n    var angle = Math.atan2(forward.x, forward.z);\n    quaternion.setFromAxisAngle(up, angle);\n    vector1.set(-0.3, 0, 0);\n    vector1.applyQuaternion(quaternion);\n    vector1.add(point);\n    vector2.set(0.3, 0, 0);\n    vector2.applyQuaternion(quaternion);\n    vector2.add(point);\n    vector3.set(0.3, 0, 0);\n    vector3.applyQuaternion(prevQuaternion);\n    vector3.add(prevPoint);\n    vector4.set(-0.3, 0, 0);\n    vector4.applyQuaternion(prevQuaternion);\n    vector4.add(prevPoint);\n    vertices.push(vector1.x, vector1.y, vector1.z);\n    vertices.push(vector2.x, vector2.y, vector2.z);\n    vertices.push(vector4.x, vector4.y, vector4.z);\n    vertices.push(vector2.x, vector2.y, vector2.z);\n    vertices.push(vector3.x, vector3.y, vector3.z);\n    vertices.push(vector4.x, vector4.y, vector4.z);\n    prevPoint.copy(point);\n    prevQuaternion.copy(quaternion);\n  }\n\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\n};\n\nRollerCoasterShadowGeometry.prototype = Object.create(BufferGeometry.prototype);\n\nvar SkyGeometry = function () {\n  BufferGeometry.call(this);\n  var vertices = [];\n\n  for (let i = 0; i < 100; i++) {\n    var x = Math.random() * 800 - 400;\n    var y = Math.random() * 50 + 50;\n    var z = Math.random() * 800 - 400;\n    var size = Math.random() * 40 + 20;\n    vertices.push(x - size, y, z - size);\n    vertices.push(x + size, y, z - size);\n    vertices.push(x - size, y, z + size);\n    vertices.push(x + size, y, z - size);\n    vertices.push(x + size, y, z + size);\n    vertices.push(x - size, y, z + size);\n  }\n\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\n};\n\nSkyGeometry.prototype = Object.create(BufferGeometry.prototype);\n\nvar TreesGeometry = function (landscape) {\n  BufferGeometry.call(this);\n  var vertices = [];\n  var colors = [];\n  var raycaster = new Raycaster();\n  raycaster.ray.direction.set(0, -1, 0);\n\n  for (let i = 0; i < 2000; i++) {\n    var x = Math.random() * 500 - 250;\n    var z = Math.random() * 500 - 250;\n    raycaster.ray.origin.set(x, 50, z);\n    var intersections = raycaster.intersectObject(landscape);\n    if (intersections.length === 0) continue;\n    var y = intersections[0].point.y;\n    var height = Math.random() * 5 + 0.5;\n    var angle = Math.random() * Math.PI * 2;\n    vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));\n    vertices.push(x, y + height, z);\n    vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));\n    angle += Math.PI / 2;\n    vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));\n    vertices.push(x, y + height, z);\n    vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));\n    var random = Math.random() * 0.1;\n\n    for (let j = 0; j < 6; j++) {\n      colors.push(0.2 + random, 0.4 + random, 0);\n    }\n  }\n\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\n  this.setAttribute('color', new BufferAttribute(new Float32Array(colors), 3));\n};\n\nTreesGeometry.prototype = Object.create(BufferGeometry.prototype);\n\nexport { RollerCoasterGeometry, RollerCoasterLiftersGeometry, RollerCoasterShadowGeometry, SkyGeometry, TreesGeometry };\n", "export default function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}", "import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}", "import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}", "import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}", "import { Texture, LinearFilter, ClampToEdgeWrapping, MeshBasicMaterial, DoubleSide, Mesh, PlaneGeometry } from 'three';\n\n/**\n * This class has been made to hold a slice of a volume data\n * @class\n * @param   {Volume} volume    The associated volume\n * @param   {number}       [index=0] The index of the slice\n * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\n * @see Volume\n */\n\nvar VolumeSlice = function (volume, index, axis) {\n  var slice = this;\n  /**\n   * @member {Volume} volume The associated volume\n   */\n\n  this.volume = volume;\n  /**\n   * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\n   */\n\n  index = index || 0;\n  Object.defineProperty(this, 'index', {\n    get: function () {\n      return index;\n    },\n    set: function (value) {\n      index = value;\n      slice.geometryNeedsUpdate = true;\n      return index;\n    }\n  });\n  /**\n   * @member {String} axis The normal axis\n   */\n\n  this.axis = axis || 'z';\n  /**\n   * @member {HTMLCanvasElement} canvas The final canvas used for the texture\n   */\n\n  /**\n   * @member {CanvasRenderingContext2D} ctx Context of the canvas\n   */\n\n  this.canvas = document.createElement('canvas');\n  /**\n   * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\n   */\n\n  /**\n   * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\n   */\n\n  this.canvasBuffer = document.createElement('canvas');\n  this.updateGeometry();\n  var canvasMap = new Texture(this.canvas);\n  canvasMap.minFilter = LinearFilter;\n  canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n  var material = new MeshBasicMaterial({\n    map: canvasMap,\n    side: DoubleSide,\n    transparent: true\n  });\n  /**\n   * @member {Mesh} mesh The mesh ready to get used in the scene\n   */\n\n  this.mesh = new Mesh(this.geometry, material);\n  this.mesh.matrixAutoUpdate = false;\n  /**\n   * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\n   */\n\n  this.geometryNeedsUpdate = true;\n  this.repaint();\n  /**\n   * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\n   */\n\n  /**\n   * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\n   */\n\n  /**\n   * @member {Function} sliceAccess Function that allow the slice to access right data\n   * @see Volume.extractPerpendicularPlane\n   * @param {Number} i The first coordinate\n   * @param {Number} j The second coordinate\n   * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\n   */\n};\n\nVolumeSlice.prototype = {\n  constructor: VolumeSlice,\n\n  /**\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n   * @memberof VolumeSlice\n   */\n  repaint: function () {\n    if (this.geometryNeedsUpdate) {\n      this.updateGeometry();\n    }\n\n    var iLength = this.iLength,\n        jLength = this.jLength,\n        sliceAccess = this.sliceAccess,\n        volume = this.volume,\n        canvas = this.canvasBuffer,\n        ctx = this.ctxBuffer; // get the imageData and pixel array from the canvas\n\n    var imgData = ctx.getImageData(0, 0, iLength, jLength);\n    var data = imgData.data;\n    var volumeData = volume.data;\n    var upperThreshold = volume.upperThreshold;\n    var lowerThreshold = volume.lowerThreshold;\n    var windowLow = volume.windowLow;\n    var windowHigh = volume.windowHigh; // manipulate some pixel elements\n\n    var pixelCount = 0;\n\n    if (volume.dataType === 'label') {\n      //this part is currently useless but will be used when colortables will be handled\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          var label = volumeData[sliceAccess(i, j)];\n          label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\n          var color = this.colorMap[label];\n          data[4 * pixelCount] = color >> 24 & 0xff;\n          data[4 * pixelCount + 1] = color >> 16 & 0xff;\n          data[4 * pixelCount + 2] = color >> 8 & 0xff;\n          data[4 * pixelCount + 3] = color & 0xff;\n          pixelCount++;\n        }\n      }\n    } else {\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          var value = volumeData[sliceAccess(i, j)];\n          var alpha = 0xff; //apply threshold\n\n          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0; //apply window level\n\n          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\n          data[4 * pixelCount] = value;\n          data[4 * pixelCount + 1] = value;\n          data[4 * pixelCount + 2] = value;\n          data[4 * pixelCount + 3] = alpha;\n          pixelCount++;\n        }\n      }\n    }\n\n    ctx.putImageData(imgData, 0, 0);\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\n    this.mesh.material.map.needsUpdate = true;\n  },\n\n  /**\n   * @member {Function} Refresh the geometry according to axis and index\n   * @see Volume.extractPerpendicularPlane\n   * @memberof VolumeSlice\n   */\n  updateGeometry: function () {\n    var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\n    this.sliceAccess = extracted.sliceAccess;\n    this.jLength = extracted.jLength;\n    this.iLength = extracted.iLength;\n    this.matrix = extracted.matrix;\n    this.canvas.width = extracted.planeWidth;\n    this.canvas.height = extracted.planeHeight;\n    this.canvasBuffer.width = this.iLength;\n    this.canvasBuffer.height = this.jLength;\n    this.ctx = this.canvas.getContext('2d');\n    this.ctxBuffer = this.canvasBuffer.getContext('2d');\n    if (this.geometry) this.geometry.dispose(); // dispose existing geometry\n\n    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\n\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry; //reset mesh matrix\n\n      this.mesh.matrix.identity();\n      this.mesh.applyMatrix4(this.matrix);\n    }\n\n    this.geometryNeedsUpdate = false;\n  }\n};\n\nexport { VolumeSlice };\n", "import { Matrix3, Matrix4, Vector3 } from 'three';\nimport { VolumeSlice } from './VolumeSlice.js';\n\n/**\n * This class had been written to handle the output of the NRRD loader.\n * It contains a volume of data and informations about it.\n * For now it only handles 3 dimensional data.\n * See the webgl_loader_nrrd.html example and the loaderNRRD.js file to see how to use this class.\n * @class\n * @param   {number}        xLength         Width of the volume\n * @param   {number}        yLength         Length of the volume\n * @param   {number}        zLength         Depth of the volume\n * @param   {string}        type            The type of data (uint8, uint16, ...)\n * @param   {ArrayBuffer}   arrayBuffer     The buffer with volume data\n */\n\nvar Volume = function (xLength, yLength, zLength, type, arrayBuffer) {\n  if (arguments.length > 0) {\n    /**\n     * @member {number} xLength Width of the volume in the IJK coordinate system\n     */\n    this.xLength = Number(xLength) || 1;\n    /**\n     * @member {number} yLength Height of the volume in the IJK coordinate system\n     */\n\n    this.yLength = Number(yLength) || 1;\n    /**\n     * @member {number} zLength Depth of the volume in the IJK coordinate system\n     */\n\n    this.zLength = Number(zLength) || 1;\n    /**\n     * @member {TypedArray} data Data of the volume\n     */\n\n    switch (type) {\n      case 'Uint8':\n      case 'uint8':\n      case 'uchar':\n      case 'unsigned char':\n      case 'uint8_t':\n        this.data = new Uint8Array(arrayBuffer);\n        break;\n\n      case 'Int8':\n      case 'int8':\n      case 'signed char':\n      case 'int8_t':\n        this.data = new Int8Array(arrayBuffer);\n        break;\n\n      case 'Int16':\n      case 'int16':\n      case 'short':\n      case 'short int':\n      case 'signed short':\n      case 'signed short int':\n      case 'int16_t':\n        this.data = new Int16Array(arrayBuffer);\n        break;\n\n      case 'Uint16':\n      case 'uint16':\n      case 'ushort':\n      case 'unsigned short':\n      case 'unsigned short int':\n      case 'uint16_t':\n        this.data = new Uint16Array(arrayBuffer);\n        break;\n\n      case 'Int32':\n      case 'int32':\n      case 'int':\n      case 'signed int':\n      case 'int32_t':\n        this.data = new Int32Array(arrayBuffer);\n        break;\n\n      case 'Uint32':\n      case 'uint32':\n      case 'uint':\n      case 'unsigned int':\n      case 'uint32_t':\n        this.data = new Uint32Array(arrayBuffer);\n        break;\n\n      case 'longlong':\n      case 'long long':\n      case 'long long int':\n      case 'signed long long':\n      case 'signed long long int':\n      case 'int64':\n      case 'int64_t':\n      case 'ulonglong':\n      case 'unsigned long long':\n      case 'unsigned long long int':\n      case 'uint64':\n      case 'uint64_t':\n        throw 'Error in Volume constructor : this type is not supported in JavaScript';\n\n      case 'Float32':\n      case 'float32':\n      case 'float':\n        this.data = new Float32Array(arrayBuffer);\n        break;\n\n      case 'Float64':\n      case 'float64':\n      case 'double':\n        this.data = new Float64Array(arrayBuffer);\n        break;\n\n      default:\n        this.data = new Uint8Array(arrayBuffer);\n    }\n\n    if (this.data.length !== this.xLength * this.yLength * this.zLength) {\n      throw 'Error in Volume constructor, lengths are not matching arrayBuffer size';\n    }\n  }\n  /**\n   * @member {Array}  spacing Spacing to apply to the volume from IJK to RAS coordinate system\n   */\n\n\n  this.spacing = [1, 1, 1];\n  /**\n   * @member {Array}  offset Offset of the volume in the RAS coordinate system\n   */\n\n  this.offset = [0, 0, 0];\n  /**\n   * @member {Martrix3} matrix The IJK to RAS matrix\n   */\n\n  this.matrix = new Matrix3();\n  this.matrix.identity();\n  /**\n   * @member {Martrix3} inverseMatrix The RAS to IJK matrix\n   */\n\n  /**\n   * @member {number} lowerThreshold The voxels with values under this threshold won't appear in the slices.\n   *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\n   */\n\n  var lowerThreshold = -Infinity;\n  Object.defineProperty(this, 'lowerThreshold', {\n    get: function () {\n      return lowerThreshold;\n    },\n    set: function (value) {\n      lowerThreshold = value;\n      this.sliceList.forEach(function (slice) {\n        slice.geometryNeedsUpdate = true;\n      });\n    }\n  });\n  /**\n   * @member {number} upperThreshold The voxels with values over this threshold won't appear in the slices.\n   *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\n   */\n\n  var upperThreshold = Infinity;\n  Object.defineProperty(this, 'upperThreshold', {\n    get: function () {\n      return upperThreshold;\n    },\n    set: function (value) {\n      upperThreshold = value;\n      this.sliceList.forEach(function (slice) {\n        slice.geometryNeedsUpdate = true;\n      });\n    }\n  });\n  /**\n   * @member {Array} sliceList The list of all the slices associated to this volume\n   */\n\n  this.sliceList = [];\n  /**\n   * @member {Array} RASDimensions This array holds the dimensions of the volume in the RAS space\n   */\n};\n\nVolume.prototype = {\n  constructor: Volume,\n\n  /**\n   * @member {Function} getData Shortcut for data[access(i,j,k)]\n   * @memberof Volume\n   * @param {number} i    First coordinate\n   * @param {number} j    Second coordinate\n   * @param {number} k    Third coordinate\n   * @returns {number}  value in the data array\n   */\n  getData: function (i, j, k) {\n    return this.data[k * this.xLength * this.yLength + j * this.xLength + i];\n  },\n\n  /**\n   * @member {Function} access compute the index in the data array corresponding to the given coordinates in IJK system\n   * @memberof Volume\n   * @param {number} i    First coordinate\n   * @param {number} j    Second coordinate\n   * @param {number} k    Third coordinate\n   * @returns {number}  index\n   */\n  access: function (i, j, k) {\n    return k * this.xLength * this.yLength + j * this.xLength + i;\n  },\n\n  /**\n   * @member {Function} reverseAccess Retrieve the IJK coordinates of the voxel corresponding of the given index in the data\n   * @memberof Volume\n   * @param {number} index index of the voxel\n   * @returns {Array}  [x,y,z]\n   */\n  reverseAccess: function (index) {\n    var z = Math.floor(index / (this.yLength * this.xLength));\n    var y = Math.floor((index - z * this.yLength * this.xLength) / this.xLength);\n    var x = index - z * this.yLength * this.xLength - y * this.xLength;\n    return [x, y, z];\n  },\n\n  /**\n   * @member {Function} map Apply a function to all the voxels, be careful, the value will be replaced\n   * @memberof Volume\n   * @param {Function} functionToMap A function to apply to every voxel, will be called with the following parameters :\n   *                                 value of the voxel\n   *                                 index of the voxel\n   *                                 the data (TypedArray)\n   * @param {Object}   context    You can specify a context in which call the function, default if this Volume\n   * @returns {Volume}   this\n   */\n  map: function (functionToMap, context) {\n    var length = this.data.length;\n    context = context || this;\n\n    for (let i = 0; i < length; i++) {\n      this.data[i] = functionToMap.call(context, this.data[i], i, this.data);\n    }\n\n    return this;\n  },\n\n  /**\n   * @member {Function} extractPerpendicularPlane Compute the orientation of the slice and returns all the information relative to the geometry such as sliceAccess, the plane matrix (orientation and position in RAS coordinate) and the dimensions of the plane in both coordinate system.\n   * @memberof Volume\n   * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'\n   * @param {number}            index the index of the slice\n   * @returns {Object} an object containing all the usefull information on the geometry of the slice\n   */\n  extractPerpendicularPlane: function (axis, RASIndex) {\n    var iLength,\n        jLength,\n        sliceAccess,\n        planeMatrix = new Matrix4().identity(),\n        volume = this,\n        planeWidth,\n        planeHeight,\n        firstSpacing,\n        secondSpacing,\n        positionOffset,\n        IJKIndex;\n    var axisInIJK = new Vector3(),\n        firstDirection = new Vector3(),\n        secondDirection = new Vector3();\n    var dimensions = new Vector3(this.xLength, this.yLength, this.zLength);\n\n    switch (axis) {\n      case 'x':\n        axisInIJK.set(1, 0, 0);\n        firstDirection.set(0, 0, -1);\n        secondDirection.set(0, -1, 0);\n        firstSpacing = this.spacing[2];\n        secondSpacing = this.spacing[1];\n        IJKIndex = new Vector3(RASIndex, 0, 0);\n        planeMatrix.multiply(new Matrix4().makeRotationY(Math.PI / 2));\n        positionOffset = (volume.RASDimensions[0] - 1) / 2;\n        planeMatrix.setPosition(new Vector3(RASIndex - positionOffset, 0, 0));\n        break;\n\n      case 'y':\n        axisInIJK.set(0, 1, 0);\n        firstDirection.set(1, 0, 0);\n        secondDirection.set(0, 0, 1);\n        firstSpacing = this.spacing[0];\n        secondSpacing = this.spacing[2];\n        IJKIndex = new Vector3(0, RASIndex, 0);\n        planeMatrix.multiply(new Matrix4().makeRotationX(-Math.PI / 2));\n        positionOffset = (volume.RASDimensions[1] - 1) / 2;\n        planeMatrix.setPosition(new Vector3(0, RASIndex - positionOffset, 0));\n        break;\n\n      case 'z':\n      default:\n        axisInIJK.set(0, 0, 1);\n        firstDirection.set(1, 0, 0);\n        secondDirection.set(0, -1, 0);\n        firstSpacing = this.spacing[0];\n        secondSpacing = this.spacing[1];\n        IJKIndex = new Vector3(0, 0, RASIndex);\n        positionOffset = (volume.RASDimensions[2] - 1) / 2;\n        planeMatrix.setPosition(new Vector3(0, 0, RASIndex - positionOffset));\n        break;\n    }\n\n    firstDirection.applyMatrix4(volume.inverseMatrix).normalize();\n    firstDirection.argVar = 'i';\n    secondDirection.applyMatrix4(volume.inverseMatrix).normalize();\n    secondDirection.argVar = 'j';\n    axisInIJK.applyMatrix4(volume.inverseMatrix).normalize();\n    iLength = Math.floor(Math.abs(firstDirection.dot(dimensions)));\n    jLength = Math.floor(Math.abs(secondDirection.dot(dimensions)));\n    planeWidth = Math.abs(iLength * firstSpacing);\n    planeHeight = Math.abs(jLength * secondSpacing);\n    IJKIndex = Math.abs(Math.round(IJKIndex.applyMatrix4(volume.inverseMatrix).dot(axisInIJK)));\n    var base = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)];\n    var iDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n      return Math.abs(x.dot(base[0])) > 0.9;\n    });\n    var jDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n      return Math.abs(x.dot(base[1])) > 0.9;\n    });\n    var kDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n      return Math.abs(x.dot(base[2])) > 0.9;\n    });\n\n    sliceAccess = function (i, j) {\n      var accessI, accessJ, accessK;\n      var si = iDirection === axisInIJK ? IJKIndex : iDirection.argVar === 'i' ? i : j;\n      var sj = jDirection === axisInIJK ? IJKIndex : jDirection.argVar === 'i' ? i : j;\n      var sk = kDirection === axisInIJK ? IJKIndex : kDirection.argVar === 'i' ? i : j; // invert indices if necessary\n\n      var accessI = iDirection.dot(base[0]) > 0 ? si : volume.xLength - 1 - si;\n      var accessJ = jDirection.dot(base[1]) > 0 ? sj : volume.yLength - 1 - sj;\n      var accessK = kDirection.dot(base[2]) > 0 ? sk : volume.zLength - 1 - sk;\n      return volume.access(accessI, accessJ, accessK);\n    };\n\n    return {\n      iLength: iLength,\n      jLength: jLength,\n      sliceAccess: sliceAccess,\n      matrix: planeMatrix,\n      planeWidth: planeWidth,\n      planeHeight: planeHeight\n    };\n  },\n\n  /**\n   * @member {Function} extractSlice Returns a slice corresponding to the given axis and index\n   *                        The coordinate are given in the Right Anterior Superior coordinate format\n   * @memberof Volume\n   * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'\n   * @param {number}            index the index of the slice\n   * @returns {VolumeSlice} the extracted slice\n   */\n  extractSlice: function (axis, index) {\n    var slice = new VolumeSlice(this, index, axis);\n    this.sliceList.push(slice);\n    return slice;\n  },\n\n  /**\n   * @member {Function} repaintAllSlices Call repaint on all the slices extracted from this volume\n   * @see VolumeSlice.repaint\n   * @memberof Volume\n   * @returns {Volume} this\n   */\n  repaintAllSlices: function () {\n    this.sliceList.forEach(function (slice) {\n      slice.repaint();\n    });\n    return this;\n  },\n\n  /**\n   * @member {Function} computeMinMax Compute the minimum and the maximum of the data in the volume\n   * @memberof Volume\n   * @returns {Array} [min,max]\n   */\n  computeMinMax: function () {\n    var min = Infinity;\n    var max = -Infinity; // buffer the length\n\n    var datasize = this.data.length;\n    var i = 0;\n\n    for (i = 0; i < datasize; i++) {\n      if (!isNaN(this.data[i])) {\n        var value = this.data[i];\n        min = Math.min(min, value);\n        max = Math.max(max, value);\n      }\n    }\n\n    this.min = min;\n    this.max = max;\n    return [min, max];\n  }\n};\n\nexport { Volume };\n", "import { Object3D, Vector3, Matrix4 } from 'three';\n\nclass CSS2DObject extends Object3D {\n  constructor(element = document.createElement('div')) {\n    super();\n    this.isCSS2DObject = true;\n    this.element = element;\n    this.element.style.position = 'absolute';\n    this.element.style.userSelect = 'none';\n    this.element.setAttribute('draggable', false);\n    this.addEventListener('removed', function () {\n      this.traverse(function (object) {\n        if (object.element instanceof Element && object.element.parentNode !== null) {\n          object.element.parentNode.removeChild(object.element);\n        }\n      });\n    });\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.element = source.element.cloneNode(true);\n    return this;\n  }\n\n}\n\nconst _vector = /*#__PURE__*/new Vector3();\n\nconst _viewMatrix = /*#__PURE__*/new Matrix4();\n\nconst _viewProjectionMatrix = /*#__PURE__*/new Matrix4();\n\nconst _a = /*#__PURE__*/new Vector3();\n\nconst _b = /*#__PURE__*/new Vector3();\n\nclass CSS2DRenderer {\n  constructor(parameters = {}) {\n    const _this = this;\n\n    let _width, _height;\n\n    let _widthHalf, _heightHalf;\n\n    const cache = {\n      objects: new WeakMap()\n    };\n    const domElement = parameters.element !== undefined ? parameters.element : document.createElement('div');\n    domElement.style.overflow = 'hidden';\n    this.domElement = domElement;\n\n    this.getSize = function () {\n      return {\n        width: _width,\n        height: _height\n      };\n    };\n\n    this.render = function (scene, camera) {\n      if (scene.matrixWorldAutoUpdate === true || scene.autoUpdate === true) scene.updateMatrixWorld();\n\n      if (camera.parent === null && (camera.matrixWorldAutoUpdate == null || camera.matrixWorldAutoUpdate === true)) {\n        camera.updateMatrixWorld();\n      }\n\n      _viewMatrix.copy(camera.matrixWorldInverse);\n\n      _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\n\n      renderObject(scene, scene, camera);\n      zOrder(scene);\n    };\n\n    this.setSize = function (width, height) {\n      _width = width;\n      _height = height;\n      _widthHalf = _width / 2;\n      _heightHalf = _height / 2;\n      domElement.style.width = width + 'px';\n      domElement.style.height = height + 'px';\n    };\n\n    function renderObject(object, scene, camera) {\n      if (object.isCSS2DObject) {\n        _vector.setFromMatrixPosition(object.matrixWorld);\n\n        _vector.applyMatrix4(_viewProjectionMatrix);\n\n        const visible = object.visible === true && _vector.z >= -1 && _vector.z <= 1 && object.layers.test(camera.layers) === true;\n        object.element.style.display = visible === true ? '' : 'none';\n\n        if (visible === true) {\n          object.onBeforeRender(_this, scene, camera);\n          const element = object.element;\n          element.style.transform = 'translate(-50%,-50%) translate(' + (_vector.x * _widthHalf + _widthHalf) + 'px,' + (-_vector.y * _heightHalf + _heightHalf) + 'px)';\n\n          if (element.parentNode !== domElement) {\n            domElement.appendChild(element);\n          }\n\n          object.onAfterRender(_this, scene, camera);\n        }\n\n        const objectData = {\n          distanceToCameraSquared: getDistanceToSquared(camera, object)\n        };\n        cache.objects.set(object, objectData);\n      }\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        renderObject(object.children[i], scene, camera);\n      }\n    }\n\n    function getDistanceToSquared(object1, object2) {\n      _a.setFromMatrixPosition(object1.matrixWorld);\n\n      _b.setFromMatrixPosition(object2.matrixWorld);\n\n      return _a.distanceToSquared(_b);\n    }\n\n    function filterAndFlatten(scene) {\n      const result = [];\n      scene.traverse(function (object) {\n        if (object.isCSS2DObject) result.push(object);\n      });\n      return result;\n    }\n\n    function zOrder(scene) {\n      const sorted = filterAndFlatten(scene).sort(function (a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n          return b.renderOrder - a.renderOrder;\n        }\n\n        const distanceA = cache.objects.get(a).distanceToCameraSquared;\n        const distanceB = cache.objects.get(b).distanceToCameraSquared;\n        return distanceA - distanceB;\n      });\n      const zMax = sorted.length;\n\n      for (let i = 0, l = sorted.length; i < l; i++) {\n        sorted[i].element.style.zIndex = zMax - i;\n      }\n    }\n  }\n\n}\n\nexport { CSS2DObject, CSS2DRenderer };\n", "import { Object3D, Matrix4 } from 'three';\n\n/**\n * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs\n */\n\nvar CSS3DObject = function (element) {\n  Object3D.call(this);\n  this.element = element || document.createElement('div');\n  this.element.style.position = 'absolute';\n  this.element.style.pointerEvents = 'auto';\n  this.addEventListener('removed', function () {\n    this.traverse(function (object) {\n      if (object.element instanceof Element && object.element.parentNode !== null) {\n        object.element.parentNode.removeChild(object.element);\n      }\n    });\n  });\n};\n\nCSS3DObject.prototype = Object.assign(Object.create(Object3D.prototype), {\n  constructor: CSS3DObject,\n  copy: function (source, recursive) {\n    Object3D.prototype.copy.call(this, source, recursive);\n    this.element = source.element.cloneNode(true);\n    return this;\n  }\n});\n\nvar CSS3DSprite = function (element) {\n  CSS3DObject.call(this, element);\n};\n\nCSS3DSprite.prototype = Object.create(CSS3DObject.prototype);\nCSS3DSprite.prototype.constructor = CSS3DSprite; //\n\nvar CSS3DRenderer = function () {\n  var _this = this;\n\n  var _width, _height;\n\n  var _widthHalf, _heightHalf;\n\n  var matrix = new Matrix4();\n  var cache = {\n    camera: {\n      fov: 0,\n      style: ''\n    },\n    objects: new WeakMap()\n  };\n  var domElement = document.createElement('div');\n  domElement.style.overflow = 'hidden';\n  this.domElement = domElement;\n  var cameraElement = document.createElement('div');\n  cameraElement.style.transformStyle = 'preserve-3d';\n  cameraElement.style.pointerEvents = 'none';\n  domElement.appendChild(cameraElement);\n\n  this.getSize = function () {\n    return {\n      width: _width,\n      height: _height\n    };\n  };\n\n  this.setSize = function (width, height) {\n    _width = width;\n    _height = height;\n    _widthHalf = _width / 2;\n    _heightHalf = _height / 2;\n    domElement.style.width = width + 'px';\n    domElement.style.height = height + 'px';\n    cameraElement.style.width = width + 'px';\n    cameraElement.style.height = height + 'px';\n  };\n\n  function epsilon(value) {\n    return Math.abs(value) < 1e-10 ? 0 : value;\n  }\n\n  function getCameraCSSMatrix(matrix) {\n    var elements = matrix.elements;\n    return 'matrix3d(' + epsilon(elements[0]) + ',' + epsilon(-elements[1]) + ',' + epsilon(elements[2]) + ',' + epsilon(elements[3]) + ',' + epsilon(elements[4]) + ',' + epsilon(-elements[5]) + ',' + epsilon(elements[6]) + ',' + epsilon(elements[7]) + ',' + epsilon(elements[8]) + ',' + epsilon(-elements[9]) + ',' + epsilon(elements[10]) + ',' + epsilon(elements[11]) + ',' + epsilon(elements[12]) + ',' + epsilon(-elements[13]) + ',' + epsilon(elements[14]) + ',' + epsilon(elements[15]) + ')';\n  }\n\n  function getObjectCSSMatrix(matrix) {\n    var elements = matrix.elements;\n    var matrix3d = 'matrix3d(' + epsilon(elements[0]) + ',' + epsilon(elements[1]) + ',' + epsilon(elements[2]) + ',' + epsilon(elements[3]) + ',' + epsilon(-elements[4]) + ',' + epsilon(-elements[5]) + ',' + epsilon(-elements[6]) + ',' + epsilon(-elements[7]) + ',' + epsilon(elements[8]) + ',' + epsilon(elements[9]) + ',' + epsilon(elements[10]) + ',' + epsilon(elements[11]) + ',' + epsilon(elements[12]) + ',' + epsilon(elements[13]) + ',' + epsilon(elements[14]) + ',' + epsilon(elements[15]) + ')';\n    return 'translate(-50%,-50%)' + matrix3d;\n  }\n\n  function renderObject(object, scene, camera, cameraCSSMatrix) {\n    if (object instanceof CSS3DObject) {\n      object.onBeforeRender(_this, scene, camera);\n      var style;\n\n      if (object instanceof CSS3DSprite) {\n        // http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/\n        matrix.copy(camera.matrixWorldInverse);\n        matrix.transpose();\n        matrix.copyPosition(object.matrixWorld);\n        matrix.scale(object.scale);\n        matrix.elements[3] = 0;\n        matrix.elements[7] = 0;\n        matrix.elements[11] = 0;\n        matrix.elements[15] = 1;\n        style = getObjectCSSMatrix(matrix);\n      } else {\n        style = getObjectCSSMatrix(object.matrixWorld);\n      }\n\n      var element = object.element;\n      var cachedObject = cache.objects.get(object);\n\n      if (cachedObject === undefined || cachedObject.style !== style) {\n        element.style.transform = style;\n        var objectData = {\n          style: style\n        };\n        cache.objects.set(object, objectData);\n      }\n\n      element.style.display = object.visible ? '' : 'none';\n\n      if (element.parentNode !== cameraElement) {\n        cameraElement.appendChild(element);\n      }\n\n      object.onAfterRender(_this, scene, camera);\n    }\n\n    for (let i = 0, l = object.children.length; i < l; i++) {\n      renderObject(object.children[i], scene, camera);\n    }\n  }\n\n  this.render = function (scene, camera) {\n    var fov = camera.projectionMatrix.elements[5] * _heightHalf;\n\n    if (cache.camera.fov !== fov) {\n      domElement.style.perspective = camera.isPerspectiveCamera ? fov + 'px' : '';\n      cache.camera.fov = fov;\n    }\n\n    if (scene.autoUpdate === true) scene.updateMatrixWorld();\n    if (camera.parent === null) camera.updateMatrixWorld();\n\n    if (camera.isOrthographicCamera) {\n      var tx = -(camera.right + camera.left) / 2;\n      var ty = (camera.top + camera.bottom) / 2;\n    }\n\n    var cameraCSSMatrix = camera.isOrthographicCamera ? 'scale(' + fov + ')' + 'translate(' + epsilon(tx) + 'px,' + epsilon(ty) + 'px)' + getCameraCSSMatrix(camera.matrixWorldInverse) : 'translateZ(' + fov + 'px)' + getCameraCSSMatrix(camera.matrixWorldInverse);\n    var style = cameraCSSMatrix + 'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';\n\n    if (cache.camera.style !== style) {\n      cameraElement.style.transform = style;\n      cache.camera.style = style;\n    }\n\n    renderObject(scene, scene, camera);\n  };\n};\n\nexport { CSS3DObject, CSS3DRenderer, CSS3DSprite };\n", "import { Vector3, Color, Vector2, Vector4, Box3, Matrix4, Frustum, Matrix3, DoubleSide } from 'three';\n\nvar RenderableObject = function () {\n  this.id = 0;\n  this.object = null;\n  this.z = 0;\n  this.renderOrder = 0;\n}; //\n\n\nvar RenderableFace = function () {\n  this.id = 0;\n  this.v1 = new RenderableVertex();\n  this.v2 = new RenderableVertex();\n  this.v3 = new RenderableVertex();\n  this.normalModel = new Vector3();\n  this.vertexNormalsModel = [new Vector3(), new Vector3(), new Vector3()];\n  this.vertexNormalsLength = 0;\n  this.color = new Color();\n  this.material = null;\n  this.uvs = [new Vector2(), new Vector2(), new Vector2()];\n  this.z = 0;\n  this.renderOrder = 0;\n}; //\n\n\nvar RenderableVertex = function () {\n  this.position = new Vector3();\n  this.positionWorld = new Vector3();\n  this.positionScreen = new Vector4();\n  this.visible = true;\n};\n\nRenderableVertex.prototype.copy = function (vertex) {\n  this.positionWorld.copy(vertex.positionWorld);\n  this.positionScreen.copy(vertex.positionScreen);\n}; //\n\n\nvar RenderableLine = function () {\n  this.id = 0;\n  this.v1 = new RenderableVertex();\n  this.v2 = new RenderableVertex();\n  this.vertexColors = [new Color(), new Color()];\n  this.material = null;\n  this.z = 0;\n  this.renderOrder = 0;\n}; //\n\n\nvar RenderableSprite = function () {\n  this.id = 0;\n  this.object = null;\n  this.x = 0;\n  this.y = 0;\n  this.z = 0;\n  this.rotation = 0;\n  this.scale = new Vector2();\n  this.material = null;\n  this.renderOrder = 0;\n}; //\n\n\nvar Projector = function () {\n  var _object,\n      _objectCount,\n      _objectPool = [],\n      _objectPoolLength = 0,\n      _vertex,\n      _vertexCount,\n      _vertexPool = [],\n      _vertexPoolLength = 0,\n      _face,\n      _faceCount,\n      _facePool = [],\n      _facePoolLength = 0,\n      _line,\n      _lineCount,\n      _linePool = [],\n      _linePoolLength = 0,\n      _sprite,\n      _spriteCount,\n      _spritePool = [],\n      _spritePoolLength = 0,\n      _renderData = {\n    objects: [],\n    lights: [],\n    elements: []\n  },\n      _vector3 = new Vector3(),\n      _vector4 = new Vector4(),\n      _clipBox = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1)),\n      _boundingBox = new Box3(),\n      _points3 = new Array(3),\n      _viewMatrix = new Matrix4(),\n      _viewProjectionMatrix = new Matrix4(),\n      _modelMatrix,\n      _modelViewProjectionMatrix = new Matrix4(),\n      _frustum = new Frustum(); //\n\n\n  this.projectVector = function (vector, camera) {\n    console.warn('THREE.Projector: .projectVector() is now vector.project().');\n    vector.project(camera);\n  };\n\n  this.unprojectVector = function (vector, camera) {\n    console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');\n    vector.unproject(camera);\n  };\n\n  this.pickingRay = function () {\n    console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');\n  }; //\n\n\n  var RenderList = function () {\n    var normals = [];\n    var colors = [];\n    var uvs = [];\n    var object = null;\n    var normalMatrix = new Matrix3();\n\n    function setObject(value) {\n      object = value;\n      normalMatrix.getNormalMatrix(object.matrixWorld);\n      normals.length = 0;\n      colors.length = 0;\n      uvs.length = 0;\n    }\n\n    function projectVertex(vertex) {\n      var position = vertex.position;\n      var positionWorld = vertex.positionWorld;\n      var positionScreen = vertex.positionScreen;\n      positionWorld.copy(position).applyMatrix4(_modelMatrix);\n      positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix);\n      var invW = 1 / positionScreen.w;\n      positionScreen.x *= invW;\n      positionScreen.y *= invW;\n      positionScreen.z *= invW;\n      vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 && positionScreen.y >= -1 && positionScreen.y <= 1 && positionScreen.z >= -1 && positionScreen.z <= 1;\n    }\n\n    function pushVertex(x, y, z) {\n      _vertex = getNextVertexInPool();\n\n      _vertex.position.set(x, y, z);\n\n      projectVertex(_vertex);\n    }\n\n    function pushNormal(x, y, z) {\n      normals.push(x, y, z);\n    }\n\n    function pushColor(r, g, b) {\n      colors.push(r, g, b);\n    }\n\n    function pushUv(x, y) {\n      uvs.push(x, y);\n    }\n\n    function checkTriangleVisibility(v1, v2, v3) {\n      if (v1.visible === true || v2.visible === true || v3.visible === true) return true;\n      _points3[0] = v1.positionScreen;\n      _points3[1] = v2.positionScreen;\n      _points3[2] = v3.positionScreen;\n      return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3));\n    }\n\n    function checkBackfaceCulling(v1, v2, v3) {\n      return (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0;\n    }\n\n    function pushLine(a, b) {\n      var v1 = _vertexPool[a];\n      var v2 = _vertexPool[b]; // Clip\n\n      v1.positionScreen.copy(v1.position).applyMatrix4(_modelViewProjectionMatrix);\n      v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix);\n\n      if (clipLine(v1.positionScreen, v2.positionScreen) === true) {\n        // Perform the perspective divide\n        v1.positionScreen.multiplyScalar(1 / v1.positionScreen.w);\n        v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w);\n        _line = getNextLineInPool();\n        _line.id = object.id;\n\n        _line.v1.copy(v1);\n\n        _line.v2.copy(v2);\n\n        _line.z = Math.max(v1.positionScreen.z, v2.positionScreen.z);\n        _line.renderOrder = object.renderOrder;\n        _line.material = object.material;\n\n        if (object.material.vertexColors) {\n          _line.vertexColors[0].fromArray(colors, a * 3);\n\n          _line.vertexColors[1].fromArray(colors, b * 3);\n        }\n\n        _renderData.elements.push(_line);\n      }\n    }\n\n    function pushTriangle(a, b, c, material) {\n      var v1 = _vertexPool[a];\n      var v2 = _vertexPool[b];\n      var v3 = _vertexPool[c];\n      if (checkTriangleVisibility(v1, v2, v3) === false) return;\n\n      if (material.side === DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {\n        _face = getNextFaceInPool();\n        _face.id = object.id;\n\n        _face.v1.copy(v1);\n\n        _face.v2.copy(v2);\n\n        _face.v3.copy(v3);\n\n        _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;\n        _face.renderOrder = object.renderOrder; // face normal\n\n        _vector3.subVectors(v3.position, v2.position);\n\n        _vector4.subVectors(v1.position, v2.position);\n\n        _vector3.cross(_vector4);\n\n        _face.normalModel.copy(_vector3);\n\n        _face.normalModel.applyMatrix3(normalMatrix).normalize();\n\n        for (let i = 0; i < 3; i++) {\n          var normal = _face.vertexNormalsModel[i];\n          normal.fromArray(normals, arguments[i] * 3);\n          normal.applyMatrix3(normalMatrix).normalize();\n          var uv = _face.uvs[i];\n          uv.fromArray(uvs, arguments[i] * 2);\n        }\n\n        _face.vertexNormalsLength = 3;\n        _face.material = material;\n\n        if (material.vertexColors) {\n          _face.color.fromArray(colors, a * 3);\n        }\n\n        _renderData.elements.push(_face);\n      }\n    }\n\n    return {\n      setObject: setObject,\n      projectVertex: projectVertex,\n      checkTriangleVisibility: checkTriangleVisibility,\n      checkBackfaceCulling: checkBackfaceCulling,\n      pushVertex: pushVertex,\n      pushNormal: pushNormal,\n      pushColor: pushColor,\n      pushUv: pushUv,\n      pushLine: pushLine,\n      pushTriangle: pushTriangle\n    };\n  };\n\n  var renderList = new RenderList();\n\n  function projectObject(object) {\n    if (object.visible === false) return;\n\n    if (object.isLight) {\n      _renderData.lights.push(object);\n    } else if (object.isMesh || object.isLine || object.isPoints) {\n      if (object.material.visible === false) return;\n      if (object.frustumCulled === true && _frustum.intersectsObject(object) === false) return;\n      addObject(object);\n    } else if (object.isSprite) {\n      if (object.material.visible === false) return;\n      if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false) return;\n      addObject(object);\n    }\n\n    var children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      projectObject(children[i]);\n    }\n  }\n\n  function addObject(object) {\n    _object = getNextObjectInPool();\n    _object.id = object.id;\n    _object.object = object;\n\n    _vector3.setFromMatrixPosition(object.matrixWorld);\n\n    _vector3.applyMatrix4(_viewProjectionMatrix);\n\n    _object.z = _vector3.z;\n    _object.renderOrder = object.renderOrder;\n\n    _renderData.objects.push(_object);\n  }\n\n  this.projectScene = function (scene, camera, sortObjects, sortElements) {\n    _faceCount = 0;\n    _lineCount = 0;\n    _spriteCount = 0;\n    _renderData.elements.length = 0;\n    if (scene.autoUpdate === true) scene.updateMatrixWorld();\n    if (camera.parent === null) camera.updateMatrixWorld();\n\n    _viewMatrix.copy(camera.matrixWorldInverse);\n\n    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\n\n    _frustum.setFromProjectionMatrix(_viewProjectionMatrix); //\n\n\n    _objectCount = 0;\n    _renderData.objects.length = 0;\n    _renderData.lights.length = 0;\n    projectObject(scene);\n\n    if (sortObjects === true) {\n      _renderData.objects.sort(painterSort);\n    } //\n\n\n    var objects = _renderData.objects;\n\n    for (let o = 0, ol = objects.length; o < ol; o++) {\n      var object = objects[o].object;\n      var geometry = object.geometry;\n      renderList.setObject(object);\n      _modelMatrix = object.matrixWorld;\n      _vertexCount = 0;\n\n      if (object.isMesh) {\n        if (geometry.isBufferGeometry) {\n          var material = object.material;\n          var isMultiMaterial = Array.isArray(material);\n          var attributes = geometry.attributes;\n          var groups = geometry.groups;\n          if (attributes.position === undefined) continue;\n          var positions = attributes.position.array;\n\n          for (let i = 0, l = positions.length; i < l; i += 3) {\n            var x = positions[i];\n            var y = positions[i + 1];\n            var z = positions[i + 2];\n\n            if (material.morphTargets === true) {\n              var morphTargets = geometry.morphAttributes.position;\n              var morphTargetsRelative = geometry.morphTargetsRelative;\n              var morphInfluences = object.morphTargetInfluences;\n\n              for (let t = 0, tl = morphTargets.length; t < tl; t++) {\n                var influence = morphInfluences[t];\n                if (influence === 0) continue;\n                var target = morphTargets[t];\n\n                if (morphTargetsRelative) {\n                  x += target.getX(i / 3) * influence;\n                  y += target.getY(i / 3) * influence;\n                  z += target.getZ(i / 3) * influence;\n                } else {\n                  x += (target.getX(i / 3) - positions[i]) * influence;\n                  y += (target.getY(i / 3) - positions[i + 1]) * influence;\n                  z += (target.getZ(i / 3) - positions[i + 2]) * influence;\n                }\n              }\n            }\n\n            renderList.pushVertex(x, y, z);\n          }\n\n          if (attributes.normal !== undefined) {\n            var normals = attributes.normal.array;\n\n            for (let i = 0, l = normals.length; i < l; i += 3) {\n              renderList.pushNormal(normals[i], normals[i + 1], normals[i + 2]);\n            }\n          }\n\n          if (attributes.color !== undefined) {\n            var colors = attributes.color.array;\n\n            for (let i = 0, l = colors.length; i < l; i += 3) {\n              renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);\n            }\n          }\n\n          if (attributes.uv !== undefined) {\n            var uvs = attributes.uv.array;\n\n            for (let i = 0, l = uvs.length; i < l; i += 2) {\n              renderList.pushUv(uvs[i], uvs[i + 1]);\n            }\n          }\n\n          if (geometry.index !== null) {\n            var indices = geometry.index.array;\n\n            if (groups.length > 0) {\n              for (let g = 0; g < groups.length; g++) {\n                var group = groups[g];\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;\n                if (material === undefined) continue;\n\n                for (let i = group.start, l = group.start + group.count; i < l; i += 3) {\n                  renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);\n                }\n              }\n            } else {\n              for (let i = 0, l = indices.length; i < l; i += 3) {\n                renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);\n              }\n            }\n          } else {\n            if (groups.length > 0) {\n              for (let g = 0; g < groups.length; g++) {\n                var group = groups[g];\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;\n                if (material === undefined) continue;\n\n                for (let i = group.start, l = group.start + group.count; i < l; i += 3) {\n                  renderList.pushTriangle(i, i + 1, i + 2, material);\n                }\n              }\n            } else {\n              for (let i = 0, l = positions.length / 3; i < l; i += 3) {\n                renderList.pushTriangle(i, i + 1, i + 2, material);\n              }\n            }\n          }\n        } else if (geometry.isGeometry) {\n          console.error('THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.');\n          return;\n        }\n      } else if (object.isLine) {\n        _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\n\n        if (geometry.isBufferGeometry) {\n          var attributes = geometry.attributes;\n\n          if (attributes.position !== undefined) {\n            var positions = attributes.position.array;\n\n            for (let i = 0, l = positions.length; i < l; i += 3) {\n              renderList.pushVertex(positions[i], positions[i + 1], positions[i + 2]);\n            }\n\n            if (attributes.color !== undefined) {\n              var colors = attributes.color.array;\n\n              for (let i = 0, l = colors.length; i < l; i += 3) {\n                renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);\n              }\n            }\n\n            if (geometry.index !== null) {\n              var indices = geometry.index.array;\n\n              for (let i = 0, l = indices.length; i < l; i += 2) {\n                renderList.pushLine(indices[i], indices[i + 1]);\n              }\n            } else {\n              var step = object.isLineSegments ? 2 : 1;\n\n              for (let i = 0, l = positions.length / 3 - 1; i < l; i += step) {\n                renderList.pushLine(i, i + 1);\n              }\n            }\n          }\n        } else if (geometry.isGeometry) {\n          console.error('THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.');\n          return;\n        }\n      } else if (object.isPoints) {\n        _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\n\n        if (geometry.isGeometry) {\n          console.error('THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.');\n          return;\n        } else if (geometry.isBufferGeometry) {\n          var attributes = geometry.attributes;\n\n          if (attributes.position !== undefined) {\n            var positions = attributes.position.array;\n\n            for (let i = 0, l = positions.length; i < l; i += 3) {\n              _vector4.set(positions[i], positions[i + 1], positions[i + 2], 1);\n\n              _vector4.applyMatrix4(_modelViewProjectionMatrix);\n\n              pushPoint(_vector4, object, camera);\n            }\n          }\n        }\n      } else if (object.isSprite) {\n        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n\n        _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);\n\n        _vector4.applyMatrix4(_viewProjectionMatrix);\n\n        pushPoint(_vector4, object, camera);\n      }\n    }\n\n    if (sortElements === true) {\n      _renderData.elements.sort(painterSort);\n    }\n\n    return _renderData;\n  };\n\n  function pushPoint(_vector4, object, camera) {\n    var invW = 1 / _vector4.w;\n    _vector4.z *= invW;\n\n    if (_vector4.z >= -1 && _vector4.z <= 1) {\n      _sprite = getNextSpriteInPool();\n      _sprite.id = object.id;\n      _sprite.x = _vector4.x * invW;\n      _sprite.y = _vector4.y * invW;\n      _sprite.z = _vector4.z;\n      _sprite.renderOrder = object.renderOrder;\n      _sprite.object = object;\n      _sprite.rotation = object.rotation;\n      _sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector4.x + camera.projectionMatrix.elements[0]) / (_vector4.w + camera.projectionMatrix.elements[12]));\n      _sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector4.y + camera.projectionMatrix.elements[5]) / (_vector4.w + camera.projectionMatrix.elements[13]));\n      _sprite.material = object.material;\n\n      _renderData.elements.push(_sprite);\n    }\n  } // Pools\n\n\n  function getNextObjectInPool() {\n    if (_objectCount === _objectPoolLength) {\n      var object = new RenderableObject();\n\n      _objectPool.push(object);\n\n      _objectPoolLength++;\n      _objectCount++;\n      return object;\n    }\n\n    return _objectPool[_objectCount++];\n  }\n\n  function getNextVertexInPool() {\n    if (_vertexCount === _vertexPoolLength) {\n      var vertex = new RenderableVertex();\n\n      _vertexPool.push(vertex);\n\n      _vertexPoolLength++;\n      _vertexCount++;\n      return vertex;\n    }\n\n    return _vertexPool[_vertexCount++];\n  }\n\n  function getNextFaceInPool() {\n    if (_faceCount === _facePoolLength) {\n      var face = new RenderableFace();\n\n      _facePool.push(face);\n\n      _facePoolLength++;\n      _faceCount++;\n      return face;\n    }\n\n    return _facePool[_faceCount++];\n  }\n\n  function getNextLineInPool() {\n    if (_lineCount === _linePoolLength) {\n      var line = new RenderableLine();\n\n      _linePool.push(line);\n\n      _linePoolLength++;\n      _lineCount++;\n      return line;\n    }\n\n    return _linePool[_lineCount++];\n  }\n\n  function getNextSpriteInPool() {\n    if (_spriteCount === _spritePoolLength) {\n      var sprite = new RenderableSprite();\n\n      _spritePool.push(sprite);\n\n      _spritePoolLength++;\n      _spriteCount++;\n      return sprite;\n    }\n\n    return _spritePool[_spriteCount++];\n  } //\n\n\n  function painterSort(a, b) {\n    if (a.renderOrder !== b.renderOrder) {\n      return a.renderOrder - b.renderOrder;\n    } else if (a.z !== b.z) {\n      return b.z - a.z;\n    } else if (a.id !== b.id) {\n      return a.id - b.id;\n    } else {\n      return 0;\n    }\n  }\n\n  function clipLine(s1, s2) {\n    var alpha1 = 0,\n        alpha2 = 1,\n        // Calculate the boundary coordinate of each vertex for the near and far clip planes,\n    // Z = -1 and Z = +1, respectively.\n    bc1near = s1.z + s1.w,\n        bc2near = s2.z + s2.w,\n        bc1far = -s1.z + s1.w,\n        bc2far = -s2.z + s2.w;\n\n    if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {\n      // Both vertices lie entirely within all clip planes.\n      return true;\n    } else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) {\n      // Both vertices lie entirely outside one of the clip planes.\n      return false;\n    } else {\n      // The line segment spans at least one clip plane.\n      if (bc1near < 0) {\n        // v1 lies outside the near plane, v2 inside\n        alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));\n      } else if (bc2near < 0) {\n        // v2 lies outside the near plane, v1 inside\n        alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));\n      }\n\n      if (bc1far < 0) {\n        // v1 lies outside the far plane, v2 inside\n        alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));\n      } else if (bc2far < 0) {\n        // v2 lies outside the far plane, v2 inside\n        alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));\n      }\n\n      if (alpha2 < alpha1) {\n        // The line segment spans two boundaries, but is outside both of them.\n        // (This can't happen when we're only clipping against just near/far but good\n        //  to leave the check here for future usage if other clip planes are added.)\n        return false;\n      } else {\n        // Update the s1 and s2 vertices to match the clipped line segment.\n        s1.lerp(s2, alpha1);\n        s2.lerp(s1, 1 - alpha2);\n        return true;\n      }\n    }\n  }\n};\n\nexport { Projector, RenderableFace, RenderableLine, RenderableObject, RenderableSprite, RenderableVertex };\n", "import { Object3D, Box2, Color, Vector3, Matrix3, Matrix4, Camera } from 'three';\nimport { Projector, RenderableSprite, RenderableLine, RenderableFace } from './Projector.js';\n\nvar SVGObject = function (node) {\n  Object3D.call(this);\n  this.node = node;\n};\n\nSVGObject.prototype = Object.create(Object3D.prototype);\nSVGObject.prototype.constructor = SVGObject;\n\nvar SVGRenderer = function () {\n  var _this = this,\n      _renderData,\n      _elements,\n      _lights,\n      _projector = new Projector(),\n      _svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),\n      _svgWidth,\n      _svgHeight,\n      _svgWidthHalf,\n      _svgHeightHalf,\n      _v1,\n      _v2,\n      _v3,\n      _clipBox = new Box2(),\n      _elemBox = new Box2(),\n      _color = new Color(),\n      _diffuseColor = new Color(),\n      _ambientLight = new Color(),\n      _directionalLights = new Color(),\n      _pointLights = new Color(),\n      _clearColor = new Color(),\n      _vector3 = new Vector3(),\n      // Needed for PointLight\n  _centroid = new Vector3(),\n      _normal = new Vector3(),\n      _normalViewMatrix = new Matrix3(),\n      _viewMatrix = new Matrix4(),\n      _viewProjectionMatrix = new Matrix4(),\n      _svgPathPool = [],\n      _svgNode,\n      _pathCount = 0,\n      _currentPath,\n      _currentStyle,\n      _quality = 1,\n      _precision = null;\n\n  this.domElement = _svg;\n  this.autoClear = true;\n  this.sortObjects = true;\n  this.sortElements = true;\n  this.overdraw = 0.5;\n  this.info = {\n    render: {\n      vertices: 0,\n      faces: 0\n    }\n  };\n\n  this.setQuality = function (quality) {\n    switch (quality) {\n      case 'high':\n        _quality = 1;\n        break;\n\n      case 'low':\n        _quality = 0;\n        break;\n    }\n  };\n\n  this.setClearColor = function (color) {\n    _clearColor.set(color);\n  };\n\n  this.setPixelRatio = function () {};\n\n  this.setSize = function (width, height) {\n    _svgWidth = width;\n    _svgHeight = height;\n    _svgWidthHalf = _svgWidth / 2;\n    _svgHeightHalf = _svgHeight / 2;\n\n    _svg.setAttribute('viewBox', -_svgWidthHalf + ' ' + -_svgHeightHalf + ' ' + _svgWidth + ' ' + _svgHeight);\n\n    _svg.setAttribute('width', _svgWidth);\n\n    _svg.setAttribute('height', _svgHeight);\n\n    _clipBox.min.set(-_svgWidthHalf, -_svgHeightHalf);\n\n    _clipBox.max.set(_svgWidthHalf, _svgHeightHalf);\n  };\n\n  this.getSize = function () {\n    return {\n      width: _svgWidth,\n      height: _svgHeight\n    };\n  };\n\n  this.setPrecision = function (precision) {\n    _precision = precision;\n  };\n\n  function removeChildNodes() {\n    _pathCount = 0;\n\n    while (_svg.childNodes.length > 0) {\n      _svg.removeChild(_svg.childNodes[0]);\n    }\n  }\n\n  function convert(c) {\n    return _precision !== null ? c.toFixed(_precision) : c;\n  }\n\n  this.clear = function () {\n    removeChildNodes();\n    _svg.style.backgroundColor = _clearColor.getStyle();\n  };\n\n  this.render = function (scene, camera) {\n    if (camera instanceof Camera === false) {\n      console.error('THREE.SVGRenderer.render: camera is not an instance of Camera.');\n      return;\n    }\n\n    var background = scene.background;\n\n    if (background && background.isColor) {\n      removeChildNodes();\n      _svg.style.backgroundColor = background.getStyle();\n    } else if (this.autoClear === true) {\n      this.clear();\n    }\n\n    _this.info.render.vertices = 0;\n    _this.info.render.faces = 0;\n\n    _viewMatrix.copy(camera.matrixWorldInverse);\n\n    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\n\n    _renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements);\n    _elements = _renderData.elements;\n    _lights = _renderData.lights;\n\n    _normalViewMatrix.getNormalMatrix(camera.matrixWorldInverse);\n\n    calculateLights(_lights); // reset accumulated path\n\n    _currentPath = '';\n    _currentStyle = '';\n\n    for (let e = 0, el = _elements.length; e < el; e++) {\n      var element = _elements[e];\n      var material = element.material;\n      if (material === undefined || material.opacity === 0) continue;\n\n      _elemBox.makeEmpty();\n\n      if (element instanceof RenderableSprite) {\n        _v1 = element;\n        _v1.x *= _svgWidthHalf;\n        _v1.y *= -_svgHeightHalf;\n        renderSprite(_v1, element, material);\n      } else if (element instanceof RenderableLine) {\n        _v1 = element.v1;\n        _v2 = element.v2;\n        _v1.positionScreen.x *= _svgWidthHalf;\n        _v1.positionScreen.y *= -_svgHeightHalf;\n        _v2.positionScreen.x *= _svgWidthHalf;\n        _v2.positionScreen.y *= -_svgHeightHalf;\n\n        _elemBox.setFromPoints([_v1.positionScreen, _v2.positionScreen]);\n\n        if (_clipBox.intersectsBox(_elemBox) === true) {\n          renderLine(_v1, _v2, element, material);\n        }\n      } else if (element instanceof RenderableFace) {\n        _v1 = element.v1;\n        _v2 = element.v2;\n        _v3 = element.v3;\n        if (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1) continue;\n        if (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1) continue;\n        if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1) continue;\n        _v1.positionScreen.x *= _svgWidthHalf;\n        _v1.positionScreen.y *= -_svgHeightHalf;\n        _v2.positionScreen.x *= _svgWidthHalf;\n        _v2.positionScreen.y *= -_svgHeightHalf;\n        _v3.positionScreen.x *= _svgWidthHalf;\n        _v3.positionScreen.y *= -_svgHeightHalf;\n\n        if (this.overdraw > 0) {\n          expand(_v1.positionScreen, _v2.positionScreen, this.overdraw);\n          expand(_v2.positionScreen, _v3.positionScreen, this.overdraw);\n          expand(_v3.positionScreen, _v1.positionScreen, this.overdraw);\n        }\n\n        _elemBox.setFromPoints([_v1.positionScreen, _v2.positionScreen, _v3.positionScreen]);\n\n        if (_clipBox.intersectsBox(_elemBox) === true) {\n          renderFace3(_v1, _v2, _v3, element, material);\n        }\n      }\n    }\n\n    flushPath(); // just to flush last svg:path\n\n    scene.traverseVisible(function (object) {\n      if (object instanceof SVGObject) {\n        _vector3.setFromMatrixPosition(object.matrixWorld);\n\n        _vector3.applyMatrix4(_viewProjectionMatrix);\n\n        if (_vector3.z < -1 || _vector3.z > 1) return;\n        var x = _vector3.x * _svgWidthHalf;\n        var y = -_vector3.y * _svgHeightHalf;\n        var node = object.node;\n        node.setAttribute('transform', 'translate(' + x + ',' + y + ')');\n\n        _svg.appendChild(node);\n      }\n    });\n  };\n\n  function calculateLights(lights) {\n    _ambientLight.setRGB(0, 0, 0);\n\n    _directionalLights.setRGB(0, 0, 0);\n\n    _pointLights.setRGB(0, 0, 0);\n\n    for (let l = 0, ll = lights.length; l < ll; l++) {\n      var light = lights[l];\n      var lightColor = light.color;\n\n      if (light.isAmbientLight) {\n        _ambientLight.r += lightColor.r;\n        _ambientLight.g += lightColor.g;\n        _ambientLight.b += lightColor.b;\n      } else if (light.isDirectionalLight) {\n        _directionalLights.r += lightColor.r;\n        _directionalLights.g += lightColor.g;\n        _directionalLights.b += lightColor.b;\n      } else if (light.isPointLight) {\n        _pointLights.r += lightColor.r;\n        _pointLights.g += lightColor.g;\n        _pointLights.b += lightColor.b;\n      }\n    }\n  }\n\n  function calculateLight(lights, position, normal, color) {\n    for (let l = 0, ll = lights.length; l < ll; l++) {\n      var light = lights[l];\n      var lightColor = light.color;\n\n      if (light.isDirectionalLight) {\n        var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld).normalize();\n\n        var amount = normal.dot(lightPosition);\n        if (amount <= 0) continue;\n        amount *= light.intensity;\n        color.r += lightColor.r * amount;\n        color.g += lightColor.g * amount;\n        color.b += lightColor.b * amount;\n      } else if (light.isPointLight) {\n        var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld);\n\n        var amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize());\n        if (amount <= 0) continue;\n        amount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1);\n        if (amount == 0) continue;\n        amount *= light.intensity;\n        color.r += lightColor.r * amount;\n        color.g += lightColor.g * amount;\n        color.b += lightColor.b * amount;\n      }\n    }\n  }\n\n  function renderSprite(v1, element, material) {\n    var scaleX = element.scale.x * _svgWidthHalf;\n    var scaleY = element.scale.y * _svgHeightHalf;\n\n    if (material.isPointsMaterial) {\n      scaleX *= material.size;\n      scaleY *= material.size;\n    }\n\n    var path = 'M' + convert(v1.x - scaleX * 0.5) + ',' + convert(v1.y - scaleY * 0.5) + 'h' + convert(scaleX) + 'v' + convert(scaleY) + 'h' + convert(-scaleX) + 'z';\n    var style = '';\n\n    if (material.isSpriteMaterial || material.isPointsMaterial) {\n      style = 'fill:' + material.color.getStyle() + ';fill-opacity:' + material.opacity;\n    }\n\n    addPath(style, path);\n  }\n\n  function renderLine(v1, v2, element, material) {\n    var path = 'M' + convert(v1.positionScreen.x) + ',' + convert(v1.positionScreen.y) + 'L' + convert(v2.positionScreen.x) + ',' + convert(v2.positionScreen.y);\n\n    if (material.isLineBasicMaterial) {\n      var style = 'fill:none;stroke:' + material.color.getStyle() + ';stroke-opacity:' + material.opacity + ';stroke-width:' + material.linewidth + ';stroke-linecap:' + material.linecap;\n\n      if (material.isLineDashedMaterial) {\n        style = style + ';stroke-dasharray:' + material.dashSize + ',' + material.gapSize;\n      }\n\n      addPath(style, path);\n    }\n  }\n\n  function renderFace3(v1, v2, v3, element, material) {\n    _this.info.render.vertices += 3;\n    _this.info.render.faces++;\n    var path = 'M' + convert(v1.positionScreen.x) + ',' + convert(v1.positionScreen.y) + 'L' + convert(v2.positionScreen.x) + ',' + convert(v2.positionScreen.y) + 'L' + convert(v3.positionScreen.x) + ',' + convert(v3.positionScreen.y) + 'z';\n    var style = '';\n\n    if (material.isMeshBasicMaterial) {\n      _color.copy(material.color);\n\n      if (material.vertexColors) {\n        _color.multiply(element.color);\n      }\n    } else if (material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial) {\n      _diffuseColor.copy(material.color);\n\n      if (material.vertexColors) {\n        _diffuseColor.multiply(element.color);\n      }\n\n      _color.copy(_ambientLight);\n\n      _centroid.copy(v1.positionWorld).add(v2.positionWorld).add(v3.positionWorld).divideScalar(3);\n\n      calculateLight(_lights, _centroid, element.normalModel, _color);\n\n      _color.multiply(_diffuseColor).add(material.emissive);\n    } else if (material.isMeshNormalMaterial) {\n      _normal.copy(element.normalModel).applyMatrix3(_normalViewMatrix).normalize();\n\n      _color.setRGB(_normal.x, _normal.y, _normal.z).multiplyScalar(0.5).addScalar(0.5);\n    }\n\n    if (material.wireframe) {\n      style = 'fill:none;stroke:' + _color.getStyle() + ';stroke-opacity:' + material.opacity + ';stroke-width:' + material.wireframeLinewidth + ';stroke-linecap:' + material.wireframeLinecap + ';stroke-linejoin:' + material.wireframeLinejoin;\n    } else {\n      style = 'fill:' + _color.getStyle() + ';fill-opacity:' + material.opacity;\n    }\n\n    addPath(style, path);\n  } // Hide anti-alias gaps\n\n\n  function expand(v1, v2, pixels) {\n    var x = v2.x - v1.x,\n        y = v2.y - v1.y,\n        det = x * x + y * y,\n        idet;\n    if (det === 0) return;\n    idet = pixels / Math.sqrt(det);\n    x *= idet;\n    y *= idet;\n    v2.x += x;\n    v2.y += y;\n    v1.x -= x;\n    v1.y -= y;\n  }\n\n  function addPath(style, path) {\n    if (_currentStyle === style) {\n      _currentPath += path;\n    } else {\n      flushPath();\n      _currentStyle = style;\n      _currentPath = path;\n    }\n  }\n\n  function flushPath() {\n    if (_currentPath) {\n      _svgNode = getPathNode(_pathCount++);\n\n      _svgNode.setAttribute('d', _currentPath);\n\n      _svgNode.setAttribute('style', _currentStyle);\n\n      _svg.appendChild(_svgNode);\n    }\n\n    _currentPath = '';\n    _currentStyle = '';\n  }\n\n  function getPathNode(id) {\n    if (_svgPathPool[id] == null) {\n      _svgPathPool[id] = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n      if (_quality == 0) {\n        _svgPathPool[id].setAttribute('shape-rendering', 'crispEdges'); //optimizeSpeed\n\n      }\n\n      return _svgPathPool[id];\n    }\n\n    return _svgPathPool[id];\n  }\n};\n\nexport { SVGObject, SVGRenderer };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { DataTexture, RGBAFormat, FloatType, RepeatWrapping, NearestFilter, Mesh, InstancedMesh, Matrix4, DynamicDrawUsage } from 'three';\n\n// Original src: https://github.com/zz85/threejs-path-flow\nconst CHANNELS = 4;\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 4;\n\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\n */\nconst initSplineTexture = (numberOfCurves = 1) => {\n  const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapT = RepeatWrapping;\n  dataTexture.magFilter = NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n};\n/**\n * Write the curve description to the data texture\n *\n * @param { DataTexture } texture The DataTexture to write to\n * @param { Curve } splineCurve The curve to describe\n * @param { number } offset Which curve slot to write to\n */\n\nconst updateSplineTexture = (texture, splineCurve, offset = 0) => {\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  const points = splineCurve.getSpacedPoints(numberOfPoints);\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n\n  for (let i = 0; i < numberOfPoints; i++) {\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    const rowIndex = i % TEXTURE_WIDTH;\n    let pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n\n  texture.needsUpdate = true;\n};\n\nconst setTextureValue = (texture, index, x, y, z, o) => {\n  const image = texture.image;\n  const {\n    data\n  } = image;\n  const i = CHANNELS * TEXTURE_WIDTH * o; // Row Offset\n\n  data[index * CHANNELS + i + 0] = x;\n  data[index * CHANNELS + i + 1] = y;\n  data[index * CHANNELS + i + 2] = z;\n  data[index * CHANNELS + i + 3] = 1;\n};\n\n/**\n * Create a new set of uniforms for describing the curve modifier\n *\n * @param { DataTexture } Texture which holds the curve description\n */\nconst getUniforms = splineTexture => ({\n  spineTexture: {\n    value: splineTexture\n  },\n  pathOffset: {\n    type: 'f',\n    value: 0\n  },\n  // time of path curve\n  pathSegment: {\n    type: 'f',\n    value: 1\n  },\n  // fractional length of path\n  spineOffset: {\n    type: 'f',\n    value: 161\n  },\n  spineLength: {\n    type: 'f',\n    value: 400\n  },\n  flow: {\n    type: 'i',\n    value: 1\n  }\n});\nfunction modifyShader(material, uniforms, numberOfCurves = 1) {\n  if (material.__ok) return;\n  material.__ok = true;\n\n  material.onBeforeCompile = shader => {\n    if (shader.__modified) return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    const vertexShader =\n    /* glsl */\n    `\n\t\tuniform sampler2D spineTexture;\n\t\tuniform float pathOffset;\n\t\tuniform float pathSegment;\n\t\tuniform float spineOffset;\n\t\tuniform float spineLength;\n\t\tuniform int flow;\n\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\n\n\t\t${shader.vertexShader}\n\t\t` // chunk import moved in front of modified shader below\n    .replace('#include <beginnormal_vertex>', '') // vec3 transformedNormal declaration overriden below\n    .replace('#include <defaultnormal_vertex>', '') // vec3 transformed declaration overriden below\n    .replace('#include <begin_vertex>', '') // shader override\n    .replace(/void\\s*main\\s*\\(\\)\\s*\\{/,\n    /* glsl */\n    `\n        void main() {\n        #include <beginnormal_vertex>\n\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\n\n        bool bend = flow > 0;\n        float xWeight = bend ? 0. : 1.;\n\n        #ifdef USE_INSTANCING\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\n        #else\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\n        #endif\n\n        mt = mod(mt, textureStacks);\n        float rowOffset = floor(mt);\n\n        #ifdef USE_INSTANCING\n        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\n        #endif\n\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\n        mat3 basis = mat3(a, b, c);\n\n        vec3 transformed = basis\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\n          + spinePos;\n\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\n\t\t\t`).replace('#include <project_vertex>',\n    /* glsl */\n    `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`);\n    shader.vertexShader = vertexShader;\n  };\n}\n/**\n * A helper class for making meshes bend aroudn curves\n */\n\nclass Flow {\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  constructor(mesh, numberOfCurves = 1) {\n    _defineProperty(this, \"curveArray\", void 0);\n\n    _defineProperty(this, \"curveLengthArray\", void 0);\n\n    _defineProperty(this, \"object3D\", void 0);\n\n    _defineProperty(this, \"splineTexure\", void 0);\n\n    _defineProperty(this, \"uniforms\", void 0);\n\n    const obj3D = mesh.clone();\n    const splineTexure = initSplineTexture(numberOfCurves);\n    const uniforms = getUniforms(splineTexure);\n    obj3D.traverse(child => {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n\n  updateCurve(index, curve) {\n    if (index >= this.curveArray.length) throw Error('Index out of range for Flow');\n    const curveLength = curve.getLength();\n    this.uniforms.spineLength.value = curveLength;\n    this.curveLengthArray[index] = curveLength;\n    this.curveArray[index] = curve;\n    updateSplineTexture(this.splineTexure, curve, index);\n  }\n\n  moveAlongCurve(amount) {\n    this.uniforms.pathOffset.value += amount;\n  }\n\n}\nconst matrix = new Matrix4();\n/**\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\n */\n\nclass InstancedFlow extends Flow {\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  constructor(count, curveCount, geometry, material) {\n    const mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    super(mesh, curveCount);\n\n    _defineProperty(this, \"offsets\", void 0);\n\n    _defineProperty(this, \"whichCurve\", void 0);\n\n    this.offsets = new Array(count).fill(0);\n    this.whichCurve = new Array(count).fill(0);\n  }\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n\n\n  writeChanges(index) {\n    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n    this.object3D.setMatrixAt(index, matrix);\n    this.object3D.instanceMatrix.needsUpdate = true;\n  }\n  /**\n   * Move an individual element along the curve by a specific amount\n   *\n   * @param {number} index Which element to update\n   * @param {number} offset Move by how much\n   */\n\n\n  moveIndividualAlongCurve(index, offset) {\n    this.offsets[index] += offset;\n    this.writeChanges(index);\n  }\n  /**\n   * Select which curve to use for an element\n   *\n   * @param {number} index the index of the instanced element to update\n   * @param {number} curveNo the index of the curve it should use\n   */\n\n\n  setCurve(index, curveNo) {\n    if (isNaN(curveNo)) throw Error('curve index being set is Not a Number (NaN)');\n    this.whichCurve[index] = curveNo;\n    this.writeChanges(index);\n  }\n\n}\n\nexport { Flow, InstancedFlow, getUniforms, initSplineTexture, modifyShader, updateSplineTexture };\n", "import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from 'three';\nimport { getWithKey } from '../types/helpers.js';\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0; // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n      return null;\n    } // gather attributes, exit early if they're different\n\n\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = [];\n      }\n\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    } // ensure geometries have the same number of attributes\n\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n      return null;\n    } // gather morph attributes, exit early if they're different\n\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n      return null;\n    }\n\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n        return null;\n      }\n\n      if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    } // gather .userData\n\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n\n    if (useGroups) {\n      let count;\n\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n        return null;\n      }\n\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }); // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach(geom => {\n      const index = geom.index;\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  } // merge attributes\n\n\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n\n    if (!mergedAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\n      return null;\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  } // merge morph attributes\n\n\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n\n      if (!mergedMorphAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\n        return null;\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n\n  return mergedGeometry;\n};\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\n\nconst mergeBufferAttributes = attributes => {\n  let TypedArray = undefined;\n  let itemSize = undefined;\n  let normalized = undefined;\n  let arrayLength = 0;\n  attributes.forEach(attr => {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor;\n    }\n\n    if (TypedArray !== attr.array.constructor) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n      return null;\n    }\n\n    if (itemSize === undefined) itemSize = attr.itemSize;\n\n    if (itemSize !== attr.itemSize) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n      return null;\n    }\n\n    if (normalized === undefined) normalized = attr.normalized;\n\n    if (normalized !== attr.normalized) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n      return null;\n    }\n\n    arrayLength += attr.array.length;\n  });\n\n  if (TypedArray && itemSize) {\n    // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach(attr => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\n\nconst interleaveAttributes = attributes => {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray = undefined;\n  let arrayLength = 0;\n  let stride = 0; // calculate the the length and type of the interleavedBuffer\n\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved');\n      return null;\n    }\n\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  } // Create the set of buffer attributes\n  // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n\n\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW'];\n  const setters = ['setX', 'setY', 'setZ', 'setW'];\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n\n  return res;\n};\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\n\nfunction estimateBytesUsed(geometry) {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0;\n\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\n\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute('position');\n  const vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\n\n  let nextIndex = 0; // attributes and new attribute arrays\n\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\n\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  } // convert the error tolerance to an amount of decimal places to truncate to\n\n\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'\n\n    let hash = '';\n\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    } // Add another reference to the vertex if it's already\n    // used by another index\n\n\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k]; // @ts-ignore\n\n          newarray.push(attribute[getterFunc](index));\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  } // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n\n\n  const result = geometry.clone();\n\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name); //@ts-expect-error  something to do with functions and constructors and new\n\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute); // Update the attribute arrays\n\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j]; //@ts-expect-error something to do with functions and constructors and new\n\n        const buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  } // indices\n\n\n  result.setIndex(newIndices);\n  return result;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\n\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n    return geometry;\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex(); // generate index if not present\n\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute('position');\n\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    } //\n\n\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    } // build final geometry\n\n\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n    return geometry;\n  }\n}\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\n\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\n    return null;\n  }\n\n  const _vA = new Vector3();\n\n  const _vB = new Vector3();\n\n  const _vC = new Vector3();\n\n  const _tempA = new Vector3();\n\n  const _tempB = new Vector3();\n\n  const _tempC = new Vector3();\n\n  const _morphA = new Vector3();\n\n  const _morphB = new Vector3();\n\n  const _morphC = new Vector3();\n\n  function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a);\n\n    _vB.fromBufferAttribute(attribute, b);\n\n    _vC.fromBufferAttribute(attribute, c);\n\n    const morphInfluences = object.morphTargetInfluences;\n\n    if ( // @ts-expect-error\n    material.morphTargets && morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n\n      _morphB.set(0, 0, 0);\n\n      _morphC.set(0, 0, 0);\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i];\n        const morph = morphAttribute[i];\n        if (influence === 0) continue;\n\n        _tempA.fromBufferAttribute(morph, a);\n\n        _tempB.fromBufferAttribute(morph, b);\n\n        _tempC.fromBufferAttribute(morph, c);\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence);\n\n          _morphB.addScaledVector(_tempB, influence);\n\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n\n      _vA.add(_morphA);\n\n      _vB.add(_morphB);\n\n      _vC.add(_morphC);\n    }\n\n    if (object.isSkinnedMesh) {\n      // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n\n      object.boneTransform(b, _vB); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n\n      object.boneTransform(c, _vC);\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\n  }\n\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n\n  if (index !== null) {\n    // indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute\n  };\n}\n\nexport { computeMorphedAttributes, estimateBytesUsed, interleaveAttributes, mergeBufferAttributes, mergeBufferGeometries, mergeVertices, toTrianglesDrawMode };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { mergeVertices } from '../utils/BufferGeometryUtils.js';\n\nconst cb = new Vector3(),\n      ab = new Vector3();\n\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\n\nfunction removeFromArray(array, object) {\n  const k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\n\nclass Vertex {\n  constructor(v, id) {\n    _defineProperty(this, \"position\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"faces\", void 0);\n\n    _defineProperty(this, \"neighbors\", void 0);\n\n    _defineProperty(this, \"collapseCost\", void 0);\n\n    _defineProperty(this, \"collapseNeighbor\", void 0);\n\n    _defineProperty(this, \"minCost\", 0);\n\n    _defineProperty(this, \"totalCost\", 0);\n\n    _defineProperty(this, \"costCount\", 0);\n\n    this.position = v;\n    this.id = id; // old index id\n\n    this.faces = []; // faces vertex is connected\n\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n    // these will be computed in computeEdgeCostAtVertex()\n\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n\n  addUniqueNeighbor(vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  }\n\n  removeIfNonNeighbor(n) {\n    const neighbors = this.neighbors;\n    const faces = this.faces;\n    const offset = neighbors.indexOf(n);\n    if (offset === -1) return;\n\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return;\n    }\n\n    neighbors.splice(offset, 1);\n  }\n\n} // we use a triangle class to represent structure of face slightly differently\n\n\nclass Triangle {\n  constructor(v1, v2, v3, a, b, c) {\n    _defineProperty(this, \"a\", void 0);\n\n    _defineProperty(this, \"b\", void 0);\n\n    _defineProperty(this, \"c\", void 0);\n\n    _defineProperty(this, \"v1\", void 0);\n\n    _defineProperty(this, \"v2\", void 0);\n\n    _defineProperty(this, \"v3\", void 0);\n\n    _defineProperty(this, \"normal\", new Vector3());\n\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n\n  computeNormal() {\n    const vA = this.v1.position;\n    const vB = this.v2.position;\n    const vC = this.v3.position;\n    cb.subVectors(vC, vB);\n    ab.subVectors(vA, vB);\n    cb.cross(ab).normalize();\n    this.normal.copy(cb);\n  }\n\n  hasVertex(v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  }\n\n  replaceVertex(oldv, newv) {\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  }\n\n}\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\n\nclass SimplifyModifier {\n  constructor() {\n    _defineProperty(this, \"computeEdgeCollapseCost\", (u, v) => {\n      // if we collapse edge uv by moving u to v then how\n      // much different will the model change, i.e. the \"error\".\n      const edgelength = v.position.distanceTo(u.position);\n      let curvature = 0;\n      const sideFaces = [];\n      let i,\n          il = u.faces.length,\n          face,\n          sideFace; // find the \"sides\" triangles that are on the edge uv\n\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      } // use the triangle facing most away from the sides\n      // to determine our curvature term\n\n\n      for (i = 0; i < il; i++) {\n        let minCurvature = 1;\n        face = u.faces[i];\n\n        for (let j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j]; // use dot product of face normals.\n\n          const dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n\n        curvature = Math.max(curvature, minCurvature);\n      } // crude approach in attempt to preserve borders\n      // though it seems not to be totally correct\n\n\n      const borders = 0;\n\n      if (sideFaces.length < 2) {\n        // we add some arbitrary cost for borders,\n        // borders += 10;\n        curvature = 1;\n      }\n\n      const amt = edgelength * curvature + borders;\n      return amt;\n    });\n\n    _defineProperty(this, \"computeEdgeCostAtVertex\", v => {\n      // compute the edge collapse cost for all edges that start\n      // from vertex v.  Since we are only interested in reducing\n      // the object by selecting the min cost edge at each step, we\n      // only cache the cost of the least cost edge at this vertex\n      // (in member variable collapse) as well as the value of the\n      // cost (in member variable collapseCost).\n      if (v.neighbors.length === 0) {\n        // collapse if no neighbors.\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n\n      v.collapseCost = 100000;\n      v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\n\n      for (let i = 0; i < v.neighbors.length; i++) {\n        const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i]);\n\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n\n        v.costCount++;\n        v.totalCost += collapseCost;\n\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      } // we average the cost of collapsing at this vertex\n\n\n      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\n    });\n\n    _defineProperty(this, \"removeFace\", (f, faces) => {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\n\n      const vs = [f.v1, f.v2, f.v3];\n      let v1, v2;\n\n      for (let i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n\n    _defineProperty(this, \"collapse\", (vertices, faces, u, v) => {\n      // u and v are pointers to vertices of an edge\n      // Collapse the edge uv by moving vertex u onto v\n      if (!v) {\n        // u is a vertex all by itself so just delete it..\n        this.removeVertex(u, vertices);\n        return;\n      }\n\n      let i;\n      const tmpVertices = [];\n\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      } // delete triangles on edge uv:\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          this.removeFace(u.faces[i], faces);\n        }\n      } // update remaining triangles to have v instead of u\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n\n      this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\n\n      for (i = 0; i < tmpVertices.length; i++) {\n        this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n\n    _defineProperty(this, \"minimumCostEdge\", vertices => {\n      // O(n * n) approach. TODO optimize this\n      let least = vertices[0];\n\n      for (let i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n\n      return least;\n    });\n\n    _defineProperty(this, \"modify\", (geometry, count) => {\n      geometry = geometry.clone();\n      const attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n      for (let name in attributes) {\n        if (name !== 'position') geometry.deleteAttribute(name);\n      }\n\n      geometry = mergeVertices(geometry); //\n      // put data of original geometry in different data structures\n      //\n\n      const vertices = [];\n      const faces = []; // add vertices\n\n      const positionAttribute = geometry.getAttribute('position');\n\n      for (let i = 0; i < positionAttribute.count; i++) {\n        const v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        const vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      } // add faces\n\n\n      const geomIndex = geometry.getIndex();\n\n      if (geomIndex !== null) {\n        for (let i = 0; i < geomIndex.count; i += 3) {\n          const a = geomIndex.getX(i);\n          const b = geomIndex.getX(i + 1);\n          const c = geomIndex.getX(i + 2);\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const a = i;\n          const b = i + 1;\n          const c = i + 2;\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } // compute all edge collapse costs\n\n\n      for (let i = 0, il = vertices.length; i < il; i++) {\n        this.computeEdgeCostAtVertex(vertices[i]);\n      }\n\n      let nextVertex;\n      let z = count;\n\n      while (z--) {\n        nextVertex = this.minimumCostEdge(vertices);\n\n        if (!nextVertex) {\n          console.log('THREE.SimplifyModifier: No next vertex');\n          break;\n        } else {\n          this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      } //\n\n\n      const simplifiedGeometry = new BufferGeometry();\n      const position = [];\n      let index = []; //\n\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i].position;\n        position.push(vertex.x, vertex.y, vertex.z);\n      } //\n\n\n      for (let i = 0; i < faces.length; i++) {\n        const face = faces[i];\n        const a = vertices.indexOf(face.v1);\n        const b = vertices.indexOf(face.v2);\n        const c = vertices.indexOf(face.v3);\n        index.push(a, b, c);\n      } //\n\n\n      simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n\n  removeVertex(v, vertices) {\n    console.assert(v.faces.length === 0);\n\n    while (v.neighbors.length) {\n      const n = v.neighbors.pop();\n      removeFromArray(n.neighbors, v);\n    }\n\n    removeFromArray(vertices, v);\n  }\n\n}\n\nexport { SimplifyModifier };\n", "const NodeShaderStage = {\n  Vertex: 'vertex',\n  Fragment: 'fragment'\n};\nconst NodeUpdateType = {\n  None: 'none',\n  Frame: 'frame',\n  Object: 'object'\n};\n\nexport { NodeShaderStage, NodeUpdateType };\n", "import { Color, Vector2, Vector3, Vector4, Matrix3, Matrix4 } from 'three';\n\nconst getNodesKeys = object => {\n  const props = [];\n\n  for (const name in object) {\n    const value = object[name];\n\n    if (value && value.isNode === true) {\n      props.push(name);\n    }\n  }\n\n  return props;\n};\nconst getValueType = value => {\n  if (typeof value === 'number') {\n    return 'float';\n  } else if (typeof value === 'boolean') {\n    return 'bool';\n  } else if ((value === null || value === void 0 ? void 0 : value.isVector2) === true) {\n    return 'vec2';\n  } else if ((value === null || value === void 0 ? void 0 : value.isVector3) === true) {\n    return 'vec3';\n  } else if ((value === null || value === void 0 ? void 0 : value.isVector4) === true) {\n    return 'vec4';\n  } else if ((value === null || value === void 0 ? void 0 : value.isMatrix3) === true) {\n    return 'mat3';\n  } else if ((value === null || value === void 0 ? void 0 : value.isMatrix4) === true) {\n    return 'mat4';\n  } else if ((value === null || value === void 0 ? void 0 : value.isColor) === true) {\n    return 'color';\n  }\n\n  return null;\n};\nconst getValueFromType = (type, ...params) => {\n  const last4 = type === null || type === void 0 ? void 0 : type.slice(-4);\n\n  if (type === 'color') {\n    return new Color(...params);\n  } else if (last4 === 'vec2') {\n    return new Vector2(...params);\n  } else if (last4 === 'vec3') {\n    return new Vector3(...params);\n  } else if (last4 === 'vec4') {\n    return new Vector4(...params);\n  } else if (last4 === 'mat3') {\n    return new Matrix3(...params);\n  } else if (last4 === 'mat4') {\n    return new Matrix4(...params);\n  } else if (type === 'bool') {\n    return false;\n  } else if (type === 'float' || type === 'int' || type === 'uint') {\n    return 0;\n  }\n\n  return null;\n};\n\nexport { getNodesKeys, getValueFromType, getValueType };\n", "import { NodeUpdateType } from './constants.js';\nimport { getNodesKeys } from './NodeUtils.js';\nimport { MathUtils } from 'three';\n\nlet _nodeId = 0;\n\nclass Node {\n  constructor(nodeType = null) {\n    this.nodeType = nodeType;\n    this.updateType = NodeUpdateType.None;\n    this.uuid = MathUtils.generateUUID();\n    Object.defineProperty(this, 'id', {\n      value: _nodeId++\n    });\n  }\n\n  get type() {\n    return this.constructor.name;\n  }\n\n  getHash() {\n    return this.uuid;\n  }\n\n  getUpdateType() {\n    return this.updateType;\n  }\n\n  getNodeType() {\n    return this.nodeType;\n  }\n\n  update() {\n    console.warn('Abstract function.');\n  }\n\n  generate() {\n    console.warn('Abstract function.');\n  }\n\n  analyze(builder) {\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.analyze(builder);\n    }\n\n    const nodeData = builder.getDataFromNode(this);\n    nodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\n    const nodeKeys = getNodesKeys(this);\n\n    for (const property of nodeKeys) {\n      this[property].analyze(builder);\n    }\n  }\n\n  build(builder, output = null) {\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.build(builder, output);\n    }\n\n    builder.addNode(this);\n    builder.addStack(this);\n    const nodeData = builder.getDataFromNode(this);\n    const isGenerateOnce = this.generate.length === 1;\n    let snippet = null;\n\n    if (isGenerateOnce) {\n      const type = this.getNodeType(builder);\n      snippet = nodeData.snippet;\n\n      if (snippet === undefined) {\n        snippet = this.generate(builder) || '';\n        nodeData.snippet = snippet;\n      }\n\n      snippet = builder.format(snippet, type, output);\n    } else {\n      snippet = this.generate(builder, output) || '';\n    }\n\n    builder.removeStack(this);\n    return snippet;\n  }\n\n  serialize(json) {\n    const nodeKeys = getNodesKeys(this);\n\n    if (nodeKeys.length > 0) {\n      const inputNodes = {};\n\n      for (const property of nodeKeys) {\n        inputNodes[property] = this[property].toJSON(json.meta).uuid;\n      }\n\n      json.inputNodes = inputNodes;\n    }\n  }\n\n  deserialize(json) {\n    if (json.inputNodes !== undefined) {\n      const nodes = json.meta.nodes;\n\n      for (const property in json.inputNodes) {\n        const uuid = json.inputNodes[property];\n        this[property] = nodes[uuid];\n      }\n    }\n  }\n\n  toJSON(meta) {\n    const {\n      uuid,\n      type\n    } = this;\n    const isRoot = meta === undefined || typeof meta === 'string';\n\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    } // serialize\n\n\n    let data = meta.nodes[uuid];\n\n    if (data === undefined) {\n      data = {\n        uuid,\n        type,\n        meta,\n        metadata: {\n          version: 4.5,\n          type: 'Node',\n          generator: 'Node.toJSON'\n        }\n      };\n      meta.nodes[data.uuid] = data;\n      this.serialize(data);\n      delete data.meta;\n    } // TODO: Copied from Object3D.toJSON\n\n\n    function extractFromCache(cache) {\n      const values = [];\n\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n\n    return data;\n  }\n\n}\n\nNode.prototype.isNode = true;\n\nexport default Node;\n", "import Node from './Node.js';\nimport { getValueType, getValueFromType } from './NodeUtils.js';\n\nclass InputNode extends Node {\n  constructor(value, nodeType = null) {\n    super(nodeType);\n    this.value = value;\n  }\n\n  getNodeType() {\n    if (this.nodeType === null) {\n      return getValueType(this.value);\n    }\n\n    return this.nodeType;\n  }\n\n  getInputType(builder) {\n    return this.getNodeType(builder);\n  }\n\n  serialize(data) {\n    var _this$value, _this$value$toArray;\n\n    super.serialize(data);\n    data.value = ((_this$value = this.value) === null || _this$value === void 0 ? void 0 : (_this$value$toArray = _this$value.toArray) === null || _this$value$toArray === void 0 ? void 0 : _this$value$toArray.call(_this$value)) || this.value;\n    data.valueType = getValueType(this.value);\n    data.nodeType = this.nodeType;\n  }\n\n  deserialize(data) {\n    var _this$value2, _this$value2$fromArra;\n\n    super.deserialize(data);\n    this.nodeType = data.nodeType;\n    this.value = getValueFromType(data.valueType);\n    this.value = ((_this$value2 = this.value) === null || _this$value2 === void 0 ? void 0 : (_this$value2$fromArra = _this$value2.fromArray) === null || _this$value2$fromArra === void 0 ? void 0 : _this$value2$fromArra.call(_this$value2, data.value)) || data.value;\n  }\n\n  generate() {\n    console.warn('Abstract function.');\n  }\n\n}\n\nInputNode.prototype.isInputNode = true;\n\nexport default InputNode;\n", "import InputNode from './InputNode.js';\n\nclass UniformNode extends InputNode {\n  getUniformHash(builder) {\n    return this.getHash(builder);\n  }\n\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    const hash = this.getUniformHash(builder);\n    let sharedNode = builder.getNodeFromHash(hash);\n\n    if (sharedNode === undefined) {\n      builder.setHashNode(this, hash);\n      sharedNode = this;\n    }\n\n    const sharedNodeType = sharedNode.getInputType(builder);\n    const nodeUniform = builder.getUniformFromNode(sharedNode, builder.shaderStage, sharedNodeType);\n    const propertyName = builder.getPropertyName(nodeUniform);\n    return builder.format(propertyName, type, output);\n  }\n\n}\n\nUniformNode.prototype.isUniformNode = true;\n\nexport default UniformNode;\n", "import UniformNode from './UniformNode.js';\n\nclass ArrayUniformNode extends UniformNode {\n  constructor(nodes = []) {\n    super();\n    this.nodes = nodes;\n  }\n\n  getNodeType(builder) {\n    return this.nodes[0].getNodeType(builder);\n  }\n\n}\n\nArrayUniformNode.prototype.isArrayUniformNode = true;\n\nexport default ArrayUniformNode;\n", "import Node from './Node.js';\nimport { NodeShaderStage } from './constants.js';\n\nclass VaryNode extends Node {\n  constructor(node, name = null) {\n    super();\n    this.node = node;\n    this.name = name;\n  }\n\n  getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n\n  getNodeType(builder) {\n    // VaryNode is auto type\n    return this.node.getNodeType(builder);\n  }\n\n  generate(builder) {\n    const type = this.getNodeType(builder);\n    const node = this.node;\n    const name = this.name;\n    const nodeVary = builder.getVaryFromNode(this, type);\n\n    if (name !== null) {\n      nodeVary.name = name;\n    }\n\n    const propertyName = builder.getPropertyName(nodeVary, NodeShaderStage.Vertex); // force node run in vertex stage\n\n    builder.flowNodeFromShaderStage(NodeShaderStage.Vertex, node, type, propertyName);\n    return builder.getPropertyName(nodeVary);\n  }\n\n}\n\nexport default VaryNode;\n", "import Node from './Node.js';\nimport VaryNode from './VaryNode.js';\n\nclass AttributeNode extends Node {\n  constructor(attributeName, nodeType) {\n    super(nodeType);\n    this._attributeName = attributeName;\n  }\n\n  getHash(builder) {\n    return this.getAttributeName(builder);\n  }\n\n  setAttributeName(attributeName) {\n    this._attributeName = attributeName;\n    return this;\n  }\n\n  getAttributeName() {\n    return this._attributeName;\n  }\n\n  generate(builder) {\n    const attribute = builder.getAttribute(this.getAttributeName(builder), this.getNodeType(builder));\n\n    if (builder.isShaderStage('vertex')) {\n      return attribute.name;\n    } else {\n      const nodeVary = new VaryNode(this);\n      return nodeVary.build(builder, attribute.type);\n    }\n  }\n\n}\n\nexport default AttributeNode;\n", "import Node from './Node.js';\n\nclass BypassNode extends Node {\n  constructor(returnNode, callNode) {\n    super();\n    this.outputNode = returnNode;\n    this.callNode = callNode;\n  }\n\n  getNodeType(builder) {\n    return this.outputNode.getNodeType(builder);\n  }\n\n  generate(builder, output) {\n    const snippet = this.callNode.build(builder, 'void');\n\n    if (snippet !== '') {\n      builder.addFlowCode(snippet);\n    }\n\n    return this.outputNode.build(builder, output);\n  }\n\n}\n\nBypassNode.prototype.isBypassNode = true;\n\nexport default BypassNode;\n", "import Node from './Node.js';\n\nclass CodeNode extends Node {\n  constructor(code = '', nodeType = 'code') {\n    super(nodeType);\n    this.code = code;\n    this._includes = [];\n  }\n\n  setIncludes(includes) {\n    this._includes = includes;\n    return this;\n  }\n\n  getIncludes() {\n    return this._includes;\n  }\n\n  generate(builder) {\n    const includes = this.getIncludes(builder);\n\n    for (const include of includes) {\n      include.build(builder);\n    }\n\n    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));\n    nodeCode.code = this.code;\n    return nodeCode.code;\n  }\n\n}\n\nCodeNode.prototype.isCodeNode = true;\n\nexport default CodeNode;\n", "import InputNode from './InputNode.js';\n\nclass ConstNode extends InputNode {\n  generateConst(builder) {\n    return builder.getConst(this.getNodeType(builder), this.value);\n  }\n\n  generate(builder, output) {\n    const type = this.getNodeType(builder);\n    return builder.format(this.generateConst(builder), type, output);\n  }\n\n}\n\nConstNode.prototype.isConstNode = true;\n\nexport default ConstNode;\n", "import Node from './Node.js';\n\nclass ContextNode extends Node {\n  constructor(node, context = {}) {\n    super();\n    this.node = node;\n    this.context = context;\n  }\n\n  getNodeType(builder) {\n    return this.node.getNodeType(builder);\n  }\n\n  generate(builder, output) {\n    const previousContext = builder.getContext();\n    builder.setContext(Object.assign({}, builder.context, this.context));\n    const snippet = this.node.build(builder, output);\n    builder.setContext(previousContext);\n    return snippet;\n  }\n\n}\n\nContextNode.prototype.isContextNode = true;\n\nexport default ContextNode;\n", "import Node from './Node.js';\n\nclass TempNode extends Node {\n  constructor(type) {\n    super(type);\n  }\n\n  build(builder, output) {\n    const type = builder.getVectorType(this.getNodeType(builder, output));\n    const nodeData = builder.getDataFromNode(this);\n\n    if (builder.context.temp !== false && type !== 'void ' && output !== 'void' && nodeData.dependenciesCount > 1) {\n      if (nodeData.snippet === undefined) {\n        const snippet = super.build(builder, type);\n        const nodeVar = builder.getVarFromNode(this, type);\n        const propertyName = builder.getPropertyName(nodeVar);\n        builder.addFlowCode(`${propertyName} = ${snippet}`);\n        nodeData.snippet = snippet;\n        nodeData.propertyName = propertyName;\n      }\n\n      return builder.format(nodeData.propertyName, type, output);\n    }\n\n    return super.build(builder, output);\n  }\n\n}\n\nexport default TempNode;\n", "import TempNode from './TempNode.js';\n\nclass ExpressionNode extends TempNode {\n  constructor(snipped = '', nodeType = 'void') {\n    super(nodeType);\n    this.snipped = snipped;\n  }\n\n  generate(builder) {\n    const type = this.getNodeType(builder);\n    const snipped = this.snipped;\n\n    if (type === 'void') {\n      builder.addFlowCode(snipped);\n    } else {\n      return `( ${snipped} )`;\n    }\n  }\n\n}\n\nexport default ExpressionNode;\n", "class NodeAttribute {\n  constructor(name, type) {\n    this.name = name;\n    this.type = type;\n  }\n\n}\n\nNodeAttribute.prototype.isNodeAttribute = true;\n\nexport default NodeAttribute;\n", "class NodeUniform {\n  constructor(name, type, node, needsUpdate = undefined) {\n    this.name = name;\n    this.type = type;\n    this.node = node;\n    this.needsUpdate = needsUpdate;\n  }\n\n  get value() {\n    return this.node.value;\n  }\n\n  set value(val) {\n    this.node.value = val;\n  }\n\n}\n\nNodeUniform.prototype.isNodeUniform = true;\n\nexport default NodeUniform;\n", "class NodeVary {\n  constructor(name, type) {\n    this.name = name;\n    this.type = type;\n  }\n\n}\n\nNodeVary.prototype.isNodeVary = true;\n\nexport default NodeVary;\n", "class NodeVar {\n  constructor(name, type) {\n    this.name = name;\n    this.type = type;\n  }\n\n}\n\nNodeVar.prototype.isNodeVar = true;\n\nexport default NodeVar;\n", "import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\n\nconst shaderStages = ['fragment', 'vertex'];\nconst vector = ['x', 'y', 'z', 'w'];\n\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\n\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n\n  addStack(node) {\n    /*\n    if ( this.stack.indexOf( node ) !== - 1 ) {\n    console.warn( 'Recursive node: ', node );\n    }\n    */\n    this.stack.push(node);\n  }\n\n  removeStack(node) {\n    const lastStack = this.stack.pop();\n\n    if (lastStack !== node) {\n      throw new Error('NodeBuilder: Invalid node stack!');\n    }\n  }\n\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n\n  addNode(node) {\n    if (this.nodes.indexOf(node) === -1) {\n      const updateType = node.getUpdateType(this);\n\n      if (updateType !== NodeUpdateType.None) {\n        this.updateNodes.push(node);\n      }\n\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n\n  getMethod(method) {\n    return method;\n  }\n\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n\n  setContext(context) {\n    this.context = context;\n  }\n\n  getContext() {\n    return this.context;\n  }\n\n  getTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getTextureBias() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTextureBias() {\n    console.warn('Abstract function.');\n  } // @TODO: rename to .generateConst()\n\n\n  getConst(type, value) {\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n\n    if (type === 'color') {\n      return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    }\n\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n\n    const getConst = value => this.getConst(componentType, value);\n\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    }\n\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n\n  getType(type) {\n    return type;\n  }\n\n  generateMethod(method) {\n    return method;\n  }\n\n  getAttribute(name, type) {\n    const attributes = this.attributes; // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    } // create a new if no exist\n\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n\n  getPropertyName(node\n  /*, shaderStage*/\n  ) {\n    return node.name;\n  }\n\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler';\n  }\n\n  isShaderStage(shaderStage) {\n    return this.shaderStage === shaderStage;\n  }\n\n  getTextureEncodingFromMap(map) {\n    let encoding;\n\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n\n    return encoding;\n  }\n\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n\n  getTypeFromLength(type) {\n    if (type === 1) return 'float';\n    if (type === 2) return 'vec2';\n    if (type === 3) return 'vec3';\n    if (type === 4) return 'vec4';\n    return 0;\n  }\n\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    return 0;\n  }\n\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n\n  getDataFromNode(node, shaderStage = this.shaderStage) {\n    let nodeData = this.nodesData.get(node);\n\n    if (nodeData === undefined) {\n      nodeData = {\n        vertex: {},\n        fragment: {}\n      };\n      this.nodesData.set(node, nodeData);\n    }\n\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n  }\n\n  getUniformFromNode(node, shaderStage, type) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n\n    return nodeUniform;\n  }\n\n  getVarFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n\n    return nodeVar;\n  }\n\n  getVaryFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, null);\n    let nodeVary = nodeData.vary;\n\n    if (nodeVary === undefined) {\n      const varys = this.varys;\n      const index = varys.length;\n      nodeVary = new NodeVary('nodeVary' + index, type);\n      varys.push(nodeVary);\n      nodeData.vary = nodeVary;\n    }\n\n    return nodeVary;\n  }\n\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n\n    return nodeCode;\n  }\n\n  addFlowCode(code) {\n    this.flow.code += code;\n  }\n\n  getFlowData(shaderStage, node) {\n    return this.flowsData.get(node);\n  }\n\n  flowNode(node) {\n    this.node = node;\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    this.node = null;\n    return flowData;\n  }\n\n  flowChildNode(node, output = null) {\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n\n    if (propertyName !== null) {\n      flowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n    }\n\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n\n  getAttributes() {\n    console.warn('Abstract function.');\n  }\n\n  getVarys() {\n    console.warn('Abstract function.');\n  }\n\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n\n    for (let index = 0; index < vars.length; index++) {\n      const variable = vars[index];\n      snippet += `${variable.type} ${variable.name}; `;\n    }\n\n    return snippet;\n  }\n\n  getUniforms() {\n    console.warn('Abstract function.');\n  }\n\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n\n    return code;\n  }\n\n  getHash() {\n    return this.vertexShader + this.fragmentShader;\n  }\n\n  getShaderStage() {\n    return this.shaderStage;\n  }\n\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n\n  build() {\n    // stage 1: analyze nodes to possible optimization and validation\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        node.analyze(this);\n      }\n    } // stage 2: pre-build vertex code used in fragment shader\n\n\n    if (this.context.vertex && this.context.vertex.isNode) {\n      this.flowNodeFromShaderStage('vertex', this.context.vertex);\n    } // stage 3: generate shader\n\n\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        this.flowNode(node, shaderStage);\n      }\n    }\n\n    this.setShaderStage(null); // stage 4: build code for a specific output\n\n    this.buildCode();\n    return this;\n  }\n\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n\n    if (fromTypeLength === 0) {\n      // fromType is matrix-like\n      const vectorType = this.getVectorFromMatrix(fromType);\n      return this.format(`( ${snippet} * ${this.getType(vectorType)}( 1.0 ) )`, vectorType, toType);\n    }\n\n    if (toTypeLength === 0) {\n      // toType is matrix-like\n      // ignore for now\n      //return `${ this.getType( toType ) }( ${ snippet } )`;\n      return snippet;\n    }\n\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);\n    }\n\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n\n}\n\nexport default NodeBuilder;\nexport { shaderStages, vector };\n", "class NodeFunctionInput {\n  constructor(type, name, count = null, qualifier = '', isConst = false) {\n    this.type = type;\n    this.name = name;\n    this.count = count;\n    this.qualifier = qualifier;\n    this.isConst = isConst;\n  }\n\n}\n\nNodeFunctionInput.isNodeFunctionInput = true;\n\nexport default NodeFunctionInput;\n", "import Node from './Node.js';\n\nclass PropertyNode extends Node {\n  constructor(name = null, nodeType = 'vec4') {\n    super(nodeType);\n    this.name = name;\n  }\n\n  getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n\n  generate(builder) {\n    const nodeVary = builder.getVarFromNode(this, this.getNodeType(builder));\n    const name = this.name;\n\n    if (name !== null) {\n      nodeVary.name = name;\n    }\n\n    return builder.getPropertyName(nodeVary);\n  }\n\n}\n\nexport default PropertyNode;\n", "import Node from './Node.js';\n\nclass VarNode extends Node {\n  constructor(node, name = null, nodeType = null) {\n    super(nodeType);\n    this.node = node;\n    this.name = name;\n  }\n\n  getHash(builder) {\n    return this.name || super.getHash(builder);\n  }\n\n  getNodeType(builder) {\n    return super.getNodeType(builder) || this.node.getNodeType(builder);\n  }\n\n  generate(builder) {\n    const type = builder.getVectorType(this.getNodeType(builder));\n    const node = this.node;\n    const name = this.name;\n    const snippet = node.build(builder, type);\n    const nodeVar = builder.getVarFromNode(this, type);\n\n    if (name !== null) {\n      nodeVar.name = name;\n    }\n\n    const propertyName = builder.getPropertyName(nodeVar);\n    builder.addFlowCode(`${propertyName} = ${snippet}`);\n    return propertyName;\n  }\n\n}\n\nVarNode.prototype.isVarNode = true;\n\nexport default VarNode;\n", "import UniformNode from '../core/UniformNode.js';\n\nclass BufferNode extends UniformNode {\n  constructor(value, bufferType, bufferCount = 0) {\n    super(value, bufferType);\n    this.bufferType = bufferType;\n    this.bufferCount = bufferCount;\n  }\n\n  getInputType() {\n    return 'buffer';\n  }\n\n}\n\nBufferNode.prototype.isBufferNode = true;\n\nexport default BufferNode;\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3 } from 'three';\nimport Node from '../core/Node.js';\nimport UniformNode from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass Object3DNode extends Node {\n  constructor(scope = Object3DNode.VIEW_MATRIX, object3d = null) {\n    super();\n    this.scope = scope;\n    this.object3d = object3d;\n    this.updateType = NodeUpdateType.Object;\n    this._uniformNode = new UniformNode(null);\n  }\n\n  getNodeType() {\n    const scope = this.scope;\n\n    if (scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX) {\n      return 'mat4';\n    } else if (scope === Object3DNode.NORMAL_MATRIX) {\n      return 'mat3';\n    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION) {\n      return 'vec3';\n    }\n  }\n\n  update(frame) {\n    const object = this.object3d !== null ? this.object3d : frame.object;\n    const uniformNode = this._uniformNode;\n    const camera = frame.camera;\n    const scope = this.scope;\n\n    if (scope === Object3DNode.VIEW_MATRIX) {\n      uniformNode.value = object.modelViewMatrix;\n    } else if (scope === Object3DNode.NORMAL_MATRIX) {\n      uniformNode.value = object.normalMatrix;\n    } else if (scope === Object3DNode.WORLD_MATRIX) {\n      uniformNode.value = object.matrixWorld;\n    } else if (scope === Object3DNode.POSITION) {\n      uniformNode.value.setFromMatrixPosition(object.matrixWorld);\n    } else if (scope === Object3DNode.VIEW_POSITION) {\n      uniformNode.value.setFromMatrixPosition(object.matrixWorld);\n      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);\n    }\n  }\n\n  generate(builder) {\n    const scope = this.scope;\n\n    if (scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX) {\n      this._uniformNode.nodeType = 'mat4';\n    } else if (scope === Object3DNode.NORMAL_MATRIX) {\n      this._uniformNode.nodeType = 'mat3';\n    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION) {\n      this._uniformNode.nodeType = 'vec3';\n      this._uniformNode.value = new Vector3();\n    }\n\n    return this._uniformNode.build(builder);\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.scope = this.scope;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.scope = data.scope;\n  }\n\n}\n\n_defineProperty(Object3DNode, \"VIEW_MATRIX\", 'viewMatrix');\n\n_defineProperty(Object3DNode, \"NORMAL_MATRIX\", 'normalMatrix');\n\n_defineProperty(Object3DNode, \"WORLD_MATRIX\", 'worldMatrix');\n\n_defineProperty(Object3DNode, \"POSITION\", 'position');\n\n_defineProperty(Object3DNode, \"VIEW_POSITION\", 'viewPosition');\n\nexport default Object3DNode;\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport Object3DNode from './Object3DNode.js';\n\nclass CameraNode extends Object3DNode {\n  constructor(scope = CameraNode.POSITION) {\n    super(scope);\n  }\n\n  getNodeType(builder) {\n    const scope = this.scope;\n\n    if (scope === CameraNode.PROJECTION_MATRIX) {\n      return 'mat4';\n    }\n\n    return super.getNodeType(builder);\n  }\n\n  update(frame) {\n    const camera = frame.camera;\n    const uniformNode = this._uniformNode;\n    const scope = this.scope;\n\n    if (scope === CameraNode.PROJECTION_MATRIX) {\n      uniformNode.value = camera.projectionMatrix;\n    } else if (scope === CameraNode.VIEW_MATRIX) {\n      uniformNode.value = camera.matrixWorldInverse;\n    } else {\n      this.object3d = camera;\n      super.update(frame);\n    }\n  }\n\n  generate(builder) {\n    const scope = this.scope;\n\n    if (scope === CameraNode.PROJECTION_MATRIX) {\n      this._uniformNode.nodeType = 'mat4';\n    }\n\n    return super.generate(builder);\n  }\n\n}\n\n_defineProperty(CameraNode, \"PROJECTION_MATRIX\", 'projectionMatrix');\n\nexport default CameraNode;\n", "import AttributeNode from '../core/AttributeNode.js';\n\nclass UVNode extends AttributeNode {\n  constructor(index = 0) {\n    super(null, 'vec2');\n    this.index = index;\n  }\n\n  getAttributeName() {\n    const index = this.index;\n    return 'uv' + (index > 0 ? index + 1 : '');\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.index = this.index;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.index = data.index;\n  }\n\n}\n\nUVNode.prototype.isUVNode = true;\n\nexport default UVNode;\n", "import UniformNode from '../core/UniformNode.js';\nimport UVNode from './UVNode.js';\n\nclass TextureNode extends UniformNode {\n  constructor(value, uvNode = new UVNode(), biasNode = null) {\n    super(value, 'vec4');\n    this.uvNode = uvNode;\n    this.biasNode = biasNode;\n  }\n\n  getUniformHash() {\n    return this.value.uuid;\n  }\n\n  getInputType() {\n    return 'texture';\n  }\n\n  generate(builder, output) {\n    const texture = this.value;\n\n    if (!texture || texture.isTexture !== true) {\n      throw new Error('TextureNode: Need a three.js texture.');\n    }\n\n    const textureProperty = super.generate(builder, 'texture');\n\n    if (output === 'sampler') {\n      return textureProperty + '_sampler';\n    } else if (builder.isReference(output)) {\n      return textureProperty;\n    } else {\n      const nodeData = builder.getDataFromNode(this);\n      let snippet = nodeData.snippet;\n\n      if (snippet === undefined) {\n        const uvSnippet = this.uvNode.build(builder, 'vec2');\n        const biasNode = this.biasNode;\n\n        if (biasNode !== null) {\n          const biasSnippet = biasNode.build(builder, 'float');\n          snippet = builder.getTextureBias(textureProperty, uvSnippet, biasSnippet);\n        } else {\n          snippet = builder.getTexture(textureProperty, uvSnippet);\n        }\n\n        nodeData.snippet = snippet;\n      }\n\n      return builder.format(snippet, 'vec4', output);\n    }\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.value = this.value.toJSON(data.meta).uuid;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.value = data.meta.textures[data.value];\n  }\n\n}\n\nTextureNode.prototype.isTextureNode = true;\n\nexport default TextureNode;\n", "import Object3DNode from './Object3DNode.js';\n\nclass ModelNode extends Object3DNode {\n  constructor(scope = ModelNode.VIEW_MATRIX) {\n    super(scope);\n  }\n\n}\n\nexport default ModelNode;\n", "import Node from '../core/Node.js';\n\nclass JoinNode extends Node {\n  constructor(nodes = []) {\n    super();\n    this.nodes = nodes;\n  }\n\n  getNodeType(builder) {\n    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));\n  }\n\n  generate(builder) {\n    const type = this.getNodeType(builder);\n    const nodes = this.nodes;\n    const snippetValues = [];\n\n    for (let i = 0; i < nodes.length; i++) {\n      const input = nodes[i];\n      const inputSnippet = input.build(builder);\n      snippetValues.push(inputSnippet);\n    }\n\n    return `${builder.getType(type)}( ${snippetValues.join(', ')} )`;\n  }\n\n}\n\nexport default JoinNode;\n", "import Node from '../core/Node.js';\nimport { vector } from '../core/NodeBuilder.js';\n\nclass SplitNode extends Node {\n  constructor(node, components = 'x') {\n    super();\n    this.node = node;\n    this.components = components;\n  }\n\n  getVectorLength() {\n    let vectorLength = this.components.length;\n\n    for (const c of this.components) {\n      vectorLength = Math.max(vector.indexOf(c) + 1, vectorLength);\n    }\n\n    return vectorLength;\n  }\n\n  getNodeType(builder) {\n    return builder.getTypeFromLength(this.components.length);\n  }\n\n  generate(builder) {\n    const node = this.node;\n    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));\n\n    if (nodeTypeLength > 1) {\n      let type = null;\n      const componentsLength = this.getVectorLength();\n\n      if (componentsLength >= nodeTypeLength) {\n        // need expand the input node\n        type = builder.getTypeFromLength(this.getVectorLength());\n      }\n\n      const nodeSnippet = node.build(builder, type);\n      return `${nodeSnippet}.${this.components}`;\n    } else {\n      // ignore components if node is a float\n      return node.build(builder);\n    }\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.components = this.components;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.components = data.components;\n  }\n\n}\n\nexport default SplitNode;\n", "import TempNode from '../core/TempNode.js';\n\nclass OperatorNode extends TempNode {\n  constructor(op, aNode, bNode, ...params) {\n    super();\n    this.op = op;\n\n    if (params.length > 0) {\n      let finalBNode = bNode;\n\n      for (let i = 0; i < params.length; i++) {\n        finalBNode = new OperatorNode(op, finalBNode, params[i]);\n      }\n\n      bNode = finalBNode;\n    }\n\n    this.aNode = aNode;\n    this.bNode = bNode;\n  }\n\n  getNodeType(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const typeA = aNode.getNodeType(builder);\n    const typeB = bNode.getNodeType(builder);\n\n    if (typeA === 'void' || typeB === 'void') {\n      return 'void';\n    } else if (op === '=' || op === '%') {\n      return typeA;\n    } else if (op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<') {\n      return 'int';\n    } else if (op === '==' || op === '&&' || op === '||' || op === '^^') {\n      return 'bool';\n    } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\n      const typeLength = builder.getTypeLength(output);\n      return typeLength > 1 ? `bvec${typeLength}` : 'bool';\n    } else {\n      if (typeA === 'float' && builder.isMatrix(typeB)) {\n        return typeB;\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n        return builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n        return builder.getVectorFromMatrix(typeB);\n      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {\n        // anytype x anytype: use the greater length vector\n        return typeB;\n      }\n\n      return typeA;\n    }\n  }\n\n  generate(builder, output) {\n    const op = this.op;\n    const aNode = this.aNode;\n    const bNode = this.bNode;\n    const type = this.getNodeType(builder, output);\n    let typeA = null;\n    let typeB = null;\n\n    if (type !== 'void') {\n      typeA = aNode.getNodeType(builder);\n      typeB = bNode.getNodeType(builder);\n\n      if (op === '=') {\n        typeB = typeA;\n      } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\n        if (builder.isVector(typeA)) {\n          typeB = typeA;\n        } else {\n          typeA = typeB = 'float';\n        }\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\n        // matrix x vector\n        typeB = builder.getVectorFromMatrix(typeA);\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\n        // vector x matrix\n        typeA = builder.getVectorFromMatrix(typeB);\n      } else {\n        // anytype x anytype\n        typeA = typeB = type;\n      }\n    } else {\n      typeA = typeB = type;\n    }\n\n    const a = aNode.build(builder, typeA);\n    const b = bNode.build(builder, typeB);\n    const outputLength = builder.getTypeLength(output);\n\n    if (output !== 'void') {\n      if (op === '=') {\n        builder.addFlowCode(`${a} ${this.op} ${b}`);\n        return a;\n      } else if (op === '>' && outputLength > 1) {\n        return builder.format(`${builder.getMethod('greaterThan')}( ${a}, ${b} )`, type, output);\n      } else if (op === '<=' && outputLength > 1) {\n        return builder.format(`${builder.getMethod('lessThanEqual')}( ${a}, ${b} )`, type, output);\n      } else {\n        return builder.format(`( ${a} ${this.op} ${b} )`, type, output);\n      }\n    } else if (typeA !== 'void') {\n      return builder.format(`${a} ${this.op} ${b}`, type, output);\n    }\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.op = this.op;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.op = data.op;\n  }\n\n}\n\nexport default OperatorNode;\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport TempNode from '../core/TempNode.js';\nimport ExpressionNode from '../core/ExpressionNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport OperatorNode from './OperatorNode.js';\n\nclass MathNode extends TempNode {\n  // 1 input\n  // 2 inputs\n  // 3 inputs\n  constructor(method, aNode, bNode = null, cNode = null) {\n    super();\n    this.method = method;\n    this.aNode = aNode;\n    this.bNode = bNode;\n    this.cNode = cNode;\n  }\n\n  getInputType(builder) {\n    const aType = this.aNode.getNodeType(builder);\n    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;\n    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;\n    const aLen = builder.getTypeLength(aType);\n    const bLen = builder.getTypeLength(bType);\n    const cLen = builder.getTypeLength(cType);\n\n    if (aLen > bLen && aLen > cLen) {\n      return aType;\n    } else if (bLen > cLen) {\n      return bType;\n    } else if (cLen > aLen) {\n      return cType;\n    }\n\n    return aType;\n  }\n\n  getNodeType(builder) {\n    const method = this.method;\n\n    if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {\n      return 'float';\n    } else if (method === MathNode.CROSS) {\n      return 'vec3';\n    } else {\n      return this.getInputType(builder);\n    }\n  }\n\n  generate(builder, output) {\n    const method = this.method;\n    const type = this.getNodeType(builder);\n    const inputType = this.getInputType(builder);\n    const a = this.aNode;\n    const b = this.bNode;\n    const c = this.cNode;\n    const isWebGL = builder.renderer.isWebGLRenderer === true;\n\n    if (isWebGL && (method === MathNode.DFDX || method === MathNode.DFDY) && output === 'vec3') {\n      // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n      return new JoinNode([new MathNode(method, new SplitNode(a, 'x')), new MathNode(method, new SplitNode(a, 'y')), new MathNode(method, new SplitNode(a, 'z'))]).build(builder);\n    } else if (method === MathNode.TRANSFORM_DIRECTION) {\n      // dir can be either a direction vector or a normal vector\n      // upper-left 3x3 of matrix is assumed to be orthogonal\n      let tA = a;\n      let tB = b;\n\n      if (builder.isMatrix(tA.getNodeType(builder))) {\n        tB = new ExpressionNode(`${builder.getType('vec4')}( ${tB.build(builder, 'vec3')}, 0.0 )`, 'vec4');\n      } else {\n        tA = new ExpressionNode(`${builder.getType('vec4')}( ${tA.build(builder, 'vec3')}, 0.0 )`, 'vec4');\n      }\n\n      const mulNode = new SplitNode(new OperatorNode('*', tA, tB), 'xyz');\n      return new MathNode(MathNode.NORMALIZE, mulNode).build(builder);\n    } else if (method === MathNode.SATURATE) {\n      return builder.format(`clamp( ${a.build(builder, inputType)}, 0.0, 1.0 )`, type, output);\n    } else if (method === MathNode.NEGATE) {\n      return builder.format('( -' + a.build(builder, inputType) + ' )', type, output);\n    } else if (method === MathNode.INVERT) {\n      return builder.format('( 1.0 - ' + a.build(builder, inputType) + ' )', type, output);\n    } else {\n      const params = [];\n\n      if (method === MathNode.CROSS) {\n        params.push(a.build(builder, type), b.build(builder, type));\n      } else if (method === MathNode.STEP) {\n        params.push(a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? 'float' : inputType), b.build(builder, inputType));\n      } else if (isWebGL && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {\n        params.push(a.build(builder, inputType), b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? 'float' : inputType));\n      } else if (method === MathNode.REFRACT) {\n        params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, 'float'));\n      } else if (method === MathNode.MIX) {\n        params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? 'float' : inputType));\n      } else {\n        params.push(a.build(builder, inputType));\n\n        if (c !== null) {\n          params.push(b.build(builder, inputType), c.build(builder, inputType));\n        } else if (b !== null) {\n          params.push(b.build(builder, inputType));\n        }\n      }\n\n      return builder.format(`${builder.getMethod(method)}( ${params.join(', ')} )`, type, output);\n    }\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.method = this.method;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.method = data.method;\n  }\n\n}\n\n_defineProperty(MathNode, \"RAD\", 'radians');\n\n_defineProperty(MathNode, \"DEG\", 'degrees');\n\n_defineProperty(MathNode, \"EXP\", 'exp');\n\n_defineProperty(MathNode, \"EXP2\", 'exp2');\n\n_defineProperty(MathNode, \"LOG\", 'log');\n\n_defineProperty(MathNode, \"LOG2\", 'log2');\n\n_defineProperty(MathNode, \"SQRT\", 'sqrt');\n\n_defineProperty(MathNode, \"INV_SQRT\", 'inversesqrt');\n\n_defineProperty(MathNode, \"FLOOR\", 'floor');\n\n_defineProperty(MathNode, \"CEIL\", 'ceil');\n\n_defineProperty(MathNode, \"NORMALIZE\", 'normalize');\n\n_defineProperty(MathNode, \"FRACT\", 'fract');\n\n_defineProperty(MathNode, \"SIN\", 'sin');\n\n_defineProperty(MathNode, \"COS\", 'cos');\n\n_defineProperty(MathNode, \"TAN\", 'tan');\n\n_defineProperty(MathNode, \"ASIN\", 'asin');\n\n_defineProperty(MathNode, \"ACOS\", 'acos');\n\n_defineProperty(MathNode, \"ATAN\", 'atan');\n\n_defineProperty(MathNode, \"ABS\", 'abs');\n\n_defineProperty(MathNode, \"SIGN\", 'sign');\n\n_defineProperty(MathNode, \"LENGTH\", 'length');\n\n_defineProperty(MathNode, \"NEGATE\", 'negate');\n\n_defineProperty(MathNode, \"INVERT\", 'invert');\n\n_defineProperty(MathNode, \"DFDX\", 'dFdx');\n\n_defineProperty(MathNode, \"DFDY\", 'dFdy');\n\n_defineProperty(MathNode, \"SATURATE\", 'saturate');\n\n_defineProperty(MathNode, \"ROUND\", 'round');\n\n_defineProperty(MathNode, \"MIN\", 'min');\n\n_defineProperty(MathNode, \"MAX\", 'max');\n\n_defineProperty(MathNode, \"MOD\", 'mod');\n\n_defineProperty(MathNode, \"STEP\", 'step');\n\n_defineProperty(MathNode, \"REFLECT\", 'reflect');\n\n_defineProperty(MathNode, \"DISTANCE\", 'distance');\n\n_defineProperty(MathNode, \"DOT\", 'dot');\n\n_defineProperty(MathNode, \"CROSS\", 'cross');\n\n_defineProperty(MathNode, \"POW\", 'pow');\n\n_defineProperty(MathNode, \"TRANSFORM_DIRECTION\", 'transformDirection');\n\n_defineProperty(MathNode, \"MIX\", 'mix');\n\n_defineProperty(MathNode, \"CLAMP\", 'clamp');\n\n_defineProperty(MathNode, \"REFRACT\", 'refract');\n\n_defineProperty(MathNode, \"SMOOTHSTEP\", 'smoothstep');\n\n_defineProperty(MathNode, \"FACEFORWARD\", 'faceforward');\n\nexport default MathNode;\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport Node from '../core/Node.js';\nimport AttributeNode from '../core/AttributeNode.js';\nimport VaryNode from '../core/VaryNode.js';\nimport ModelNode from './ModelNode.js';\nimport MathNode from '../math/MathNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\n\nclass PositionNode extends Node {\n  constructor(scope = PositionNode.LOCAL) {\n    super('vec3');\n    this.scope = scope;\n  }\n\n  getHash() {\n    return `position-${this.scope}`;\n  }\n\n  generate(builder) {\n    const scope = this.scope;\n    let outputNode = null;\n\n    if (scope === PositionNode.GEOMETRY) {\n      outputNode = new AttributeNode('position', 'vec3');\n    } else if (scope === PositionNode.LOCAL) {\n      outputNode = new VaryNode(new PositionNode(PositionNode.GEOMETRY));\n    } else if (scope === PositionNode.WORLD) {\n      const vertexPositionNode = new MathNode(MathNode.TRANSFORM_DIRECTION, new ModelNode(ModelNode.WORLD_MATRIX), new PositionNode(PositionNode.LOCAL));\n      outputNode = new VaryNode(vertexPositionNode);\n    } else if (scope === PositionNode.VIEW) {\n      const vertexPositionNode = new OperatorNode('*', new ModelNode(ModelNode.VIEW_MATRIX), new PositionNode(PositionNode.LOCAL));\n      outputNode = new VaryNode(vertexPositionNode);\n    } else if (scope === PositionNode.VIEW_DIRECTION) {\n      const vertexPositionNode = new MathNode(MathNode.NEGATE, new PositionNode(PositionNode.VIEW));\n      outputNode = new MathNode(MathNode.NORMALIZE, new VaryNode(vertexPositionNode));\n    }\n\n    return outputNode.build(builder, this.getNodeType(builder));\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.scope = this.scope;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.scope = data.scope;\n  }\n\n}\n\n_defineProperty(PositionNode, \"GEOMETRY\", 'geometry');\n\n_defineProperty(PositionNode, \"LOCAL\", 'local');\n\n_defineProperty(PositionNode, \"WORLD\", 'world');\n\n_defineProperty(PositionNode, \"VIEW\", 'view');\n\n_defineProperty(PositionNode, \"VIEW_DIRECTION\", 'viewDirection');\n\nexport default PositionNode;\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport Node from '../core/Node.js';\nimport AttributeNode from '../core/AttributeNode.js';\nimport VaryNode from '../core/VaryNode.js';\nimport ModelNode from './ModelNode.js';\nimport CameraNode from './CameraNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport MathNode from '../math/MathNode.js';\n\nclass NormalNode extends Node {\n  constructor(scope = NormalNode.LOCAL) {\n    super('vec3');\n    this.scope = scope;\n  }\n\n  getHash() {\n    return `normal-${this.scope}`;\n  }\n\n  generate(builder) {\n    const scope = this.scope;\n    let outputNode = null;\n\n    if (scope === NormalNode.GEOMETRY) {\n      outputNode = new AttributeNode('normal', 'vec3');\n    } else if (scope === NormalNode.LOCAL) {\n      outputNode = new VaryNode(new NormalNode(NormalNode.GEOMETRY));\n    } else if (scope === NormalNode.VIEW) {\n      const vertexNormalNode = new OperatorNode('*', new ModelNode(ModelNode.NORMAL_MATRIX), new NormalNode(NormalNode.LOCAL));\n      outputNode = new MathNode(MathNode.NORMALIZE, new VaryNode(vertexNormalNode));\n    } else if (scope === NormalNode.WORLD) {\n      // To use INVERSE_TRANSFORM_DIRECTION only inverse the param order like this: MathNode( ..., Vector, Matrix );\n      const vertexNormalNode = new MathNode(MathNode.TRANSFORM_DIRECTION, new NormalNode(NormalNode.VIEW), new CameraNode(CameraNode.VIEW_MATRIX));\n      outputNode = new MathNode(MathNode.NORMALIZE, new VaryNode(vertexNormalNode));\n    }\n\n    return outputNode.build(builder);\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.scope = this.scope;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.scope = data.scope;\n  }\n\n}\n\n_defineProperty(NormalNode, \"GEOMETRY\", 'geometry');\n\n_defineProperty(NormalNode, \"LOCAL\", 'local');\n\n_defineProperty(NormalNode, \"WORLD\", 'world');\n\n_defineProperty(NormalNode, \"VIEW\", 'view');\n\nexport default NormalNode;\n", "import Node from '../core/Node.js';\nimport PropertyNode from '../core/PropertyNode.js';\nimport ContextNode from '../core/ContextNode.js';\n\nclass CondNode extends Node {\n  constructor(node, ifNode, elseNode) {\n    super();\n    this.node = node;\n    this.ifNode = ifNode;\n    this.elseNode = elseNode;\n  }\n\n  getNodeType(builder) {\n    const ifType = this.ifNode.getNodeType(builder);\n    const elseType = this.elseNode.getNodeType(builder);\n\n    if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {\n      return elseType;\n    }\n\n    return ifType;\n  }\n\n  generate(builder) {\n    const type = this.getNodeType(builder);\n    const context = {\n      temp: false\n    };\n    const nodeProperty = new PropertyNode(null, type).build(builder);\n    const nodeSnippet = new ContextNode(this.node\n    /*, context*/\n    ).build(builder, 'bool'),\n          ifSnippet = new ContextNode(this.ifNode, context).build(builder, type),\n          elseSnippet = new ContextNode(this.elseNode, context).build(builder, type);\n    builder.addFlowCode(`if ( ${nodeSnippet} ) {\n\n\\t\\t${nodeProperty} = ${ifSnippet};\n\n\\t} else {\n\n\\t\\t${nodeProperty} = ${elseSnippet};\n\n\\t}`);\n    return nodeProperty;\n  }\n\n}\n\nexport default CondNode;\n", "import Node from '../core/Node.js';\n\nclass ArrayElementNode extends Node {\n  constructor(node, indexNode) {\n    super();\n    this.node = node;\n    this.indexNode = indexNode;\n  }\n\n  getNodeType(builder) {\n    return this.node.getNodeType(builder);\n  }\n\n  generate(builder) {\n    const nodeSnippet = this.node.build(builder);\n    const indexSnippet = this.indexNode.build(builder, 'int');\n    return `${nodeSnippet}[ ${indexSnippet} ]`;\n  }\n\n}\n\nexport default ArrayElementNode;\n", "import Node from '../core/Node.js';\n\nclass ConvertNode extends Node {\n  constructor(node, convertTo) {\n    super();\n    this.node = node;\n    this.convertTo = convertTo;\n  }\n\n  getNodeType() {\n    return this.convertTo;\n  }\n\n  generate(builder) {\n    const convertTo = this.convertTo;\n    const node = this.node;\n\n    if (builder.isReference(convertTo) === false) {\n      const convertToSnippet = builder.getType(convertTo);\n      const nodeSnippet = node.build(builder, convertTo);\n      return `${builder.getVectorType(convertToSnippet)}( ${nodeSnippet} )`;\n    } else {\n      return node.build(builder, convertTo);\n    }\n  }\n\n}\n\nexport default ConvertNode;\n", "import PropertyNode from './core/PropertyNode.js';\nimport VarNode from './core/VarNode.js';\nimport AttributeNode from './core/AttributeNode.js';\nimport ConstNode from './core/ConstNode.js';\nimport UniformNode from './core/UniformNode.js';\nimport BufferNode from './accessors/BufferNode.js';\nimport PositionNode from './accessors/PositionNode.js';\nimport NormalNode from './accessors/NormalNode.js';\nimport CameraNode from './accessors/CameraNode.js';\nimport ModelNode from './accessors/ModelNode.js';\nimport TextureNode from './accessors/TextureNode.js';\nimport UVNode from './accessors/UVNode.js';\nimport OperatorNode from './math/OperatorNode.js';\nimport CondNode from './math/CondNode.js';\nimport MathNode from './math/MathNode.js';\nimport ArrayElementNode from './utils/ArrayElementNode.js';\nimport ConvertNode from './utils/ConvertNode.js';\nimport JoinNode from './utils/JoinNode.js';\nimport SplitNode from './utils/SplitNode.js';\nimport { getValueFromType } from './core/NodeUtils.js';\n\n// core nodes\nconst NodeHandler = {\n  construct(NodeClosure, params) {\n    const inputs = params.shift();\n    return NodeClosure(new ShaderNodeObjects(inputs), ...params);\n  },\n\n  get: function (node, prop) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n        prop = prop.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\n        return new ShaderNodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n        return new ShaderNodeObject(new ArrayElementNode(node, uint(Number(prop))));\n      }\n    }\n\n    return node[prop];\n  }\n};\nconst nodeObjects = new WeakMap();\n\nconst ShaderNodeObject = function (obj) {\n  const type = typeof obj;\n\n  if (type === 'number' || type === 'boolean') {\n    return new ShaderNodeObject(getAutoTypedConstNode(obj));\n  } else if (type === 'object') {\n    if (obj.isNode === true) {\n      let nodeObject = nodeObjects.get(obj);\n\n      if (nodeObject === undefined) {\n        nodeObject = new Proxy(obj, NodeHandler);\n        nodeObjects.set(obj, nodeObject);\n        nodeObjects.set(nodeObject, nodeObject);\n      }\n\n      return nodeObject;\n    }\n  }\n\n  return obj;\n};\n\nconst ShaderNodeObjects = function (objects) {\n  for (const name in objects) {\n    objects[name] = new ShaderNodeObject(objects[name]);\n  }\n\n  return objects;\n};\n\nconst getShaderNodeArray = array => {\n  const len = array.length;\n\n  for (let i = 0; i < len; i++) {\n    array[i] = new ShaderNodeObject(array[i]);\n  }\n\n  return array;\n};\n\nconst ShaderNodeProxy = function (NodeClass, scope = null, factor = null) {\n  if (scope === null) {\n    return (...params) => {\n      return new ShaderNodeObject(new NodeClass(...getShaderNodeArray(params)));\n    };\n  } else if (factor === null) {\n    return (...params) => {\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params)));\n    };\n  } else {\n    factor = new ShaderNodeObject(factor);\n    return (...params) => {\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params), factor));\n    };\n  }\n};\n\nconst ShaderNodeScript = function (jsFunc) {\n  return (inputs, builder) => {\n    new ShaderNodeObjects(inputs);\n    return new ShaderNodeObject(jsFunc(inputs, builder));\n  };\n};\n\nconst bools = [false, true];\nconst uints = [0, 1, 2, 3];\nconst ints = [-1, -2];\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nconst boolsCacheMap = new Map();\n\nfor (let bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\n\nconst uintsCacheMap = new Map();\n\nfor (let uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\n\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\n\nfor (let int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\n\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\n\nfor (let float of floats) floatsCacheMap.set(float, new ConstNode(float));\n\nfor (let float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\n\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\n\nconst getAutoTypedConstNode = value => {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value);\n  }\n};\n\nconst ConvertType = function (type, cacheMap = null) {\n  return (...params) => {\n    if (params.length === 0) {\n      return nodeObject(new ConstNode(getValueFromType(type), type));\n    } else {\n      if (type === 'color' && params[0].isNode !== true) {\n        params = [getValueFromType(type, ...params)];\n      }\n\n      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n        return cacheMap.get(params[0]);\n      }\n\n      const nodes = params.map(getAutoTypedConstNode);\n      return nodeObject(new ConvertNode(nodes.length === 1 ? nodes[0] : new JoinNode(nodes), type));\n    }\n  };\n}; //\n// Node Material Shader Syntax\n//\n\n\nconst ShaderNode = new Proxy(ShaderNodeScript, NodeHandler);\nconst nodeObject = val => {\n  return new ShaderNodeObject(val);\n};\nconst uniform = value => {\n  var _value$node;\n\n  // TODO: get ConstNode from .traverse() in the future\n  value = value.isNode === true ? ((_value$node = value.node) === null || _value$node === void 0 ? void 0 : _value$node.value) || value.value : value;\n  return nodeObject(new UniformNode(value, value.nodeType));\n};\nconst label = (node, name) => {\n  node = nodeObject(node);\n\n  if (node.isVarNode === true) {\n    node.name = name;\n    return node;\n  }\n\n  return nodeObject(new VarNode(node, name));\n};\nconst temp = node => nodeObject(new VarNode(nodeObject(node)));\nconst color = new ConvertType('color');\nconst float = new ConvertType('float', floatsCacheMap);\nconst int = new ConvertType('int', intsCacheMap);\nconst uint = new ConvertType('uint', uintsCacheMap);\nconst bool = new ConvertType('bool', boolsCacheMap);\nconst vec2 = new ConvertType('vec2');\nconst ivec2 = new ConvertType('ivec2');\nconst uvec2 = new ConvertType('uvec2');\nconst bvec2 = new ConvertType('bvec2');\nconst vec3 = new ConvertType('vec3');\nconst ivec3 = new ConvertType('ivec3');\nconst uvec3 = new ConvertType('uvec3');\nconst bvec3 = new ConvertType('bvec3');\nconst vec4 = new ConvertType('vec4');\nconst ivec4 = new ConvertType('ivec4');\nconst uvec4 = new ConvertType('uvec4');\nconst bvec4 = new ConvertType('bvec4');\nconst mat3 = new ConvertType('mat3');\nconst imat3 = new ConvertType('imat3');\nconst umat3 = new ConvertType('umat3');\nconst bmat3 = new ConvertType('bmat3');\nconst mat4 = new ConvertType('mat4');\nconst imat4 = new ConvertType('imat4');\nconst umat4 = new ConvertType('umat4');\nconst bmat4 = new ConvertType('bmat4');\nconst join = (...params) => nodeObject(new JoinNode(getShaderNodeArray(params)));\nconst uv = (...params) => nodeObject(new UVNode(...params));\nconst attribute = (...params) => nodeObject(new AttributeNode(...params));\nconst buffer = (...params) => nodeObject(new BufferNode(...params));\nconst texture = (...params) => nodeObject(new TextureNode(...params));\nconst sampler = texture => nodeObject(new ConvertNode(texture.isNode === true ? texture : new TextureNode(texture), 'sampler'));\nconst cond = (...params) => nodeObject(new CondNode(...getShaderNodeArray(params)));\nconst addTo = (varNode, ...params) => {\n  varNode.node = add(varNode.node, ...getShaderNodeArray(params));\n  return nodeObject(varNode);\n};\nconst add = new ShaderNodeProxy(OperatorNode, '+');\nconst sub = new ShaderNodeProxy(OperatorNode, '-');\nconst mul = new ShaderNodeProxy(OperatorNode, '*');\nconst div = new ShaderNodeProxy(OperatorNode, '/');\nconst remainder = new ShaderNodeProxy(OperatorNode, '%');\nconst equal = new ShaderNodeProxy(OperatorNode, '==');\nconst assign = new ShaderNodeProxy(OperatorNode, '=');\nconst lessThan = new ShaderNodeProxy(OperatorNode, '<');\nconst greaterThan = new ShaderNodeProxy(OperatorNode, '>');\nconst lessThanEqual = new ShaderNodeProxy(OperatorNode, '<=');\nconst greaterThanEqual = new ShaderNodeProxy(OperatorNode, '>=');\nconst and = new ShaderNodeProxy(OperatorNode, '&&');\nconst or = new ShaderNodeProxy(OperatorNode, '||');\nconst xor = new ShaderNodeProxy(OperatorNode, '^^');\nconst bitAnd = new ShaderNodeProxy(OperatorNode, '&');\nconst bitOr = new ShaderNodeProxy(OperatorNode, '|');\nconst bitXor = new ShaderNodeProxy(OperatorNode, '^');\nconst shiftLeft = new ShaderNodeProxy(OperatorNode, '<<');\nconst shiftRight = new ShaderNodeProxy(OperatorNode, '>>');\nconst element = new ShaderNodeProxy(ArrayElementNode);\nconst normalGeometry = new ShaderNodeObject(new NormalNode(NormalNode.GEOMETRY));\nconst normalLocal = new ShaderNodeObject(new NormalNode(NormalNode.LOCAL));\nconst normalWorld = new ShaderNodeObject(new NormalNode(NormalNode.WORLD));\nconst normalView = new ShaderNodeObject(new NormalNode(NormalNode.VIEW));\nconst transformedNormalView = new ShaderNodeObject(new VarNode(new NormalNode(NormalNode.VIEW), 'TransformedNormalView', 'vec3'));\nconst positionLocal = new ShaderNodeObject(new PositionNode(PositionNode.LOCAL));\nconst positionWorld = new ShaderNodeObject(new PositionNode(PositionNode.WORLD));\nconst positionView = new ShaderNodeObject(new PositionNode(PositionNode.VIEW));\nconst positionViewDirection = new ShaderNodeObject(new PositionNode(PositionNode.VIEW_DIRECTION));\nconst viewMatrix = new ShaderNodeObject(new ModelNode(ModelNode.VIEW_MATRIX));\nconst cameraPosition = new ShaderNodeObject(new CameraNode(CameraNode.POSITION));\nconst diffuseColor = new ShaderNodeObject(new PropertyNode('DiffuseColor', 'vec4'));\nconst roughness = new ShaderNodeObject(new PropertyNode('Roughness', 'float'));\nconst metalness = new ShaderNodeObject(new PropertyNode('Metalness', 'float'));\nconst alphaTest = new ShaderNodeObject(new PropertyNode('AlphaTest', 'float'));\nconst specularColor = new ShaderNodeObject(new PropertyNode('SpecularColor', 'color'));\nconst abs = new ShaderNodeProxy(MathNode, 'abs');\nconst acos = new ShaderNodeProxy(MathNode, 'acos');\nconst asin = new ShaderNodeProxy(MathNode, 'asin');\nconst atan = new ShaderNodeProxy(MathNode, 'atan');\nconst ceil = new ShaderNodeProxy(MathNode, 'ceil');\nconst clamp = new ShaderNodeProxy(MathNode, 'clamp');\nconst cos = new ShaderNodeProxy(MathNode, 'cos');\nconst cross = new ShaderNodeProxy(MathNode, 'cross');\nconst degrees = new ShaderNodeProxy(MathNode, 'degrees');\nconst dFdx = new ShaderNodeProxy(MathNode, 'dFdx');\nconst dFdy = new ShaderNodeProxy(MathNode, 'dFdy');\nconst distance = new ShaderNodeProxy(MathNode, 'distance');\nconst dot = new ShaderNodeProxy(MathNode, 'dot');\nconst exp = new ShaderNodeProxy(MathNode, 'exp');\nconst exp2 = new ShaderNodeProxy(MathNode, 'exp2');\nconst faceforward = new ShaderNodeProxy(MathNode, 'faceforward');\nconst floor = new ShaderNodeProxy(MathNode, 'floor');\nconst fract = new ShaderNodeProxy(MathNode, 'fract');\nconst invert = new ShaderNodeProxy(MathNode, 'invert');\nconst inversesqrt = new ShaderNodeProxy(MathNode, 'inversesqrt');\nconst length = new ShaderNodeProxy(MathNode, 'length');\nconst log = new ShaderNodeProxy(MathNode, 'log');\nconst log2 = new ShaderNodeProxy(MathNode, 'log2');\nconst max = new ShaderNodeProxy(MathNode, 'max');\nconst min = new ShaderNodeProxy(MathNode, 'min');\nconst mix = new ShaderNodeProxy(MathNode, 'mix');\nconst mod = new ShaderNodeProxy(MathNode, 'mod');\nconst negate = new ShaderNodeProxy(MathNode, 'negate');\nconst normalize = new ShaderNodeProxy(MathNode, 'normalize');\nconst pow = new ShaderNodeProxy(MathNode, 'pow');\nconst pow2 = new ShaderNodeProxy(MathNode, 'pow', 2);\nconst pow3 = new ShaderNodeProxy(MathNode, 'pow', 3);\nconst pow4 = new ShaderNodeProxy(MathNode, 'pow', 4);\nconst radians = new ShaderNodeProxy(MathNode, 'radians');\nconst reflect = new ShaderNodeProxy(MathNode, 'reflect');\nconst refract = new ShaderNodeProxy(MathNode, 'refract');\nconst round = new ShaderNodeProxy(MathNode, 'round');\nconst saturate = new ShaderNodeProxy(MathNode, 'saturate');\nconst sign = new ShaderNodeProxy(MathNode, 'sign');\nconst sin = new ShaderNodeProxy(MathNode, 'sin');\nconst smoothstep = new ShaderNodeProxy(MathNode, 'smoothstep');\nconst sqrt = new ShaderNodeProxy(MathNode, 'sqrt');\nconst step = new ShaderNodeProxy(MathNode, 'step');\nconst tan = new ShaderNodeProxy(MathNode, 'tan');\nconst transformDirection = new ShaderNodeProxy(MathNode, 'transformDirection');\nconst EPSILON = float(1e-6);\nconst INFINITY = float(1e6);\n\nexport { EPSILON, INFINITY, ShaderNode, abs, acos, add, addTo, alphaTest, and, asin, assign, atan, attribute, bitAnd, bitOr, bitXor, bmat3, bmat4, bool, buffer, bvec2, bvec3, bvec4, cameraPosition, ceil, clamp, color, cond, cos, cross, dFdx, dFdy, degrees, diffuseColor, distance, div, dot, element, equal, exp, exp2, faceforward, float, floor, fract, greaterThan, greaterThanEqual, imat3, imat4, int, inversesqrt, invert, ivec2, ivec3, ivec4, join, label, length, lessThan, lessThanEqual, log, log2, mat3, mat4, max, metalness, min, mix, mod, mul, negate, nodeObject, normalGeometry, normalLocal, normalView, normalWorld, normalize, or, positionLocal, positionView, positionViewDirection, positionWorld, pow, pow2, pow3, pow4, radians, reflect, refract, remainder, roughness, round, sampler, saturate, shiftLeft, shiftRight, sign, sin, smoothstep, specularColor, sqrt, step, sub, tan, temp, texture, transformDirection, transformedNormalView, uint, umat3, umat4, uniform, uv, uvec2, uvec3, uvec4, vec2, vec3, vec4, viewMatrix, xor };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport Node from '../core/Node.js';\nimport { normalize, sub, positionWorld, cameraPosition, reflect, normalWorld, nodeObject, join, negate } from '../ShaderNode.js';\n\nclass ReflectNode extends Node {\n  constructor(scope = ReflectNode.CUBE) {\n    super('vec3');\n    this.scope = scope;\n  }\n\n  getHash() {\n    return `reflect-${this.scope}`;\n  }\n\n  generate(builder) {\n    const scope = this.scope;\n\n    if (scope === ReflectNode.VECTOR) {\n      const cameraToFrag = normalize(sub(positionWorld, cameraPosition));\n      const reflectVec = reflect(cameraToFrag, normalWorld);\n      return reflectVec.build(builder);\n    } else if (scope === ReflectNode.CUBE) {\n      const reflectVec = nodeObject(new ReflectNode(ReflectNode.VECTOR));\n      const cubeUV = join(negate(reflectVec.x), reflectVec.yz);\n      return cubeUV.build(builder);\n    }\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.scope = this.scope;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.scope = data.scope;\n  }\n\n}\n\n_defineProperty(ReflectNode, \"VECTOR\", 'vector');\n\n_defineProperty(ReflectNode, \"CUBE\", 'cube');\n\nexport default ReflectNode;\n", "import TextureNode from './TextureNode.js';\nimport UniformNode from '../core/UniformNode.js';\nimport ReflectNode from './ReflectNode.js';\n\nclass CubeTextureNode extends TextureNode {\n  constructor(value, uvNode = new ReflectNode(), biasNode = null) {\n    super(value, uvNode, biasNode);\n  }\n\n  getInputType() {\n    return 'cubeTexture';\n  }\n\n  generate(builder, output) {\n    const texture = this.value;\n\n    if (!texture || texture.isCubeTexture !== true) {\n      throw new Error('CubeTextureNode: Need a three.js cube texture.');\n    }\n\n    const textureProperty = UniformNode.prototype.generate.call(this, builder, 'cubeTexture');\n\n    if (output === 'sampler') {\n      return textureProperty + '_sampler';\n    } else if (builder.isReference(output)) {\n      return textureProperty;\n    } else {\n      const nodeData = builder.getDataFromNode(this);\n      let snippet = nodeData.snippet;\n\n      if (snippet === undefined) {\n        const uvSnippet = this.uvNode.build(builder, 'vec3');\n        const biasNode = this.biasNode;\n\n        if (biasNode !== null) {\n          const biasSnippet = biasNode.build(builder, 'float');\n          snippet = builder.getCubeTextureBias(textureProperty, uvSnippet, biasSnippet);\n        } else {\n          snippet = builder.getCubeTexture(textureProperty, uvSnippet);\n        }\n\n        nodeData.snippet = snippet;\n      }\n\n      return builder.format(snippet, 'vec4', output);\n    }\n  }\n\n}\n\nCubeTextureNode.prototype.isCubeTextureNode = true;\n\nexport default CubeTextureNode;\n", "import Node from '../core/Node.js';\nimport UniformNode from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass ReferenceNode extends Node {\n  constructor(property, uniformType, object = null) {\n    super();\n    this.property = property;\n    this.uniformType = uniformType;\n    this.object = object;\n    this.node = null;\n    this.updateType = NodeUpdateType.Object;\n    this.setNodeType(uniformType);\n  }\n\n  setNodeType(uniformType) {\n    this.node = new UniformNode(null, uniformType);\n    this.nodeType = uniformType;\n\n    if (uniformType === 'color') {\n      this.nodeType = 'vec3';\n    } else if (uniformType === 'texture') {\n      this.nodeType = 'vec4';\n    }\n  }\n\n  getNodeType() {\n    return this.uniformType;\n  }\n\n  update(frame) {\n    const object = this.object !== null ? this.object : frame.object;\n    const value = object[this.property];\n    this.node.value = value;\n  }\n\n  generate(builder) {\n    return this.node.build(builder, this.getNodeType(builder));\n  }\n\n}\n\nexport default ReferenceNode;\n", "import ReferenceNode from './ReferenceNode.js';\n\nclass MaterialReferenceNode extends ReferenceNode {\n  constructor(property, inputType, material = null) {\n    super(property, inputType, material);\n    this.material = material;\n  }\n\n  update(frame) {\n    this.object = this.material !== null ? this.material : frame.material;\n    super.update(frame);\n  }\n\n}\n\nexport default MaterialReferenceNode;\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport Node from '../core/Node.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport MaterialReferenceNode from './MaterialReferenceNode.js';\n\nclass MaterialNode extends Node {\n  constructor(scope = MaterialNode.COLOR) {\n    super();\n    this.scope = scope;\n  }\n\n  getNodeType(builder) {\n    const scope = this.scope;\n    const material = builder.context.material;\n\n    if (scope === MaterialNode.COLOR) {\n      return material.map !== null ? 'vec4' : 'vec3';\n    } else if (scope === MaterialNode.OPACITY) {\n      return 'float';\n    } else if (scope === MaterialNode.SPECULAR) {\n      return 'vec3';\n    } else if (scope === MaterialNode.ROUGHNESS || scope === MaterialNode.METALNESS) {\n      return 'float';\n    }\n  }\n\n  generate(builder, output) {\n    const material = builder.context.material;\n    const scope = this.scope;\n    let node = null;\n\n    if (scope === MaterialNode.ALPHA_TEST) {\n      node = new MaterialReferenceNode('alphaTest', 'float');\n    } else if (scope === MaterialNode.COLOR) {\n      const colorNode = new MaterialReferenceNode('color', 'color');\n\n      if (material.map !== null && material.map !== undefined && material.map.isTexture === true) {\n        node = new OperatorNode('*', colorNode, new MaterialReferenceNode('map', 'texture'));\n      } else {\n        node = colorNode;\n      }\n    } else if (scope === MaterialNode.OPACITY) {\n      const opacityNode = new MaterialReferenceNode('opacity', 'float');\n\n      if (material.alphaMap !== null && material.alphaMap !== undefined && material.alphaMap.isTexture === true) {\n        node = new OperatorNode('*', opacityNode, new MaterialReferenceNode('alphaMap', 'texture'));\n      } else {\n        node = opacityNode;\n      }\n    } else if (scope === MaterialNode.SPECULAR) {\n      const specularColorNode = new MaterialReferenceNode('specularColor', 'color');\n\n      if (material.specularColorMap !== null && material.specularColorMap !== undefined && material.specularColorMap.isTexture === true) {\n        node = new OperatorNode('*', specularColorNode, new MaterialReferenceNode('specularColorMap', 'texture'));\n      } else {\n        node = specularColorNode;\n      }\n    } else {\n      const outputType = this.getNodeType(builder);\n      node = new MaterialReferenceNode(scope, outputType);\n    }\n\n    return node.build(builder, output);\n  }\n\n}\n\n_defineProperty(MaterialNode, \"ALPHA_TEST\", 'alphaTest');\n\n_defineProperty(MaterialNode, \"COLOR\", 'color');\n\n_defineProperty(MaterialNode, \"OPACITY\", 'opacity');\n\n_defineProperty(MaterialNode, \"SPECULAR\", 'specular');\n\n_defineProperty(MaterialNode, \"ROUGHNESS\", 'roughness');\n\n_defineProperty(MaterialNode, \"METALNESS\", 'metalness');\n\nexport default MaterialNode;\n", "import Node from '../core/Node.js';\n\nclass PointUVNode extends Node {\n  constructor() {\n    super('vec2');\n  }\n\n  generate() {\n    return 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';\n  }\n\n}\n\nPointUVNode.prototype.isPointUVNode = true;\n\nexport default PointUVNode;\n", "import Node from '../core/Node.js';\nimport { ShaderNode, element, mul, positionLocal, add, transformDirection, normalLocal, assign, attribute, uniform, mat4, buffer } from '../ShaderNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nconst Skinning = new ShaderNode((inputs, builder) => {\n  const {\n    index,\n    weight,\n    bindMatrix,\n    bindMatrixInverse,\n    boneMatrices\n  } = inputs;\n  const boneMatX = element(boneMatrices, index.x);\n  const boneMatY = element(boneMatrices, index.y);\n  const boneMatZ = element(boneMatrices, index.z);\n  const boneMatW = element(boneMatrices, index.w); // POSITION\n\n  const skinVertex = mul(bindMatrix, positionLocal);\n  const skinned = add(mul(mul(boneMatX, skinVertex), weight.x), mul(mul(boneMatY, skinVertex), weight.y), mul(mul(boneMatZ, skinVertex), weight.z), mul(mul(boneMatW, skinVertex), weight.w));\n  const skinPosition = mul(bindMatrixInverse, skinned).xyz; // NORMAL\n\n  let skinMatrix = add(mul(weight.x, boneMatX), mul(weight.y, boneMatY), mul(weight.z, boneMatZ), mul(weight.w, boneMatW));\n  skinMatrix = mul(mul(bindMatrixInverse, skinMatrix), bindMatrix);\n  const skinNormal = transformDirection(skinMatrix, normalLocal).xyz; // ASSIGNS\n\n  assign(positionLocal, skinPosition).build(builder);\n  assign(normalLocal, skinNormal).build(builder);\n});\n\nclass SkinningNode extends Node {\n  constructor(skinnedMesh) {\n    super('void');\n    this.skinnedMesh = skinnedMesh;\n    this.updateType = NodeUpdateType.Object; //\n\n    this.skinIndexNode = attribute('skinIndex', 'uvec4');\n    this.skinWeightNode = attribute('skinWeight', 'vec4');\n    this.bindMatrixNode = uniform(mat4(skinnedMesh.bindMatrix));\n    this.bindMatrixInverseNode = uniform(mat4(skinnedMesh.bindMatrixInverse));\n    this.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length);\n  }\n\n  generate(builder) {\n    Skinning({\n      index: this.skinIndexNode,\n      weight: this.skinWeightNode,\n      bindMatrix: this.bindMatrixNode,\n      bindMatrixInverse: this.bindMatrixInverseNode,\n      boneMatrices: this.boneMatricesNode\n    }, builder);\n  }\n\n  update() {\n    this.skinnedMesh.skeleton.update();\n  }\n\n}\n\nexport default SkinningNode;\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport Node from '../core/Node.js';\nimport { ShaderNode, sub, mul, pow, vec3, lessThanEqual, mix, join } from '../ShaderNode.js';\nimport { LinearEncoding, sRGBEncoding } from 'three';\n\nconst LinearToLinear = new ShaderNode(inputs => {\n  return inputs.value;\n});\nconst LinearTosRGB = new ShaderNode(inputs => {\n  const {\n    value\n  } = inputs;\n  const rgb = value.rgb;\n  const a = sub(mul(pow(value.rgb, vec3(0.41666)), 1.055), vec3(0.055));\n  const b = mul(rgb, 12.92);\n  const factor = vec3(lessThanEqual(rgb, vec3(0.0031308)));\n  const rgbResult = mix(a, b, factor);\n  return join(rgbResult.r, rgbResult.g, rgbResult.b, value.a);\n});\nconst EncodingLib = {\n  LinearToLinear,\n  LinearTosRGB\n};\n\nclass ColorSpaceNode extends Node {\n  constructor(method, node) {\n    super('vec4');\n    this.method = method;\n    this.node = node;\n  }\n\n  fromEncoding(encoding) {\n    let method = null;\n\n    if (encoding === LinearEncoding) {\n      method = 'Linear';\n    } else if (encoding === sRGBEncoding) {\n      method = 'sRGB';\n    }\n\n    this.method = 'LinearTo' + method;\n    return this;\n  }\n\n  generate(builder) {\n    const type = this.getNodeType(builder);\n    const method = this.method;\n    const node = this.node;\n\n    if (method !== ColorSpaceNode.LINEAR_TO_LINEAR) {\n      const encodingFunctionNode = EncodingLib[method];\n      return encodingFunctionNode({\n        value: node\n      }).build(builder, type);\n    } else {\n      return node.build(builder, type);\n    }\n  }\n\n}\n\n_defineProperty(ColorSpaceNode, \"LINEAR_TO_LINEAR\", 'LinearToLinear');\n\n_defineProperty(ColorSpaceNode, \"LINEAR_TO_SRGB\", 'LinearTosRGB');\n\nexport default ColorSpaceNode;\nexport { LinearToLinear, LinearTosRGB };\n", "import TempNode from '../core/TempNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport { ShaderNode, dFdx, dFdy, cross, add, mul, max, dot, cond, inversesqrt, equal, normalize, sub, join, positionView, normalView, uv } from '../ShaderNode.js';\nimport { TangentSpaceNormalMap, ObjectSpaceNormalMap } from 'three';\n\n// http://www.thetenthplanet.de/archives/1180\n\nconst perturbNormal2ArbNode = new ShaderNode(inputs => {\n  const {\n    eye_pos,\n    surf_norm,\n    mapN,\n    faceDirection,\n    uv\n  } = inputs;\n  const q0 = dFdx(eye_pos.xyz);\n  const q1 = dFdy(eye_pos.xyz);\n  const st0 = dFdx(uv.st);\n  const st1 = dFdy(uv.st);\n  const N = surf_norm; // normalized\n\n  const q1perp = cross(q1, N);\n  const q0perp = cross(N, q0);\n  const T = add(mul(q1perp, st0.x), mul(q0perp, st1.x));\n  const B = add(mul(q1perp, st0.y), mul(q0perp, st1.y));\n  const det = max(dot(T, T), dot(B, B));\n  const scale = cond(equal(det, 0), 0, mul(faceDirection, inversesqrt(det)));\n  return normalize(add(mul(T, mul(mapN.x, scale)), mul(B, mul(mapN.y, scale)), mul(N, mapN.z)));\n});\n\nclass NormalMapNode extends TempNode {\n  constructor(node, scaleNode = null) {\n    super('vec3');\n    this.node = node;\n    this.scaleNode = scaleNode;\n    this.normalMapType = TangentSpaceNormalMap;\n  }\n\n  generate(builder) {\n    const type = this.getNodeType(builder);\n    const {\n      normalMapType,\n      scaleNode\n    } = this;\n    const normalOP = mul(this.node, 2.0);\n    let normalMap = sub(normalOP, 1.0);\n\n    if (scaleNode !== null) {\n      const normalMapScale = mul(normalMap.xy, scaleNode);\n      normalMap = join(normalMapScale, normalMap.z);\n    }\n\n    if (normalMapType === ObjectSpaceNormalMap) {\n      const vertexNormalNode = mul(new ModelNode(ModelNode.NORMAL_MATRIX), normalMap);\n      const normal = normalize(vertexNormalNode);\n      return normal.build(builder, type);\n    } else if (normalMapType === TangentSpaceNormalMap) {\n      const perturbNormal2ArbCall = perturbNormal2ArbNode({\n        eye_pos: positionView,\n        surf_norm: normalView,\n        mapN: normalMap,\n        faceDirection: 1.0,\n        uv: uv()\n      });\n      return perturbNormal2ArbCall.build(builder, type);\n    }\n  }\n\n}\n\nexport default NormalMapNode;\n", "import { ShaderNode, exp2, mul, sub, add, cond, pow, saturate, div, negate, and, greaterThan, pow2, sqrt, max, EPSILON, normalize, positionViewDirection, dot, transformedNormalView, addTo, diffuseColor, specularColor, roughness } from '../ShaderNode.js';\n\nconst F_Schlick = new ShaderNode(inputs => {\n  const {\n    f0,\n    f90,\n    dotVH\n  } = inputs; // Original approximation by Christophe Schlick '94\n  // float fresnel = pow( 1.0 - dotVH, 5.0 );\n  // Optimized variant (presented by Epic at SIGGRAPH '13)\n  // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\n  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));\n  return add(mul(f0, sub(1.0, fresnel)), mul(f90, fresnel));\n}); // validated\n\nconst BRDF_Lambert = new ShaderNode(inputs => {\n  return mul(1 / Math.PI, inputs.diffuseColor); // punctual light\n}); // validated\n\nconst getDistanceAttenuation = new ShaderNode(inputs => {\n  const {\n    lightDistance,\n    cutoffDistance,\n    decayExponent\n  } = inputs;\n  return cond(and(greaterThan(cutoffDistance, 0), greaterThan(decayExponent, 0)), pow(saturate(add(div(negate(lightDistance), cutoffDistance), 1.0)), decayExponent), 1.0);\n}); // validated\n//\n// STANDARD\n//\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\nconst V_GGX_SmithCorrelated = new ShaderNode(inputs => {\n  const {\n    alpha,\n    dotNL,\n    dotNV\n  } = inputs;\n  const a2 = pow2(alpha);\n  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNV)))));\n  const gl = mul(dotNV, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNL)))));\n  return div(0.5, max(add(gv, gl), EPSILON));\n}); // validated\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\n\nconst D_GGX = new ShaderNode(inputs => {\n  const {\n    alpha,\n    dotNH\n  } = inputs;\n  const a2 = pow2(alpha);\n  const denom = add(mul(pow2(dotNH), sub(a2, 1.0)), 1.0); // avoid alpha = 0 with dotNH = 1\n\n  return mul(1 / Math.PI, div(a2, pow2(denom)));\n}); // validated\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\n\nconst BRDF_GGX = new ShaderNode(inputs => {\n  const {\n    lightDirection,\n    f0,\n    f90,\n    roughness\n  } = inputs;\n  const alpha = pow2(roughness); // UE4's roughness\n\n  const halfDir = normalize(add(lightDirection, positionViewDirection));\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\n  const dotNV = saturate(dot(transformedNormalView, positionViewDirection));\n  const dotNH = saturate(dot(transformedNormalView, halfDir));\n  const dotVH = saturate(dot(positionViewDirection, halfDir));\n  const F = F_Schlick({\n    f0,\n    f90,\n    dotVH\n  });\n  const V = V_GGX_SmithCorrelated({\n    alpha,\n    dotNL,\n    dotNV\n  });\n  const D = D_GGX({\n    alpha,\n    dotNH\n  });\n  return mul(F, mul(V, D));\n}); // validated\n\nconst RE_Direct_Physical = new ShaderNode(inputs => {\n  const {\n    lightDirection,\n    lightColor,\n    directDiffuse,\n    directSpecular\n  } = inputs;\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\n  let irradiance = mul(dotNL, lightColor);\n  irradiance = mul(irradiance, Math.PI); // punctual light\n\n  addTo(directDiffuse, mul(irradiance, BRDF_Lambert({\n    diffuseColor: diffuseColor.rgb\n  })));\n  addTo(directSpecular, mul(irradiance, BRDF_GGX({\n    lightDirection,\n    f0: specularColor,\n    f90: 1,\n    roughness\n  })));\n});\nconst PhysicalLightingModel = new ShaderNode((inputs\n/*, builder*/\n) => {\n  // PHYSICALLY_CORRECT_LIGHTS <-> builder.renderer.physicallyCorrectLights === true\n  RE_Direct_Physical(inputs);\n});\n\nexport { BRDF_GGX, BRDF_Lambert, D_GGX, F_Schlick, PhysicalLightingModel, RE_Direct_Physical, V_GGX_SmithCorrelated, getDistanceAttenuation };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport UniformNode from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass TimerNode extends UniformNode {\n  constructor(scope = TimerNode.LOCAL) {\n    super(0);\n    this.scope = scope;\n    this.scale = 1;\n    this.updateType = NodeUpdateType.Frame;\n  }\n\n  update(frame) {\n    const scope = this.scope;\n    const scale = this.scale;\n\n    if (scope === TimerNode.LOCAL) {\n      this.value += frame.deltaTime * scale;\n    } else if (scope === TimerNode.DELTA) {\n      this.value = frame.deltaTime * scale;\n    } else {\n      // global\n      this.value = frame.time * scale;\n    }\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.scope = this.scope;\n    data.scale = this.scale;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.scope = data.scope;\n    this.scale = data.scale;\n  }\n\n}\n\n_defineProperty(TimerNode, \"LOCAL\", 'local');\n\n_defineProperty(TimerNode, \"GLOBAL\", 'global');\n\n_defineProperty(TimerNode, \"DELTA\", 'delta');\n\nexport default TimerNode;\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport Node from '../core/Node.js';\nimport TimerNode from './TimerNode.js';\nimport { add, mul, sin, round, fract, abs, sub } from '../ShaderNode.js';\n\nclass OscNode extends Node {\n  constructor(method = OscNode.SINE, timeNode = new TimerNode()) {\n    super();\n    this.method = method;\n    this.timeNode = timeNode;\n  }\n\n  getNodeType(builder) {\n    return this.timeNode.getNodeType(builder);\n  }\n\n  generate(builder) {\n    const method = this.method;\n    const timeNode = this.timeNode;\n    let outputNode = null;\n\n    if (method === OscNode.SINE) {\n      outputNode = add(mul(sin(mul(add(timeNode, 0.75), Math.PI * 2)), 0.5), 0.5);\n    } else if (method === OscNode.SQUARE) {\n      outputNode = round(fract(timeNode));\n    } else if (method === OscNode.TRIANGLE) {\n      outputNode = abs(sub(1, mul(fract(add(timeNode, 0.5)), 2)));\n    } else if (method === OscNode.SAWTOOTH) {\n      outputNode = fract(timeNode);\n    }\n\n    return outputNode.build(builder);\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.method = this.method;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.method = data.method;\n  }\n\n}\n\n_defineProperty(OscNode, \"SINE\", 'sine');\n\n_defineProperty(OscNode, \"SQUARE\", 'square');\n\n_defineProperty(OscNode, \"TRIANGLE\", 'triangle');\n\n_defineProperty(OscNode, \"SAWTOOTH\", 'sawtooth');\n\nexport default OscNode;\n", "import Node from '../core/Node.js';\nimport { ShaderNode, mul, floor, mod, add, sign, uv } from '../ShaderNode.js';\n\nconst checkerShaderNode = new ShaderNode(inputs => {\n  const uv = mul(inputs.uv, 2.0);\n  const cx = floor(uv.x);\n  const cy = floor(uv.y);\n  const result = mod(add(cx, cy), 2.0);\n  return sign(result);\n});\n\nclass CheckerNode extends Node {\n  constructor(uvNode = uv()) {\n    super('float');\n    this.uvNode = uvNode;\n  }\n\n  generate(builder) {\n    return checkerShaderNode({\n      uv: this.uvNode\n    }).build(builder);\n  }\n\n}\n\nexport default CheckerNode;\n", "import Node from '../core/Node.js';\n\nclass FogNode extends Node {\n  constructor(colorNode, factorNode) {\n    super('float');\n    this.colorNode = colorNode;\n    this.factorNode = factorNode;\n  }\n\n  generate(builder) {\n    return this.factorNode.build(builder, 'float');\n  }\n\n}\n\nFogNode.prototype.isFogNode = true;\n\nexport default FogNode;\n", "import FogNode from './FogNode.js';\nimport { smoothstep, negate, positionView } from '../ShaderNode.js';\n\nclass FogRangeNode extends FogNode {\n  constructor(colorNode, nearNode, farNode) {\n    super(colorNode);\n    this.nearNode = nearNode;\n    this.farNode = farNode;\n  }\n\n  generate(builder) {\n    this.factorNode = smoothstep(this.nearNode, this.farNode, negate(positionView.z));\n    return super.generate(builder);\n  }\n\n}\n\nFogRangeNode.prototype.isFogRangeNode = true;\n\nexport default FogRangeNode;\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { PropertyBinding, InterpolateLinear, Vector3, RGBAFormat, ShaderMaterial, MeshStandardMaterial, MeshBasicMaterial, MeshPhysicalMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshToonMaterial, MeshLambertMaterial, DoubleSide, LineSegments, LineLoop, Line, Points, MeshDepthMaterial, InterleavedBufferAttribute, BufferAttribute, Object3D, Material, OrthographicCamera, PerspectiveCamera, MathUtils, InterpolateDiscrete, SkinnedMesh, Matrix4, Mesh, Camera, Scene, DirectionalLight, PointLight, SpotLight, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from 'three';\n\nclass GLTFExporter {\n  constructor() {\n    _defineProperty(this, \"pluginCallbacks\", void 0);\n\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n\n    return this;\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n\n    return this;\n  }\n\n  parse(input, onDone, options) {\n    const writer = new GLTFWriter();\n    const plugins = [];\n\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n\n    writer.setPlugins(plugins);\n    writer.write(input, onDone, options);\n  }\n  /**\n   * Static utility functions\n   */\n\n\n} //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\n\n_defineProperty(GLTFExporter, \"Utils\", {\n  insertKeyframe: function (track, time) {\n    const tolerance = 0.001; // 1ms\n\n    const valueSize = track.getValueSize(); // @ts-expect-error\n\n    const times = new track.TimeBufferType(track.times.length + 1); // @ts-expect-error\n\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    /**\n     * NOTE: createInterpolant does not exist in the type, but it does exist as a property of the class\n     * https://github.com/mrdoob/three.js/blob/77480d339d737b7505b335101ffd3cf29a30738d/src/animation/KeyframeTrack.js#L117\n     */\n    // @ts-expect-error\n\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    let index;\n\n    if (track.times.length === 0) {\n      times[0] = time;\n\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\n\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n          index = i + 1;\n          break;\n        }\n      }\n    }\n\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function (clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n\n      if ( // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        // @ts-expect-error\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n        }\n\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n\n      if (targetIndex === undefined) {\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n      }\n\n      let mergedTrack; // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone(); // @ts-expect-error\n\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        } // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n\n\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      } // @ts-expect-error\n\n\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n      } // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n\n\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n      }\n    }\n\n    clip.tracks = tracks;\n    return clip;\n  }\n});\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  UNSIGNED_BYTE: 0x1401,\n  UNSIGNED_SHORT: 0x1403,\n  FLOAT: 0x1406,\n  UNSIGNED_INT: 0x1405,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights'\n}; // GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546c67;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\n/**\n * Writer\n */\n\nclass GLTFWriter {\n  constructor() {\n    _defineProperty(this, \"plugins\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"pending\", void 0);\n\n    _defineProperty(this, \"buffers\", void 0);\n\n    _defineProperty(this, \"byteOffset\", void 0);\n\n    _defineProperty(this, \"nodeMap\", void 0);\n\n    _defineProperty(this, \"skins\", void 0);\n\n    _defineProperty(this, \"extensionsUsed\", void 0);\n\n    _defineProperty(this, \"uids\", void 0);\n\n    _defineProperty(this, \"uid\", void 0);\n\n    _defineProperty(this, \"json\", void 0);\n\n    _defineProperty(this, \"cache\", void 0);\n\n    _defineProperty(this, \"cachedCanvas\", void 0);\n\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n    this.cachedCanvas = null;\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n\n\n  write(input, onDone, options) {\n    this.options = Object.assign({}, {\n      // default options\n      binary: false,\n      trs: false,\n      onlyVisible: true,\n      truncateDrawRange: true,\n      embedImages: true,\n      maxTextureSize: Infinity,\n      animations: [],\n      includeCustomExtensions: false\n    }, options);\n\n    if (this.options.animations !== undefined && this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true;\n    }\n\n    this.processInput(input);\n    const writer = this;\n    Promise.all(this.pending).then(() => {\n      const buffers = writer.buffers;\n      const json = writer.json;\n      const options = writer.options;\n      const extensionsUsed = writer.extensionsUsed; // Merge buffers.\n\n      const blob = new Blob(buffers, {\n        type: 'application/octet-stream'\n      }); // Declare extensions.\n\n      const extensionsUsedList = Object.keys(extensionsUsed);\n      if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\n\n      if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n\n      if (options.binary) {\n        // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n        const reader = new window.FileReader();\n        reader.readAsArrayBuffer(blob);\n\n        reader.onloadend = () => {\n          if (reader.result !== null && typeof reader.result !== 'string') {\n            // Binary chunk.\n            const binaryChunk = this.getPaddedArrayBuffer(reader.result);\n            const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\n\n            const jsonChunk = this.getPaddedArrayBuffer(this.stringToArrayBuffer(JSON.stringify(json)), 0x20);\n            const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\n\n            const header = new ArrayBuffer(GLB_HEADER_BYTES);\n            const headerView = new DataView(header);\n            headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n            headerView.setUint32(4, GLB_VERSION, true);\n            const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n            headerView.setUint32(8, totalByteLength, true);\n            const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n              type: 'application/octet-stream'\n            });\n            const glbReader = new window.FileReader();\n            glbReader.readAsArrayBuffer(glbBlob);\n\n            glbReader.onloadend = function () {\n              if (glbReader.result !== null && typeof glbReader.result !== 'string') {\n                onDone(glbReader.result);\n              }\n            };\n          }\n        };\n      } else {\n        if (json.buffers && json.buffers.length > 0) {\n          const reader = new window.FileReader();\n          reader.readAsDataURL(blob);\n\n          reader.onloadend = function () {\n            const base64data = reader.result;\n\n            if (json.buffers !== undefined && base64data !== null) {\n              json.buffers[0].uri = base64data;\n              onDone(json);\n            }\n          };\n        } else {\n          onDone(json);\n        }\n      }\n    });\n  }\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n\n\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {};\n\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n\n        delete json.gltfExtensions;\n      }\n\n      if (Object.keys(json).length > 0) objectDef.extras = json;\n    } catch (error) {\n      if (error instanceof Error) {\n        console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' \" + \"won't be serialized because of JSON.stringify error - \" + error.message);\n      }\n    }\n  }\n  /**\n   * Assign and return a temporal unique id for an object\n   * especially which doesn't have .uuid\n   * @param  {Object} object\n   * @return {Integer}\n   */\n\n\n  getUID(object) {\n    if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n    return this.uids.get(object);\n  }\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n\n\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return false;\n    const v = new Vector3();\n\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n\n\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0);\n      } else {\n        v.normalize();\n      }\n\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n\n\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions['KHR_texture_transform'] = transformDef;\n      this.extensionsUsed['KHR_texture_transform'] = true;\n    }\n  }\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n\n\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers) json.buffers = [{\n      byteLength: 0\n    }]; // All buffers are merged before export.\n\n    buffers.push(buffer);\n    return 0;\n  }\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n\n\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\n\n    let componentSize;\n\n    if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n      componentSize = 1;\n    } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n      componentSize = 2;\n    } else {\n      componentSize = 4;\n    }\n\n    const byteLength = this.getPaddedBufferSize(count * attribute.itemSize * componentSize);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n\n        if (value !== undefined) {\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\n            dataView.setFloat32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n            dataView.setUint32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n            dataView.setUint16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n            dataView.setUint8(offset, value);\n          }\n        }\n\n        offset += componentSize;\n      }\n    }\n\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength\n    };\n    if (target !== undefined) bufferViewDef.target = target;\n\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\n    }\n\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\n\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n\n\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    return new Promise(resolve => {\n      const reader = new window.FileReader();\n      reader.readAsArrayBuffer(blob);\n\n      reader.onloadend = () => {\n        if (reader.result !== null && typeof reader.result !== 'string' && json.bufferViews !== undefined) {\n          const buffer = this.getPaddedArrayBuffer(reader.result);\n          const bufferViewDef = {\n            buffer: writer.processBuffer(buffer),\n            byteOffset: writer.byteOffset,\n            byteLength: buffer.byteLength\n          };\n          writer.byteOffset += buffer.byteLength;\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\n        }\n      };\n    });\n  }\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n\n\n  processAccessor(attribute, geometry, start, count) {\n    const options = this.options;\n    const json = this.json;\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      16: 'MAT4'\n    };\n    let componentType; // Detect the component type of the attribute array (float, uint or ushort)\n\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n    }\n\n    if (start === undefined) start = 0;\n    if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\n\n    if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n      const end = start + count;\n      const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n      start = Math.max(start, geometry.drawRange.start);\n      count = Math.min(end, end2) - start;\n      if (count < 0) count = 0;\n    } // Skip creating an accessor if the attribute doesn't have data to export\n\n\n    if (count === 0) return null;\n    const minMax = this.getMinMax(attribute, start, count);\n    let bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n\n    if (geometry !== undefined) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n\n    if (bufferViewTarget !== undefined) {\n      const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n      const accessorDef = {\n        bufferView: bufferView.id,\n        byteOffset: bufferView.byteOffset,\n        componentType: componentType,\n        count: count,\n        max: minMax.max,\n        min: minMax.min,\n        type: types[attribute.itemSize]\n      };\n      if (attribute.normalized) accessorDef.normalized = true;\n      if (!json.accessors) json.accessors = [];\n      return json.accessors.push(accessorDef) - 1;\n    }\n  }\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n\n\n  processImage(image, format, flipY) {\n    const writer = this;\n    const cache = writer.cache;\n    const json = writer.json;\n    const options = writer.options;\n    const pending = writer.pending;\n    if (!cache.images.has(image)) cache.images.set(image, {});\n    const cachedImages = cache.images.get(image);\n    const mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\n    const key = mimeType + ':flipY/' + flipY.toString();\n    if (cachedImages !== undefined && cachedImages[key] !== undefined) return cachedImages[key];\n    if (!json.images) json.images = [];\n    const imageDef = {\n      mimeType: mimeType\n    };\n\n    if (options.embedImages && options.maxTextureSize !== undefined) {\n      const canvas = this.cachedCanvas = this.cachedCanvas || document.createElement('canvas');\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext('2d');\n\n      if (flipY) {\n        ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, canvas.height);\n        ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);\n      }\n\n      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n      } else {\n        if (format !== RGBAFormat) {\n          console.error('GLTFExporter: Only RGBA format is supported.');\n        }\n\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n        }\n\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n\n        if (image instanceof ImageData) {\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = image.data[i + 0];\n            data[i + 1] = image.data[i + 1];\n            data[i + 2] = image.data[i + 2];\n            data[i + 3] = image.data[i + 3];\n          }\n        }\n\n        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      }\n\n      if (options.binary) {\n        pending.push(new Promise(function (resolve) {\n          canvas.toBlob(function (blob) {\n            if (blob !== null) {\n              writer.processBufferViewImage(blob).then(function (bufferViewIndex) {\n                imageDef.bufferView = bufferViewIndex; // @ts-expect-error\n\n                resolve();\n              });\n            }\n          }, mimeType);\n        }));\n      } else {\n        imageDef.uri = canvas.toDataURL(mimeType);\n      }\n    } else if (image instanceof Image) {\n      imageDef.uri = image.src;\n    }\n\n    const index = json.images.push(imageDef) - 1;\n    if (cachedImages !== undefined) cachedImages[key] = index;\n    return index;\n  }\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n\n\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers) json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n\n\n  processTexture(map) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map)) return cache.textures.get(map);\n    if (!json.textures) json.textures = [];\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY)\n    };\n    if (map.name) textureDef.name = map.name;\n\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef);\n    });\n\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n\n\n  processMaterial(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material)) return cache.materials.get(material);\n\n    if (material instanceof ShaderMaterial && material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n      return null;\n    }\n\n    if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\n\n    const materialDef = {\n      pbrMetallicRoughness: {}\n    };\n\n    if (!(material instanceof MeshStandardMaterial && material.isMeshStandardMaterial && material instanceof MeshBasicMaterial && // @ts-expect-error\n    material.isMeshBasicMaterial)) {\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n    }\n\n    if (material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) {\n      // pbrMetallicRoughness.baseColorFactor\n      const color = material.color.toArray().concat([material.opacity]);\n\n      if (!this.equalArray(color, [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\n      }\n    }\n\n    if (material instanceof MeshStandardMaterial && material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n    } // pbrMetallicRoughness.metallicRoughnessTexture\n\n\n    if (material instanceof MeshStandardMaterial && material.metalnessMap || material instanceof MeshStandardMaterial && material.roughnessMap) {\n      if (material.metalnessMap === material.roughnessMap && material.metalnessMap !== null) {\n        const metalRoughMapDef = {\n          index: this.processTexture(material.metalnessMap)\n        };\n        this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n      } else {\n        console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n      }\n    } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\n\n    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map)\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n\n    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.emissive) {\n      // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n      const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n\n      if (maxEmissiveComponent > 1) {\n        emissive.multiplyScalar(1 / maxEmissiveComponent);\n        console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');\n      }\n\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = emissive.toArray();\n      } // emissiveTexture\n\n\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap)\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    } // normalTexture\n\n\n    if ((material instanceof MeshMatcapMaterial || material instanceof MeshNormalMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap)\n      };\n\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x;\n      }\n\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    } // occlusionTexture\n\n\n    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: 1\n      };\n\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    } // alphaMode\n\n\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND';\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK';\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    } // doubleSided\n\n\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\n    if (material.name !== '') materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\n    });\n\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n\n\n  processMesh(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n\n    const meshCacheKey = meshCacheKeyParts.join(':');\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode; // Use the correct mode\n\n    if (mesh instanceof LineSegments && mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh instanceof LineLoop && mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh instanceof Line && mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh instanceof Points && mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = (mesh.material instanceof MeshBasicMaterial || mesh.material instanceof MeshDepthMaterial || mesh.material instanceof MeshLambertMaterial || mesh.material instanceof MeshNormalMaterial || mesh.material instanceof MeshPhongMaterial || mesh.material instanceof MeshStandardMaterial || mesh.material instanceof MeshToonMaterial || mesh.material instanceof ShaderMaterial) && mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n    }\n\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = []; // Conversion between attributes names in threejs and gltf spec\n\n    const nameConversion = {\n      uv: 'TEXCOORD_0',\n      uv2: 'TEXCOORD_1',\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0'\n    };\n    const originalNormal = geometry.getAttribute('normal');\n\n    if (originalNormal !== undefined && !(originalNormal instanceof InterleavedBufferAttribute) && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n    } // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n\n\n    let modifiedAttribute = null;\n\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.substr(0, 5) === 'morph') continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\n\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\n\n      modifiedAttribute = null;\n      const array = attribute.array;\n\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      }\n\n      const accessor = modifiedAttribute !== null && this.processAccessor(modifiedAttribute || attribute, geometry);\n\n      if (accessor) {\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\n\n    if (Object.keys(attributes).length === 0) return null; // Morph targets\n\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n              warned = true;\n            }\n\n            continue;\n          }\n\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName];\n\n          if (cache.attributes.has(this.getUID(attribute))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\n            continue;\n          } // Clones attribute not to override\n\n\n          const relativeAttribute = attribute.clone();\n\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n            }\n          }\n\n          const accessor = this.processAccessor(relativeAttribute, geometry);\n\n          if (accessor != undefined) {\n            target[gltfAttributeName] = accessor;\n          }\n\n          cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\n        }\n\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n      }\n\n      meshDef.weights = weights;\n\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{\n      materialIndex: 0,\n      start: undefined,\n      count: undefined\n    }];\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes\n      };\n\n      if (geometry instanceof Object3D || geometry instanceof Material) {\n        this.serializeUserData(geometry, primitive);\n      }\n\n      if (targets.length > 0) primitive.targets = targets;\n\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          // @ts-expect-error\n          cacheKey += `:${groups[i].start}:${groups[i].count}`;\n        }\n\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n\n        if (primitive.indices === null) delete primitive.indices;\n      }\n\n      const materialIndex = groups[i].materialIndex;\n\n      if (materialIndex !== undefined && Array.isArray(materials)) {\n        const targetMaterials = materials[materialIndex];\n\n        if (!Array.isArray(targetMaterials)) {\n          const material = this.processMaterial(targetMaterials);\n          if (material !== null) primitive.material = material;\n          primitives.push(primitive);\n        }\n      }\n    }\n\n    meshDef.primitives = primitives;\n    if (!json.meshes) json.meshes = [];\n\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n\n\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras) json.cameras = [];\n    const isOrtho = camera instanceof OrthographicCamera && camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective'\n    };\n\n    if (camera instanceof OrthographicCamera && isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else if (camera instanceof PerspectiveCamera) {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } // Question: Is saving \"type\" as name intentional?\n\n\n    if (camera.name !== '') cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n\n\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations) json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = undefined;\n        }\n      }\n\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        return null;\n      }\n\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n\n      let interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n      // @ts-expect-error\n\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP';\n      } else {\n        interpolation = 'LINEAR';\n      }\n\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation: interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n\n    json.animations.push({\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels\n    });\n    return json.animations.length - 1;\n  }\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n\n\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n\n    if (json.nodes !== undefined && object instanceof SkinnedMesh) {\n      const node = json.nodes[nodeMap.get(object)];\n      const skeleton = object.skeleton;\n      if (skeleton === undefined) return null;\n      const rootJoint = object.skeleton.bones[0];\n      if (rootJoint === undefined) return null;\n      const joints = [];\n      const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n      const temporaryBoneInverse = new Matrix4();\n\n      for (let i = 0; i < skeleton.bones.length; ++i) {\n        joints.push(nodeMap.get(skeleton.bones[i]));\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n      }\n\n      if (json.skins === undefined) json.skins = [];\n      json.skins.push({\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n        joints: joints,\n        skeleton: nodeMap.get(rootJoint)\n      });\n      const skinIndex = node.skin = json.skins.length - 1;\n      return skinIndex;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n\n\n  processNode(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes) json.nodes = [];\n    const nodeDef = {};\n\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n\n      if (!this.equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n\n      if (!this.equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n\n      if (!this.equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n\n      if (!this.isIdentityMatrix(object.matrix)) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    } // We don't export empty strings name because it represents no-name in Three.js.\n\n\n    if (object.name !== '') nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n\n    if ((object instanceof Mesh && object.isMesh || object instanceof Line && object.isLine || object instanceof Points && object.isPoints) && object instanceof Mesh) {\n      const meshIndex = this.processMesh(object);\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\n    } else if (object instanceof Camera && object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n\n    if (object instanceof SkinnedMesh && object.isSkinnedMesh) this.skins.push(object);\n\n    if (object.children.length > 0) {\n      const children = [];\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n\n        if (child.visible || !options.onlyVisible) {\n          const nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) children.push(nodeIndex);\n        }\n      }\n\n      if (children.length > 0) nodeDef.children = children;\n    }\n\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n\n\n  processScene(scene) {\n    const json = this.json;\n    const options = this.options;\n\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n\n    const sceneDef = {};\n    if (scene.name !== '') sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n\n      if (child.visible || !options.onlyVisible) {\n        const nodeIndex = this.processNode(child);\n        if (nodeIndex !== null) nodes.push(nodeIndex);\n      }\n    }\n\n    if (nodes.length > 0) sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n\n  processObjects(objects) {\n    const scene = new Scene();\n    scene.name = 'AuxScene';\n\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i]);\n    }\n\n    this.processScene(scene);\n  }\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n\n\n  processInput(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n\n    const objectsWithoutScene = [];\n\n    for (let i = 0; i < input.length; i++) {\n      const inputScene = input[i];\n\n      if (inputScene instanceof Scene) {\n        this.processScene(inputScene);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n\n    for (let i = 0; options.animations !== undefined && i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i]);\n    }\n  } //------------------------------------------------------------------------------\n  // Utility functions\n  //------------------------------------------------------------------------------\n\n  /**\n   * Compare two arrays\n   * @param  {Array} array1 Array 1 to compare\n   * @param  {Array} array2 Array 2 to compare\n   * @return {Boolean}        Returns true if both arrays are equal\n   */\n\n\n  equalArray(array1, array2) {\n    return array1.length === array2.length && array1.every(function (element, index) {\n      return element === array2[index];\n    });\n  }\n  /**\n   * Converts a string to an ArrayBuffer.\n   * @param  {string} text\n   * @return {ArrayBuffer}\n   */\n\n\n  stringToArrayBuffer(text) {\n    if (window.TextEncoder !== undefined) {\n      return new TextEncoder().encode(text).buffer;\n    }\n\n    const array = new Uint8Array(new ArrayBuffer(text.length));\n\n    for (let i = 0, il = text.length; i < il; i++) {\n      const value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\n\n      array[i] = value > 0xff ? 0x20 : value;\n    }\n\n    return array.buffer;\n  }\n\n  isIdentityMatrix(matrix) {\n    return this.equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n  }\n\n  getMinMax(attribute, start, count) {\n    const output = {\n      min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n      max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n    };\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n\n        if (value !== undefined) {\n          output.min[a] = Math.min(output.min[a], value);\n          output.max[a] = Math.max(output.max[a], value);\n        }\n      }\n    }\n\n    return output;\n  }\n  /**\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n   */\n\n\n  getPaddedBufferSize(bufferSize) {\n    return Math.ceil(bufferSize / 4) * 4;\n  }\n  /**\n   * Returns a buffer aligned to 4-byte boundary.\n   *\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\n   * @param {Integer} paddingByte (Optional)\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n   */\n\n\n  getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n    const paddedLength = this.getPaddedBufferSize(arrayBuffer.byteLength);\n\n    if (paddedLength !== arrayBuffer.byteLength) {\n      const array = new Uint8Array(paddedLength);\n      array.set(new Uint8Array(arrayBuffer));\n\n      if (paddingByte !== 0) {\n        for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n          array[i] = paddingByte;\n        }\n      }\n\n      return array.buffer;\n    }\n\n    return arrayBuffer;\n  }\n\n}\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\n\n\nclass GLTFLightExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return;\n\n    if (!(light instanceof DirectionalLight && light.isDirectionalLight) && // @ts-expect-error\n    !(light instanceof PointLight && light.isPointLight) && !(light instanceof SpotLight && light.isSpotLight)) {\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n      return;\n    }\n\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name) lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n\n    if (light instanceof DirectionalLight && light.isDirectionalLight) {\n      lightDef.type = 'directional';\n    } else if (light instanceof PointLight && // @ts-expect-error\n    light.isPointLight) {\n      lightDef.type = 'point';\n      if (light.distance > 0) lightDef.range = light.distance;\n    } else if (light instanceof SpotLight && light.isSpotLight) {\n      lightDef.type = 'spot';\n      if (light.distance > 0) lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n\n    if (!(light instanceof DirectionalLight) && light.decay !== undefined && light.decay !== 2) {\n      console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n    }\n\n    if (!(light instanceof PointLight) && light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n    }\n\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = {\n        lights: []\n      };\n      extensionsUsed[this.name] = true;\n    }\n\n    if (json.extensions !== undefined) {\n      const lights = json.extensions[this.name].lights;\n      lights.push(lightDef);\n      nodeDef.extensions = nodeDef.extensions || {};\n      nodeDef.extensions[this.name] = {\n        light: lights.length - 1\n      };\n    }\n  }\n\n}\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\n\n\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!(material instanceof MeshBasicMaterial && // @ts-expect-error\n    material.isMeshBasicMaterial)) {\n      return;\n    }\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n\n}\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n */\n\n\nclass GLTFMaterialsPBRSpecularGlossiness {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n\n  writeMaterial(material, materialDef) {\n    // @ts-expect-error\n    if (!material.isGLTFSpecularGlossinessMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n\n    if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n      extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n    }\n\n    if (material instanceof MeshPhongMaterial) {\n      const specularFactor = [1, 1, 1];\n      material.specular.toArray(specularFactor, 0);\n      extensionDef.specularFactor = specularFactor;\n      extensionDef.glossinessFactor = // @ts-expect-error\n      material.glossiness;\n    }\n\n    if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n      extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n    }\n\n    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial) && material.specularMap) {\n      const specularMapDef = {\n        index: writer.processTexture(material.specularMap)\n      };\n      writer.applyTextureTransform(specularMapDef, material.specularMap);\n      extensionDef.specularGlossinessTexture = specularMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\n\n\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\n    material.isMeshPhysicalMaterial) || material.transmission === 0) {\n      return;\n    }\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap)\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\n\n\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\n    material.isMeshPhysicalMaterial) || material.thickness === 0) {\n      return;\n    }\n\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thickness = material.thickness;\n\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap)\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n\n    extensionDef.attenuationDistance = material.attenuationDistance;\n    extensionDef.attenuationColor = //@ts-expect-error\n    material.attenuationTint.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n\n}\n\nexport { GLTFExporter };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { BufferGeometry, Mesh, Points } from 'three';\n\n/**\n * Export draco compressed files from threejs geometry objects.\n *\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\n *\n * The exporter receives a options object containing\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\n *  - encoderMethod\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\n *  - exportUvs\n *  - exportNormals\n */\n\nclass DRACOExporter {\n  // Encoder methods\n  // Geometry type\n  // Attribute type\n  parse(object, options = {\n    decodeSpeed: 5,\n    encodeSpeed: 5,\n    encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n    quantization: [16, 8, 8, 8, 8],\n    exportUvs: true,\n    exportNormals: true,\n    exportColor: false\n  }) {\n    if (object instanceof BufferGeometry && object.isBufferGeometry) {\n      throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.');\n    }\n\n    if (DracoEncoderModule === undefined) {\n      throw new Error('THREE.DRACOExporter: required the draco_encoder to work.');\n    }\n\n    const geometry = object.geometry;\n    const dracoEncoder = DracoEncoderModule();\n    const encoder = new dracoEncoder.Encoder();\n    let builder;\n    let dracoObject;\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.');\n    }\n\n    if (object instanceof Mesh && object.isMesh) {\n      builder = new dracoEncoder.MeshBuilder();\n      dracoObject = new dracoEncoder.Mesh();\n      const vertices = geometry.getAttribute('position'); // @ts-expect-error\n\n      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      const faces = geometry.getIndex();\n\n      if (faces !== null) {\n        // @ts-expect-error\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n      } else {\n        const faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n\n        for (let i = 0; i < faces.length; i++) {\n          faces[i] = i;\n        }\n\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces);\n      }\n\n      if (options.exportNormals) {\n        const normals = geometry.getAttribute('normal');\n\n        if (normals !== undefined) {\n          // @ts-expect-error\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n        }\n      }\n\n      if (options.exportUvs) {\n        const uvs = geometry.getAttribute('uv');\n\n        if (uvs !== undefined) {\n          // @ts-expect-error\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n        }\n      }\n\n      if (options.exportColor) {\n        const colors = geometry.getAttribute('color');\n\n        if (colors !== undefined) {\n          // @ts-expect-error\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else if (object instanceof Points && object.isPoints) {\n      // @ts-expect-error\n      builder = new dracoEncoder.PointCloudBuilder(); // @ts-expect-error\n\n      dracoObject = new dracoEncoder.PointCloud();\n      const vertices = geometry.getAttribute('position');\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n\n      if (options.exportColor) {\n        const colors = geometry.getAttribute('color');\n\n        if (colors !== undefined) {\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else {\n      throw new Error('DRACOExporter: Unsupported object type.');\n    } //Compress using draco encoder\n\n\n    const encodedData = new dracoEncoder.DracoInt8Array(); //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n    const encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5;\n    const decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5;\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed); // Sets the desired encoding method for a given geometry.\n\n    if (options.encoderMethod !== undefined) {\n      encoder.SetEncodingMethod(options.encoderMethod);\n    } // Sets the quantization (number of bits used to represent) compression options for a named attribute.\n    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n\n\n    if (options.quantization !== undefined) {\n      for (let i = 0; i < 5; i++) {\n        if (options.quantization[i] !== undefined) {\n          encoder.SetAttributeQuantization(i, options.quantization[i]);\n        }\n      }\n    }\n\n    let length;\n\n    if (object instanceof Mesh && object.isMesh) {\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n    } else {\n      // @ts-expect-error\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n    }\n\n    dracoEncoder.destroy(dracoObject);\n\n    if (length === 0) {\n      throw new Error('THREE.DRACOExporter: Draco encoding failed.');\n    } //Copy encoded data to buffer.\n\n\n    const outputData = new Int8Array(new ArrayBuffer(length));\n\n    for (let i = 0; i < length; i++) {\n      outputData[i] = encodedData.GetValue(i);\n    }\n\n    dracoEncoder.destroy(encodedData);\n    dracoEncoder.destroy(encoder);\n    dracoEncoder.destroy(builder);\n    return outputData;\n  }\n\n}\n\n_defineProperty(DRACOExporter, \"MESH_EDGEBREAKER_ENCODING\", 1);\n\n_defineProperty(DRACOExporter, \"MESH_SEQUENTIAL_ENCODING\", 0);\n\n_defineProperty(DRACOExporter, \"POINT_CLOUD\", 0);\n\n_defineProperty(DRACOExporter, \"TRIANGULAR_MESH\", 1);\n\n_defineProperty(DRACOExporter, \"INVALID\", -1);\n\n_defineProperty(DRACOExporter, \"POSITION\", 0);\n\n_defineProperty(DRACOExporter, \"NORMAL\", 1);\n\n_defineProperty(DRACOExporter, \"COLOR\", 2);\n\n_defineProperty(DRACOExporter, \"TEX_COORD\", 3);\n\n_defineProperty(DRACOExporter, \"GENERIC\", 4);\n\nexport { DRACOExporter };\n", "import { NumberKeyframeTrack, AnimationClip, Vector3, VectorKeyframeTrack, BooleanKeyframeTrack, ColorKeyframeTrack } from 'three';\n\nconst AnimationClipCreator = () => {};\n\nAnimationClipCreator.CreateRotationAnimation = (period, axis) => {\n  const times = [0, period],\n        values = [0, 360];\n  axis = axis || 'x';\n  const trackName = `.rotation[${axis}]`;\n  const track = new NumberKeyframeTrack(trackName, times, values);\n  return new AnimationClip(null, period, [track]);\n};\n\nAnimationClipCreator.CreateScaleAxisAnimation = (period, axis) => {\n  const times = [0, period],\n        values = [0, 1];\n  axis = axis || 'x';\n  const trackName = `.scale[${axis}]`;\n  const track = new NumberKeyframeTrack(trackName, times, values);\n  return new AnimationClip(null, period, [track]);\n};\n\nAnimationClipCreator.CreateShakeAnimation = (duration, shakeScale) => {\n  const times = [],\n        values = [],\n        tmp = new Vector3();\n\n  for (let i = 0; i < duration * 10; i++) {\n    times.push(i / 10);\n    tmp.set(Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0).multiply(shakeScale).toArray(values, values.length);\n  }\n\n  const trackName = '.position';\n  const track = new VectorKeyframeTrack(trackName, times, values);\n  return new AnimationClip(null, duration, [track]);\n};\n\nAnimationClipCreator.CreatePulsationAnimation = (duration, pulseScale) => {\n  const times = [],\n        values = [],\n        tmp = new Vector3();\n\n  for (let i = 0; i < duration * 10; i++) {\n    times.push(i / 10);\n    const scaleFactor = Math.random() * pulseScale;\n    tmp.set(scaleFactor, scaleFactor, scaleFactor).toArray(values, values.length);\n  }\n\n  const trackName = '.scale';\n  const track = new VectorKeyframeTrack(trackName, times, values);\n  return new AnimationClip(null, duration, [track]);\n};\n\nAnimationClipCreator.CreateVisibilityAnimation = duration => {\n  const times = [0, duration / 2, duration],\n        values = [true, false, true];\n  const trackName = '.visible';\n  const track = new BooleanKeyframeTrack(trackName, times, values);\n  return new AnimationClip(null, duration, [track]);\n};\n\nAnimationClipCreator.CreateMaterialColorAnimation = (duration, colors) => {\n  const times = [],\n        values = [],\n        timeStep = duration / colors.length;\n\n  for (let i = 0; i <= colors.length; i++) {\n    times.push(i * timeStep);\n    values.push(colors[i % colors.length]);\n  }\n\n  const trackName = '.material[0].color';\n  const track = new ColorKeyframeTrack(trackName, times, values);\n  return new AnimationClip(null, duration, [track]);\n};\n\nexport { AnimationClipCreator };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Object3D, Matrix4, Vector3, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, Mesh, Line, Quaternion, BufferGeometry, BufferAttribute } from 'three';\n\nclass CCDIKHelper extends Object3D {\n  constructor(mesh, iks = [], sphereSize = 0.25) {\n    super();\n\n    _defineProperty(this, \"_m\", new Matrix4());\n\n    _defineProperty(this, \"_v\", new Vector3());\n\n    this.root = mesh;\n    this.iks = iks;\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(0xff0000),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n\n    function createLineGeometry(ik) {\n      const geometry = new BufferGeometry();\n      const vertices = new Float32Array((2 + ik.links.length) * 3);\n      geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n      return geometry;\n    }\n\n    const scope = this;\n\n    function createTargetMesh() {\n      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n    }\n\n    function createEffectorMesh() {\n      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n    }\n\n    function createLinkMesh() {\n      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n    }\n\n    function createLine(ik) {\n      return new Line(createLineGeometry(ik), scope.lineMaterial);\n    }\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      this.add(createTargetMesh());\n      this.add(createEffectorMesh());\n\n      for (let j = 0, jl = ik.links.length; j < jl; j++) {\n        this.add(createLinkMesh());\n      }\n\n      this.add(createLine(ik));\n    }\n  }\n\n  _getPosition(bone, matrixWorldInv) {\n    return this._v.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n  }\n\n  _setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n    const v = this._getPosition(bone, matrixWorldInv);\n\n    array[index * 3 + 0] = v.x;\n    array[index * 3 + 1] = v.y;\n    array[index * 3 + 2] = v.z;\n  }\n\n  updateMatrixWorld(force) {\n    const mesh = this.root;\n\n    if (this.visible) {\n      let offset = 0;\n      const iks = this.iks;\n      const bones = mesh.skeleton.bones;\n\n      this._m.copy(mesh.matrixWorld).invert();\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const targetBone = bones[ik.target];\n        const effectorBone = bones[ik.effector];\n        const targetMesh = this.children[offset++];\n        const effectorMesh = this.children[offset++];\n        targetMesh.position.copy(this._getPosition(targetBone, this._m));\n        effectorMesh.position.copy(this._getPosition(effectorBone, this._m));\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n          const linkMesh = this.children[offset++];\n          linkMesh.position.copy(this._getPosition(linkBone, this._m));\n        }\n\n        const line = this.children[offset++];\n        const array = line.geometry.attributes.position.array;\n\n        this._setPositionOfBoneToAttributeArray(array, 0, targetBone, this._m);\n\n        this._setPositionOfBoneToAttributeArray(array, 1, effectorBone, this._m);\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n\n          this._setPositionOfBoneToAttributeArray(array, j + 2, linkBone, this._m);\n        }\n\n        line.geometry.attributes.position.needsUpdate = true;\n      }\n    }\n\n    this.matrix.copy(mesh.matrixWorld);\n    super.updateMatrixWorld(force);\n  }\n\n}\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\n\n\nclass CCDIKSolver {\n  constructor(mesh, iks) {\n    _defineProperty(this, \"q\", new Quaternion());\n\n    _defineProperty(this, \"targetPos\", new Vector3());\n\n    _defineProperty(this, \"targetVec\", new Vector3());\n\n    _defineProperty(this, \"effectorPos\", new Vector3());\n\n    _defineProperty(this, \"effectorVec\", new Vector3());\n\n    _defineProperty(this, \"linkPos\", new Vector3());\n\n    _defineProperty(this, \"invLinkQ\", new Quaternion());\n\n    _defineProperty(this, \"linkScale\", new Vector3());\n\n    _defineProperty(this, \"axis\", new Vector3());\n\n    _defineProperty(this, \"vector\", new Vector3());\n\n    this.mesh = mesh;\n    this.iks = iks;\n    const bones = this.mesh.skeleton.bones;\n\n    for (let i = 0, il = this.iks.length; i < il; i++) {\n      const ik = this.iks[i];\n      const effector = bones[ik.effector];\n      const links = ik.links;\n      let link0, link1;\n      link0 = effector;\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        link1 = bones[links[j].index];\n\n        if (link0.parent !== link1) {\n          console.warn(`THREE.CCDIKSolver: bone ${link0.name} is not the child of bone ${link1.name}`);\n        }\n\n        link0 = link1;\n      }\n    }\n  }\n\n  update() {\n    const bones = this.mesh.skeleton.bones;\n    const iks = this.iks; // for reference overhead reduction in loop\n\n    const math = Math;\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      const effector = bones[ik.effector];\n      const target = bones[ik.target]; // don't use getWorldPosition() here for the performance\n      // because it calls updateMatrixWorld( true ) inside.\n\n      this.targetPos.setFromMatrixPosition(target.matrixWorld);\n      const links = ik.links;\n      const iteration = ik.iteration !== undefined ? ik.iteration : 1;\n\n      for (let j = 0; j < iteration; j++) {\n        let rotated = false;\n\n        for (let k = 0, kl = links.length; k < kl; k++) {\n          const link = bones[links[k].index]; // skip this link and following links.\n          // this skip is used for MMD performance optimization.\n\n          if (links[k].enabled === false) break;\n          const limitation = links[k].limitation;\n          const rotationMin = links[k].rotationMin;\n          const rotationMax = links[k].rotationMax; // don't use getWorldPosition/Quaternion() here for the performance\n          // because they call updateMatrixWorld( true ) inside.\n\n          link.matrixWorld.decompose(this.linkPos, this.invLinkQ, this.linkScale);\n          this.invLinkQ.invert();\n          this.effectorPos.setFromMatrixPosition(effector.matrixWorld); // work in link world\n\n          this.effectorVec.subVectors(this.effectorPos, this.linkPos);\n          this.effectorVec.applyQuaternion(this.invLinkQ);\n          this.effectorVec.normalize();\n          this.targetVec.subVectors(this.targetPos, this.linkPos);\n          this.targetVec.applyQuaternion(this.invLinkQ);\n          this.targetVec.normalize();\n          let angle = this.targetVec.dot(this.effectorVec);\n\n          if (angle > 1.0) {\n            angle = 1.0;\n          } else if (angle < -1.0) {\n            angle = -1.0;\n          }\n\n          angle = math.acos(angle); // skip if changing angle is too small to prevent vibration of bone\n          // Refer to http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n\n          if (angle < 1e-5) continue;\n\n          if (ik.minAngle !== undefined && angle < ik.minAngle) {\n            angle = ik.minAngle;\n          }\n\n          if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\n            angle = ik.maxAngle;\n          }\n\n          this.axis.crossVectors(this.effectorVec, this.targetVec);\n          this.axis.normalize();\n          this.q.setFromAxisAngle(this.axis, angle);\n          link.quaternion.multiply(this.q); // TODO: re-consider the limitation specification\n\n          if (limitation !== undefined) {\n            let c = link.quaternion.w;\n            if (c > 1.0) c = 1.0;\n            const c2 = math.sqrt(1 - c * c);\n            link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n          }\n\n          if (rotationMin !== undefined) {\n            link.rotation.setFromVector3(this.vector.setFromEuler(link.rotation).max(rotationMin));\n          }\n\n          if (rotationMax !== undefined) {\n            link.rotation.setFromVector3(this.vector.setFromEuler(link.rotation).min(rotationMax));\n          }\n\n          link.updateMatrixWorld(true);\n          rotated = true;\n        }\n\n        if (!rotated) break;\n      }\n    }\n\n    return this;\n  }\n\n  createHelper() {\n    return new CCDIKHelper(this.mesh, this.mesh.geometry.userData.MMD.iks);\n  }\n\n}\n\nexport { CCDIKHelper, CCDIKSolver };\n", "import { Object3D, Vector3, Quaternion, Matrix4, Mesh, Euler, Bone, MeshBasicMaterial, Color, BoxGeometry, SphereGeometry, CylinderGeometry } from 'three';\n\n/**\n * Dependencies\n *  - Ammo.js https://github.com/kripken/ammo.js\n *\n * MMDPhysics calculates physics with Ammo(Bullet based JavaScript Physics engine)\n * for MMD model loaded by MMDLoader.\n *\n * TODO\n *  - Physics in Worker\n */\n\n/* global Ammo */\n\nconst MMDPhysics = (() => {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} rigidBodyParams\n   * @param {Array<Object>} (optional) constraintParams\n   * @param {Object} params - (optional)\n   * @param {Number} params.unitStep - Default is 1 / 65.\n   * @param {Integer} params.maxStepNum - Default is 3.\n   * @param {Vector3} params.gravity - Default is ( 0, - 9.8 * 10, 0 )\n   */\n  function MMDPhysics(mesh, rigidBodyParams, constraintParams, params) {\n    if (typeof Ammo === 'undefined') {\n      throw new Error('THREE.MMDPhysics: Import ammo.js https://github.com/kripken/ammo.js');\n    }\n\n    constraintParams = constraintParams || [];\n    params = params || {};\n    this.manager = new ResourceManager();\n    this.mesh = mesh;\n    /*\n     * I don't know why but 1/60 unitStep easily breaks models\n     * so I set it 1/65 so far.\n     * Don't set too small unitStep because\n     * the smaller unitStep can make the performance worse.\n     */\n\n    this.unitStep = params.unitStep !== undefined ? params.unitStep : 1 / 65;\n    this.maxStepNum = params.maxStepNum !== undefined ? params.maxStepNum : 3;\n    this.gravity = new Vector3(0, -9.8 * 10, 0);\n    if (params.gravity !== undefined) this.gravity.copy(params.gravity);\n    this.world = params.world !== undefined ? params.world : null; // experimental\n\n    this.bodies = [];\n    this.constraints = [];\n\n    this._init(mesh, rigidBodyParams, constraintParams);\n  }\n\n  MMDPhysics.prototype = {\n    constructor: MMDPhysics,\n\n    /**\n     * Advances Physics calculation and updates bones.\n     *\n     * @param {Number} delta - time in second\n     * @return {MMDPhysics}\n     */\n    update: function (delta) {\n      const manager = this.manager;\n      const mesh = this.mesh; // rigid bodies and constrains are for\n      // mesh's world scale (1, 1, 1).\n      // Convert to (1, 1, 1) if it isn't.\n\n      let isNonDefaultScale = false;\n      const position = manager.allocThreeVector3();\n      const quaternion = manager.allocThreeQuaternion();\n      const scale = manager.allocThreeVector3();\n      mesh.matrixWorld.decompose(position, quaternion, scale);\n\n      if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {\n        isNonDefaultScale = true;\n      }\n\n      let parent;\n\n      if (isNonDefaultScale) {\n        parent = mesh.parent;\n        if (parent !== null) mesh.parent = null;\n        scale.copy(this.mesh.scale);\n        mesh.scale.set(1, 1, 1);\n        mesh.updateMatrixWorld(true);\n      } // calculate physics and update bones\n\n\n      this._updateRigidBodies();\n\n      this._stepSimulation(delta);\n\n      this._updateBones(); // restore mesh if converted above\n\n\n      if (isNonDefaultScale) {\n        if (parent !== null) mesh.parent = parent;\n        mesh.scale.copy(scale);\n      }\n\n      manager.freeThreeVector3(scale);\n      manager.freeThreeQuaternion(quaternion);\n      manager.freeThreeVector3(position);\n      return this;\n    },\n\n    /**\n     * Resets rigid bodies transorm to current bone's.\n     *\n     * @return {MMDPhysics}\n     */\n    reset: function () {\n      for (let i = 0, il = this.bodies.length; i < il; i++) {\n        this.bodies[i].reset();\n      }\n\n      return this;\n    },\n\n    /**\n     * Warm ups Rigid bodies. Calculates cycles steps.\n     *\n     * @param {Integer} cycles\n     * @return {MMDPhysics}\n     */\n    warmup: function (cycles) {\n      for (let i = 0; i < cycles; i++) {\n        this.update(1 / 60);\n      }\n\n      return this;\n    },\n\n    /**\n     * Sets gravity.\n     *\n     * @param {Vector3} gravity\n     * @return {MMDPhysicsHelper}\n     */\n    setGravity: function (gravity) {\n      this.world.setGravity(new Ammo.btVector3(gravity.x, gravity.y, gravity.z));\n      this.gravity.copy(gravity);\n      return this;\n    },\n\n    /**\n     * Creates MMDPhysicsHelper\n     *\n     * @return {MMDPhysicsHelper}\n     */\n    createHelper: function () {\n      return new MMDPhysicsHelper(this.mesh, this);\n    },\n    // private methods\n    _init: function (mesh, rigidBodyParams, constraintParams) {\n      const manager = this.manager; // rigid body/constraint parameters are for\n      // mesh's default world transform as position(0, 0, 0),\n      // quaternion(0, 0, 0, 1) and scale(0, 0, 0)\n\n      let parent = mesh.parent;\n      if (parent !== null) parent = null;\n      const currentPosition = manager.allocThreeVector3();\n      const currentQuaternion = manager.allocThreeQuaternion();\n      const currentScale = manager.allocThreeVector3();\n      currentPosition.copy(mesh.position);\n      currentQuaternion.copy(mesh.quaternion);\n      currentScale.copy(mesh.scale);\n      mesh.position.set(0, 0, 0);\n      mesh.quaternion.set(0, 0, 0, 1);\n      mesh.scale.set(1, 1, 1);\n      mesh.updateMatrixWorld(true);\n\n      if (this.world === null) {\n        this.world = this._createWorld();\n        this.setGravity(this.gravity);\n      }\n\n      this._initRigidBodies(rigidBodyParams);\n\n      this._initConstraints(constraintParams);\n\n      if (parent !== null) mesh.parent = parent;\n      mesh.position.copy(currentPosition);\n      mesh.quaternion.copy(currentQuaternion);\n      mesh.scale.copy(currentScale);\n      mesh.updateMatrixWorld(true);\n      this.reset();\n      manager.freeThreeVector3(currentPosition);\n      manager.freeThreeQuaternion(currentQuaternion);\n      manager.freeThreeVector3(currentScale);\n    },\n    _createWorld: function () {\n      const config = new Ammo.btDefaultCollisionConfiguration();\n      const dispatcher = new Ammo.btCollisionDispatcher(config);\n      const cache = new Ammo.btDbvtBroadphase();\n      const solver = new Ammo.btSequentialImpulseConstraintSolver();\n      const world = new Ammo.btDiscreteDynamicsWorld(dispatcher, cache, solver, config);\n      return world;\n    },\n    _initRigidBodies: function (rigidBodies) {\n      for (let i = 0, il = rigidBodies.length; i < il; i++) {\n        this.bodies.push(new RigidBody(this.mesh, this.world, rigidBodies[i], this.manager));\n      }\n    },\n    _initConstraints: function (constraints) {\n      for (let i = 0, il = constraints.length; i < il; i++) {\n        const params = constraints[i];\n        const bodyA = this.bodies[params.rigidBodyIndex1];\n        const bodyB = this.bodies[params.rigidBodyIndex2];\n        this.constraints.push(new Constraint(this.mesh, this.world, bodyA, bodyB, params, this.manager));\n      }\n    },\n    _stepSimulation: function (delta) {\n      const unitStep = this.unitStep;\n      let stepTime = delta;\n      let maxStepNum = (delta / unitStep | 0) + 1;\n\n      if (stepTime < unitStep) {\n        stepTime = unitStep;\n        maxStepNum = 1;\n      }\n\n      if (maxStepNum > this.maxStepNum) {\n        maxStepNum = this.maxStepNum;\n      }\n\n      this.world.stepSimulation(stepTime, maxStepNum, unitStep);\n    },\n    _updateRigidBodies: function () {\n      for (let i = 0, il = this.bodies.length; i < il; i++) {\n        this.bodies[i].updateFromBone();\n      }\n    },\n    _updateBones: function () {\n      for (let i = 0, il = this.bodies.length; i < il; i++) {\n        this.bodies[i].updateBone();\n      }\n    }\n  };\n  /**\n   * This manager's responsibilies are\n   *\n   * 1. manage Ammo.js and Three.js object resources and\n   *    improve the performance and the memory consumption by\n   *    reusing objects.\n   *\n   * 2. provide simple Ammo object operations.\n   */\n\n  function ResourceManager() {\n    // for Three.js\n    this.threeVector3s = [];\n    this.threeMatrix4s = [];\n    this.threeQuaternions = [];\n    this.threeEulers = []; // for Ammo.js\n\n    this.transforms = [];\n    this.quaternions = [];\n    this.vector3s = [];\n  }\n\n  ResourceManager.prototype = {\n    constructor: ResourceManager,\n    allocThreeVector3: function () {\n      return this.threeVector3s.length > 0 ? this.threeVector3s.pop() : new Vector3();\n    },\n    freeThreeVector3: function (v) {\n      this.threeVector3s.push(v);\n    },\n    allocThreeMatrix4: function () {\n      return this.threeMatrix4s.length > 0 ? this.threeMatrix4s.pop() : new Matrix4();\n    },\n    freeThreeMatrix4: function (m) {\n      this.threeMatrix4s.push(m);\n    },\n    allocThreeQuaternion: function () {\n      return this.threeQuaternions.length > 0 ? this.threeQuaternions.pop() : new Quaternion();\n    },\n    freeThreeQuaternion: function (q) {\n      this.threeQuaternions.push(q);\n    },\n    allocThreeEuler: function () {\n      return this.threeEulers.length > 0 ? this.threeEulers.pop() : new Euler();\n    },\n    freeThreeEuler: function (e) {\n      this.threeEulers.push(e);\n    },\n    allocTransform: function () {\n      return this.transforms.length > 0 ? this.transforms.pop() : new Ammo.btTransform();\n    },\n    freeTransform: function (t) {\n      this.transforms.push(t);\n    },\n    allocQuaternion: function () {\n      return this.quaternions.length > 0 ? this.quaternions.pop() : new Ammo.btQuaternion();\n    },\n    freeQuaternion: function (q) {\n      this.quaternions.push(q);\n    },\n    allocVector3: function () {\n      return this.vector3s.length > 0 ? this.vector3s.pop() : new Ammo.btVector3();\n    },\n    freeVector3: function (v) {\n      this.vector3s.push(v);\n    },\n    setIdentity: function (t) {\n      t.setIdentity();\n    },\n    getBasis: function (t) {\n      const q = this.allocQuaternion();\n      t.getBasis().getRotation(q);\n      return q;\n    },\n    getBasisAsMatrix3: function (t) {\n      const q = this.getBasis(t);\n      const m = this.quaternionToMatrix3(q);\n      this.freeQuaternion(q);\n      return m;\n    },\n    getOrigin: function (t) {\n      return t.getOrigin();\n    },\n    setOrigin: function (t, v) {\n      t.getOrigin().setValue(v.x(), v.y(), v.z());\n    },\n    copyOrigin: function (t1, t2) {\n      const o = t2.getOrigin();\n      this.setOrigin(t1, o);\n    },\n    setBasis: function (t, q) {\n      t.setRotation(q);\n    },\n    setBasisFromMatrix3: function (t, m) {\n      const q = this.matrix3ToQuaternion(m);\n      this.setBasis(t, q);\n      this.freeQuaternion(q);\n    },\n    setOriginFromArray3: function (t, a) {\n      t.getOrigin().setValue(a[0], a[1], a[2]);\n    },\n    setOriginFromThreeVector3: function (t, v) {\n      t.getOrigin().setValue(v.x, v.y, v.z);\n    },\n    setBasisFromArray3: function (t, a) {\n      const thQ = this.allocThreeQuaternion();\n      const thE = this.allocThreeEuler();\n      thE.set(a[0], a[1], a[2]);\n      this.setBasisFromThreeQuaternion(t, thQ.setFromEuler(thE));\n      this.freeThreeEuler(thE);\n      this.freeThreeQuaternion(thQ);\n    },\n    setBasisFromThreeQuaternion: function (t, a) {\n      const q = this.allocQuaternion();\n      q.setX(a.x);\n      q.setY(a.y);\n      q.setZ(a.z);\n      q.setW(a.w);\n      this.setBasis(t, q);\n      this.freeQuaternion(q);\n    },\n    multiplyTransforms: function (t1, t2) {\n      const t = this.allocTransform();\n      this.setIdentity(t);\n      const m1 = this.getBasisAsMatrix3(t1);\n      const m2 = this.getBasisAsMatrix3(t2);\n      const o1 = this.getOrigin(t1);\n      const o2 = this.getOrigin(t2);\n      const v1 = this.multiplyMatrix3ByVector3(m1, o2);\n      const v2 = this.addVector3(v1, o1);\n      this.setOrigin(t, v2);\n      const m3 = this.multiplyMatrices3(m1, m2);\n      this.setBasisFromMatrix3(t, m3);\n      this.freeVector3(v1);\n      this.freeVector3(v2);\n      return t;\n    },\n    inverseTransform: function (t) {\n      const t2 = this.allocTransform();\n      const m1 = this.getBasisAsMatrix3(t);\n      const o = this.getOrigin(t);\n      const m2 = this.transposeMatrix3(m1);\n      const v1 = this.negativeVector3(o);\n      const v2 = this.multiplyMatrix3ByVector3(m2, v1);\n      this.setOrigin(t2, v2);\n      this.setBasisFromMatrix3(t2, m2);\n      this.freeVector3(v1);\n      this.freeVector3(v2);\n      return t2;\n    },\n    multiplyMatrices3: function (m1, m2) {\n      const m3 = [];\n      const v10 = this.rowOfMatrix3(m1, 0);\n      const v11 = this.rowOfMatrix3(m1, 1);\n      const v12 = this.rowOfMatrix3(m1, 2);\n      const v20 = this.columnOfMatrix3(m2, 0);\n      const v21 = this.columnOfMatrix3(m2, 1);\n      const v22 = this.columnOfMatrix3(m2, 2);\n      m3[0] = this.dotVectors3(v10, v20);\n      m3[1] = this.dotVectors3(v10, v21);\n      m3[2] = this.dotVectors3(v10, v22);\n      m3[3] = this.dotVectors3(v11, v20);\n      m3[4] = this.dotVectors3(v11, v21);\n      m3[5] = this.dotVectors3(v11, v22);\n      m3[6] = this.dotVectors3(v12, v20);\n      m3[7] = this.dotVectors3(v12, v21);\n      m3[8] = this.dotVectors3(v12, v22);\n      this.freeVector3(v10);\n      this.freeVector3(v11);\n      this.freeVector3(v12);\n      this.freeVector3(v20);\n      this.freeVector3(v21);\n      this.freeVector3(v22);\n      return m3;\n    },\n    addVector3: function (v1, v2) {\n      const v = this.allocVector3();\n      v.setValue(v1.x() + v2.x(), v1.y() + v2.y(), v1.z() + v2.z());\n      return v;\n    },\n    dotVectors3: function (v1, v2) {\n      return v1.x() * v2.x() + v1.y() * v2.y() + v1.z() * v2.z();\n    },\n    rowOfMatrix3: function (m, i) {\n      const v = this.allocVector3();\n      v.setValue(m[i * 3 + 0], m[i * 3 + 1], m[i * 3 + 2]);\n      return v;\n    },\n    columnOfMatrix3: function (m, i) {\n      const v = this.allocVector3();\n      v.setValue(m[i + 0], m[i + 3], m[i + 6]);\n      return v;\n    },\n    negativeVector3: function (v) {\n      const v2 = this.allocVector3();\n      v2.setValue(-v.x(), -v.y(), -v.z());\n      return v2;\n    },\n    multiplyMatrix3ByVector3: function (m, v) {\n      const v4 = this.allocVector3();\n      const v0 = this.rowOfMatrix3(m, 0);\n      const v1 = this.rowOfMatrix3(m, 1);\n      const v2 = this.rowOfMatrix3(m, 2);\n      const x = this.dotVectors3(v0, v);\n      const y = this.dotVectors3(v1, v);\n      const z = this.dotVectors3(v2, v);\n      v4.setValue(x, y, z);\n      this.freeVector3(v0);\n      this.freeVector3(v1);\n      this.freeVector3(v2);\n      return v4;\n    },\n    transposeMatrix3: function (m) {\n      const m2 = [];\n      m2[0] = m[0];\n      m2[1] = m[3];\n      m2[2] = m[6];\n      m2[3] = m[1];\n      m2[4] = m[4];\n      m2[5] = m[7];\n      m2[6] = m[2];\n      m2[7] = m[5];\n      m2[8] = m[8];\n      return m2;\n    },\n    quaternionToMatrix3: function (q) {\n      const m = [];\n      const x = q.x();\n      const y = q.y();\n      const z = q.z();\n      const w = q.w();\n      const xx = x * x;\n      const yy = y * y;\n      const zz = z * z;\n      const xy = x * y;\n      const yz = y * z;\n      const zx = z * x;\n      const xw = x * w;\n      const yw = y * w;\n      const zw = z * w;\n      m[0] = 1 - 2 * (yy + zz);\n      m[1] = 2 * (xy - zw);\n      m[2] = 2 * (zx + yw);\n      m[3] = 2 * (xy + zw);\n      m[4] = 1 - 2 * (zz + xx);\n      m[5] = 2 * (yz - xw);\n      m[6] = 2 * (zx - yw);\n      m[7] = 2 * (yz + xw);\n      m[8] = 1 - 2 * (xx + yy);\n      return m;\n    },\n    matrix3ToQuaternion: function (m) {\n      const t = m[0] + m[4] + m[8];\n      let s, x, y, z, w;\n\n      if (t > 0) {\n        s = Math.sqrt(t + 1.0) * 2;\n        w = 0.25 * s;\n        x = (m[7] - m[5]) / s;\n        y = (m[2] - m[6]) / s;\n        z = (m[3] - m[1]) / s;\n      } else if (m[0] > m[4] && m[0] > m[8]) {\n        s = Math.sqrt(1.0 + m[0] - m[4] - m[8]) * 2;\n        w = (m[7] - m[5]) / s;\n        x = 0.25 * s;\n        y = (m[1] + m[3]) / s;\n        z = (m[2] + m[6]) / s;\n      } else if (m[4] > m[8]) {\n        s = Math.sqrt(1.0 + m[4] - m[0] - m[8]) * 2;\n        w = (m[2] - m[6]) / s;\n        x = (m[1] + m[3]) / s;\n        y = 0.25 * s;\n        z = (m[5] + m[7]) / s;\n      } else {\n        s = Math.sqrt(1.0 + m[8] - m[0] - m[4]) * 2;\n        w = (m[3] - m[1]) / s;\n        x = (m[2] + m[6]) / s;\n        y = (m[5] + m[7]) / s;\n        z = 0.25 * s;\n      }\n\n      const q = this.allocQuaternion();\n      q.setX(x);\n      q.setY(y);\n      q.setZ(z);\n      q.setW(w);\n      return q;\n    }\n  };\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Ammo.btDiscreteDynamicsWorld} world\n   * @param {Object} params\n   * @param {ResourceManager} manager\n   */\n\n  function RigidBody(mesh, world, params, manager) {\n    this.mesh = mesh;\n    this.world = world;\n    this.params = params;\n    this.manager = manager;\n    this.body = null;\n    this.bone = null;\n    this.boneOffsetForm = null;\n    this.boneOffsetFormInverse = null;\n\n    this._init();\n  }\n\n  RigidBody.prototype = {\n    constructor: MMDPhysics.RigidBody,\n\n    /**\n     * Resets rigid body transform to the current bone's.\n     *\n     * @return {RigidBody}\n     */\n    reset: function () {\n      this._setTransformFromBone();\n\n      return this;\n    },\n\n    /**\n     * Updates rigid body's transform from the current bone.\n     *\n     * @return {RidigBody}\n     */\n    updateFromBone: function () {\n      if (this.params.boneIndex !== -1 && this.params.type === 0) {\n        this._setTransformFromBone();\n      }\n\n      return this;\n    },\n\n    /**\n     * Updates bone from the current ridid body's transform.\n     *\n     * @return {RidigBody}\n     */\n    updateBone: function () {\n      if (this.params.type === 0 || this.params.boneIndex === -1) {\n        return this;\n      }\n\n      this._updateBoneRotation();\n\n      if (this.params.type === 1) {\n        this._updateBonePosition();\n      }\n\n      this.bone.updateMatrixWorld(true);\n\n      if (this.params.type === 2) {\n        this._setPositionFromBone();\n      }\n\n      return this;\n    },\n    // private methods\n    _init: function () {\n      function generateShape(p) {\n        switch (p.shapeType) {\n          case 0:\n            return new Ammo.btSphereShape(p.width);\n\n          case 1:\n            return new Ammo.btBoxShape(new Ammo.btVector3(p.width, p.height, p.depth));\n\n          case 2:\n            return new Ammo.btCapsuleShape(p.width, p.height);\n\n          default:\n            throw `unknown shape type ${p.shapeType}`;\n        }\n      }\n\n      const manager = this.manager;\n      const params = this.params;\n      const bones = this.mesh.skeleton.bones;\n      const bone = params.boneIndex === -1 ? new Bone() : bones[params.boneIndex];\n      const shape = generateShape(params);\n      const weight = params.type === 0 ? 0 : params.weight;\n      const localInertia = manager.allocVector3();\n      localInertia.setValue(0, 0, 0);\n\n      if (weight !== 0) {\n        shape.calculateLocalInertia(weight, localInertia);\n      }\n\n      const boneOffsetForm = manager.allocTransform();\n      manager.setIdentity(boneOffsetForm);\n      manager.setOriginFromArray3(boneOffsetForm, params.position);\n      manager.setBasisFromArray3(boneOffsetForm, params.rotation);\n      const vector = manager.allocThreeVector3();\n      const boneForm = manager.allocTransform();\n      manager.setIdentity(boneForm);\n      manager.setOriginFromThreeVector3(boneForm, bone.getWorldPosition(vector));\n      const form = manager.multiplyTransforms(boneForm, boneOffsetForm);\n      const state = new Ammo.btDefaultMotionState(form);\n      const info = new Ammo.btRigidBodyConstructionInfo(weight, state, shape, localInertia);\n      info.set_m_friction(params.friction);\n      info.set_m_restitution(params.restitution);\n      const body = new Ammo.btRigidBody(info);\n\n      if (params.type === 0) {\n        body.setCollisionFlags(body.getCollisionFlags() | 2);\n        /*\n         * It'd be better to comment out this line though in general I should call this method\n         * because I'm not sure why but physics will be more like MMD's\n         * if I comment out.\n         */\n\n        body.setActivationState(4);\n      }\n\n      body.setDamping(params.positionDamping, params.rotationDamping);\n      body.setSleepingThresholds(0, 0);\n      this.world.addRigidBody(body, 1 << params.groupIndex, params.groupTarget);\n      this.body = body;\n      this.bone = bone;\n      this.boneOffsetForm = boneOffsetForm;\n      this.boneOffsetFormInverse = manager.inverseTransform(boneOffsetForm);\n      manager.freeVector3(localInertia);\n      manager.freeTransform(form);\n      manager.freeTransform(boneForm);\n      manager.freeThreeVector3(vector);\n    },\n    _getBoneTransform: function () {\n      const manager = this.manager;\n      const p = manager.allocThreeVector3();\n      const q = manager.allocThreeQuaternion();\n      const s = manager.allocThreeVector3();\n      this.bone.matrixWorld.decompose(p, q, s);\n      const tr = manager.allocTransform();\n      manager.setOriginFromThreeVector3(tr, p);\n      manager.setBasisFromThreeQuaternion(tr, q);\n      const form = manager.multiplyTransforms(tr, this.boneOffsetForm);\n      manager.freeTransform(tr);\n      manager.freeThreeVector3(s);\n      manager.freeThreeQuaternion(q);\n      manager.freeThreeVector3(p);\n      return form;\n    },\n    _getWorldTransformForBone: function () {\n      const manager = this.manager;\n      const tr = this.body.getCenterOfMassTransform();\n      return manager.multiplyTransforms(tr, this.boneOffsetFormInverse);\n    },\n    _setTransformFromBone: function () {\n      const manager = this.manager;\n\n      const form = this._getBoneTransform(); // TODO: check the most appropriate way to set\n      //this.body.setWorldTransform( form );\n\n\n      this.body.setCenterOfMassTransform(form);\n      this.body.getMotionState().setWorldTransform(form);\n      manager.freeTransform(form);\n    },\n    _setPositionFromBone: function () {\n      const manager = this.manager;\n\n      const form = this._getBoneTransform();\n\n      const tr = manager.allocTransform();\n      this.body.getMotionState().getWorldTransform(tr);\n      manager.copyOrigin(tr, form); // TODO: check the most appropriate way to set\n      //this.body.setWorldTransform( tr );\n\n      this.body.setCenterOfMassTransform(tr);\n      this.body.getMotionState().setWorldTransform(tr);\n      manager.freeTransform(tr);\n      manager.freeTransform(form);\n    },\n    _updateBoneRotation: function () {\n      const manager = this.manager;\n\n      const tr = this._getWorldTransformForBone();\n\n      const q = manager.getBasis(tr);\n      const thQ = manager.allocThreeQuaternion();\n      const thQ2 = manager.allocThreeQuaternion();\n      const thQ3 = manager.allocThreeQuaternion();\n      thQ.set(q.x(), q.y(), q.z(), q.w());\n      thQ2.setFromRotationMatrix(this.bone.matrixWorld);\n      thQ2.conjugate();\n      thQ2.multiply(thQ); //this.bone.quaternion.multiply( thQ2 );\n\n      thQ3.setFromRotationMatrix(this.bone.matrix); // Renormalizing quaternion here because repeatedly transforming\n      // quaternion continuously accumulates floating point error and\n      // can end up being overflow. See #15335\n\n      this.bone.quaternion.copy(thQ2.multiply(thQ3).normalize());\n      manager.freeThreeQuaternion(thQ);\n      manager.freeThreeQuaternion(thQ2);\n      manager.freeThreeQuaternion(thQ3);\n      manager.freeQuaternion(q);\n      manager.freeTransform(tr);\n    },\n    _updateBonePosition: function () {\n      const manager = this.manager;\n\n      const tr = this._getWorldTransformForBone();\n\n      const thV = manager.allocThreeVector3();\n      const o = manager.getOrigin(tr);\n      thV.set(o.x(), o.y(), o.z());\n\n      if (this.bone.parent) {\n        this.bone.parent.worldToLocal(thV);\n      }\n\n      this.bone.position.copy(thV);\n      manager.freeThreeVector3(thV);\n      manager.freeTransform(tr);\n    }\n  };\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Ammo.btDiscreteDynamicsWorld} world\n   * @param {RigidBody} bodyA\n   * @param {RigidBody} bodyB\n   * @param {Object} params\n   * @param {ResourceManager} manager\n   */\n\n  function Constraint(mesh, world, bodyA, bodyB, params, manager) {\n    this.mesh = mesh;\n    this.world = world;\n    this.bodyA = bodyA;\n    this.bodyB = bodyB;\n    this.params = params;\n    this.manager = manager;\n    this.constraint = null;\n\n    this._init();\n  }\n\n  Constraint.prototype = {\n    constructor: Constraint,\n    // private method\n    _init: function () {\n      const manager = this.manager;\n      const params = this.params;\n      const bodyA = this.bodyA;\n      const bodyB = this.bodyB;\n      const form = manager.allocTransform();\n      manager.setIdentity(form);\n      manager.setOriginFromArray3(form, params.position);\n      manager.setBasisFromArray3(form, params.rotation);\n      const formA = manager.allocTransform();\n      const formB = manager.allocTransform();\n      bodyA.body.getMotionState().getWorldTransform(formA);\n      bodyB.body.getMotionState().getWorldTransform(formB);\n      const formInverseA = manager.inverseTransform(formA);\n      const formInverseB = manager.inverseTransform(formB);\n      const formA2 = manager.multiplyTransforms(formInverseA, form);\n      const formB2 = manager.multiplyTransforms(formInverseB, form);\n      const constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA.body, bodyB.body, formA2, formB2, true);\n      const lll = manager.allocVector3();\n      const lul = manager.allocVector3();\n      const all = manager.allocVector3();\n      const aul = manager.allocVector3();\n      lll.setValue(params.translationLimitation1[0], params.translationLimitation1[1], params.translationLimitation1[2]);\n      lul.setValue(params.translationLimitation2[0], params.translationLimitation2[1], params.translationLimitation2[2]);\n      all.setValue(params.rotationLimitation1[0], params.rotationLimitation1[1], params.rotationLimitation1[2]);\n      aul.setValue(params.rotationLimitation2[0], params.rotationLimitation2[1], params.rotationLimitation2[2]);\n      constraint.setLinearLowerLimit(lll);\n      constraint.setLinearUpperLimit(lul);\n      constraint.setAngularLowerLimit(all);\n      constraint.setAngularUpperLimit(aul);\n\n      for (let i = 0; i < 3; i++) {\n        if (params.springPosition[i] !== 0) {\n          constraint.enableSpring(i, true);\n          constraint.setStiffness(i, params.springPosition[i]);\n        }\n      }\n\n      for (let i = 0; i < 3; i++) {\n        if (params.springRotation[i] !== 0) {\n          constraint.enableSpring(i + 3, true);\n          constraint.setStiffness(i + 3, params.springRotation[i]);\n        }\n      }\n      /*\n       * Currently(10/31/2016) official ammo.js doesn't support\n       * btGeneric6DofSpringConstraint.setParam method.\n       * You need custom ammo.js (add the method into idl) if you wanna use.\n       * By setting this parameter, physics will be more like MMD's\n       */\n\n\n      if (constraint.setParam !== undefined) {\n        for (let i = 0; i < 6; i++) {\n          // this parameter is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n          constraint.setParam(2, 0.475, i);\n        }\n      }\n\n      this.world.addConstraint(constraint, true);\n      this.constraint = constraint;\n      manager.freeTransform(form);\n      manager.freeTransform(formA);\n      manager.freeTransform(formB);\n      manager.freeTransform(formInverseA);\n      manager.freeTransform(formInverseB);\n      manager.freeTransform(formA2);\n      manager.freeTransform(formB2);\n      manager.freeVector3(lll);\n      manager.freeVector3(lul);\n      manager.freeVector3(all);\n      manager.freeVector3(aul);\n    }\n  };\n  /**\n   * Visualize Rigid bodies\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Physics} physics\n   */\n\n  function MMDPhysicsHelper(mesh, physics) {\n    Object3D.call(this);\n    this.root = mesh;\n    this.physics = physics;\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.materials = [];\n    this.materials.push(new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      wireframe: true,\n      depthTest: false,\n      depthWrite: false,\n      opacity: 0.25,\n      transparent: true\n    }));\n    this.materials.push(new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      wireframe: true,\n      depthTest: false,\n      depthWrite: false,\n      opacity: 0.25,\n      transparent: true\n    }));\n    this.materials.push(new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      wireframe: true,\n      depthTest: false,\n      depthWrite: false,\n      opacity: 0.25,\n      transparent: true\n    }));\n\n    this._init();\n  }\n\n  MMDPhysicsHelper.prototype = Object.assign(Object.create(Object3D.prototype), {\n    constructor: MMDPhysicsHelper,\n\n    /**\n     * Updates Rigid Bodies visualization.\n     */\n    updateMatrixWorld: (() => {\n      const position = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      const matrixWorldInv = new Matrix4();\n      return function updateMatrixWorld(force) {\n        const mesh = this.root;\n\n        if (this.visible) {\n          const bodies = this.physics.bodies;\n          matrixWorldInv.copy(mesh.matrixWorld).decompose(position, quaternion, scale).compose(position, quaternion, scale.set(1, 1, 1)).invert();\n\n          for (let i = 0, il = bodies.length; i < il; i++) {\n            const body = bodies[i].body;\n            const child = this.children[i];\n            const tr = body.getCenterOfMassTransform();\n            const origin = tr.getOrigin();\n            const rotation = tr.getRotation();\n            child.position.set(origin.x(), origin.y(), origin.z()).applyMatrix4(matrixWorldInv);\n            child.quaternion.setFromRotationMatrix(matrixWorldInv).multiply(quaternion.set(rotation.x(), rotation.y(), rotation.z(), rotation.w()));\n          }\n        }\n\n        this.matrix.copy(mesh.matrixWorld).decompose(position, quaternion, scale).compose(position, quaternion, scale.set(1, 1, 1));\n        Object3D.prototype.updateMatrixWorld.call(this, force);\n      };\n    })(),\n    // private method\n    _init: function () {\n      const bodies = this.physics.bodies;\n\n      function createGeometry(param) {\n        switch (param.shapeType) {\n          case 0:\n            return new SphereGeometry(param.width, 16, 8);\n\n          case 1:\n            return new BoxGeometry(param.width * 2, param.height * 2, param.depth * 2, 8, 8, 8);\n\n          case 2:\n            return new createCapsuleGeometry(param.width, param.height, 16, 8);\n\n          default:\n            return null;\n        }\n      } // copy from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mytest37.js?ver=20160815\n\n\n      function createCapsuleGeometry(radius, cylinderHeight, segmentsRadius, segmentsHeight) {\n        const geometry = new CylinderGeometry(radius, radius, cylinderHeight, segmentsRadius, segmentsHeight, true);\n        const upperSphere = new Mesh(new SphereGeometry(radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, 0, Math.PI / 2));\n        const lowerSphere = new Mesh(new SphereGeometry(radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2));\n        upperSphere.position.set(0, cylinderHeight / 2, 0);\n        lowerSphere.position.set(0, -cylinderHeight / 2, 0);\n        upperSphere.updateMatrix();\n        lowerSphere.updateMatrix();\n        geometry.merge(upperSphere.geometry, upperSphere.matrix);\n        geometry.merge(lowerSphere.geometry, lowerSphere.matrix);\n        return geometry;\n      }\n\n      for (let i = 0, il = bodies.length; i < il; i++) {\n        const param = bodies[i].params;\n        this.add(new Mesh(createGeometry(param), this.materials[param.type]));\n      }\n    }\n  });\n  return MMDPhysics;\n})();\n\nexport { MMDPhysics };\n", "import { Quaternion, Object3D, Vector3, AnimationMixer } from 'three';\nimport { CCDIKSolver } from './CCDIKSolver.js';\nimport { MMDPhysics } from './MMDPhysics.js';\n\n/**\n * MMDAnimationHelper handles animation of MMD assets loaded by MMDLoader\n * with MMD special features as IK, Grant, and Physics.\n *\n * Dependencies\n *  - ammo.js https://github.com/kripken/ammo.js\n *  - MMDPhysics\n *  - CCDIKSolver\n *\n * TODO\n *  - more precise grant skinning support.\n */\n\nconst MMDAnimationHelper = (() => {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  function MMDAnimationHelper(params) {\n    params = params || {};\n    this.meshes = [];\n    this.camera = null;\n    this.cameraTarget = new Object3D();\n    this.cameraTarget.name = 'target';\n    this.audio = null;\n    this.audioManager = null;\n    this.objects = new WeakMap();\n    this.configuration = {\n      sync: params.sync !== undefined ? params.sync : true,\n      afterglow: params.afterglow !== undefined ? params.afterglow : 0.0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== undefined ? params.resetPhysicsOnLoop : true\n    };\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true\n    };\n\n    this.onBeforePhysics = () =>\n    /* mesh */\n    {}; // experimental\n\n\n    this.sharedPhysics = false;\n    this.masterPhysics = null;\n  }\n\n  MMDAnimationHelper.prototype = {\n    constructor: MMDAnimationHelper,\n\n    /**\n     * Adds an Three.js Object to helper and setups animation.\n     * The anmation durations of added objects are synched\n     * if this.configuration.sync is true.\n     *\n     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n     * @param {Object} params - (optional)\n     * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n     * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n     * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n     * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n     * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n     * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n     * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n     * @return {MMDAnimationHelper}\n     */\n    add: function (object, params) {\n      params = params || {};\n\n      if (object.isSkinnedMesh) {\n        this._addMesh(object, params);\n      } else if (object.isCamera) {\n        this._setupCamera(object, params);\n      } else if (object.type === 'Audio') {\n        this._setupAudio(object, params);\n      } else {\n        throw new Error('THREE.MMDAnimationHelper.add: ' + 'accepts only ' + 'THREE.SkinnedMesh or ' + 'THREE.Camera or ' + 'THREE.Audio instance.');\n      }\n\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    },\n\n    /**\n     * Removes an Three.js Object from helper.\n     *\n     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n     * @return {MMDAnimationHelper}\n     */\n    remove: function (object) {\n      if (object.isSkinnedMesh) {\n        this._removeMesh(object);\n      } else if (object.isCamera) {\n        this._clearCamera(object);\n      } else if (object.type === 'Audio') {\n        this._clearAudio(object);\n      } else {\n        throw new Error('THREE.MMDAnimationHelper.remove: ' + 'accepts only ' + 'THREE.SkinnedMesh or ' + 'THREE.Camera or ' + 'THREE.Audio instance.');\n      }\n\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    },\n\n    /**\n     * Updates the animation.\n     *\n     * @param {Number} delta\n     * @return {MMDAnimationHelper}\n     */\n    update: function (delta) {\n      if (this.audioManager !== null) this.audioManager.control(delta);\n\n      for (let i = 0; i < this.meshes.length; i++) {\n        this._animateMesh(this.meshes[i], delta);\n      }\n\n      if (this.sharedPhysics) this._updateSharedPhysics(delta);\n      if (this.camera !== null) this._animateCamera(this.camera, delta);\n      return this;\n    },\n\n    /**\n     * Changes the pose of SkinnedMesh as VPD specifies.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @param {Object} vpd - VPD content parsed MMDParser\n     * @param {Object} params - (optional)\n     * @param {boolean} params.resetPose - Default is true.\n     * @param {boolean} params.ik - Default is true.\n     * @param {boolean} params.grant - Default is true.\n     * @return {MMDAnimationHelper}\n     */\n    pose: function (mesh, vpd, params) {\n      params = params || {};\n      if (params.resetPose !== false) mesh.pose();\n      const bones = mesh.skeleton.bones;\n      const boneParams = vpd.bones;\n      const boneNameDictionary = {};\n\n      for (let i = 0, il = bones.length; i < il; i++) {\n        boneNameDictionary[bones[i].name] = i;\n      }\n\n      const vector = new Vector3();\n      const quaternion = new Quaternion();\n\n      for (let i = 0, il = boneParams.length; i < il; i++) {\n        const boneParam = boneParams[i];\n        const boneIndex = boneNameDictionary[boneParam.name];\n        if (boneIndex === undefined) continue;\n        const bone = bones[boneIndex];\n        bone.position.add(vector.fromArray(boneParam.translation));\n        bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));\n      }\n\n      mesh.updateMatrixWorld(true);\n\n      if (params.ik !== false) {\n        this._createCCDIKSolver(mesh).update(params.saveOriginalBonesBeforeIK); // this param is experimental\n\n      }\n\n      if (params.grant !== false) {\n        this.createGrantSolver(mesh).update();\n      }\n\n      return this;\n    },\n\n    /**\n     * Enabes/Disables an animation feature.\n     *\n     * @param {string} key\n     * @param {boolean} enabled\n     * @return {MMDAnimationHelper}\n     */\n    enable: function (key, enabled) {\n      if (this.enabled[key] === undefined) {\n        throw new Error(`THREE.MMDAnimationHelper.enable: unknown key ${key}`);\n      }\n\n      this.enabled[key] = enabled;\n\n      if (key === 'physics') {\n        for (let i = 0, il = this.meshes.length; i < il; i++) {\n          this._optimizeIK(this.meshes[i], enabled);\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * Creates an GrantSolver instance.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @return {GrantSolver}\n     */\n    createGrantSolver: function (mesh) {\n      return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);\n    },\n    // private methods\n    _addMesh: function (mesh, params) {\n      if (this.meshes.indexOf(mesh) >= 0) {\n        throw new Error(`THREE.MMDAnimationHelper._addMesh: SkinnedMesh '${mesh.name}' has already been added.`);\n      }\n\n      this.meshes.push(mesh);\n      this.objects.set(mesh, {\n        looped: false\n      });\n\n      this._setupMeshAnimation(mesh, params.animation);\n\n      if (params.physics !== false) {\n        this._setupMeshPhysics(mesh, params);\n      }\n\n      return this;\n    },\n    _setupCamera: function (camera, params) {\n      if (this.camera === camera) {\n        throw new Error(`THREE.MMDAnimationHelper._setupCamera: Camera '${camera.name}' has already been set.`);\n      }\n\n      if (this.camera) this.clearCamera(this.camera);\n      this.camera = camera;\n      camera.add(this.cameraTarget);\n      this.objects.set(camera, {});\n\n      if (params.animation !== undefined) {\n        this._setupCameraAnimation(camera, params.animation);\n      }\n\n      return this;\n    },\n    _setupAudio: function (audio, params) {\n      if (this.audio === audio) {\n        throw new Error(`THREE.MMDAnimationHelper._setupAudio: Audio '${audio.name}' has already been set.`);\n      }\n\n      if (this.audio) this.clearAudio(this.audio);\n      this.audio = audio;\n      this.audioManager = new AudioManager(audio, params);\n      this.objects.set(this.audioManager, {\n        duration: this.audioManager.duration\n      });\n      return this;\n    },\n    _removeMesh: function (mesh) {\n      let found = false;\n      let writeIndex = 0;\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        if (this.meshes[i] === mesh) {\n          this.objects.delete(mesh);\n          found = true;\n          continue;\n        }\n\n        this.meshes[writeIndex++] = this.meshes[i];\n      }\n\n      if (!found) {\n        throw new Error(`THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '${mesh.name}' has not been added yet.`);\n      }\n\n      this.meshes.length = writeIndex;\n      return this;\n    },\n    _clearCamera: function (camera) {\n      if (camera !== this.camera) {\n        throw new Error(`THREE.MMDAnimationHelper._clearCamera: Camera '${camera.name}' has not been set yet.`);\n      }\n\n      this.camera.remove(this.cameraTarget);\n      this.objects.delete(this.camera);\n      this.camera = null;\n      return this;\n    },\n    _clearAudio: function (audio) {\n      if (audio !== this.audio) {\n        throw new Error(`THREE.MMDAnimationHelper._clearAudio: Audio '${audio.name}' has not been set yet.`);\n      }\n\n      this.objects.delete(this.audioManager);\n      this.audio = null;\n      this.audioManager = null;\n      return this;\n    },\n    _setupMeshAnimation: function (mesh, animation) {\n      const objects = this.objects.get(mesh);\n\n      if (animation !== undefined) {\n        const animations = Array.isArray(animation) ? animation : [animation];\n        objects.mixer = new AnimationMixer(mesh);\n\n        for (let i = 0, il = animations.length; i < il; i++) {\n          objects.mixer.clipAction(animations[i]).play();\n        } // TODO: find a workaround not to access ._clip looking like a private property\n\n\n        objects.mixer.addEventListener('loop', event => {\n          const tracks = event.action._clip.tracks;\n          if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== '.bones') return;\n          objects.looped = true;\n        });\n      }\n\n      objects.ikSolver = this._createCCDIKSolver(mesh);\n      objects.grantSolver = this.createGrantSolver(mesh);\n      return this;\n    },\n    _setupCameraAnimation: function (camera, animation) {\n      const animations = Array.isArray(animation) ? animation : [animation];\n      const objects = this.objects.get(camera);\n      objects.mixer = new AnimationMixer(camera);\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play();\n      }\n    },\n    _setupMeshPhysics: function (mesh, params) {\n      const objects = this.objects.get(mesh); // shared physics is experimental\n\n      if (params.world === undefined && this.sharedPhysics) {\n        const masterPhysics = this._getMasterPhysics();\n\n        if (masterPhysics !== null) world = masterPhysics.world; // eslint-disable-line no-undef\n      }\n\n      objects.physics = this._createMMDPhysics(mesh, params);\n\n      if (objects.mixer && params.animationWarmup !== false) {\n        this._animateMesh(mesh, 0);\n\n        objects.physics.reset();\n      }\n\n      objects.physics.warmup(params.warmup !== undefined ? params.warmup : 60);\n\n      this._optimizeIK(mesh, true);\n    },\n    _animateMesh: function (mesh, delta) {\n      const objects = this.objects.get(mesh);\n      const mixer = objects.mixer;\n      const ikSolver = objects.ikSolver;\n      const grantSolver = objects.grantSolver;\n      const physics = objects.physics;\n      const looped = objects.looped; // alternate solution to save/restore bones but less performant?\n      //mesh.pose();\n      //this._updatePropertyMixersBuffer( mesh );\n\n      if (mixer && this.enabled.animation) {\n        this._restoreBones(mesh);\n\n        mixer.update(delta);\n\n        this._saveBones(mesh);\n\n        if (ikSolver && this.enabled.ik) {\n          mesh.updateMatrixWorld(true);\n          ikSolver.update();\n        }\n\n        if (grantSolver && this.enabled.grant) {\n          grantSolver.update();\n        }\n      }\n\n      if (looped === true && this.enabled.physics) {\n        if (physics && this.configuration.resetPhysicsOnLoop) physics.reset();\n        objects.looped = false;\n      }\n\n      if (physics && this.enabled.physics && !this.sharedPhysics) {\n        this.onBeforePhysics(mesh);\n        physics.update(delta);\n      }\n    },\n    _animateCamera: function (camera, delta) {\n      const mixer = this.objects.get(camera).mixer;\n\n      if (mixer && this.enabled.cameraAnimation) {\n        mixer.update(delta);\n        camera.updateProjectionMatrix();\n        camera.up.set(0, 1, 0);\n        camera.up.applyQuaternion(camera.quaternion);\n        camera.lookAt(this.cameraTarget.position);\n      }\n    },\n    _optimizeIK: function (mesh, physicsEnabled) {\n      const iks = mesh.geometry.userData.MMD.iks;\n      const bones = mesh.geometry.userData.MMD.bones;\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const links = ik.links;\n\n        for (let j = 0, jl = links.length; j < jl; j++) {\n          const link = links[j];\n\n          if (physicsEnabled === true) {\n            // disable IK of the bone the corresponding rigidBody type of which is 1 or 2\n            // because its rotation will be overriden by physics\n            link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\n          } else {\n            link.enabled = true;\n          }\n        }\n      }\n    },\n    _createCCDIKSolver: function (mesh) {\n      if (CCDIKSolver === undefined) {\n        throw new Error('THREE.MMDAnimationHelper: Import CCDIKSolver.');\n      }\n\n      return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);\n    },\n    _createMMDPhysics: function (mesh, params) {\n      if (MMDPhysics === undefined) {\n        throw new Error('THREE.MMDPhysics: Import MMDPhysics.');\n      }\n\n      return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);\n    },\n\n    /*\n     * Detects the longest duration and then sets it to them to sync.\n     * TODO: Not to access private properties ( ._actions and ._clip )\n     */\n    _syncDuration: function () {\n      let max = 0.0;\n      const objects = this.objects;\n      const meshes = this.meshes;\n      const camera = this.camera;\n      const audioManager = this.audioManager; // get the longest duration\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        var mixer = this.objects.get(meshes[i]).mixer;\n        if (mixer === undefined) continue;\n\n        for (let j = 0; j < mixer._actions.length; j++) {\n          var clip = mixer._actions[j]._clip;\n\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration\n            });\n          }\n\n          max = Math.max(max, objects.get(clip).duration);\n        }\n      }\n\n      if (camera !== null) {\n        var mixer = this.objects.get(camera).mixer;\n\n        if (mixer !== undefined) {\n          for (let i = 0, il = mixer._actions.length; i < il; i++) {\n            var clip = mixer._actions[i]._clip;\n\n            if (!objects.has(clip)) {\n              objects.set(clip, {\n                duration: clip.duration\n              });\n            }\n\n            max = Math.max(max, objects.get(clip).duration);\n          }\n        }\n      }\n\n      if (audioManager !== null) {\n        max = Math.max(max, objects.get(audioManager).duration);\n      }\n\n      max += this.configuration.afterglow; // update the duration\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        var mixer = this.objects.get(this.meshes[i]).mixer;\n        if (mixer === undefined) continue;\n\n        for (let j = 0, jl = mixer._actions.length; j < jl; j++) {\n          mixer._actions[j]._clip.duration = max;\n        }\n      }\n\n      if (camera !== null) {\n        var mixer = this.objects.get(camera).mixer;\n\n        if (mixer !== undefined) {\n          for (let i = 0, il = mixer._actions.length; i < il; i++) {\n            mixer._actions[i]._clip.duration = max;\n          }\n        }\n      }\n\n      if (audioManager !== null) {\n        audioManager.duration = max;\n      }\n    },\n    // workaround\n    _updatePropertyMixersBuffer: function (mesh) {\n      const mixer = this.objects.get(mesh).mixer;\n      const propertyMixers = mixer._bindings;\n      const accuIndex = mixer._accuIndex;\n\n      for (let i = 0, il = propertyMixers.length; i < il; i++) {\n        const propertyMixer = propertyMixers[i];\n        const buffer = propertyMixer.buffer;\n        const stride = propertyMixer.valueSize;\n        const offset = (accuIndex + 1) * stride;\n        propertyMixer.binding.getValue(buffer, offset);\n      }\n    },\n\n    /*\n     * Avoiding these two issues by restore/save bones before/after mixer animation.\n     *\n     * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n     *    Calculating IK, Grant, and Physics after mixer animation can break\n     *    the cache coherency.\n     *\n     * 2. Applying Grant two or more times without reset the posing breaks model.\n     */\n    _saveBones: function (mesh) {\n      const objects = this.objects.get(mesh);\n      const bones = mesh.skeleton.bones;\n      let backupBones = objects.backupBones;\n\n      if (backupBones === undefined) {\n        backupBones = new Float32Array(bones.length * 7);\n        objects.backupBones = backupBones;\n      }\n\n      for (let i = 0, il = bones.length; i < il; i++) {\n        const bone = bones[i];\n        bone.position.toArray(backupBones, i * 7);\n        bone.quaternion.toArray(backupBones, i * 7 + 3);\n      }\n    },\n    _restoreBones: function (mesh) {\n      const objects = this.objects.get(mesh);\n      const backupBones = objects.backupBones;\n      if (backupBones === undefined) return;\n      const bones = mesh.skeleton.bones;\n\n      for (let i = 0, il = bones.length; i < il; i++) {\n        const bone = bones[i];\n        bone.position.fromArray(backupBones, i * 7);\n        bone.quaternion.fromArray(backupBones, i * 7 + 3);\n      }\n    },\n    // experimental\n    _getMasterPhysics: function () {\n      if (this.masterPhysics !== null) return this.masterPhysics;\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        const physics = this.meshes[i].physics;\n\n        if (physics !== undefined && physics !== null) {\n          this.masterPhysics = physics;\n          return this.masterPhysics;\n        }\n      }\n\n      return null;\n    },\n    _updateSharedPhysics: function (delta) {\n      if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return;\n\n      const physics = this._getMasterPhysics();\n\n      if (physics === null) return;\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        var p = this.meshes[i].physics;\n\n        if (p !== null && p !== undefined) {\n          p.updateRigidBodies();\n        }\n      }\n\n      physics.stepSimulation(delta);\n\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        var p = this.meshes[i].physics;\n\n        if (p !== null && p !== undefined) {\n          p.updateBones();\n        }\n      }\n    }\n  }; //\n\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n\n  function AudioManager(audio, params) {\n    params = params || {};\n    this.audio = audio;\n    this.elapsedTime = 0.0;\n    this.currentTime = 0.0;\n    this.delayTime = params.delayTime !== undefined ? params.delayTime : 0.0;\n    this.audioDuration = this.audio.buffer.duration;\n    this.duration = this.audioDuration + this.delayTime;\n  }\n\n  AudioManager.prototype = {\n    constructor: AudioManager,\n\n    /**\n     * @param {Number} delta\n     * @return {AudioManager}\n     */\n    control: function (delta) {\n      this.elapsed += delta;\n      this.currentTime += delta;\n      if (this._shouldStopAudio()) this.audio.stop();\n      if (this._shouldStartAudio()) this.audio.play();\n      return this;\n    },\n    // private methods\n    _shouldStartAudio: function () {\n      if (this.audio.isPlaying) return false;\n\n      while (this.currentTime >= this.duration) {\n        this.currentTime -= this.duration;\n      }\n\n      if (this.currentTime < this.delayTime) return false; // 'duration' can be bigger than 'audioDuration + delayTime' because of sync configuration\n\n      if (this.currentTime - this.delayTime > this.audioDuration) return false;\n      return true;\n    },\n    _shouldStopAudio: function () {\n      return this.audio.isPlaying && this.currentTime >= this.duration;\n    }\n  };\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} grants\n   */\n\n  function GrantSolver(mesh, grants) {\n    this.mesh = mesh;\n    this.grants = grants || [];\n  }\n\n  GrantSolver.prototype = {\n    constructor: GrantSolver,\n\n    /**\n     * @return {GrantSolver}\n     */\n    update: (() => {\n      const quaternion = new Quaternion();\n      return function () {\n        const bones = this.mesh.skeleton.bones;\n        const grants = this.grants;\n\n        for (let i = 0, il = grants.length; i < il; i++) {\n          const grant = grants[i];\n          const bone = bones[grant.index];\n          const parentBone = bones[grant.parentIndex];\n\n          if (grant.isLocal) {\n            // TODO: implement\n            if (grant.affectPosition) ; // TODO: implement\n\n\n            if (grant.affectRotation) ;\n          } else {\n            // TODO: implement\n            if (grant.affectPosition) ;\n\n            if (grant.affectRotation) {\n              quaternion.set(0, 0, 0, 1);\n              quaternion.slerp(parentBone.quaternion, grant.ratio);\n              bone.quaternion.multiply(quaternion);\n            }\n          }\n        }\n\n        return this;\n      };\n    })()\n  };\n  return MMDAnimationHelper;\n})();\n\nexport { MMDAnimationHelper };\n", "import { Mesh, Color, Plane, Vector3, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, ShaderMaterial, UniformsUtils } from 'three';\n\nclass Reflector extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.type = 'Reflector';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || Reflector.ReflectorShader; //\n\n    const reflectorPlane = new Plane();\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = new PerspectiveCamera();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    const material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    this.material = material;\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      const projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w; // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding;\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n\n}\n\nReflector.prototype.isReflector = true;\nReflector.ReflectorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}`\n};\n\nexport { Reflector };\n", "import { Mesh, Color, PerspectiveCamera, Plane, Matrix4, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4 } from 'three';\n\nclass Refractor extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.type = 'Refractor';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || Refractor.RefractorShader; //\n\n    const virtualCamera = new PerspectiveCamera();\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true; //\n\n    const refractorPlane = new Plane();\n    const textureMatrix = new Matrix4(); // render target\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight); // material\n\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true // ensures, refractors are drawn from farthest to closest\n\n    });\n    this.material.uniforms['color'].value = color;\n    this.material.uniforms['tDiffuse'].value = renderTarget.texture;\n    this.material.uniforms['textureMatrix'].value = textureMatrix; // functions\n\n    const visible = function () {\n      const refractorWorldPosition = new Vector3();\n      const cameraWorldPosition = new Vector3();\n      const rotationMatrix = new Matrix4();\n      const view = new Vector3();\n      const normal = new Vector3();\n      return function visible(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n\n    const updateRefractorPlane = function () {\n      const normal = new Vector3();\n      const position = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      return function updateRefractorPlane() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize(); // flip the normal because we want to cull everything above the plane\n\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n\n    const updateVirtualCamera = function () {\n      const clipPlane = new Plane();\n      const clipVector = new Vector4();\n      const q = new Vector4();\n      return function updateVirtualCamera(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far; // used in WebGLBackground\n        // The following code creates an oblique view frustum for clipping.\n        // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n        // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant); // calculate the clip-space corner point opposite the clipping plane and\n        // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n        const projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1.0;\n        q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // calculate the scaled plane vector\n\n        clipVector.multiplyScalar(2.0 / clipVector.dot(q)); // replacing the third row of the projection matrix\n\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }(); // This will update the texture matrix that is used for projective texture mapping in the shader.\n    // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\n    function updateTextureMatrix(camera) {\n      // this matrix does range mapping to [ 0, 1 ]\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0); // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n      // (matrix above) with the projection and view matrix of the virtual camera\n      // and the model matrix of the refractor\n\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    } //\n\n\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    } //\n\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      // Render\n      renderTarget.texture.encoding = renderer.outputEncoding; // ensure refractors are rendered only once per frame\n\n      if (camera.userData.refractor === true) return; // avoid rendering when the refractor is viewed from behind\n\n      if (!visible(camera) === true) return; // update\n\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n  }\n\n}\n\nRefractor.prototype.isRefractor = true;\nRefractor.RefractorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}`\n};\n\nexport { Refractor };\n", "import { Matrix4, Mesh, MeshBasicMaterial } from 'three';\n\n/**\n * A shadow Mesh that follows a shadow-casting Mesh in the scene, but is confined to a single plane.\n */\n\nconst _shadowMatrix = new Matrix4();\n\nclass ShadowMesh extends Mesh {\n  constructor(mesh) {\n    const shadowMaterial = new MeshBasicMaterial({\n      color: 0x000000,\n      transparent: true,\n      opacity: 0.6,\n      depthWrite: false\n    });\n    super(mesh.geometry, shadowMaterial);\n    this.meshMatrix = mesh.matrixWorld;\n    this.frustumCulled = false;\n    this.matrixAutoUpdate = false;\n  }\n\n  update(plane, lightPosition4D) {\n    // based on https://www.opengl.org/archives/resources/features/StencilTalk/tsld021.htm\n    const dot = plane.normal.x * lightPosition4D.x + plane.normal.y * lightPosition4D.y + plane.normal.z * lightPosition4D.z + -plane.constant * lightPosition4D.w;\n    const sme = _shadowMatrix.elements;\n    sme[0] = dot - lightPosition4D.x * plane.normal.x;\n    sme[4] = -lightPosition4D.x * plane.normal.y;\n    sme[8] = -lightPosition4D.x * plane.normal.z;\n    sme[12] = -lightPosition4D.x * -plane.constant;\n    sme[1] = -lightPosition4D.y * plane.normal.x;\n    sme[5] = dot - lightPosition4D.y * plane.normal.y;\n    sme[9] = -lightPosition4D.y * plane.normal.z;\n    sme[13] = -lightPosition4D.y * -plane.constant;\n    sme[2] = -lightPosition4D.z * plane.normal.x;\n    sme[6] = -lightPosition4D.z * plane.normal.y;\n    sme[10] = dot - lightPosition4D.z * plane.normal.z;\n    sme[14] = -lightPosition4D.z * -plane.constant;\n    sme[3] = -lightPosition4D.w * plane.normal.x;\n    sme[7] = -lightPosition4D.w * plane.normal.y;\n    sme[11] = -lightPosition4D.w * plane.normal.z;\n    sme[15] = dot - lightPosition4D.w * -plane.constant;\n    this.matrix.multiplyMatrices(_shadowMatrix, this.meshMatrix);\n  }\n\n}\n\nShadowMesh.prototype.isShadowMesh = true;\n\nexport { ShadowMesh };\n", "import { Mesh, MeshBasicMaterial, Vector3, DataTexture, RGBAFormat, NearestFilter, ClampToEdgeWrapping, RawShaderMaterial, Color, Vector2, AdditiveBlending, Box2, Vector4, BufferGeometry, InterleavedBuffer, InterleavedBufferAttribute } from 'three';\n\nclass Lensflare extends Mesh {\n  constructor() {\n    super(Lensflare.Geometry, new MeshBasicMaterial({\n      opacity: 0,\n      transparent: true\n    }));\n    this.type = 'Lensflare';\n    this.frustumCulled = false;\n    this.renderOrder = Infinity; //\n\n    const positionScreen = new Vector3();\n    const positionView = new Vector3(); // textures\n\n    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);\n    tempMap.minFilter = NearestFilter;\n    tempMap.magFilter = NearestFilter;\n    tempMap.wrapS = ClampToEdgeWrapping;\n    tempMap.wrapT = ClampToEdgeWrapping;\n    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);\n    occlusionMap.minFilter = NearestFilter;\n    occlusionMap.magFilter = NearestFilter;\n    occlusionMap.wrapS = ClampToEdgeWrapping;\n    occlusionMap.wrapT = ClampToEdgeWrapping; // material\n\n    const geometry = Lensflare.Geometry;\n    const material1a = new RawShaderMaterial({\n      uniforms: {\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}`,\n      depthTest: true,\n      depthWrite: false,\n      transparent: false\n    });\n    const material1b = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: tempMap\n        },\n        scale: {\n          value: null\n        },\n        screenPosition: {\n          value: null\n        }\n      },\n      vertexShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}`,\n      fragmentShader:\n      /* glsl */\n      `\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}`,\n      depthTest: false,\n      depthWrite: false,\n      transparent: false\n    }); // the following object is used for occlusionMap generation\n\n    const mesh1 = new Mesh(geometry, material1a); //\n\n    const elements = [];\n    const shader = LensflareElement.Shader;\n    const material2 = new RawShaderMaterial({\n      uniforms: {\n        map: {\n          value: null\n        },\n        occlusionMap: {\n          value: occlusionMap\n        },\n        color: {\n          value: new Color(0xffffff)\n        },\n        scale: {\n          value: new Vector2()\n        },\n        screenPosition: {\n          value: new Vector3()\n        }\n      },\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      blending: AdditiveBlending,\n      transparent: true,\n      depthWrite: false\n    });\n    const mesh2 = new Mesh(geometry, material2);\n\n    this.addElement = function (element) {\n      elements.push(element);\n    }; //\n\n\n    const scale = new Vector2();\n    const screenPositionPixels = new Vector2();\n    const validArea = new Box2();\n    const viewport = new Vector4();\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      renderer.getCurrentViewport(viewport);\n      const invAspect = viewport.w / viewport.z;\n      const halfViewportWidth = viewport.z / 2.0;\n      const halfViewportHeight = viewport.w / 2.0;\n      let size = 16 / viewport.w;\n      scale.set(size * invAspect, size);\n      validArea.min.set(viewport.x, viewport.y);\n      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16)); // calculate position in screen space\n\n      positionView.setFromMatrixPosition(this.matrixWorld);\n      positionView.applyMatrix4(camera.matrixWorldInverse);\n      if (positionView.z > 0) return; // lensflare is behind the camera\n\n      positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix); // horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;\n      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8; // screen cull\n\n      if (validArea.containsPoint(screenPositionPixels)) {\n        // save current RGB to temp texture\n        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap); // render pink quad\n\n        let uniforms = material1a.uniforms;\n        uniforms['scale'].value = scale;\n        uniforms['screenPosition'].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null); // copy result to occlusionMap\n\n        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap); // restore graphics\n\n        uniforms = material1b.uniforms;\n        uniforms['scale'].value = scale;\n        uniforms['screenPosition'].value = positionScreen;\n        renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null); // render elements\n\n        const vecX = -positionScreen.x * 2;\n        const vecY = -positionScreen.y * 2;\n\n        for (let i = 0, l = elements.length; i < l; i++) {\n          const element = elements[i];\n          const uniforms = material2.uniforms;\n          uniforms['color'].value.copy(element.color);\n          uniforms['map'].value = element.texture;\n          uniforms['screenPosition'].value.x = positionScreen.x + vecX * element.distance;\n          uniforms['screenPosition'].value.y = positionScreen.y + vecY * element.distance;\n          size = element.size / viewport.w;\n          const invAspect = viewport.w / viewport.z;\n          uniforms['scale'].value.set(size * invAspect, size);\n          material2.uniformsNeedUpdate = true;\n          renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);\n        }\n      }\n    };\n\n    this.dispose = function () {\n      material1a.dispose();\n      material1b.dispose();\n      material2.dispose();\n      tempMap.dispose();\n      occlusionMap.dispose();\n\n      for (let i = 0, l = elements.length; i < l; i++) {\n        elements[i].texture.dispose();\n      }\n    };\n  }\n\n}\n\nLensflare.prototype.isLensflare = true; //\n\nclass LensflareElement {\n  constructor(texture, size = 1, distance = 0, color = new Color(0xffffff)) {\n    this.texture = texture;\n    this.size = size;\n    this.distance = distance;\n    this.color = color;\n  }\n\n}\n\nLensflareElement.Shader = {\n  uniforms: {\n    map: {\n      value: null\n    },\n    occlusionMap: {\n      value: null\n    },\n    color: {\n      value: null\n    },\n    scale: {\n      value: null\n    },\n    screenPosition: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}`\n};\n\nLensflare.Geometry = function () {\n  const geometry = new BufferGeometry();\n  const float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);\n  const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n  geometry.setIndex([0, 1, 2, 0, 2, 3]);\n  geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n  geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n  return geometry;\n}();\n\nexport { Lensflare, LensflareElement };\n", "import { Mesh, Vector3, Color, FrontSide, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, UniformsUtils, UniformsLib, ShaderMaterial } from 'three';\n\n/**\n * Work based on :\n * https://github.com/Slayvin: Flat mirror for three.js\n * https://home.adelphi.edu/~stemkoski/ : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nclass Water extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    const scope = this;\n    const textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n    const textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n    const clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n    const alpha = options.alpha !== undefined ? options.alpha : 1.0;\n    const time = options.time !== undefined ? options.time : 0.0;\n    const normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n    const sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0);\n    const sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\n    const waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f);\n    const eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0);\n    const distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n    const side = options.side !== undefined ? options.side : FrontSide;\n    const fog = options.fog !== undefined ? options.fog : false; //\n\n    const mirrorPlane = new Plane();\n    const normal = new Vector3();\n    const mirrorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const mirrorCamera = new PerspectiveCamera();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    const mirrorShader = {\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {\n        normalSampler: {\n          value: null\n        },\n        mirrorSampler: {\n          value: null\n        },\n        alpha: {\n          value: 1.0\n        },\n        time: {\n          value: 0.0\n        },\n        size: {\n          value: 1.0\n        },\n        distortionScale: {\n          value: 20.0\n        },\n        textureMatrix: {\n          value: new Matrix4()\n        },\n        sunColor: {\n          value: new Color(0x7f7f7f)\n        },\n        sunDirection: {\n          value: new Vector3(0.70707, 0.70707, 0)\n        },\n        eye: {\n          value: new Vector3()\n        },\n        waterColor: {\n          value: new Color(0x555555)\n        }\n      }]),\n      vertexShader:\n      /* glsl */\n      `\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`,\n      fragmentShader:\n      /* glsl */\n      `\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}`\n    };\n    const material = new ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side: side,\n      fog: fog\n    });\n    material.uniforms['mirrorSampler'].value = renderTarget.texture;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    material.uniforms['alpha'].value = alpha;\n    material.uniforms['time'].value = time;\n    material.uniforms['normalSampler'].value = normalSampler;\n    material.uniforms['sunColor'].value = sunColor;\n    material.uniforms['waterColor'].value = waterColor;\n    material.uniforms['sunDirection'].value = sunDirection;\n    material.uniforms['distortionScale'].value = distortionScale;\n    material.uniforms['eye'].value = eye;\n    scope.material = material;\n\n    scope.onBeforeRender = function (renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(mirrorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(mirrorWorldPosition);\n      mirrorCamera.position.copy(view);\n      mirrorCamera.up.set(0, 1, 0);\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\n      mirrorCamera.up.reflect(normal);\n      mirrorCamera.lookAt(target);\n      mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n      mirrorCamera.updateMatrixWorld();\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n      const projectionMatrix = mirrorCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      eye.setFromMatrixPosition(camera.matrixWorld); // Render\n\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      scope.visible = false;\n      renderer.xr.enabled = false; // Avoid camera modification and recursion\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, mirrorCamera);\n      scope.visible = true;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n    };\n  }\n\n}\n\nWater.prototype.isWater = true;\n\nexport { Water };\n", "import { Mesh, BufferGeometry, BufferAttribute, DynamicDrawUsage, Color } from 'three';\n\n/**\n * Port of http://webglsamples.org/blob/blob.html\n */\n\nclass MarchingCubes extends Mesh {\n  constructor(resolution, material, enableUvs = false, enableColors = false, maxPolyCount = 10000) {\n    const geometry = new BufferGeometry();\n    super(geometry, material);\n    const scope = this; // temp buffers used in polygonize\n\n    const vlist = new Float32Array(12 * 3);\n    const nlist = new Float32Array(12 * 3);\n    const clist = new Float32Array(12 * 3);\n    this.enableUvs = enableUvs;\n    this.enableColors = enableColors; // functions have to be object properties\n    // prototype functions kill performance\n    // (tested and it was 4x slower !!!)\n\n    this.init = function (resolution) {\n      this.resolution = resolution; // parameters\n\n      this.isolation = 80.0; // size of field, 32 is pushing it in Javascript :)\n\n      this.size = resolution;\n      this.size2 = this.size * this.size;\n      this.size3 = this.size2 * this.size;\n      this.halfsize = this.size / 2.0; // deltas\n\n      this.delta = 2.0 / this.size;\n      this.yd = this.size;\n      this.zd = this.size2;\n      this.field = new Float32Array(this.size3);\n      this.normal_cache = new Float32Array(this.size3 * 3);\n      this.palette = new Float32Array(this.size3 * 3); //\n\n      this.count = 0;\n      const maxVertexCount = maxPolyCount * 3;\n      this.positionArray = new Float32Array(maxVertexCount * 3);\n      const positionAttribute = new BufferAttribute(this.positionArray, 3);\n      positionAttribute.setUsage(DynamicDrawUsage);\n      geometry.setAttribute('position', positionAttribute);\n      this.normalArray = new Float32Array(maxVertexCount * 3);\n      const normalAttribute = new BufferAttribute(this.normalArray, 3);\n      normalAttribute.setUsage(DynamicDrawUsage);\n      geometry.setAttribute('normal', normalAttribute);\n\n      if (this.enableUvs) {\n        this.uvArray = new Float32Array(maxVertexCount * 2);\n        const uvAttribute = new BufferAttribute(this.uvArray, 2);\n        uvAttribute.setUsage(DynamicDrawUsage);\n        geometry.setAttribute('uv', uvAttribute);\n      }\n\n      if (this.enableColors) {\n        this.colorArray = new Float32Array(maxVertexCount * 3);\n        const colorAttribute = new BufferAttribute(this.colorArray, 3);\n        colorAttribute.setUsage(DynamicDrawUsage);\n        geometry.setAttribute('color', colorAttribute);\n      }\n    }; ///////////////////////\n    // Polygonization\n    ///////////////////////\n\n\n    function lerp(a, b, t) {\n      return a + (b - a) * t;\n    }\n\n    function VIntX(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {\n      const mu = (isol - valp1) / (valp2 - valp1),\n            nc = scope.normal_cache;\n      vlist[offset + 0] = x + mu * scope.delta;\n      vlist[offset + 1] = y;\n      vlist[offset + 2] = z;\n      nlist[offset + 0] = lerp(nc[q + 0], nc[q + 3], mu);\n      nlist[offset + 1] = lerp(nc[q + 1], nc[q + 4], mu);\n      nlist[offset + 2] = lerp(nc[q + 2], nc[q + 5], mu);\n      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);\n      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);\n      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);\n    }\n\n    function VIntY(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {\n      const mu = (isol - valp1) / (valp2 - valp1),\n            nc = scope.normal_cache;\n      vlist[offset + 0] = x;\n      vlist[offset + 1] = y + mu * scope.delta;\n      vlist[offset + 2] = z;\n      const q2 = q + scope.yd * 3;\n      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);\n      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);\n      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);\n      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);\n      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);\n      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);\n    }\n\n    function VIntZ(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {\n      const mu = (isol - valp1) / (valp2 - valp1),\n            nc = scope.normal_cache;\n      vlist[offset + 0] = x;\n      vlist[offset + 1] = y;\n      vlist[offset + 2] = z + mu * scope.delta;\n      const q2 = q + scope.zd * 3;\n      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);\n      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);\n      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);\n      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);\n      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);\n      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);\n    }\n\n    function compNorm(q) {\n      const q3 = q * 3;\n\n      if (scope.normal_cache[q3] === 0.0) {\n        scope.normal_cache[q3 + 0] = scope.field[q - 1] - scope.field[q + 1];\n        scope.normal_cache[q3 + 1] = scope.field[q - scope.yd] - scope.field[q + scope.yd];\n        scope.normal_cache[q3 + 2] = scope.field[q - scope.zd] - scope.field[q + scope.zd];\n      }\n    } // Returns total number of triangles. Fills triangles.\n    // (this is where most of time is spent - it's inner work of O(n3) loop )\n\n\n    function polygonize(fx, fy, fz, q, isol) {\n      // cache indices\n      const q1 = q + 1,\n            qy = q + scope.yd,\n            qz = q + scope.zd,\n            q1y = q1 + scope.yd,\n            q1z = q1 + scope.zd,\n            qyz = q + scope.yd + scope.zd,\n            q1yz = q1 + scope.yd + scope.zd;\n      let cubeindex = 0;\n      const field0 = scope.field[q],\n            field1 = scope.field[q1],\n            field2 = scope.field[qy],\n            field3 = scope.field[q1y],\n            field4 = scope.field[qz],\n            field5 = scope.field[q1z],\n            field6 = scope.field[qyz],\n            field7 = scope.field[q1yz];\n      if (field0 < isol) cubeindex |= 1;\n      if (field1 < isol) cubeindex |= 2;\n      if (field2 < isol) cubeindex |= 8;\n      if (field3 < isol) cubeindex |= 4;\n      if (field4 < isol) cubeindex |= 16;\n      if (field5 < isol) cubeindex |= 32;\n      if (field6 < isol) cubeindex |= 128;\n      if (field7 < isol) cubeindex |= 64; // if cube is entirely in/out of the surface - bail, nothing to draw\n\n      const bits = edgeTable[cubeindex];\n      if (bits === 0) return 0;\n      const d = scope.delta,\n            fx2 = fx + d,\n            fy2 = fy + d,\n            fz2 = fz + d; // top of the cube\n\n      if (bits & 1) {\n        compNorm(q);\n        compNorm(q1);\n        VIntX(q * 3, 0, isol, fx, fy, fz, field0, field1, q, q1);\n      }\n\n      if (bits & 2) {\n        compNorm(q1);\n        compNorm(q1y);\n        VIntY(q1 * 3, 3, isol, fx2, fy, fz, field1, field3, q1, q1y);\n      }\n\n      if (bits & 4) {\n        compNorm(qy);\n        compNorm(q1y);\n        VIntX(qy * 3, 6, isol, fx, fy2, fz, field2, field3, qy, q1y);\n      }\n\n      if (bits & 8) {\n        compNorm(q);\n        compNorm(qy);\n        VIntY(q * 3, 9, isol, fx, fy, fz, field0, field2, q, qy);\n      } // bottom of the cube\n\n\n      if (bits & 16) {\n        compNorm(qz);\n        compNorm(q1z);\n        VIntX(qz * 3, 12, isol, fx, fy, fz2, field4, field5, qz, q1z);\n      }\n\n      if (bits & 32) {\n        compNorm(q1z);\n        compNorm(q1yz);\n        VIntY(q1z * 3, 15, isol, fx2, fy, fz2, field5, field7, q1z, q1yz);\n      }\n\n      if (bits & 64) {\n        compNorm(qyz);\n        compNorm(q1yz);\n        VIntX(qyz * 3, 18, isol, fx, fy2, fz2, field6, field7, qyz, q1yz);\n      }\n\n      if (bits & 128) {\n        compNorm(qz);\n        compNorm(qyz);\n        VIntY(qz * 3, 21, isol, fx, fy, fz2, field4, field6, qz, qyz);\n      } // vertical lines of the cube\n\n\n      if (bits & 256) {\n        compNorm(q);\n        compNorm(qz);\n        VIntZ(q * 3, 24, isol, fx, fy, fz, field0, field4, q, qz);\n      }\n\n      if (bits & 512) {\n        compNorm(q1);\n        compNorm(q1z);\n        VIntZ(q1 * 3, 27, isol, fx2, fy, fz, field1, field5, q1, q1z);\n      }\n\n      if (bits & 1024) {\n        compNorm(q1y);\n        compNorm(q1yz);\n        VIntZ(q1y * 3, 30, isol, fx2, fy2, fz, field3, field7, q1y, q1yz);\n      }\n\n      if (bits & 2048) {\n        compNorm(qy);\n        compNorm(qyz);\n        VIntZ(qy * 3, 33, isol, fx, fy2, fz, field2, field6, qy, qyz);\n      }\n\n      cubeindex <<= 4; // re-purpose cubeindex into an offset into triTable\n\n      let o1,\n          o2,\n          o3,\n          numtris = 0,\n          i = 0; // here is where triangles are created\n\n      while (triTable[cubeindex + i] != -1) {\n        o1 = cubeindex + i;\n        o2 = o1 + 1;\n        o3 = o1 + 2;\n        posnormtriv(vlist, nlist, clist, 3 * triTable[o1], 3 * triTable[o2], 3 * triTable[o3]);\n        i += 3;\n        numtris++;\n      }\n\n      return numtris;\n    }\n\n    function posnormtriv(pos, norm, colors, o1, o2, o3) {\n      const c = scope.count * 3; // positions\n\n      scope.positionArray[c + 0] = pos[o1];\n      scope.positionArray[c + 1] = pos[o1 + 1];\n      scope.positionArray[c + 2] = pos[o1 + 2];\n      scope.positionArray[c + 3] = pos[o2];\n      scope.positionArray[c + 4] = pos[o2 + 1];\n      scope.positionArray[c + 5] = pos[o2 + 2];\n      scope.positionArray[c + 6] = pos[o3];\n      scope.positionArray[c + 7] = pos[o3 + 1];\n      scope.positionArray[c + 8] = pos[o3 + 2]; // normals\n\n      if (scope.material.flatShading === true) {\n        const nx = (norm[o1 + 0] + norm[o2 + 0] + norm[o3 + 0]) / 3;\n        const ny = (norm[o1 + 1] + norm[o2 + 1] + norm[o3 + 1]) / 3;\n        const nz = (norm[o1 + 2] + norm[o2 + 2] + norm[o3 + 2]) / 3;\n        scope.normalArray[c + 0] = nx;\n        scope.normalArray[c + 1] = ny;\n        scope.normalArray[c + 2] = nz;\n        scope.normalArray[c + 3] = nx;\n        scope.normalArray[c + 4] = ny;\n        scope.normalArray[c + 5] = nz;\n        scope.normalArray[c + 6] = nx;\n        scope.normalArray[c + 7] = ny;\n        scope.normalArray[c + 8] = nz;\n      } else {\n        scope.normalArray[c + 0] = norm[o1 + 0];\n        scope.normalArray[c + 1] = norm[o1 + 1];\n        scope.normalArray[c + 2] = norm[o1 + 2];\n        scope.normalArray[c + 3] = norm[o2 + 0];\n        scope.normalArray[c + 4] = norm[o2 + 1];\n        scope.normalArray[c + 5] = norm[o2 + 2];\n        scope.normalArray[c + 6] = norm[o3 + 0];\n        scope.normalArray[c + 7] = norm[o3 + 1];\n        scope.normalArray[c + 8] = norm[o3 + 2];\n      } // uvs\n\n\n      if (scope.enableUvs) {\n        const d = scope.count * 2;\n        scope.uvArray[d + 0] = pos[o1 + 0];\n        scope.uvArray[d + 1] = pos[o1 + 2];\n        scope.uvArray[d + 2] = pos[o2 + 0];\n        scope.uvArray[d + 3] = pos[o2 + 2];\n        scope.uvArray[d + 4] = pos[o3 + 0];\n        scope.uvArray[d + 5] = pos[o3 + 2];\n      } // colors\n\n\n      if (scope.enableColors) {\n        scope.colorArray[c + 0] = colors[o1 + 0];\n        scope.colorArray[c + 1] = colors[o1 + 1];\n        scope.colorArray[c + 2] = colors[o1 + 2];\n        scope.colorArray[c + 3] = colors[o2 + 0];\n        scope.colorArray[c + 4] = colors[o2 + 1];\n        scope.colorArray[c + 5] = colors[o2 + 2];\n        scope.colorArray[c + 6] = colors[o3 + 0];\n        scope.colorArray[c + 7] = colors[o3 + 1];\n        scope.colorArray[c + 8] = colors[o3 + 2];\n      }\n\n      scope.count += 3;\n    } /////////////////////////////////////\n    // Metaballs\n    /////////////////////////////////////\n    // Adds a reciprocal ball (nice and blobby) that, to be fast, fades to zero after\n    // a fixed distance, determined by strength and subtract.\n\n\n    this.addBall = function (ballx, bally, ballz, strength, subtract, colors) {\n      const sign = Math.sign(strength);\n      strength = Math.abs(strength);\n      const userDefineColor = !(colors === undefined || colors === null);\n      let ballColor = new Color(ballx, bally, ballz);\n\n      if (userDefineColor) {\n        try {\n          ballColor = colors instanceof Color ? colors : Array.isArray(colors) ? new Color(Math.min(Math.abs(colors[0]), 1), Math.min(Math.abs(colors[1]), 1), Math.min(Math.abs(colors[2]), 1)) : new Color(colors);\n        } catch (err) {\n          ballColor = new Color(ballx, bally, ballz);\n        }\n      } // Let's solve the equation to find the radius:\n      // 1.0 / (0.000001 + radius^2) * strength - subtract = 0\n      // strength / (radius^2) = subtract\n      // strength = subtract * radius^2\n      // radius^2 = strength / subtract\n      // radius = sqrt(strength / subtract)\n\n\n      const radius = this.size * Math.sqrt(strength / subtract),\n            zs = ballz * this.size,\n            ys = bally * this.size,\n            xs = ballx * this.size;\n      let min_z = Math.floor(zs - radius);\n      if (min_z < 1) min_z = 1;\n      let max_z = Math.floor(zs + radius);\n      if (max_z > this.size - 1) max_z = this.size - 1;\n      let min_y = Math.floor(ys - radius);\n      if (min_y < 1) min_y = 1;\n      let max_y = Math.floor(ys + radius);\n      if (max_y > this.size - 1) max_y = this.size - 1;\n      let min_x = Math.floor(xs - radius);\n      if (min_x < 1) min_x = 1;\n      let max_x = Math.floor(xs + radius);\n      if (max_x > this.size - 1) max_x = this.size - 1; // Don't polygonize in the outer layer because normals aren't\n      // well-defined there.\n\n      let x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;\n\n      for (z = min_z; z < max_z; z++) {\n        z_offset = this.size2 * z;\n        fz = z / this.size - ballz;\n        fz2 = fz * fz;\n\n        for (y = min_y; y < max_y; y++) {\n          y_offset = z_offset + this.size * y;\n          fy = y / this.size - bally;\n          fy2 = fy * fy;\n\n          for (x = min_x; x < max_x; x++) {\n            fx = x / this.size - ballx;\n            val = strength / (0.000001 + fx * fx + fy2 + fz2) - subtract;\n\n            if (val > 0.0) {\n              this.field[y_offset + x] += val * sign; // optimization\n              // http://www.geisswerks.com/ryan/BLOBS/blobs.html\n\n              const ratio = Math.sqrt((x - xs) * (x - xs) + (y - ys) * (y - ys) + (z - zs) * (z - zs)) / radius;\n              const contrib = 1 - ratio * ratio * ratio * (ratio * (ratio * 6 - 15) + 10);\n              this.palette[(y_offset + x) * 3 + 0] += ballColor.r * contrib;\n              this.palette[(y_offset + x) * 3 + 1] += ballColor.g * contrib;\n              this.palette[(y_offset + x) * 3 + 2] += ballColor.b * contrib;\n            }\n          }\n        }\n      }\n    };\n\n    this.addPlaneX = function (strength, subtract) {\n      // cache attribute lookups\n      const size = this.size,\n            yd = this.yd,\n            zd = this.zd,\n            field = this.field;\n      let x,\n          y,\n          z,\n          xx,\n          val,\n          xdiv,\n          cxy,\n          dist = size * Math.sqrt(strength / subtract);\n      if (dist > size) dist = size;\n\n      for (x = 0; x < dist; x++) {\n        xdiv = x / size;\n        xx = xdiv * xdiv;\n        val = strength / (0.0001 + xx) - subtract;\n\n        if (val > 0.0) {\n          for (y = 0; y < size; y++) {\n            cxy = x + y * yd;\n\n            for (z = 0; z < size; z++) {\n              field[zd * z + cxy] += val;\n            }\n          }\n        }\n      }\n    };\n\n    this.addPlaneY = function (strength, subtract) {\n      // cache attribute lookups\n      const size = this.size,\n            yd = this.yd,\n            zd = this.zd,\n            field = this.field;\n      let x,\n          y,\n          z,\n          yy,\n          val,\n          ydiv,\n          cy,\n          cxy,\n          dist = size * Math.sqrt(strength / subtract);\n      if (dist > size) dist = size;\n\n      for (y = 0; y < dist; y++) {\n        ydiv = y / size;\n        yy = ydiv * ydiv;\n        val = strength / (0.0001 + yy) - subtract;\n\n        if (val > 0.0) {\n          cy = y * yd;\n\n          for (x = 0; x < size; x++) {\n            cxy = cy + x;\n\n            for (z = 0; z < size; z++) field[zd * z + cxy] += val;\n          }\n        }\n      }\n    };\n\n    this.addPlaneZ = function (strength, subtract) {\n      // cache attribute lookups\n      const size = this.size,\n            yd = this.yd,\n            zd = this.zd,\n            field = this.field;\n      let x,\n          y,\n          z,\n          zz,\n          val,\n          zdiv,\n          cz,\n          cyz,\n          dist = size * Math.sqrt(strength / subtract);\n      if (dist > size) dist = size;\n\n      for (z = 0; z < dist; z++) {\n        zdiv = z / size;\n        zz = zdiv * zdiv;\n        val = strength / (0.0001 + zz) - subtract;\n\n        if (val > 0.0) {\n          cz = zd * z;\n\n          for (y = 0; y < size; y++) {\n            cyz = cz + y * yd;\n\n            for (x = 0; x < size; x++) field[cyz + x] += val;\n          }\n        }\n      }\n    }; /////////////////////////////////////\n    // Updates\n    /////////////////////////////////////\n\n\n    this.setCell = function (x, y, z, value) {\n      const index = this.size2 * z + this.size * y + x;\n      this.field[index] = value;\n    };\n\n    this.getCell = function (x, y, z) {\n      const index = this.size2 * z + this.size * y + x;\n      return this.field[index];\n    };\n\n    this.blur = function (intensity = 1) {\n      const field = this.field;\n      const fieldCopy = field.slice();\n      const size = this.size;\n      const size2 = this.size2;\n\n      for (let x = 0; x < size; x++) {\n        for (let y = 0; y < size; y++) {\n          for (let z = 0; z < size; z++) {\n            const index = size2 * z + size * y + x;\n            let val = fieldCopy[index];\n            let count = 1;\n\n            for (let x2 = -1; x2 <= 1; x2 += 2) {\n              const x3 = x2 + x;\n              if (x3 < 0 || x3 >= size) continue;\n\n              for (let y2 = -1; y2 <= 1; y2 += 2) {\n                const y3 = y2 + y;\n                if (y3 < 0 || y3 >= size) continue;\n\n                for (let z2 = -1; z2 <= 1; z2 += 2) {\n                  const z3 = z2 + z;\n                  if (z3 < 0 || z3 >= size) continue;\n                  const index2 = size2 * z3 + size * y3 + x3;\n                  const val2 = fieldCopy[index2];\n                  count++;\n                  val += intensity * (val2 - val) / count;\n                }\n              }\n            }\n\n            field[index] = val;\n          }\n        }\n      }\n    };\n\n    this.reset = function () {\n      // wipe the normal cache\n      for (let i = 0; i < this.size3; i++) {\n        this.normal_cache[i * 3] = 0.0;\n        this.field[i] = 0.0;\n        this.palette[i * 3] = this.palette[i * 3 + 1] = this.palette[i * 3 + 2] = 0.0;\n      }\n    };\n\n    this.onBeforeRender = function () {\n      this.count = 0; // Triangulate. Yeah, this is slow.\n\n      const smin2 = this.size - 2;\n\n      for (let z = 1; z < smin2; z++) {\n        const z_offset = this.size2 * z;\n        const fz = (z - this.halfsize) / this.halfsize; //+ 1\n\n        for (let y = 1; y < smin2; y++) {\n          const y_offset = z_offset + this.size * y;\n          const fy = (y - this.halfsize) / this.halfsize; //+ 1\n\n          for (let x = 1; x < smin2; x++) {\n            const fx = (x - this.halfsize) / this.halfsize; //+ 1\n\n            const q = y_offset + x;\n            polygonize(fx, fy, fz, q, this.isolation);\n          }\n        }\n      } // reset unneeded data\n\n\n      for (let i = this.count * 3; i < this.positionArray.length; i++) {\n        this.positionArray[i] = 0.0;\n      } // update geometry data\n\n\n      geometry.getAttribute('position').needsUpdate = true;\n      geometry.getAttribute('normal').needsUpdate = true;\n      if (this.enableUvs) geometry.getAttribute('uv').needsUpdate = true;\n      if (this.enableColors) geometry.getAttribute('color').needsUpdate = true; // safety check\n\n      if (this.count / 3 > maxPolyCount) {\n        console.warn('MarchingCubes: Geometry buffers too small for rendering. Please create an instance with a higher poly count.');\n      }\n    };\n\n    this.init(resolution);\n  }\n\n}\n\nMarchingCubes.prototype.isMarchingCubes = true; /////////////////////////////////////\n// Marching cubes lookup tables\n/////////////////////////////////////\n// These tables are straight from Paul Bourke's page:\n// http://paulbourke.net/geometry/polygonise/\n// who in turn got them from Cory Gene Bloyd.\n// prettier-ignore\n\nconst edgeTable = new Int32Array([0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0]); // prettier-ignore\n\nconst triTable = new Int32Array([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1, 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1, 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);\n\nexport { MarchingCubes, edgeTable, triTable };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\n\n// Ported from Stefan Gustavson's java implementation\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n// Read Stefan's excellent paper for details on how this code works.\n//\n// Sean McCullough banksean@gmail.com\n//\n// Added 4D noise\nclass SimplexNoise {\n  // To remove the need for index wrapping, double the permutation table length\n  // A lookup table to traverse the simplex around a given point in 4D.\n  // Details can be found where this table is used, in the 4D noise method.\n\n  /**\n   * You can pass in a random number generator object if you like.\n   * It is assumed to have a random() method.\n   */\n  constructor(r = Math) {\n    _defineProperty(this, \"grad3\", [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]]);\n\n    _defineProperty(this, \"grad4\", [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]]);\n\n    _defineProperty(this, \"p\", []);\n\n    _defineProperty(this, \"perm\", []);\n\n    _defineProperty(this, \"simplex\", [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]]);\n\n    _defineProperty(this, \"dot\", (g, x, y) => {\n      return g[0] * x + g[1] * y;\n    });\n\n    _defineProperty(this, \"dot3\", (g, x, y, z) => {\n      return g[0] * x + g[1] * y + g[2] * z;\n    });\n\n    _defineProperty(this, \"dot4\", (g, x, y, z, w) => {\n      return g[0] * x + g[1] * y + g[2] * z + g[3] * w;\n    });\n\n    _defineProperty(this, \"noise\", (xin, yin) => {\n      let n0;\n      let n1;\n      let n2; // Noise contributions from the three corners\n      // Skew the input space to determine which simplex cell we're in\n\n      const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);\n      const s = (xin + yin) * F2; // Hairy factor for 2D\n\n      const i = Math.floor(xin + s);\n      const j = Math.floor(yin + s);\n      const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;\n      const t = (i + j) * G2;\n      const X0 = i - t; // Unskew the cell origin back to (x,y) space\n\n      const Y0 = j - t;\n      const x0 = xin - X0; // The x,y distances from the cell origin\n\n      const y0 = yin - Y0; // For the 2D case, the simplex shape is an equilateral triangle.\n      // Determine which simplex we are in.\n      // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n\n      let i1 = 0; // Offsets for second (middle) corner of simplex in (i,j) coords\n\n      let j1 = 1;\n\n      if (x0 > y0) {\n        i1 = 1;\n        j1 = 0;\n      } // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n      // c = (3-sqrt(3))/6\n\n\n      const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\n      const y1 = y0 - j1 + G2;\n      const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n\n      const y2 = y0 - 1.0 + 2.0 * G2; // Work out the hashed gradient indices of the three simplex corners\n\n      const ii = i & 255;\n      const jj = j & 255;\n      const gi0 = this.perm[ii + this.perm[jj]] % 12;\n      const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;\n      const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12; // Calculate the contribution from the three corners\n\n      let t0 = 0.5 - x0 * x0 - y0 * y0;\n\n      if (t0 < 0) {\n        n0 = 0.0;\n      } else {\n        t0 *= t0;\n        n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\n      }\n\n      let t1 = 0.5 - x1 * x1 - y1 * y1;\n\n      if (t1 < 0) {\n        n1 = 0.0;\n      } else {\n        t1 *= t1;\n        n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);\n      }\n\n      let t2 = 0.5 - x2 * x2 - y2 * y2;\n\n      if (t2 < 0) {\n        n2 = 0.0;\n      } else {\n        t2 *= t2;\n        n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);\n      } // Add contributions from each corner to get the final noise value.\n      // The result is scaled to return values in the interval [-1,1].\n\n\n      return 70.0 * (n0 + n1 + n2);\n    });\n\n    _defineProperty(this, \"noise3d\", (xin, yin, zin) => {\n      // Noise contributions from the four corners\n      let n0;\n      let n1;\n      let n2;\n      let n3; // Skew the input space to determine which simplex cell we're in\n\n      const F3 = 1.0 / 3.0;\n      const s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D\n\n      const i = Math.floor(xin + s);\n      const j = Math.floor(yin + s);\n      const k = Math.floor(zin + s);\n      const G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too\n\n      const t = (i + j + k) * G3;\n      const X0 = i - t; // Unskew the cell origin back to (x,y,z) space\n\n      const Y0 = j - t;\n      const Z0 = k - t;\n      const x0 = xin - X0; // The x,y,z distances from the cell origin\n\n      const y0 = yin - Y0;\n      const z0 = zin - Z0; // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n      // Determine which simplex we are in.\n\n      let i1;\n      let j1;\n      let k1; // Offsets for second corner of simplex in (i,j,k) coords\n\n      let i2;\n      let j2;\n      let k2; // Offsets for third corner of simplex in (i,j,k) coords\n\n      if (x0 >= y0) {\n        if (y0 >= z0) {\n          i1 = 1;\n          j1 = 0;\n          k1 = 0;\n          i2 = 1;\n          j2 = 1;\n          k2 = 0; // X Y Z order\n        } else if (x0 >= z0) {\n          i1 = 1;\n          j1 = 0;\n          k1 = 0;\n          i2 = 1;\n          j2 = 0;\n          k2 = 1; // X Z Y order\n        } else {\n          i1 = 0;\n          j1 = 0;\n          k1 = 1;\n          i2 = 1;\n          j2 = 0;\n          k2 = 1;\n        } // Z X Y order\n\n      } else {\n        // x0<y0\n        if (y0 < z0) {\n          i1 = 0;\n          j1 = 0;\n          k1 = 1;\n          i2 = 0;\n          j2 = 1;\n          k2 = 1; // Z Y X order\n        } else if (x0 < z0) {\n          i1 = 0;\n          j1 = 1;\n          k1 = 0;\n          i2 = 0;\n          j2 = 1;\n          k2 = 1; // Y Z X order\n        } else {\n          i1 = 0;\n          j1 = 1;\n          k1 = 0;\n          i2 = 1;\n          j2 = 1;\n          k2 = 0;\n        } // Y X Z order\n\n      } // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n      // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n      // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n      // c = 1/6.\n\n\n      const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n\n      const y1 = y0 - j1 + G3;\n      const z1 = z0 - k1 + G3;\n      const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\n\n      const y2 = y0 - j2 + 2.0 * G3;\n      const z2 = z0 - k2 + 2.0 * G3;\n      const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\n\n      const y3 = y0 - 1.0 + 3.0 * G3;\n      const z3 = z0 - 1.0 + 3.0 * G3; // Work out the hashed gradient indices of the four simplex corners\n\n      const ii = i & 255;\n      const jj = j & 255;\n      const kk = k & 255;\n      const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;\n      const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;\n      const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;\n      const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12; // Calculate the contribution from the four corners\n\n      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n\n      if (t0 < 0) {\n        n0 = 0.0;\n      } else {\n        t0 *= t0;\n        n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);\n      }\n\n      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n\n      if (t1 < 0) {\n        n1 = 0.0;\n      } else {\n        t1 *= t1;\n        n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);\n      }\n\n      let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n\n      if (t2 < 0) {\n        n2 = 0.0;\n      } else {\n        t2 *= t2;\n        n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);\n      }\n\n      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n\n      if (t3 < 0) {\n        n3 = 0.0;\n      } else {\n        t3 *= t3;\n        n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);\n      } // Add contributions from each corner to get the final noise value.\n      // The result is scaled to stay just inside [-1,1]\n\n\n      return 32.0 * (n0 + n1 + n2 + n3);\n    });\n\n    _defineProperty(this, \"noise4d\", (x, y, z, w) => {\n      // For faster and easier lookups\n      const grad4 = this.grad4;\n      const simplex = this.simplex;\n      const perm = this.perm; // The skewing and unskewing factors are hairy again for the 4D case\n\n      const F4 = (Math.sqrt(5.0) - 1.0) / 4.0;\n      const G4 = (5.0 - Math.sqrt(5.0)) / 20.0;\n      let n0;\n      let n1;\n      let n2;\n      let n3;\n      let n4; // Noise contributions from the five corners\n      // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n\n      const s = (x + y + z + w) * F4; // Factor for 4D skewing\n\n      const i = Math.floor(x + s);\n      const j = Math.floor(y + s);\n      const k = Math.floor(z + s);\n      const l = Math.floor(w + s);\n      const t = (i + j + k + l) * G4; // Factor for 4D unskewing\n\n      const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n\n      const Y0 = j - t;\n      const Z0 = k - t;\n      const W0 = l - t;\n      const x0 = x - X0; // The x,y,z,w distances from the cell origin\n\n      const y0 = y - Y0;\n      const z0 = z - Z0;\n      const w0 = w - W0; // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n      // To find out which of the 24 possible simplices we're in, we need to\n      // determine the magnitude ordering of x0, y0, z0 and w0.\n      // The method below is a good way of finding the ordering of x,y,z,w and\n      // then find the correct traversal order for the simplex we’re in.\n      // First, six pair-wise comparisons are performed between each possible pair\n      // of the four coordinates, and the results are used to add up binary bits\n      // for an integer index.\n\n      const c1 = x0 > y0 ? 32 : 0;\n      const c2 = x0 > z0 ? 16 : 0;\n      const c3 = y0 > z0 ? 8 : 0;\n      const c4 = x0 > w0 ? 4 : 0;\n      const c5 = y0 > w0 ? 2 : 0;\n      const c6 = z0 > w0 ? 1 : 0;\n      const c = c1 + c2 + c3 + c4 + c5 + c6; // The integer offsets for the second simplex corner\n\n      let i1;\n      let j1;\n      let k1;\n      let l1; // The integer offsets for the third simplex corner\n\n      let i2;\n      let j2;\n      let k2;\n      let l2; // The integer offsets for the fourth simplex corner\n\n      let i3;\n      let j3;\n      let k3;\n      let l3; // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n      // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n      // impossible. Only the 24 indices which have non-zero entries make any sense.\n      // We use a thresholding to set the coordinates in turn from the largest magnitude.\n      // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n\n      i1 = simplex[c][0] >= 3 ? 1 : 0;\n      j1 = simplex[c][1] >= 3 ? 1 : 0;\n      k1 = simplex[c][2] >= 3 ? 1 : 0;\n      l1 = simplex[c][3] >= 3 ? 1 : 0; // The number 2 in the \"simplex\" array is at the second largest coordinate.\n\n      i2 = simplex[c][0] >= 2 ? 1 : 0;\n      j2 = simplex[c][1] >= 2 ? 1 : 0;\n      k2 = simplex[c][2] >= 2 ? 1 : 0;\n      l2 = simplex[c][3] >= 2 ? 1 : 0; // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n\n      i3 = simplex[c][0] >= 1 ? 1 : 0;\n      j3 = simplex[c][1] >= 1 ? 1 : 0;\n      k3 = simplex[c][2] >= 1 ? 1 : 0;\n      l3 = simplex[c][3] >= 1 ? 1 : 0; // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n\n      const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n\n      const y1 = y0 - j1 + G4;\n      const z1 = z0 - k1 + G4;\n      const w1 = w0 - l1 + G4;\n      const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\n\n      const y2 = y0 - j2 + 2.0 * G4;\n      const z2 = z0 - k2 + 2.0 * G4;\n      const w2 = w0 - l2 + 2.0 * G4;\n      const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\n\n      const y3 = y0 - j3 + 3.0 * G4;\n      const z3 = z0 - k3 + 3.0 * G4;\n      const w3 = w0 - l3 + 3.0 * G4;\n      const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\n\n      const y4 = y0 - 1.0 + 4.0 * G4;\n      const z4 = z0 - 1.0 + 4.0 * G4;\n      const w4 = w0 - 1.0 + 4.0 * G4; // Work out the hashed gradient indices of the five simplex corners\n\n      const ii = i & 255;\n      const jj = j & 255;\n      const kk = k & 255;\n      const ll = l & 255;\n      const gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;\n      const gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;\n      const gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;\n      const gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;\n      const gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32; // Calculate the contribution from the five corners\n\n      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\n\n      if (t0 < 0) {\n        n0 = 0.0;\n      } else {\n        t0 *= t0;\n        n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);\n      }\n\n      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\n\n      if (t1 < 0) {\n        n1 = 0.0;\n      } else {\n        t1 *= t1;\n        n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);\n      }\n\n      let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\n\n      if (t2 < 0) {\n        n2 = 0.0;\n      } else {\n        t2 *= t2;\n        n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);\n      }\n\n      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\n\n      if (t3 < 0) {\n        n3 = 0.0;\n      } else {\n        t3 *= t3;\n        n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);\n      }\n\n      let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\n\n      if (t4 < 0) {\n        n4 = 0.0;\n      } else {\n        t4 *= t4;\n        n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);\n      } // Sum up and scale the result to cover the range [-1,1]\n\n\n      return 27.0 * (n0 + n1 + n2 + n3 + n4);\n    });\n\n    for (let i = 0; i < 256; i++) {\n      this.p[i] = Math.floor(r.random() * 256);\n    }\n\n    for (let i = 0; i < 512; i++) {\n      this.perm[i] = this.p[i & 255];\n    }\n  }\n\n}\n\nexport { SimplexNoise };\n", "import { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from 'three';\nimport { SimplexNoise } from '../math/SimplexNoise.js';\n\n/**\n * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\n *\n *\n * Usage\n *\n * var myRay = new LightningStrike( paramsObject );\n * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\n * scene.add( myRayMesh );\n * ...\n * myRay.update( currentTime );\n *\n * The \"currentTime\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\n *\n * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\n *\n *\n * LightningStrike parameters\n *\n * The paramsObject can contain any of the following parameters.\n *\n * Legend:\n * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\n * 'Subray': A ramification of the ray. It is not a LightningStrike object.\n * 'Segment': A linear segment piece of a subray.\n * 'Leaf segment': A ray segment which cannot be smaller.\n *\n *\n * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\n *\n * @param {Vector3} sourceOffset The point where the ray starts.\n *\n * @param {Vector3} destOffset The point where the ray ends.\n *\n * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\n *\n * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\n *\n * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\n *\n * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\n *\n * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\n *\n * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\n *\n * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\n *\n * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\n *\n * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\n *\n * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\n *\n *\n * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n *\n * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\n *\n * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\n *\n * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\n *\n * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\n *\n * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\n *\n * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\n *\n * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\n *\n *\n * These parameters cannot change after lightning creation:\n *\n * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\n *\n * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\n *\n * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\n *\n * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\n *\n * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\n *\n * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\n *\n * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\n * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\n * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\n * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\n * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\n *\n * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\n *\n * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\n *\n * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\n *\n *\n */\n\nclass LightningStrike extends BufferGeometry {\n  constructor(rayParameters) {\n    super();\n    this.type = 'LightningStrike'; // Set parameters, and set undefined parameters to default values\n\n    rayParameters = rayParameters || {};\n    this.init(LightningStrike.copyParameters(rayParameters, rayParameters)); // Creates and populates the mesh\n\n    this.createMesh();\n  }\n\n  update(time) {\n    if (this.isStatic) return;\n\n    if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n      this.updateMesh(time);\n\n      if (time < this.subrays[0].endPropagationTime) {\n        this.state = LightningStrike.RAY_PROPAGATING;\n      } else if (time > this.subrays[0].beginVanishingTime) {\n        this.state = LightningStrike.RAY_VANISHING;\n      } else {\n        this.state = LightningStrike.RAY_STEADY;\n      }\n\n      this.visible = true;\n    } else {\n      this.visible = false;\n\n      if (time < this.rayParameters.birthTime) {\n        this.state = LightningStrike.RAY_UNBORN;\n      } else {\n        this.state = LightningStrike.RAY_EXTINGUISHED;\n      }\n    }\n  }\n\n  init(rayParameters) {\n    // Init all the state from the parameters\n    this.rayParameters = rayParameters; // These parameters cannot change after lightning creation:\n\n    this.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor(rayParameters.maxIterations) : 9;\n    rayParameters.maxIterations = this.maxIterations;\n    this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false;\n    rayParameters.isStatic = this.isStatic;\n    this.ramification = rayParameters.ramification !== undefined ? Math.floor(rayParameters.ramification) : 5;\n    rayParameters.ramification = this.ramification;\n    this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== undefined ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n    this.recursionProbability = rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6;\n    rayParameters.recursionProbability = this.recursionProbability;\n    this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false;\n    rayParameters.generateUVs = this.generateUVs; // Random generator\n\n    if (rayParameters.randomGenerator !== undefined) {\n      this.randomGenerator = rayParameters.randomGenerator;\n      this.seedGenerator = rayParameters.randomGenerator;\n\n      if (rayParameters.noiseSeed !== undefined) {\n        this.seedGenerator.setSeed(rayParameters.noiseSeed);\n      }\n    } else {\n      this.randomGenerator = LightningStrike.createRandomGenerator();\n      this.seedGenerator = Math;\n    } // Ray creation callbacks\n\n\n    if (rayParameters.onDecideSubrayCreation !== undefined) {\n      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n    } else {\n      this.createDefaultSubrayCreationCallbacks();\n\n      if (rayParameters.onSubrayCreation !== undefined) {\n        this.onSubrayCreation = rayParameters.onSubrayCreation;\n      }\n    } // Internal state\n\n\n    this.state = LightningStrike.RAY_INITIALIZED;\n    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n    rayParameters.maxSubrays = this.maxSubrays;\n    this.maxRaySegments = 2 * (1 << this.maxIterations);\n    this.subrays = [];\n\n    for (let i = 0; i < this.maxSubrays; i++) {\n      this.subrays.push(this.createSubray());\n    }\n\n    this.raySegments = [];\n\n    for (let i = 0; i < this.maxRaySegments; i++) {\n      this.raySegments.push(this.createSegment());\n    }\n\n    this.time = 0;\n    this.timeFraction = 0;\n    this.currentSegmentCallback = null;\n    this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n    this.numSubrays = 0;\n    this.currentSubray = null;\n    this.currentSegmentIndex = 0;\n    this.isInitialSegment = false;\n    this.subrayProbability = 0;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.vertices = null;\n    this.uvs = null;\n    this.indices = null;\n    this.positionAttribute = null;\n    this.uvsAttribute = null;\n    this.simplexX = new SimplexNoise(this.seedGenerator);\n    this.simplexY = new SimplexNoise(this.seedGenerator);\n    this.simplexZ = new SimplexNoise(this.seedGenerator); // Temp vectors\n\n    this.forwards = new Vector3();\n    this.forwardsFill = new Vector3();\n    this.side = new Vector3();\n    this.down = new Vector3();\n    this.middlePos = new Vector3();\n    this.middleLinPos = new Vector3();\n    this.newPos = new Vector3();\n    this.vPos = new Vector3();\n    this.cross1 = new Vector3();\n  }\n\n  createMesh() {\n    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n    this.vertices = new Float32Array(maxVerts * 3);\n    this.indices = new Uint32Array(maxIndices);\n\n    if (this.generateUVs) {\n      this.uvs = new Float32Array(maxVerts * 2);\n    } // Populate the mesh\n\n\n    this.fillMesh(0);\n    this.setIndex(new Uint32BufferAttribute(this.indices, 1));\n    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\n    this.setAttribute('position', this.positionAttribute);\n\n    if (this.generateUVs) {\n      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\n      this.setAttribute('uv', this.uvsAttribute);\n    }\n\n    if (!this.isStatic) {\n      this.index.usage = DynamicDrawUsage;\n      this.positionAttribute.usage = DynamicDrawUsage;\n\n      if (this.generateUVs) {\n        this.uvsAttribute.usage = DynamicDrawUsage;\n      }\n    } // Store buffers for later modification\n\n\n    this.vertices = this.positionAttribute.array;\n    this.indices = this.index.array;\n\n    if (this.generateUVs) {\n      this.uvs = this.uvsAttribute.array;\n    }\n  }\n\n  updateMesh(time) {\n    this.fillMesh(time);\n    this.drawRange.count = this.currentIndex;\n    this.index.needsUpdate = true;\n    this.positionAttribute.needsUpdate = true;\n\n    if (this.generateUVs) {\n      this.uvsAttribute.needsUpdate = true;\n    }\n  }\n\n  fillMesh(time) {\n    const scope = this;\n    this.currentVertex = 0;\n    this.currentIndex = 0;\n    this.currentCoordinate = 0;\n    this.currentUVCoordinate = 0;\n    this.fractalRay(time, function fillVertices(segment) {\n      const subray = scope.currentSubray;\n\n      if (time < subray.birthTime) {\n        //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\n        return;\n      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n        // Eternal rays don't propagate nor vanish, but its subrays do\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else if (time < subray.endPropagationTime) {\n        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n          // Ray propagation has arrived to this segment\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      } else if (time < subray.beginVanishingTime) {\n        // Ray is steady (nor propagating nor vanishing)\n        scope.createPrism(segment);\n        scope.onDecideSubrayCreation(segment, scope);\n      } else {\n        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n          // Segment has not yet vanished\n          scope.createPrism(segment);\n        }\n\n        scope.onDecideSubrayCreation(segment, scope);\n      }\n    });\n  }\n\n  addNewSubray()\n  /*rayParameters*/\n  {\n    return this.subrays[this.numSubrays++];\n  }\n\n  initSubray(subray, rayParameters) {\n    subray.pos0.copy(rayParameters.sourceOffset);\n    subray.pos1.copy(rayParameters.destOffset);\n    subray.up0.copy(rayParameters.up0);\n    subray.up1.copy(rayParameters.up1);\n    subray.radius0 = rayParameters.radius0;\n    subray.radius1 = rayParameters.radius1;\n    subray.birthTime = rayParameters.birthTime;\n    subray.deathTime = rayParameters.deathTime;\n    subray.timeScale = rayParameters.timeScale;\n    subray.roughness = rayParameters.roughness;\n    subray.straightness = rayParameters.straightness;\n    subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n    subray.maxIterations = this.maxIterations;\n    subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0;\n    subray.recursion = 0;\n  }\n\n  fractalRay(time, segmentCallback) {\n    this.time = time;\n    this.currentSegmentCallback = segmentCallback;\n    this.numSubrays = 0; // Add the top level subray\n\n    this.initSubray(this.addNewSubray(), this.rayParameters); // Process all subrays that are being generated until consuming all of them\n\n    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n      const subray = this.subrays[subrayIndex];\n      this.currentSubray = subray;\n      this.randomGenerator.setSeed(subray.seed);\n      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n      const random1 = this.randomGenerator.random;\n      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\n      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\n      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = true;\n      const segment = this.getNewSegment();\n      segment.iteration = 0;\n      segment.pos0.copy(subray.pos0);\n      segment.pos1.copy(subray.pos1);\n      segment.linPos0.copy(subray.linPos0);\n      segment.linPos1.copy(subray.linPos1);\n      segment.up0.copy(subray.up0);\n      segment.up1.copy(subray.up1);\n      segment.radius0 = subray.radius0;\n      segment.radius1 = subray.radius1;\n      segment.fraction0 = 0;\n      segment.fraction1 = 1;\n      segment.positionVariationFactor = 1 - subray.straightness;\n      this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n      this.fractalRayRecursive(segment);\n    }\n\n    this.currentSegmentCallback = null;\n    this.currentSubray = null;\n  }\n\n  fractalRayRecursive(segment) {\n    // Leave recursion condition\n    if (segment.iteration >= this.currentSubray.maxIterations) {\n      this.currentSegmentCallback(segment);\n      return;\n    } // Interpolation\n\n\n    this.forwards.subVectors(segment.pos1, segment.pos0);\n    let lForwards = this.forwards.length();\n\n    if (lForwards < 0.000001) {\n      this.forwards.set(0, 0, 0.01);\n      lForwards = this.forwards.length();\n    }\n\n    const middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n    const p = this.middleLinPos; // Noise\n\n    this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\n    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n    this.newPos.add(this.middlePos); // Recursion\n\n    const newSegment1 = this.getNewSegment();\n    newSegment1.pos0.copy(segment.pos0);\n    newSegment1.pos1.copy(this.newPos);\n    newSegment1.linPos0.copy(segment.linPos0);\n    newSegment1.linPos1.copy(this.middleLinPos);\n    newSegment1.up0.copy(segment.up0);\n    newSegment1.up1.copy(segment.up1);\n    newSegment1.radius0 = segment.radius0;\n    newSegment1.radius1 = middleRadius;\n    newSegment1.fraction0 = segment.fraction0;\n    newSegment1.fraction1 = middleFraction;\n    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment1.iteration = segment.iteration + 1;\n    const newSegment2 = this.getNewSegment();\n    newSegment2.pos0.copy(this.newPos);\n    newSegment2.pos1.copy(segment.pos1);\n    newSegment2.linPos0.copy(this.middleLinPos);\n    newSegment2.linPos1.copy(segment.linPos1);\n    this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n    newSegment2.up1.copy(segment.up1);\n    newSegment2.radius0 = middleRadius;\n    newSegment2.radius1 = segment.radius1;\n    newSegment2.fraction0 = middleFraction;\n    newSegment2.fraction1 = segment.fraction1;\n    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n    newSegment2.iteration = segment.iteration + 1;\n    this.fractalRayRecursive(newSegment1);\n    this.fractalRayRecursive(newSegment2);\n  }\n\n  createPrism(segment) {\n    // Creates one triangular prism and its vertices at the segment\n    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n\n    if (this.isInitialSegment) {\n      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n      this.isInitialSegment = false;\n    }\n\n    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\n    this.createPrismFaces();\n  }\n\n  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n    // Create an equilateral triangle (only vertices)\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    this.currentVertex += 3;\n  }\n\n  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n    // Create an equilateral triangle (only vertices)\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\n    const p = this.vPos;\n    const v = this.vertices;\n    const uv = this.uvs;\n    p.copy(pos).sub(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0;\n    p.copy(pos).add(this.side).add(this.down);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 0.5;\n    p.copy(up).multiplyScalar(radius).add(pos);\n    v[this.currentCoordinate++] = p.x;\n    v[this.currentCoordinate++] = p.y;\n    v[this.currentCoordinate++] = p.z;\n    uv[this.currentUVCoordinate++] = u;\n    uv[this.currentUVCoordinate++] = 1;\n    this.currentVertex += 3;\n  }\n\n  createPrismFaces(vertex\n  /*, index*/\n  ) {\n    const indices = this.indices;\n    var vertex = this.currentVertex - 6;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 5;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 1;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 4;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 0;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 2;\n    indices[this.currentIndex++] = vertex + 3;\n    indices[this.currentIndex++] = vertex + 5;\n  }\n\n  createDefaultSubrayCreationCallbacks() {\n    const random1 = this.randomGenerator.random;\n\n    this.onDecideSubrayCreation = (segment, lightningStrike) => {\n      // Decide subrays creation at parent (sub)ray segment\n      const subray = lightningStrike.currentSubray;\n      const period = lightningStrike.rayParameters.subrayPeriod;\n      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n      const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n      const phase = lightningStrike.time - phase0;\n      const currentCycle = Math.floor(phase / period);\n      const childSubraySeed = random1() * (currentCycle + 1);\n      const isActive = phase % period <= dutyCycle * period;\n      let probability = 0;\n\n      if (isActive) {\n        probability = lightningStrike.subrayProbability; // Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\n      }\n\n      if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n        const childSubray = lightningStrike.addNewSubray();\n        const parentSeed = lightningStrike.randomGenerator.getSeed();\n        childSubray.seed = childSubraySeed;\n        lightningStrike.randomGenerator.setSeed(childSubraySeed);\n        childSubray.recursion = subray.recursion + 1;\n        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\n        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\n        childSubray.up0.copy(subray.up0);\n        childSubray.up1.copy(subray.up1);\n        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n        childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\n        childSubray.birthTime = phase0 + currentCycle * period;\n        childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n\n        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n        }\n\n        childSubray.timeScale = subray.timeScale * 2;\n        childSubray.roughness = subray.roughness;\n        childSubray.straightness = subray.straightness;\n        childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n        lightningStrike.randomGenerator.setSeed(parentSeed);\n      }\n    };\n\n    const vec1Pos = new Vector3();\n    const vec2Forward = new Vector3();\n    const vec3Side = new Vector3();\n    const vec4Up = new Vector3();\n\n    this.onSubrayCreation = (segment, parentSubray, childSubray, lightningStrike) => {\n      // Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\n      // Just use the default cone position generator\n      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n    };\n\n    this.subrayConePosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {\n      // Sets childSubray pos0 and pos1 in a cone\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n\n    this.subrayCylinderPosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {\n      // Sets childSubray pos0 and pos1 in a cylinder\n      childSubray.pos0.copy(segment.pos0);\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n      vec2Forward.copy(vec1Pos).normalize();\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n      const length = vec1Pos.length();\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n      const angle = 2 * Math.PI * random1();\n      vec3Side.multiplyScalar(Math.cos(angle));\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n    };\n  }\n\n  createSubray() {\n    return {\n      seed: 0,\n      maxIterations: 0,\n      recursion: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      birthTime: 0,\n      deathTime: 0,\n      timeScale: 0,\n      roughness: 0,\n      straightness: 0,\n      propagationTimeFactor: 0,\n      vanishingTimeFactor: 0,\n      endPropagationTime: 0,\n      beginVanishingTime: 0\n    };\n  }\n\n  createSegment() {\n    return {\n      iteration: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      fraction0: 0,\n      fraction1: 0,\n      positionVariationFactor: 0\n    };\n  }\n\n  getNewSegment() {\n    return this.raySegments[this.currentSegmentIndex++];\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.init(LightningStrike.copyParameters({}, source.rayParameters));\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters));\n  }\n\n}\n\nLightningStrike.prototype.isLightningStrike = true; // Ray states\n\nLightningStrike.RAY_INITIALIZED = 0;\nLightningStrike.RAY_UNBORN = 1;\nLightningStrike.RAY_PROPAGATING = 2;\nLightningStrike.RAY_STEADY = 3;\nLightningStrike.RAY_VANISHING = 4;\nLightningStrike.RAY_EXTINGUISHED = 5;\nLightningStrike.COS30DEG = Math.cos(30 * Math.PI / 180);\nLightningStrike.SIN30DEG = Math.sin(30 * Math.PI / 180);\n\nLightningStrike.createRandomGenerator = () => {\n  const numSeeds = 2053;\n  const seeds = [];\n\n  for (let i = 0; i < numSeeds; i++) {\n    seeds.push(Math.random());\n  }\n\n  const generator = {\n    currentSeed: 0,\n    random: function () {\n      const value = seeds[generator.currentSeed];\n      generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n      return value;\n    },\n    getSeed: function () {\n      return generator.currentSeed / numSeeds;\n    },\n    setSeed: function (seed) {\n      generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n    }\n  };\n  return generator;\n};\n\nLightningStrike.copyParameters = (dest, source) => {\n  source = source || {};\n  dest = dest || {};\n\n  const vecCopy = v => {\n    if (source === dest) {\n      return v;\n    } else {\n      return v.clone();\n    }\n  };\n\n  dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== undefined ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1, dest.roughness = source.roughness !== undefined ? source.roughness : 0.9, dest.straightness = source.straightness !== undefined ? source.straightness : 0.7, dest.up0 = source.up0 !== undefined ? vecCopy(source.up0) : new Vector3(0, 0, 1);\n  dest.up1 = source.up1 !== undefined ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1, dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2, // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n  dest.isEternal = source.isEternal !== undefined ? source.isEternal : source.birthTime === undefined || source.deathTime === undefined, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6; // These parameters cannot change after lightning creation:\n\n  dest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9;\n  dest.isStatic = source.isStatic !== undefined ? source.isStatic : false;\n  dest.ramification = source.ramification !== undefined ? source.ramification : 5;\n  dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3;\n  dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6;\n  dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false;\n  dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n  return dest;\n};\n\nexport { LightningStrike };\n", "import { Object3D, MeshBasicMaterial, MathUtils, Mesh } from 'three';\nimport { LightningStrike } from '../geometries/LightningStrike.js';\n\n/**\n * @fileoverview Lightning strike object generator\n *\n *\n * Usage\n *\n * const myStorm = new LightningStorm( paramsObject );\n * myStorm.position.set( ... );\n * scene.add( myStorm );\n * ...\n * myStorm.update( currentTime );\n *\n * The \"currentTime\" can only go forwards or be stopped.\n *\n *\n * LightningStorm parameters:\n *\n * @param {double} size Size of the storm. If no 'onRayPosition' parameter is defined, it means the side of the rectangle the storm covers.\n *\n * @param {double} minHeight Minimum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\n *\n * @param {double} maxHeight Maximum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\n *\n * @param {double} maxSlope The maximum inclination slope of a ray. If no 'onRayPosition' parameter is defined, it means the slope relative to plane y = 0.\n *\n * @param {integer} maxLightnings Greater than 0. The maximum number of simultaneous rays.\n *\n * @param {double} lightningMinPeriod minimum time between two consecutive rays.\n *\n * @param {double} lightningMaxPeriod maximum time between two consecutive rays.\n *\n * @param {double} lightningMinDuration The minimum time a ray can last.\n *\n * @param {double} lightningMaxDuration The maximum time a ray can last.\n *\n * @param {Object} lightningParameters The parameters for created rays. See LightningStrike (geometry)\n *\n * @param {Material} lightningMaterial The THREE.Material used for the created rays.\n *\n * @param {function} onRayPosition Optional callback with two Vector3 parameters (source, dest). You can set here the start and end points for each created ray, using the standard size, minHeight, etc parameters and other values in your algorithm.\n *\n * @param {function} onLightningDown This optional callback is called with one parameter (lightningStrike) when a ray ends propagating, so it has hit the ground.\n *\n *\n */\n\nclass LightningStorm extends Object3D {\n  constructor(stormParams = {}) {\n    super(); // Parameters\n\n    this.stormParams = stormParams;\n    stormParams.size = stormParams.size !== undefined ? stormParams.size : 1000.0;\n    stormParams.minHeight = stormParams.minHeight !== undefined ? stormParams.minHeight : 80.0;\n    stormParams.maxHeight = stormParams.maxHeight !== undefined ? stormParams.maxHeight : 100.0;\n    stormParams.maxSlope = stormParams.maxSlope !== undefined ? stormParams.maxSlope : 1.1;\n    stormParams.maxLightnings = stormParams.maxLightnings !== undefined ? stormParams.maxLightnings : 3;\n    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== undefined ? stormParams.lightningMinPeriod : 3.0;\n    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== undefined ? stormParams.lightningMaxPeriod : 7.0;\n    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== undefined ? stormParams.lightningMinDuration : 1.0;\n    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== undefined ? stormParams.lightningMaxDuration : 2.5;\n    this.lightningParameters = LightningStrike.copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);\n    this.lightningParameters.isEternal = false;\n    this.lightningMaterial = stormParams.lightningMaterial !== undefined ? stormParams.lightningMaterial : new MeshBasicMaterial({\n      color: 0xb0ffff\n    });\n\n    if (stormParams.onRayPosition !== undefined) {\n      this.onRayPosition = stormParams.onRayPosition;\n    } else {\n      this.onRayPosition = function (source, dest) {\n        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);\n        const height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());\n        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);\n      };\n    }\n\n    this.onLightningDown = stormParams.onLightningDown; // Internal state\n\n    this.inited = false;\n    this.nextLightningTime = 0;\n    this.lightningsMeshes = [];\n    this.deadLightningsMeshes = [];\n\n    for (let i = 0; i < this.stormParams.maxLightnings; i++) {\n      const lightning = new LightningStrike(LightningStrike.copyParameters({}, this.lightningParameters));\n      const mesh = new Mesh(lightning, this.lightningMaterial);\n      this.deadLightningsMeshes.push(mesh);\n    }\n  }\n\n  update(time) {\n    if (!this.inited) {\n      this.nextLightningTime = this.getNextLightningTime(time) * Math.random();\n      this.inited = true;\n    }\n\n    if (time >= this.nextLightningTime) {\n      // Lightning creation\n      const lightningMesh = this.deadLightningsMeshes.pop();\n\n      if (lightningMesh) {\n        const lightningParams1 = LightningStrike.copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);\n        lightningParams1.birthTime = time;\n        lightningParams1.deathTime = time + MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());\n        this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);\n        lightningParams1.noiseSeed = Math.random();\n        this.add(lightningMesh);\n        this.lightningsMeshes.push(lightningMesh);\n      } // Schedule next lightning\n\n\n      this.nextLightningTime = this.getNextLightningTime(time);\n    }\n\n    let i = 0,\n        il = this.lightningsMeshes.length;\n\n    while (i < il) {\n      const mesh = this.lightningsMeshes[i];\n      const lightning = mesh.geometry;\n      const prevState = lightning.state;\n      lightning.update(time);\n\n      if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {\n        if (this.onLightningDown) {\n          this.onLightningDown(lightning);\n        }\n      }\n\n      if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {\n        // Lightning is to be destroyed\n        this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);\n        this.deadLightningsMeshes.push(mesh);\n        this.remove(mesh);\n        il--;\n      } else {\n        i++;\n      }\n    }\n  }\n\n  getNextLightningTime(currentTime) {\n    return currentTime + MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.stormParams.size = source.stormParams.size;\n    this.stormParams.minHeight = source.stormParams.minHeight;\n    this.stormParams.maxHeight = source.stormParams.maxHeight;\n    this.stormParams.maxSlope = source.stormParams.maxSlope;\n    this.stormParams.maxLightnings = source.stormParams.maxLightnings;\n    this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;\n    this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;\n    this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;\n    this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;\n    this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters);\n    this.lightningMaterial = source.stormParams.lightningMaterial;\n    this.onLightningDown = source.onLightningDown;\n    return this;\n  }\n\n  clone() {\n    return new this.constructor(this.stormParams).copy(this);\n  }\n\n}\n\nLightningStorm.prototype.isLightningStorm = true;\n\nexport { LightningStorm };\n", "import { Mesh, Color, Vector3, Vector2, Matrix4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Plane } from 'three';\n\nclass ReflectorForSSRPass extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.type = 'ReflectorForSSRPass';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n    const useDepthTexture = options.useDepthTexture === true;\n    const yAxis = new Vector3(0, 1, 0);\n    const vecTemp0 = new Vector3();\n    const vecTemp1 = new Vector3(); //\n\n    scope.needsUpdate = false;\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n    scope.color = color;\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n    Object.defineProperty(scope, 'distanceAttenuation', {\n      get() {\n        return scope._distanceAttenuation;\n      },\n\n      set(val) {\n        if (scope._distanceAttenuation === val) return;\n        scope._distanceAttenuation = val;\n        scope.material.defines.DISTANCE_ATTENUATION = val;\n        scope.material.needsUpdate = true;\n      }\n\n    });\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n    Object.defineProperty(scope, 'fresnel', {\n      get() {\n        return scope._fresnel;\n      },\n\n      set(val) {\n        if (scope._fresnel === val) return;\n        scope._fresnel = val;\n        scope.material.defines.FRESNEL = val;\n        scope.material.needsUpdate = true;\n      }\n\n    });\n    const normal = new Vector3();\n    const reflectorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const view = new Vector3();\n    const target = new Vector3();\n    const textureMatrix = new Matrix4();\n    const virtualCamera = new PerspectiveCamera();\n    let depthTexture;\n\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.type = UnsignedShortType;\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n    }\n\n    const parameters = {\n      depthTexture: useDepthTexture ? depthTexture : null\n    };\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n    const material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = scope.color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n\n    if (useDepthTexture) {\n      material.uniforms['tDepth'].value = renderTarget.depthTexture;\n    }\n\n    this.material = material;\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n    const globalPlanes = [globalPlane];\n\n    this.doRender = function (renderer, scene, camera) {\n      material.uniforms['maxDistance'].value = scope.maxDistance;\n      material.uniforms['color'].value = scope.color;\n      material.uniforms['opacity'].value = scope.opacity;\n      vecTemp0.copy(camera.position).normalize();\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      material.uniforms['virtualCameraNear'].value = camera.near;\n      material.uniforms['virtualCameraFar'].value = camera.far;\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld;\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix;\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse;\n      material.uniforms['resolution'].value = scope.resolution; // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      const currentClippingPlanes = renderer.clippingPlanes;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.clippingPlanes = globalPlanes;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.clippingPlanes = currentClippingPlanes;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      } // scope.visible = true;\n\n    };\n\n    this.getRenderTarget = function () {\n      return renderTarget;\n    };\n  }\n\n}\n\nReflectorForSSRPass.prototype.isReflectorForSSRPass = true;\nReflectorForSSRPass.ReflectorShader = {\n  defines: {\n    DISTANCE_ATTENUATION: true,\n    FRESNEL: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: new Matrix4()\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnelCoe: {\n      value: null\n    },\n    virtualCameraNear: {\n      value: null\n    },\n    virtualCameraFar: {\n      value: null\n    },\n    virtualCameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    virtualCameraMatrixWorld: {\n      value: new Matrix4()\n    },\n    virtualCameraProjectionMatrixInverse: {\n      value: new Matrix4()\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`\n};\n\nexport { ReflectorForSSRPass };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Mesh, BoxGeometry, Vector3, ShaderMaterial, UniformsUtils, BackSide } from 'three';\n\n/**\n * Based on \"A Practical Analytic Model for Daylight\"\n * aka The Preetham Model, the de facto standard analytic skydome model\n * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight\n *\n * First implemented by Simon Wallner\n * http://www.simonwallner.at/projects/atmospheric-scattering\n *\n * Improved by Martin Upitis\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n *\n * Three.js integration by zz85 http://twitter.com/blurspline\n */\n\nclass Sky extends Mesh {\n  constructor() {\n    super(new BoxGeometry(1, 1, 1), Sky.material);\n  }\n\n}\n\n_defineProperty(Sky, \"SkyShader\", {\n  uniforms: {\n    turbidity: {\n      value: 2\n    },\n    rayleigh: {\n      value: 1\n    },\n    mieCoefficient: {\n      value: 0.005\n    },\n    mieDirectionalG: {\n      value: 0.8\n    },\n    sunPosition: {\n      value: new Vector3()\n    },\n    up: {\n      value: new Vector3(0, 1, 0)\n    }\n  },\n  vertexShader: ['uniform vec3 sunPosition;', 'uniform float rayleigh;', 'uniform float turbidity;', 'uniform float mieCoefficient;', 'uniform vec3 up;', 'varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', // constants for atmospheric scattering\n  'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;', // wavelength of used primaries, according to preetham\n  'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );', // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n  // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n  'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );', // mie stuff\n  // K coefficient for the primaries\n  'const float v = 4.0;', 'const vec3 K = vec3( 0.686, 0.678, 0.666 );', // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n  'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );', // earth shadow hack\n  // cutoffAngle = pi / 1.95;\n  'const float cutoffAngle = 1.6110731556870734;', 'const float steepness = 1.5;', 'const float EE = 1000.0;', 'float sunIntensity( float zenithAngleCos ) {', '\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );', '\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );', '}', 'vec3 totalMie( float T ) {', '\tfloat c = ( 0.2 * T ) * 10E-18;', '\treturn 0.434 * c * MieConst;', '}', 'void main() {', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvWorldPosition = worldPosition.xyz;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tgl_Position.z = gl_Position.w;', // set z to camera.far\n  '\tvSunDirection = normalize( sunPosition );', '\tvSunE = sunIntensity( dot( vSunDirection, up ) );', '\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );', '\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );', // extinction (absorbtion + out scattering)\n  // rayleigh coefficients\n  '\tvBetaR = totalRayleigh * rayleighCoefficient;', // mie coefficients\n  '\tvBetaM = totalMie( turbidity ) * mieCoefficient;', '}'].join('\\n'),\n  fragmentShader: ['varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'uniform float mieDirectionalG;', 'uniform vec3 up;', 'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );', // constants for atmospheric scattering\n  'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003;', // refractive index of air\n  'const float N = 2.545E25;', // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n  // optical length at zenith for molecules\n  'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;', // 66 arc seconds -> degrees, and the cosine of that\n  'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;', // 3.0 / ( 16.0 * pi )\n  'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;', // 1.0 / ( 4.0 * pi )\n  'const float ONE_OVER_FOURPI = 0.07957747154594767;', 'float rayleighPhase( float cosTheta ) {', '\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );', '}', 'float hgPhase( float cosTheta, float g ) {', '\tfloat g2 = pow( g, 2.0 );', '\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );', '\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );', '}', 'void main() {', '\tvec3 direction = normalize( vWorldPosition - cameraPos );', // optical length\n  // cutoff angle at 90 to avoid singularity in next formula.\n  '\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );', '\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );', '\tfloat sR = rayleighZenithLength * inverse;', '\tfloat sM = mieZenithLength * inverse;', // combined extinction factor\n  '\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );', // in scattering\n  '\tfloat cosTheta = dot( direction, vSunDirection );', '\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );', '\tvec3 betaRTheta = vBetaR * rPhase;', '\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );', '\tvec3 betaMTheta = vBetaM * mPhase;', '\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );', '\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );', // nightsky\n  '\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]', '\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]', '\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );', '\tvec3 L0 = vec3( 0.1 ) * Fex;', // composition + solar disc\n  '\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );', '\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;', '\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );', '\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );', '\tgl_FragColor = vec4( retColor, 1.0 );', '#include <tonemapping_fragment>', '#include <encodings_fragment>', '}'].join('\\n')\n});\n\n_defineProperty(Sky, \"material\", new ShaderMaterial({\n  name: 'SkyShader',\n  fragmentShader: Sky.SkyShader.fragmentShader,\n  vertexShader: Sky.SkyShader.vertexShader,\n  uniforms: UniformsUtils.clone(Sky.SkyShader.uniforms),\n  side: BackSide,\n  depthWrite: false\n}));\n\nexport { Sky };\n", "import { Mesh, Color, Vector2, LinearEncoding, TextureLoader, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping, Vector4 } from 'three';\nimport { Reflector } from './Reflector.js';\nimport { Refractor } from './Refractor.js';\n\n/**\n * References:\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\n *\n */\n\nclass Water2 extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.type = 'Water';\n    const scope = this;\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0xffffff);\n    const textureWidth = options.textureWidth || 512;\n    const textureHeight = options.textureHeight || 512;\n    const clipBias = options.clipBias || 0;\n    const flowDirection = options.flowDirection || new Vector2(1, 0);\n    const flowSpeed = options.flowSpeed || 0.03;\n    const reflectivity = options.reflectivity || 0.02;\n    const scale = options.scale || 1;\n    const shader = options.shader || Water2.WaterShader;\n    const encoding = options.encoding !== undefined ? options.encoding : LinearEncoding;\n    const textureLoader = new TextureLoader();\n    const flowMap = options.flowMap || undefined;\n    const normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\n    const normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\n    const cycle = 0.15; // a cycle of a flow map phase\n\n    const halfCycle = cycle * 0.5;\n    const textureMatrix = new Matrix4();\n    const clock = new Clock(); // internal components\n\n    if (Reflector === undefined) {\n      console.error('THREE.Water: Required component Reflector not found.');\n      return;\n    }\n\n    if (Refractor === undefined) {\n      console.error('THREE.Water: Required component Refractor not found.');\n      return;\n    }\n\n    const reflector = new Reflector(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    const refractor = new Refractor(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    reflector.matrixAutoUpdate = false;\n    refractor.matrixAutoUpdate = false; // material\n\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], shader.uniforms]),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true,\n      fog: true\n    });\n\n    if (flowMap !== undefined) {\n      this.material.defines.USE_FLOWMAP = '';\n      this.material.uniforms['tFlowMap'] = {\n        type: 't',\n        value: flowMap\n      };\n    } else {\n      this.material.uniforms['flowDirection'] = {\n        type: 'v2',\n        value: flowDirection\n      };\n    } // maps\n\n\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n    this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\n    this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\n    this.material.uniforms['tNormalMap0'].value = normalMap0;\n    this.material.uniforms['tNormalMap1'].value = normalMap1; // water\n\n    this.material.uniforms['color'].value = color;\n    this.material.uniforms['reflectivity'].value = reflectivity;\n    this.material.uniforms['textureMatrix'].value = textureMatrix; // inital values\n\n    this.material.uniforms['config'].value.x = 0; // flowMapOffset0\n\n    this.material.uniforms['config'].value.y = halfCycle; // flowMapOffset1\n\n    this.material.uniforms['config'].value.z = halfCycle; // halfCycle\n\n    this.material.uniforms['config'].value.w = scale; // scale\n    // functions\n\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n\n    function updateFlow() {\n      const delta = clock.getDelta();\n      const config = scope.material.uniforms['config'];\n      config.value.x += flowSpeed * delta; // flowMapOffset0\n\n      config.value.y = config.value.x + halfCycle; // flowMapOffset1\n      // Important: The distance between offsets should be always the value of \"halfCycle\".\n      // Moreover, both offsets should be in the range of [ 0, cycle ].\n      // This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n      if (config.value.x >= cycle) {\n        config.value.x = 0;\n        config.value.y = halfCycle;\n      } else if (config.value.y >= cycle) {\n        config.value.y = config.value.y - cycle;\n      }\n    } //\n\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      updateTextureMatrix(camera);\n      updateFlow();\n      scope.visible = false;\n      reflector.matrixWorld.copy(scope.matrixWorld);\n      refractor.matrixWorld.copy(scope.matrixWorld);\n      reflector.onBeforeRender(renderer, scene, camera);\n      refractor.onBeforeRender(renderer, scene, camera);\n      scope.visible = true;\n    };\n  }\n\n}\n\nWater2.prototype.isWater = true;\nWater2.WaterShader = {\n  uniforms: {\n    color: {\n      type: 'c',\n      value: null\n    },\n    reflectivity: {\n      type: 'f',\n      value: 0\n    },\n    tReflectionMap: {\n      type: 't',\n      value: null\n    },\n    tRefractionMap: {\n      type: 't',\n      value: null\n    },\n    tNormalMap0: {\n      type: 't',\n      value: null\n    },\n    tNormalMap1: {\n      type: 't',\n      value: null\n    },\n    textureMatrix: {\n      type: 'm4',\n      value: null\n    },\n    config: {\n      type: 'v4',\n      value: new Vector4()\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`,\n  fragmentShader:\n  /* glsl */\n  `\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}`\n};\n\nexport { Water2 };\n", "import { Mesh, PlaneGeometry, OrthographicCamera, MathUtils, WebGLRenderTarget, Vector2, RawShaderMaterial, NoBlending } from 'three';\n\n/**\n * This class generates custom mipmaps for a roughness map by encoding the lost variation in the\n * normal map mip levels as increased roughness in the corresponding roughness mip levels. This\n * helps with rendering accuracy for MeshStandardMaterial, and also helps with anti-aliasing when\n * using PMREM. If the normal map is larger than the roughness map, the roughness map will be\n * enlarged to match the dimensions of the normal map.\n */\n\nvar _mipmapMaterial = _getMipmapMaterial();\n\nvar _mesh = new Mesh(new PlaneGeometry(2, 2), _mipmapMaterial);\n\nvar _flatCamera = new OrthographicCamera(0, 1, 0, 1, 0, 1);\n\nvar _tempTarget = null;\nvar _renderer = null;\n\nfunction RoughnessMipmapper(renderer) {\n  _renderer = renderer;\n\n  _renderer.compile(_mesh, _flatCamera);\n}\n\nRoughnessMipmapper.prototype = {\n  constructor: RoughnessMipmapper,\n  generateMipmaps: function (material) {\n    if ('roughnessMap' in material === false) return;\n    var {\n      roughnessMap,\n      normalMap\n    } = material;\n\n    if (roughnessMap === null || normalMap === null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated) {\n      return;\n    }\n\n    material.userData.roughnessUpdated = true;\n    var width = Math.max(roughnessMap.image.width, normalMap.image.width);\n    var height = Math.max(roughnessMap.image.height, normalMap.image.height);\n    if (!MathUtils.isPowerOfTwo(width) || !MathUtils.isPowerOfTwo(height)) return;\n\n    var oldTarget = _renderer.getRenderTarget();\n\n    var autoClear = _renderer.autoClear;\n    _renderer.autoClear = false;\n\n    if (_tempTarget === null || _tempTarget.width !== width || _tempTarget.height !== height) {\n      if (_tempTarget !== null) _tempTarget.dispose();\n      _tempTarget = new WebGLRenderTarget(width, height, {\n        depthBuffer: false\n      });\n      _tempTarget.scissorTest = true;\n    }\n\n    if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {\n      var params = {\n        wrapS: roughnessMap.wrapS,\n        wrapT: roughnessMap.wrapT,\n        magFilter: roughnessMap.magFilter,\n        minFilter: roughnessMap.minFilter,\n        depthBuffer: false\n      };\n      var newRoughnessTarget = new WebGLRenderTarget(width, height, params);\n      newRoughnessTarget.texture.generateMipmaps = true; // Setting the render target causes the memory to be allocated.\n\n      _renderer.setRenderTarget(newRoughnessTarget);\n\n      material.roughnessMap = newRoughnessTarget.texture;\n      if (material.metalnessMap == roughnessMap) material.metalnessMap = material.roughnessMap;\n      if (material.aoMap == roughnessMap) material.aoMap = material.roughnessMap;\n    }\n\n    _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;\n    _mipmapMaterial.uniforms.normalMap.value = normalMap;\n    var position = new Vector2(0, 0);\n    var texelSize = _mipmapMaterial.uniforms.texelSize.value;\n\n    for (let mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {\n      // Rendering to a mip level is not allowed in webGL1. Instead we must set\n      // up a secondary texture to write the result to, then copy it back to the\n      // proper mipmap level.\n      texelSize.set(1.0 / width, 1.0 / height);\n      if (mip == 0) texelSize.set(0.0, 0.0);\n\n      _tempTarget.viewport.set(position.x, position.y, width, height);\n\n      _tempTarget.scissor.set(position.x, position.y, width, height);\n\n      _renderer.setRenderTarget(_tempTarget);\n\n      _renderer.render(_mesh, _flatCamera);\n\n      _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);\n\n      _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;\n    }\n\n    if (roughnessMap !== material.roughnessMap) roughnessMap.dispose();\n\n    _renderer.setRenderTarget(oldTarget);\n\n    _renderer.autoClear = autoClear;\n  },\n  dispose: function () {\n    _mipmapMaterial.dispose();\n\n    _mesh.geometry.dispose();\n\n    if (_tempTarget != null) _tempTarget.dispose();\n  }\n};\n\nfunction _getMipmapMaterial() {\n  var shaderMaterial = new RawShaderMaterial({\n    uniforms: {\n      roughnessMap: {\n        value: null\n      },\n      normalMap: {\n        value: null\n      },\n      texelSize: {\n        value: new Vector2(1, 1)\n      }\n    },\n    vertexShader:\n    /* glsl */\n    `\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t`,\n    fragmentShader:\n    /* glsl */\n    `\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  shaderMaterial.type = 'RoughnessMipmapper';\n  return shaderMaterial;\n}\n\nexport { RoughnessMipmapper };\n", "import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper, Vector2, Euler } from 'three';\n\nvar SkeletonUtils = {\n  retarget: function () {\n    var pos = new Vector3(),\n        quat = new Quaternion(),\n        scale = new Vector3(),\n        bindBoneMatrix = new Matrix4(),\n        relativeMatrix = new Matrix4(),\n        globalMatrix = new Matrix4();\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          bindBones,\n          bone,\n          name,\n          boneTo,\n          bonesPosition,\n          i; // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n\n      if (options.preservePosition) {\n        bonesPosition = [];\n\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // reset matrix\n        target.updateMatrixWorld();\n        target.matrixWorld.identity(); // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n\n      if (options.offsets) {\n        bindBones = [];\n\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n            bone.updateMatrixWorld();\n          }\n\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.copy(target.matrixWorld).invert();\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          } // ignore scale to extract rotation\n\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n            globalMatrix.multiply(wBindMatrix);\n          }\n\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // restore matrix\n        target.updateMatrixWorld(true);\n      }\n    };\n  }(),\n  retargetClip: function (target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n        delta = 1 / options.fps,\n        convertedTracks = [],\n        mixer = new AnimationMixer(source),\n        bones = this.getBones(target.skeleton),\n        boneDatas = [],\n        positionOffset,\n        bone,\n        boneTo,\n        boneData,\n        name,\n        i,\n        j;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n      this.retarget(target, source, options);\n\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n\n              bone.position.sub(positionOffset);\n            }\n\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n        }\n\n        convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n      }\n    }\n\n    mixer.uncacheAction(clip);\n    return new AnimationClip(clip.name, -1, convertedTracks);\n  },\n  getHelperFromSkeleton: function (skeleton) {\n    var source = new SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  },\n  getSkeletonOffsets: function () {\n    var targetParentPos = new Vector3(),\n        targetPos = new Vector3(),\n        sourceParentPos = new Vector3(),\n        sourcePos = new Vector3(),\n        targetDir = new Vector2(),\n        sourceDir = new Vector2();\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n\n      var nameKeys = Object.keys(options.names),\n          nameValues = Object.values(options.names),\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          offsets = [],\n          bone,\n          boneTo,\n          name,\n          i;\n      target.skeleton.pose();\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n          bone.matrix.multiply(offset);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n          offsets[name] = offset;\n        }\n      }\n\n      return offsets;\n    };\n  }(),\n  renameBones: function (skeleton, names) {\n    var bones = this.getBones(skeleton);\n\n    for (let i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n\n    return this;\n  },\n  getBones: function (skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n  getBoneByName: function (name, skeleton) {\n    for (let i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n  getNearestBone: function (bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n\n      bone = bone.parent;\n    }\n  },\n  findBoneTrackData: function (name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n        result = {\n      name: name\n    };\n\n    for (let i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n\n    return result;\n  },\n  getEqualsBonesNames: function (skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n        targetBones = this.getBones(targetSkeleton),\n        bones = [];\n\n    search: for (let i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n\n      for (let j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n\n    return bones;\n  },\n  clone: function (source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n    var clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n};\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\nexport { SkeletonUtils };\n", "/**\n * Unpack RGBA depth shader\n * - show RGBA encoded depth as monochrome color\n */\nconst UnpackDepthRGBAShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    opacity: {\n      value: 1.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float opacity;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', '#include <packing>', 'void main() {', '\tfloat depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );', '\tgl_FragColor = vec4( vec3( depth ), opacity );', '}'].join('\\n')\n};\n\nexport { UnpackDepthRGBAShader };\n", "import { OrthographicCamera, Scene, UniformsUtils, ShaderMaterial, PlaneGeometry, Mesh, Texture, LinearFilter, MeshBasicMaterial, DoubleSide } from 'three';\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';\n\n/**\n * This is a helper for visualising a given light's shadow map.\n * It works for shadow casting lights: DirectionalLight and SpotLight.\n * It renders out the shadow map and displays it on a HUD.\n *\n * Example usage:\n *\t1) Import ShadowMapViewer into your app.\n *\n *\t2) Create a shadow casting light and name it optionally:\n *\t\tvar light = new DirectionalLight( 0xffffff, 1 );\n *\t\tlight.castShadow = true;\n *\t\tlight.name = 'Sun';\n *\n *\t3) Create a shadow map viewer for that light and set its size and position optionally:\n *\t\tvar shadowMapViewer = new ShadowMapViewer( light );\n *\t\tshadowMapViewer.size.set( 128, 128 );\t//width, height  default: 256, 256\n *\t\tshadowMapViewer.position.set( 10, 10 );\t//x, y in pixel\t default: 0, 0 (top left corner)\n *\n *\t4) Render the shadow map viewer in your render loop:\n *\t\tshadowMapViewer.render( renderer );\n *\n *\t5) Optionally: Update the shadow map viewer on window resize:\n *\t\tshadowMapViewer.updateForWindowResize();\n *\n *\t6) If you set the position or size members directly, you need to call shadowMapViewer.update();\n */\n\nvar ShadowMapViewer = function (light) {\n  //- Internals\n  var scope = this;\n  var doRenderLabel = light.name !== undefined && light.name !== '';\n  var userAutoClearSetting; //Holds the initial position and dimension of the HUD\n\n  var frame = {\n    x: 10,\n    y: 10,\n    width: 256,\n    height: 256\n  };\n  var camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);\n  camera.position.set(0, 0, 2);\n  var scene = new Scene(); //HUD for shadow map\n\n  var shader = UnpackDepthRGBAShader;\n  var uniforms = UniformsUtils.clone(shader.uniforms);\n  var material = new ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader\n  });\n  var plane = new PlaneGeometry(frame.width, frame.height);\n  var mesh = new Mesh(plane, material);\n  scene.add(mesh); //Label for light's name\n\n  var labelCanvas, labelMesh;\n\n  if (doRenderLabel) {\n    labelCanvas = document.createElement('canvas');\n    var context = labelCanvas.getContext('2d');\n    context.font = 'Bold 20px Arial';\n    var labelWidth = context.measureText(light.name).width;\n    labelCanvas.width = labelWidth;\n    labelCanvas.height = 25; //25 to account for g, p, etc.\n\n    context.font = 'Bold 20px Arial';\n    context.fillStyle = 'rgba( 255, 0, 0, 1 )';\n    context.fillText(light.name, 0, 20);\n    var labelTexture = new Texture(labelCanvas);\n    labelTexture.magFilter = LinearFilter;\n    labelTexture.minFilter = LinearFilter;\n    labelTexture.needsUpdate = true;\n    var labelMaterial = new MeshBasicMaterial({\n      map: labelTexture,\n      side: DoubleSide\n    });\n    labelMaterial.transparent = true;\n    var labelPlane = new PlaneGeometry(labelCanvas.width, labelCanvas.height);\n    labelMesh = new Mesh(labelPlane, labelMaterial);\n    scene.add(labelMesh);\n  }\n\n  function resetPosition() {\n    scope.position.set(scope.position.x, scope.position.y);\n  } //- API\n  // Set to false to disable displaying this shadow map\n\n\n  this.enabled = true; // Set the size of the displayed shadow map on the HUD\n\n  this.size = {\n    width: frame.width,\n    height: frame.height,\n    set: function (width, height) {\n      this.width = width;\n      this.height = height;\n      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1); //Reset the position as it is off when we scale stuff\n\n      resetPosition();\n    }\n  }; // Set the position of the displayed shadow map on the HUD\n\n  this.position = {\n    x: frame.x,\n    y: frame.y,\n    set: function (x, y) {\n      this.x = x;\n      this.y = y;\n      var width = scope.size.width;\n      var height = scope.size.height;\n      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);\n\n      if (doRenderLabel) {\n        labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);\n      }\n    }\n  };\n\n  this.render = function (renderer) {\n    if (this.enabled) {\n      //Because a light's .shadowMap is only initialised after the first render pass\n      //we have to make sure the correct map is sent into the shader, otherwise we\n      //always end up with the scene's first added shadow casting light's shadowMap\n      //in the shader\n      //See: https://github.com/mrdoob/three.js/issues/5932\n      uniforms.tDiffuse.value = light.shadow.map.texture;\n      userAutoClearSetting = renderer.autoClear;\n      renderer.autoClear = false; // To allow render overlay\n\n      renderer.clearDepth();\n      renderer.render(scene, camera);\n      renderer.autoClear = userAutoClearSetting; //Restore user's setting\n    }\n  };\n\n  this.updateForWindowResize = function () {\n    if (this.enabled) {\n      camera.left = window.innerWidth / -2;\n      camera.right = window.innerWidth / 2;\n      camera.top = window.innerHeight / 2;\n      camera.bottom = window.innerHeight / -2;\n      camera.updateProjectionMatrix();\n      this.update();\n    }\n  };\n\n  this.update = function () {\n    this.position.set(this.position.x, this.position.y);\n    this.size.set(this.size.width, this.size.height);\n  }; //Force an update to set position/size\n\n\n  this.update();\n};\n\nShadowMapViewer.prototype.constructor = ShadowMapViewer;\n\nexport { ShadowMapViewer };\n", "import { Vector2 } from 'three';\n\n/**\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\nconst BokehShader2 = {\n  uniforms: {\n    textureWidth: {\n      value: 1.0\n    },\n    textureHeight: {\n      value: 1.0\n    },\n    focalDepth: {\n      value: 1.0\n    },\n    focalLength: {\n      value: 24.0\n    },\n    fstop: {\n      value: 0.9\n    },\n    tColor: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    maxblur: {\n      value: 1.0\n    },\n    showFocus: {\n      value: 0\n    },\n    manualdof: {\n      value: 0\n    },\n    vignetting: {\n      value: 0\n    },\n    depthblur: {\n      value: 0\n    },\n    threshold: {\n      value: 0.5\n    },\n    gain: {\n      value: 2.0\n    },\n    bias: {\n      value: 0.5\n    },\n    fringe: {\n      value: 0.7\n    },\n    znear: {\n      value: 0.1\n    },\n    zfar: {\n      value: 100\n    },\n    noise: {\n      value: 1\n    },\n    dithering: {\n      value: 0.0001\n    },\n    pentagon: {\n      value: 0\n    },\n    shaderFocus: {\n      value: 1\n    },\n    focusCoords: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', 'uniform sampler2D tColor;', 'uniform sampler2D tDepth;', 'uniform float textureWidth;', 'uniform float textureHeight;', 'uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below', 'uniform float focalLength; //focal length in mm', 'uniform float fstop; //f-stop value', 'uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)', '/*', 'make sure that these two values are the same for your camera, otherwise distances will be wrong.', '*/', 'uniform float znear; // camera clipping start', 'uniform float zfar; // camera clipping end', '//------------------------------------------', '//user variables', 'const int samples = SAMPLES; //samples on the first ring', 'const int rings = RINGS; //ring count', 'const int maxringsamples = rings * samples;', 'uniform bool manualdof; // manual dof calculation', 'float ndofstart = 1.0; // near dof blur start', 'float ndofdist = 2.0; // near dof blur falloff distance', 'float fdofstart = 1.0; // far dof blur start', 'float fdofdist = 3.0; // far dof blur falloff distance', 'float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)', 'uniform bool vignetting; // use optical lens vignetting', 'float vignout = 1.3; // vignetting outer border', 'float vignin = 0.0; // vignetting inner border', 'float vignfade = 22.0; // f-stops till vignete fades', 'uniform bool shaderFocus;', '// disable if you use external focalDepth value', 'uniform vec2 focusCoords;', '// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)', '// if center of screen use vec2(0.5, 0.5);', 'uniform float maxblur;', '//clamp value of max blur (0.0 = no blur, 1.0 default)', 'uniform float threshold; // highlight threshold;', 'uniform float gain; // highlight gain;', 'uniform float bias; // bokeh edge bias', 'uniform float fringe; // bokeh chromatic aberration / fringing', 'uniform bool noise; //use noise instead of pattern for sample dithering', 'uniform float dithering;', 'uniform bool depthblur; // blur the depth buffer', 'float dbsize = 1.25; // depth blur size', '/*', 'next part is experimental', 'not looking good with small sample and ring count', 'looks okay starting from samples = 4, rings = 4', '*/', 'uniform bool pentagon; //use pentagon as bokeh shape?', 'float feather = 0.4; //pentagon shape feather', '//------------------------------------------', 'float penta(vec2 coords) {', '\t//pentagonal shape', '\tfloat scale = float(rings) - 1.3;', '\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);', '\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);', '\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);', '\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);', '\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);', '\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);', '\tvec4  one = vec4( 1.0 );', '\tvec4 P = vec4((coords),vec2(scale, scale));', '\tvec4 dist = vec4(0.0);', '\tfloat inorout = -4.0;', '\tdist.x = dot( P, HS0 );', '\tdist.y = dot( P, HS1 );', '\tdist.z = dot( P, HS2 );', '\tdist.w = dot( P, HS3 );', '\tdist = smoothstep( -feather, feather, dist );', '\tinorout += dot( dist, one );', '\tdist.x = dot( P, HS4 );', '\tdist.y = HS5.w - abs( P.z );', '\tdist = smoothstep( -feather, feather, dist );', '\tinorout += dist.x;', '\treturn clamp( inorout, 0.0, 1.0 );', '}', 'float bdepth(vec2 coords) {', '\t// Depth buffer blur', '\tfloat d = 0.0;', '\tfloat kernel[9];', '\tvec2 offset[9];', '\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;', '\toffset[0] = vec2(-wh.x,-wh.y);', '\toffset[1] = vec2( 0.0, -wh.y);', '\toffset[2] = vec2( wh.x -wh.y);', '\toffset[3] = vec2(-wh.x,  0.0);', '\toffset[4] = vec2( 0.0,   0.0);', '\toffset[5] = vec2( wh.x,  0.0);', '\toffset[6] = vec2(-wh.x, wh.y);', '\toffset[7] = vec2( 0.0,  wh.y);', '\toffset[8] = vec2( wh.x, wh.y);', '\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;', '\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;', '\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;', '\tfor( int i=0; i<9; i++ ) {', '\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;', '\t\td += tmp * kernel[i];', '\t}', '\treturn d;', '}', 'vec3 color(vec2 coords,float blur) {', '\t//processing the sample', '\tvec3 col = vec3(0.0);', '\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);', '\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;', '\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;', '\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;', '\tvec3 lumcoeff = vec3(0.299,0.587,0.114);', '\tfloat lum = dot(col.rgb, lumcoeff);', '\tfloat thresh = max((lum-threshold)*gain, 0.0);', '\treturn col+mix(vec3(0.0),col,thresh*blur);', '}', 'vec3 debugFocus(vec3 col, float blur, float depth) {', '\tfloat edge = 0.002*depth; //distance based edge smoothing', '\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);', '\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);', '\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);', '\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);', '\treturn col;', '}', 'float linearize(float depth) {', '\treturn -zfar * znear / (depth * (zfar - znear) - zfar);', '}', 'float vignette() {', '\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));', '\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);', '\treturn clamp(dist,0.0,1.0);', '}', 'float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {', '\tfloat rings2 = float(rings);', '\tfloat step = PI*2.0 / float(ringsamples);', '\tfloat pw = cos(j*step)*i;', '\tfloat ph = sin(j*step)*i;', '\tfloat p = 1.0;', '\tif (pentagon) {', '\t\tp = penta(vec2(pw,ph));', '\t}', '\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;', '\treturn 1.0 * mix(1.0, i /rings2, bias) * p;', '}', 'void main() {', '\t//scene depth calculation', '\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);', '\t// Blur depth?', '\tif ( depthblur ) {', '\t\tdepth = linearize(bdepth(vUv.xy));', '\t}', '\t//focal plane calculation', '\tfloat fDepth = focalDepth;', '\tif (shaderFocus) {', '\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);', '\t}', '\t// dof blur factor calculation', '\tfloat blur = 0.0;', '\tif (manualdof) {', '\t\tfloat a = depth-fDepth; // Focal plane', '\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF', '\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof', '\t\tblur = (a>0.0) ? b : c;', '\t} else {', '\t\tfloat f = focalLength; // focal length in mm', '\t\tfloat d = fDepth*1000.0; // focal plane in mm', '\t\tfloat o = depth*1000.0; // depth in mm', '\t\tfloat a = (o*f)/(o-f);', '\t\tfloat b = (d*f)/(d-f);', '\t\tfloat c = (d-f)/(d*fstop*CoC);', '\t\tblur = abs(a-b)*c;', '\t}', '\tblur = clamp(blur,0.0,1.0);', '\t// calculation of pattern for dithering', '\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;', '\t// getting blur x and y step factor', '\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;', '\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;', '\t// calculation of final color', '\tvec3 col = vec3(0.0);', '\tif(blur < 0.05) {', '\t\t//some optimization thingy', '\t\tcol = texture2D(tColor, vUv.xy).rgb;', '\t} else {', '\t\tcol = texture2D(tColor, vUv.xy).rgb;', '\t\tfloat s = 1.0;', '\t\tint ringsamples;', '\t\tfor (int i = 1; i <= rings; i++) {', '\t\t\t/*unboxstart*/', '\t\t\tringsamples = i * samples;', '\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {', '\t\t\t\tif (j >= ringsamples) break;', '\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);', '\t\t\t}', '\t\t\t/*unboxend*/', '\t\t}', '\t\tcol /= s; //divide by sample count', '\t}', '\tif (showFocus) {', '\t\tcol = debugFocus(col, blur, depth);', '\t}', '\tif (vignetting) {', '\t\tcol *= vignette();', '\t}', '\tgl_FragColor.rgb = col;', '\tgl_FragColor.a = 1.0;', '} '].join('\\n')\n};\nconst BokehDepthShader = {\n  uniforms: {\n    mNear: {\n      value: 1.0\n    },\n    mFar: {\n      value: 1000.0\n    }\n  },\n  vertexShader: ['varying float vViewZDepth;', 'void main() {', '\t#include <begin_vertex>', '\t#include <project_vertex>', '\tvViewZDepth = - mvPosition.z;', '}'].join('\\n'),\n  fragmentShader: ['uniform float mNear;', 'uniform float mFar;', 'varying float vViewZDepth;', 'void main() {', '\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );', '\tgl_FragColor = vec4( vec3( color ), 1.0 );', '} '].join('\\n')\n};\n\nexport { BokehDepthShader, BokehShader2 };\n", "import { Triangle, Vector3 } from 'three';\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - http://www.joesfer.com/?p=84\n * - https://stackoverflow.com/a/4322940/1314762\n */\n\nvar MeshSurfaceSampler = function () {\n  var _face = new Triangle();\n\n  var _color = new Vector3();\n\n  function MeshSurfaceSampler(mesh) {\n    var geometry = mesh.geometry;\n\n    if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {\n      throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');\n    }\n\n    if (geometry.index) {\n      console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');\n      geometry = geometry.toNonIndexed();\n    }\n\n    this.geometry = geometry;\n    this.randomFunction = Math.random;\n    this.positionAttribute = this.geometry.getAttribute('position');\n    this.colorAttribute = this.geometry.getAttribute('color');\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n\n  MeshSurfaceSampler.prototype = {\n    constructor: MeshSurfaceSampler,\n    setWeightAttribute: function (name) {\n      this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n      return this;\n    },\n    build: function () {\n      var positionAttribute = this.positionAttribute;\n      var weightAttribute = this.weightAttribute;\n      var faceWeights = new Float32Array(positionAttribute.count / 3); // Accumulate weights for each mesh face.\n\n      for (let i = 0; i < positionAttribute.count; i += 3) {\n        var faceWeight = 1;\n\n        if (weightAttribute) {\n          faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n        }\n\n        _face.a.fromBufferAttribute(positionAttribute, i);\n\n        _face.b.fromBufferAttribute(positionAttribute, i + 1);\n\n        _face.c.fromBufferAttribute(positionAttribute, i + 2);\n\n        faceWeight *= _face.getArea();\n        faceWeights[i / 3] = faceWeight;\n      } // Store cumulative total face weights in an array, where weight index\n      // corresponds to face index.\n\n\n      this.distribution = new Float32Array(positionAttribute.count / 3);\n      var cumulativeTotal = 0;\n\n      for (let i = 0; i < faceWeights.length; i++) {\n        cumulativeTotal += faceWeights[i];\n        this.distribution[i] = cumulativeTotal;\n      }\n\n      return this;\n    },\n    setRandomGenerator: function (randomFunction) {\n      this.randomFunction = randomFunction;\n      return this;\n    },\n    sample: function (targetPosition, targetNormal, targetColor) {\n      var cumulativeTotal = this.distribution[this.distribution.length - 1];\n      var faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);\n      return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\n    },\n    binarySearch: function (x) {\n      var dist = this.distribution;\n      var start = 0;\n      var end = dist.length - 1;\n      var index = -1;\n\n      while (start <= end) {\n        var mid = Math.ceil((start + end) / 2);\n\n        if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n          index = mid;\n          break;\n        } else if (x < dist[mid]) {\n          end = mid - 1;\n        } else {\n          start = mid + 1;\n        }\n      }\n\n      return index;\n    },\n    sampleFace: function (faceIndex, targetPosition, targetNormal, targetColor) {\n      var u = this.randomFunction();\n      var v = this.randomFunction();\n\n      if (u + v > 1) {\n        u = 1 - u;\n        v = 1 - v;\n      }\n\n      _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n\n      _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n\n      _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n\n      targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n\n      if (targetNormal !== undefined) {\n        _face.getNormal(targetNormal);\n      }\n\n      if (targetColor !== undefined && this.colorAttribute !== undefined) {\n        _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\n\n        _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\n\n        _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\n\n        _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n\n        targetColor.r = _color.x;\n        targetColor.g = _color.y;\n        targetColor.b = _color.z;\n      }\n\n      return this;\n    }\n  };\n  return MeshSurfaceSampler;\n}();\n\nexport { MeshSurfaceSampler };\n", "import { Vector3, Matrix3, Box3, Matrix4, Ray, MathUtils } from 'three';\n\nvar a = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: [] // half width\n\n};\nvar b = {\n  c: null,\n  // center\n  u: [new Vector3(), new Vector3(), new Vector3()],\n  // basis vectors\n  e: [] // half width\n\n};\nvar R = [[], [], []];\nvar AbsR = [[], [], []];\nvar t = [];\nvar xAxis = new Vector3();\nvar yAxis = new Vector3();\nvar zAxis = new Vector3();\nvar v1 = new Vector3();\nvar size = new Vector3();\nvar closestPoint = new Vector3();\nvar rotationMatrix = new Matrix3();\nvar aabb = new Box3();\nvar matrix = new Matrix4();\nvar inverse = new Matrix4();\nvar localRay = new Ray(); // OBB\n\nfunction OBB(center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3()) {\n  this.center = center;\n  this.halfSize = halfSize;\n  this.rotation = rotation;\n}\n\nObject.assign(OBB.prototype, {\n  set: function (center, halfSize, rotation) {\n    this.center = center;\n    this.halfSize = halfSize;\n    this.rotation = rotation;\n    return this;\n  },\n  copy: function (obb) {\n    this.center.copy(obb.center);\n    this.halfSize.copy(obb.halfSize);\n    this.rotation.copy(obb.rotation);\n    return this;\n  },\n  clone: function () {\n    return new this.constructor().copy(this);\n  },\n  getSize: function (result) {\n    return result.copy(this.halfSize).multiplyScalar(2);\n  },\n\n  /**\n   * Reference: Closest Point on OBB to Point in Real-Time Collision Detection\n   * by Christer Ericson (chapter 5.1.4)\n   */\n  clampPoint: function (point, result) {\n    var halfSize = this.halfSize;\n    v1.subVectors(point, this.center);\n    this.rotation.extractBasis(xAxis, yAxis, zAxis); // start at the center position of the OBB\n\n    result.copy(this.center); // project the target onto the OBB axes and walk towards that point\n\n    var x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);\n    result.add(xAxis.multiplyScalar(x));\n    var y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);\n    result.add(yAxis.multiplyScalar(y));\n    var z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);\n    result.add(zAxis.multiplyScalar(z));\n    return result;\n  },\n  containsPoint: function (point) {\n    v1.subVectors(point, this.center);\n    this.rotation.extractBasis(xAxis, yAxis, zAxis); // project v1 onto each axis and check if these points lie inside the OBB\n\n    return Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;\n  },\n  intersectsBox3: function (box3) {\n    return this.intersectsOBB(obb.fromBox3(box3));\n  },\n  intersectsSphere: function (sphere) {\n    // find the point on the OBB closest to the sphere center\n    this.clampPoint(sphere.center, closestPoint); // if that point is inside the sphere, the OBB and sphere intersect\n\n    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n  },\n\n  /**\n   * Reference: OBB-OBB Intersection in Real-Time Collision Detection\n   * by Christer Ericson (chapter 4.4.1)\n   *\n   */\n  intersectsOBB: function (obb, epsilon = Number.EPSILON) {\n    // prepare data structures (the code uses the same nomenclature like the reference)\n    a.c = this.center;\n    a.e[0] = this.halfSize.x;\n    a.e[1] = this.halfSize.y;\n    a.e[2] = this.halfSize.z;\n    this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]);\n    b.c = obb.center;\n    b.e[0] = obb.halfSize.x;\n    b.e[1] = obb.halfSize.y;\n    b.e[2] = obb.halfSize.z;\n    obb.rotation.extractBasis(b.u[0], b.u[1], b.u[2]); // compute rotation matrix expressing b in a's coordinate frame\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        R[i][j] = a.u[i].dot(b.u[j]);\n      }\n    } // compute translation vector\n\n\n    v1.subVectors(b.c, a.c); // bring translation into a's coordinate frame\n\n    t[0] = v1.dot(a.u[0]);\n    t[1] = v1.dot(a.u[1]);\n    t[2] = v1.dot(a.u[2]); // compute common subexpressions. Add in an epsilon term to\n    // counteract arithmetic errors when two edges are parallel and\n    // their cross product is (near) null\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        AbsR[i][j] = Math.abs(R[i][j]) + epsilon;\n      }\n    }\n\n    var ra, rb; // test axes L = A0, L = A1, L = A2\n\n    for (let i = 0; i < 3; i++) {\n      ra = a.e[i];\n      rb = b.e[0] * AbsR[i][0] + b.e[1] * AbsR[i][1] + b.e[2] * AbsR[i][2];\n      if (Math.abs(t[i]) > ra + rb) return false;\n    } // test axes L = B0, L = B1, L = B2\n\n\n    for (let i = 0; i < 3; i++) {\n      ra = a.e[0] * AbsR[0][i] + a.e[1] * AbsR[1][i] + a.e[2] * AbsR[2][i];\n      rb = b.e[i];\n      if (Math.abs(t[0] * R[0][i] + t[1] * R[1][i] + t[2] * R[2][i]) > ra + rb) return false;\n    } // test axis L = A0 x B0\n\n\n    ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];\n    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];\n    if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb) return false; // test axis L = A0 x B1\n\n    ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];\n    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];\n    if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb) return false; // test axis L = A0 x B2\n\n    ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];\n    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];\n    if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb) return false; // test axis L = A1 x B0\n\n    ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];\n    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];\n    if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb) return false; // test axis L = A1 x B1\n\n    ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];\n    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];\n    if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb) return false; // test axis L = A1 x B2\n\n    ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];\n    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];\n    if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb) return false; // test axis L = A2 x B0\n\n    ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];\n    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];\n    if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb) return false; // test axis L = A2 x B1\n\n    ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];\n    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];\n    if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb) return false; // test axis L = A2 x B2\n\n    ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];\n    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];\n    if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb) return false; // since no separating axis is found, the OBBs must be intersecting\n\n    return true;\n  },\n\n  /**\n   * Reference: Testing Box Against Plane in Real-Time Collision Detection\n   * by Christer Ericson (chapter 5.2.3)\n   */\n  intersectsPlane: function (plane) {\n    this.rotation.extractBasis(xAxis, yAxis, zAxis); // compute the projection interval radius of this OBB onto L(t) = this->center + t * p.normal;\n\n    const r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis)); // compute distance of the OBB's center from the plane\n\n    const d = plane.normal.dot(this.center) - plane.constant; // Intersection occurs when distance d falls within [-r,+r] interval\n\n    return Math.abs(d) <= r;\n  },\n\n  /**\n   * Performs a ray/OBB intersection test and stores the intersection point\n   * to the given 3D vector. If no intersection is detected, *null* is returned.\n   */\n  intersectRay: function (ray, result) {\n    // the idea is to perform the intersection test in the local space\n    // of the OBB.\n    this.getSize(size);\n    aabb.setFromCenterAndSize(v1.set(0, 0, 0), size); // create a 4x4 transformation matrix\n\n    matrix4FromRotationMatrix(matrix, this.rotation);\n    matrix.setPosition(this.center); // transform ray to the local space of the OBB\n\n    inverse.copy(matrix).invert();\n    localRay.copy(ray).applyMatrix4(inverse); // perform ray <-> AABB intersection test\n\n    if (localRay.intersectBox(aabb, result)) {\n      // transform the intersection point back to world space\n      return result.applyMatrix4(matrix);\n    } else {\n      return null;\n    }\n  },\n\n  /**\n   * Performs a ray/OBB intersection test. Returns either true or false if\n   * there is a intersection or not.\n   */\n  intersectsRay: function (ray) {\n    return this.intersectRay(ray, v1) !== null;\n  },\n  fromBox3: function (box3) {\n    box3.getCenter(this.center);\n    box3.getSize(this.halfSize).multiplyScalar(0.5);\n    this.rotation.identity();\n    return this;\n  },\n  equals: function (obb) {\n    return obb.center.equals(this.center) && obb.halfSize.equals(this.halfSize) && obb.rotation.equals(this.rotation);\n  },\n  applyMatrix4: function (matrix) {\n    var e = matrix.elements;\n    var sx = v1.set(e[0], e[1], e[2]).length();\n    var sy = v1.set(e[4], e[5], e[6]).length();\n    var sz = v1.set(e[8], e[9], e[10]).length();\n    var det = matrix.determinant();\n    if (det < 0) sx = -sx;\n    rotationMatrix.setFromMatrix4(matrix);\n    var invSX = 1 / sx;\n    var invSY = 1 / sy;\n    var invSZ = 1 / sz;\n    rotationMatrix.elements[0] *= invSX;\n    rotationMatrix.elements[1] *= invSX;\n    rotationMatrix.elements[2] *= invSX;\n    rotationMatrix.elements[3] *= invSY;\n    rotationMatrix.elements[4] *= invSY;\n    rotationMatrix.elements[5] *= invSY;\n    rotationMatrix.elements[6] *= invSZ;\n    rotationMatrix.elements[7] *= invSZ;\n    rotationMatrix.elements[8] *= invSZ;\n    this.rotation.multiply(rotationMatrix);\n    this.halfSize.x *= sx;\n    this.halfSize.y *= sy;\n    this.halfSize.z *= sz;\n    v1.setFromMatrixPosition(matrix);\n    this.center.add(v1);\n    return this;\n  }\n});\n\nfunction matrix4FromRotationMatrix(matrix4, matrix3) {\n  var e = matrix4.elements;\n  var me = matrix3.elements;\n  e[0] = me[0];\n  e[1] = me[1];\n  e[2] = me[2];\n  e[3] = 0;\n  e[4] = me[3];\n  e[5] = me[4];\n  e[6] = me[5];\n  e[7] = 0;\n  e[8] = me[6];\n  e[9] = me[7];\n  e[10] = me[8];\n  e[11] = 0;\n  e[12] = 0;\n  e[13] = 0;\n  e[14] = 0;\n  e[15] = 1;\n}\n\nvar obb = new OBB();\n\nexport { OBB };\n", "import { Vector3 } from 'three';\n\nvar Capsule = function () {\n  var _v1 = new Vector3();\n\n  var _v2 = new Vector3();\n\n  var _v3 = new Vector3();\n\n  var EPS = 1e-10;\n\n  function Capsule(start, end, radius) {\n    this.start = start == undefined ? new Vector3(0, 0, 0) : start;\n    this.end = end == undefined ? new Vector3(0, 1, 0) : end;\n    this.radius = radius == undefined ? 1 : radius;\n  }\n\n  Object.assign(Capsule.prototype, {\n    clone: function () {\n      return new Capsule(this.start.clone(), this.end.clone(), this.radius);\n    },\n    set: function (start, end, radius) {\n      this.start.copy(start);\n      this.end.copy(end);\n      this.radius = radius;\n    },\n    copy: function (capsule) {\n      this.start.copy(capsule.start);\n      this.end.copy(capsule.end);\n      this.radius = capsule.radius;\n    },\n    getCenter: function (target) {\n      return target.copy(this.end).add(this.start).multiplyScalar(0.5);\n    },\n    translate: function (v) {\n      this.start.add(v);\n      this.end.add(v);\n    },\n    checkAABBAxis: function (p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius) {\n      return (minx - p1x < radius || minx - p2x < radius) && (p1x - maxx < radius || p2x - maxx < radius) && (miny - p1y < radius || miny - p2y < radius) && (p1y - maxy < radius || p2y - maxy < radius);\n    },\n    intersectsBox: function (box) {\n      return this.checkAABBAxis(this.start.x, this.start.y, this.end.x, this.end.y, box.min.x, box.max.x, box.min.y, box.max.y, this.radius) && this.checkAABBAxis(this.start.x, this.start.z, this.end.x, this.end.z, box.min.x, box.max.x, box.min.z, box.max.z, this.radius) && this.checkAABBAxis(this.start.y, this.start.z, this.end.y, this.end.z, box.min.y, box.max.y, box.min.z, box.max.z, this.radius);\n    },\n    lineLineMinimumPoints: function (line1, line2) {\n      var r = _v1.copy(line1.end).sub(line1.start);\n\n      var s = _v2.copy(line2.end).sub(line2.start);\n\n      var w = _v3.copy(line2.start).sub(line1.start);\n\n      var a = r.dot(s),\n          b = r.dot(r),\n          c = s.dot(s),\n          d = s.dot(w),\n          e = r.dot(w);\n      var t1,\n          t2,\n          divisor = b * c - a * a;\n\n      if (Math.abs(divisor) < EPS) {\n        var d1 = -d / c;\n        var d2 = (a - d) / c;\n\n        if (Math.abs(d1 - 0.5) < Math.abs(d2 - 0.5)) {\n          t1 = 0;\n          t2 = d1;\n        } else {\n          t1 = 1;\n          t2 = d2;\n        }\n      } else {\n        t1 = (d * a + e * c) / divisor;\n        t2 = (t1 * a - d) / c;\n      }\n\n      t2 = Math.max(0, Math.min(1, t2));\n      t1 = Math.max(0, Math.min(1, t1));\n      var point1 = r.multiplyScalar(t1).add(line1.start);\n      var point2 = s.multiplyScalar(t2).add(line2.start);\n      return [point1, point2];\n    }\n  });\n  return Capsule;\n}();\n\nexport { Capsule };\n", "import { MathUtils } from 'three';\n\nvar ColorConverter = {\n  setHSV: function (color, h, s, v) {\n    // https://gist.github.com/xpansive/1337890#file-index-js\n    h = MathUtils.euclideanModulo(h, 1);\n    s = MathUtils.clamp(s, 0, 1);\n    v = MathUtils.clamp(v, 0, 1);\n    return color.setHSL(h, s * v / ((h = (2 - s) * v) < 1 ? h : 2 - h), h * 0.5);\n  },\n  getHSV: function () {\n    var hsl = {};\n    return function getHSV(color, target) {\n      if (target === undefined) {\n        console.warn('THREE.ColorConverter: .getHSV() target is now required');\n        target = {\n          h: 0,\n          s: 0,\n          l: 0\n        };\n      }\n\n      color.getHSL(hsl); // based on https://gist.github.com/xpansive/1337890#file-index-js\n\n      hsl.s *= hsl.l < 0.5 ? hsl.l : 1 - hsl.l;\n      target.h = hsl.h;\n      target.s = 2 * hsl.s / (hsl.l + hsl.s);\n      target.v = hsl.l + hsl.s;\n      return target;\n    };\n  }(),\n  // where c, m, y, k is between 0 and 1\n  setCMYK: function (color, c, m, y, k) {\n    var r = (1 - c) * (1 - k);\n    var g = (1 - m) * (1 - k);\n    var b = (1 - y) * (1 - k);\n    return color.setRGB(r, g, b);\n  },\n  getCMYK: function (color, target) {\n    if (target === undefined) {\n      console.warn('THREE.ColorConverter: .getCMYK() target is now required');\n      target = {\n        c: 0,\n        m: 0,\n        y: 0,\n        k: 0\n      };\n    }\n\n    var r = color.r;\n    var g = color.g;\n    var b = color.b;\n    var k = 1 - Math.max(r, g, b);\n    var c = (1 - r - k) / (1 - k);\n    var m = (1 - g - k) / (1 - k);\n    var y = (1 - b - k) / (1 - k);\n    target.c = c;\n    target.m = m;\n    target.y = y;\n    target.k = k;\n    return target;\n  }\n};\n\nexport { ColorConverter };\n", "import { Vector3, Plane, Line3, Sphere, Box3, Triangle } from 'three';\nimport { Capsule } from './Capsule.js';\n\nvar Octree = function () {\n  var _v1 = new Vector3();\n\n  var _v2 = new Vector3();\n\n  var _plane = new Plane();\n\n  var _line1 = new Line3();\n\n  var _line2 = new Line3();\n\n  var _sphere = new Sphere();\n\n  var _capsule = new Capsule();\n\n  function Octree(box) {\n    this.triangles = [];\n    this.box = box;\n    this.subTrees = [];\n  }\n\n  Object.assign(Octree.prototype, {\n    addTriangle: function (triangle) {\n      if (!this.bounds) this.bounds = new Box3();\n      this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x);\n      this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y);\n      this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z);\n      this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x);\n      this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y);\n      this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z);\n      this.triangles.push(triangle);\n      return this;\n    },\n    calcBox: function () {\n      this.box = this.bounds.clone(); // offset small ammount to account for regular grid\n\n      this.box.min.x -= 0.01;\n      this.box.min.y -= 0.01;\n      this.box.min.z -= 0.01;\n      return this;\n    },\n    split: function (level) {\n      if (!this.box) return;\n\n      var subTrees = [],\n          halfsize = _v2.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5),\n          box,\n          v,\n          triangle;\n\n      for (let x = 0; x < 2; x++) {\n        for (let y = 0; y < 2; y++) {\n          for (let z = 0; z < 2; z++) {\n            box = new Box3();\n            v = _v1.set(x, y, z);\n            box.min.copy(this.box.min).add(v.multiply(halfsize));\n            box.max.copy(box.min).add(halfsize);\n            subTrees.push(new Octree(box));\n          }\n        }\n      }\n\n      while (triangle = this.triangles.pop()) {\n        for (let i = 0; i < subTrees.length; i++) {\n          if (subTrees[i].box.intersectsTriangle(triangle)) {\n            subTrees[i].triangles.push(triangle);\n          }\n        }\n      }\n\n      for (let i = 0; i < subTrees.length; i++) {\n        var len = subTrees[i].triangles.length;\n\n        if (len > 8 && level < 16) {\n          subTrees[i].split(level + 1);\n        }\n\n        if (len != 0) {\n          this.subTrees.push(subTrees[i]);\n        }\n      }\n\n      return this;\n    },\n    build: function () {\n      this.calcBox();\n      this.split(0);\n      return this;\n    },\n    getRayTriangles: function (ray, triangles) {\n      for (let i = 0; i < this.subTrees.length; i++) {\n        var subTree = this.subTrees[i];\n        if (!ray.intersectsBox(subTree.box)) continue;\n\n        if (subTree.triangles.length > 0) {\n          for (let j = 0; j < subTree.triangles.length; j++) {\n            if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n          }\n        } else {\n          subTree.getRayTriangles(ray, triangles);\n        }\n      }\n\n      return triangles;\n    },\n    triangleCapsuleIntersect: function (capsule, triangle) {\n      var point1, point2, line1, line2;\n      triangle.getPlane(_plane);\n      var d1 = _plane.distanceToPoint(capsule.start) - capsule.radius;\n      var d2 = _plane.distanceToPoint(capsule.end) - capsule.radius;\n\n      if (d1 > 0 && d2 > 0 || d1 < -capsule.radius && d2 < -capsule.radius) {\n        return false;\n      }\n\n      var delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)));\n\n      var intersectPoint = _v1.copy(capsule.start).lerp(capsule.end, delta);\n\n      if (triangle.containsPoint(intersectPoint)) {\n        return {\n          normal: _plane.normal.clone(),\n          point: intersectPoint.clone(),\n          depth: Math.abs(Math.min(d1, d2))\n        };\n      }\n\n      var r2 = capsule.radius * capsule.radius;\n      line1 = _line1.set(capsule.start, capsule.end);\n      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\n\n      for (let i = 0; i < lines.length; i++) {\n        line2 = _line2.set(lines[i][0], lines[i][1]);\n        [point1, point2] = capsule.lineLineMinimumPoints(line1, line2);\n\n        if (point1.distanceToSquared(point2) < r2) {\n          return {\n            normal: point1.clone().sub(point2).normalize(),\n            point: point2.clone(),\n            depth: capsule.radius - point1.distanceTo(point2)\n          };\n        }\n      }\n\n      return false;\n    },\n    triangleSphereIntersect: function (sphere, triangle) {\n      triangle.getPlane(_plane);\n      if (!sphere.intersectsPlane(_plane)) return false;\n      var depth = Math.abs(_plane.distanceToSphere(sphere));\n      var r2 = sphere.radius * sphere.radius - depth * depth;\n\n      var plainPoint = _plane.projectPoint(sphere.center, _v1);\n\n      if (triangle.containsPoint(sphere.center)) {\n        return {\n          normal: _plane.normal.clone(),\n          point: plainPoint.clone(),\n          depth: Math.abs(_plane.distanceToSphere(sphere))\n        };\n      }\n\n      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\n\n      for (let i = 0; i < lines.length; i++) {\n        _line1.set(lines[i][0], lines[i][1]);\n\n        _line1.closestPointToPoint(plainPoint, true, _v2);\n\n        var d = _v2.distanceToSquared(sphere.center);\n\n        if (d < r2) {\n          return {\n            normal: sphere.center.clone().sub(_v2).normalize(),\n            point: _v2.clone(),\n            depth: sphere.radius - Math.sqrt(d)\n          };\n        }\n      }\n\n      return false;\n    },\n    getSphereTriangles: function (sphere, triangles) {\n      for (let i = 0; i < this.subTrees.length; i++) {\n        var subTree = this.subTrees[i];\n        if (!sphere.intersectsBox(subTree.box)) continue;\n\n        if (subTree.triangles.length > 0) {\n          for (let j = 0; j < subTree.triangles.length; j++) {\n            if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n          }\n        } else {\n          subTree.getSphereTriangles(sphere, triangles);\n        }\n      }\n    },\n    getCapsuleTriangles: function (capsule, triangles) {\n      for (let i = 0; i < this.subTrees.length; i++) {\n        var subTree = this.subTrees[i];\n        if (!capsule.intersectsBox(subTree.box)) continue;\n\n        if (subTree.triangles.length > 0) {\n          for (let j = 0; j < subTree.triangles.length; j++) {\n            if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n          }\n        } else {\n          subTree.getCapsuleTriangles(capsule, triangles);\n        }\n      }\n    },\n\n    sphereIntersect(sphere) {\n      _sphere.copy(sphere);\n\n      var triangles = [],\n          result,\n          hit = false;\n      this.getSphereTriangles(sphere, triangles);\n\n      for (let i = 0; i < triangles.length; i++) {\n        if (result = this.triangleSphereIntersect(_sphere, triangles[i])) {\n          hit = true;\n\n          _sphere.center.add(result.normal.multiplyScalar(result.depth));\n        }\n      }\n\n      if (hit) {\n        var collisionVector = _sphere.center.clone().sub(sphere.center);\n\n        var depth = collisionVector.length();\n        return {\n          normal: collisionVector.normalize(),\n          depth: depth\n        };\n      }\n\n      return false;\n    },\n\n    capsuleIntersect: function (capsule) {\n      _capsule.copy(capsule);\n\n      var triangles = [],\n          result,\n          hit = false;\n      this.getCapsuleTriangles(_capsule, triangles);\n\n      for (let i = 0; i < triangles.length; i++) {\n        if (result = this.triangleCapsuleIntersect(_capsule, triangles[i])) {\n          hit = true;\n\n          _capsule.translate(result.normal.multiplyScalar(result.depth));\n        }\n      }\n\n      if (hit) {\n        var collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v1));\n\n        var depth = collisionVector.length();\n        return {\n          normal: collisionVector.normalize(),\n          depth: depth\n        };\n      }\n\n      return false;\n    },\n    rayIntersect: function (ray) {\n      if (ray.direction.length() === 0) return;\n      var triangles = [],\n          triangle,\n          position,\n          distance = 1e100,\n          result;\n      this.getRayTriangles(ray, triangles);\n\n      for (let i = 0; i < triangles.length; i++) {\n        result = ray.intersectTriangle(triangles[i].a, triangles[i].b, triangles[i].c, true, _v1);\n\n        if (result) {\n          var newdistance = result.sub(ray.origin).length();\n\n          if (distance > newdistance) {\n            position = result.clone().add(ray.origin);\n            distance = newdistance;\n            triangle = triangles[i];\n          }\n        }\n      }\n\n      return distance < 1e100 ? {\n        distance: distance,\n        triangle: triangle,\n        position: position\n      } : false;\n    },\n    fromGraphNode: function (group) {\n      group.traverse(obj => {\n        if (obj.type === 'Mesh') {\n          obj.updateMatrix();\n          obj.updateWorldMatrix();\n          var geometry,\n              isTemp = false;\n\n          if (obj.geometry.index) {\n            isTemp = true;\n            geometry = obj.geometry.clone().toNonIndexed();\n          } else {\n            geometry = obj.geometry;\n          }\n\n          var positions = geometry.attributes.position.array;\n          var transform = obj.matrixWorld;\n\n          for (let i = 0; i < positions.length; i += 9) {\n            var v1 = new Vector3(positions[i], positions[i + 1], positions[i + 2]);\n            var v2 = new Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);\n            var v3 = new Vector3(positions[i + 6], positions[i + 7], positions[i + 8]);\n            v1.applyMatrix4(transform);\n            v2.applyMatrix4(transform);\n            v3.applyMatrix4(transform);\n            this.addTriangle(new Triangle(v1, v2, v3));\n          }\n\n          if (isTemp) {\n            geometry.dispose();\n          }\n        }\n      });\n      this.build();\n      return this;\n    }\n  });\n  return Octree;\n}();\n\nexport { Octree };\n", "import { Color } from 'three';\n\nvar Lut = function (colormap, numberofcolors) {\n  this.lut = [];\n  this.setColorMap(colormap, numberofcolors);\n  return this;\n};\n\nLut.prototype = {\n  constructor: Lut,\n  lut: [],\n  map: [],\n  n: 256,\n  minV: 0,\n  maxV: 1,\n  set: function (value) {\n    if (value instanceof Lut) {\n      this.copy(value);\n    }\n\n    return this;\n  },\n  setMin: function (min) {\n    this.minV = min;\n    return this;\n  },\n  setMax: function (max) {\n    this.maxV = max;\n    return this;\n  },\n  setColorMap: function (colormap, numberofcolors) {\n    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;\n    this.n = numberofcolors || 32;\n    var step = 1.0 / this.n;\n    this.lut.length = 0;\n\n    for (let i = 0; i <= 1; i += step) {\n      for (let j = 0; j < this.map.length - 1; j++) {\n        if (i >= this.map[j][0] && i < this.map[j + 1][0]) {\n          var min = this.map[j][0];\n          var max = this.map[j + 1][0];\n          var minColor = new Color(this.map[j][1]);\n          var maxColor = new Color(this.map[j + 1][1]);\n          var color = minColor.lerp(maxColor, (i - min) / (max - min));\n          this.lut.push(color);\n        }\n      }\n    }\n\n    return this;\n  },\n  copy: function (lut) {\n    this.lut = lut.lut;\n    this.map = lut.map;\n    this.n = lut.n;\n    this.minV = lut.minV;\n    this.maxV = lut.maxV;\n    return this;\n  },\n  getColor: function (alpha) {\n    if (alpha <= this.minV) {\n      alpha = this.minV;\n    } else if (alpha >= this.maxV) {\n      alpha = this.maxV;\n    }\n\n    alpha = (alpha - this.minV) / (this.maxV - this.minV);\n    var colorPosition = Math.round(alpha * this.n);\n    colorPosition == this.n ? colorPosition -= 1 : colorPosition;\n    return this.lut[colorPosition];\n  },\n  addColorMap: function (colormapName, arrayOfColors) {\n    ColorMapKeywords[colormapName] = arrayOfColors;\n  },\n  createCanvas: function () {\n    var canvas = document.createElement('canvas');\n    canvas.width = 1;\n    canvas.height = this.n;\n    this.updateCanvas(canvas);\n    return canvas;\n  },\n  updateCanvas: function (canvas) {\n    var ctx = canvas.getContext('2d', {\n      alpha: false\n    });\n    var imageData = ctx.getImageData(0, 0, 1, this.n);\n    var data = imageData.data;\n    var k = 0;\n    var step = 1.0 / this.n;\n\n    for (let i = 1; i >= 0; i -= step) {\n      for (let j = this.map.length - 1; j >= 0; j--) {\n        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n          var min = this.map[j - 1][0];\n          var max = this.map[j][0];\n          var minColor = new Color(this.map[j - 1][1]);\n          var maxColor = new Color(this.map[j][1]);\n          var color = minColor.lerp(maxColor, (i - min) / (max - min));\n          data[k * 4] = Math.round(color.r * 255);\n          data[k * 4 + 1] = Math.round(color.g * 255);\n          data[k * 4 + 2] = Math.round(color.b * 255);\n          data[k * 4 + 3] = 255;\n          k += 1;\n        }\n      }\n    }\n\n    ctx.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n};\nvar ColorMapKeywords = {\n  rainbow: [[0.0, 0x0000ff], [0.2, 0x00ffff], [0.5, 0x00ff00], [0.8, 0xffff00], [1.0, 0xff0000]],\n  cooltowarm: [[0.0, 0x3c4ec2], [0.2, 0x9bbcff], [0.5, 0xdcdcdc], [0.8, 0xf6a385], [1.0, 0xb40426]],\n  blackbody: [[0.0, 0x000000], [0.2, 0x780000], [0.5, 0xe63200], [0.8, 0xffff00], [1.0, 0xffffff]],\n  grayscale: [[0.0, 0x000000], [0.2, 0x404040], [0.5, 0x7f7f80], [0.8, 0xbfbfbf], [1.0, 0xffffff]]\n};\n\nexport { ColorMapKeywords, Lut };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { EventDispatcher, Vector3, TOUCH, Spherical, Vector2, Quaternion, PerspectiveCamera, OrthographicCamera, MOUSE } from 'three';\n\nlet STATE;\n\n(function (STATE) {\n  STATE[STATE[\"NONE\"] = -1] = \"NONE\";\n  STATE[STATE[\"ROTATE\"] = 0] = \"ROTATE\";\n  STATE[STATE[\"DOLLY\"] = 1] = \"DOLLY\";\n  STATE[STATE[\"PAN\"] = 2] = \"PAN\";\n  STATE[STATE[\"TOUCH_ROTATE\"] = 3] = \"TOUCH_ROTATE\";\n  STATE[STATE[\"TOUCH_PAN\"] = 4] = \"TOUCH_PAN\";\n  STATE[STATE[\"TOUCH_DOLLY_PAN\"] = 5] = \"TOUCH_DOLLY_PAN\";\n  STATE[STATE[\"TOUCH_DOLLY_ROTATE\"] = 6] = \"TOUCH_DOLLY_ROTATE\";\n})(STATE || (STATE = {}));\n\nclass CameraControls extends EventDispatcher {\n  /** Set to false to disable this control */\n\n  /** \"target\" sets the location of focus, where the object orbits around */\n\n  /** Set to true to enable trackball behavior */\n\n  /** How far you can dolly in ( PerspectiveCamera only ) */\n\n  /** How far you can dolly out ( PerspectiveCamera only ) */\n  // How far you can zoom in and out ( OrthographicCamera only )\n  // How far you can orbit vertically, upper and lower limits.\n  // Range is 0 to Math.PI radians.\n  // How far you can orbit horizontally, upper and lower limits.\n  // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n  // radians\n  // radians\n  // Set to true to enable damping (inertia)\n  // If damping is enabled, you must call controls.update() in your animation loop\n\n  /**\n   * This option enables dollying in and out; property named as \"zoom\" for backwards compatibility\n   * Set to false to disable zooming\n   */\n\n  /** Set to false to disable rotating */\n\n  /** Set to false to disable panning */\n\n  /** if true, pan in screen-space */\n\n  /** pixels moved per arrow key push */\n\n  /**\n   * Set to true to automatically rotate around the target\n   * If auto-rotate is enabled, you must call controls.update() in your animation loop\n   * auto-rotate is not supported for trackball behavior\n   */\n  // 30 seconds per round when fps is 60\n\n  /** Set to false to disable use of the keys */\n\n  /** The four arrow keys */\n\n  /** Touch fingers */\n  // for reset\n  // current position in spherical coordinates\n  constructor(object, domElement) {\n    super();\n\n    _defineProperty(this, \"object\", void 0);\n\n    _defineProperty(this, \"domElement\", void 0);\n\n    _defineProperty(this, \"enabled\", true);\n\n    _defineProperty(this, \"target\", new Vector3());\n\n    _defineProperty(this, \"trackball\", false);\n\n    _defineProperty(this, \"minDistance\", 0);\n\n    _defineProperty(this, \"maxDistance\", Infinity);\n\n    _defineProperty(this, \"minZoom\", 0);\n\n    _defineProperty(this, \"maxZoom\", Infinity);\n\n    _defineProperty(this, \"minPolarAngle\", 0);\n\n    _defineProperty(this, \"maxPolarAngle\", Math.PI);\n\n    _defineProperty(this, \"minAzimuthAngle\", -Infinity);\n\n    _defineProperty(this, \"maxAzimuthAngle\", Infinity);\n\n    _defineProperty(this, \"enableDamping\", false);\n\n    _defineProperty(this, \"dampingFactor\", 0.05);\n\n    _defineProperty(this, \"enableZoom\", true);\n\n    _defineProperty(this, \"zoomSpeed\", 1.0);\n\n    _defineProperty(this, \"enableRotate\", true);\n\n    _defineProperty(this, \"rotateSpeed\", 1.0);\n\n    _defineProperty(this, \"enablePan\", true);\n\n    _defineProperty(this, \"panSpeed\", 1.0);\n\n    _defineProperty(this, \"screenSpacePanning\", false);\n\n    _defineProperty(this, \"keyPanSpeed\", 7.0);\n\n    _defineProperty(this, \"autoRotate\", false);\n\n    _defineProperty(this, \"autoRotateSpeed\", 2.0);\n\n    _defineProperty(this, \"enableKeys\", true);\n\n    _defineProperty(this, \"keys\", {\n      LEFT: 'ArrowLeft',\n      UP: 'ArrowUp',\n      RIGHT: 'ArrowRight',\n      BOTTOM: 'ArrowDown'\n    });\n\n    _defineProperty(this, \"mouseButtons\", void 0);\n\n    _defineProperty(this, \"touches\", {\n      ONE: TOUCH.ROTATE,\n      TWO: TOUCH.DOLLY_PAN\n    });\n\n    _defineProperty(this, \"target0\", void 0);\n\n    _defineProperty(this, \"position0\", void 0);\n\n    _defineProperty(this, \"quaternion0\", void 0);\n\n    _defineProperty(this, \"zoom0\", void 0);\n\n    _defineProperty(this, \"spherical\", new Spherical());\n\n    _defineProperty(this, \"sphericalDelta\", new Spherical());\n\n    _defineProperty(this, \"changeEvent\", {\n      type: 'change'\n    });\n\n    _defineProperty(this, \"startEvent\", {\n      type: 'start'\n    });\n\n    _defineProperty(this, \"endEvent\", {\n      type: 'end'\n    });\n\n    _defineProperty(this, \"state\", STATE.NONE);\n\n    _defineProperty(this, \"EPS\", 0.000001);\n\n    _defineProperty(this, \"scale\", 1);\n\n    _defineProperty(this, \"panOffset\", new Vector3());\n\n    _defineProperty(this, \"zoomChanged\", false);\n\n    _defineProperty(this, \"rotateStart\", new Vector2());\n\n    _defineProperty(this, \"rotateEnd\", new Vector2());\n\n    _defineProperty(this, \"rotateDelta\", new Vector2());\n\n    _defineProperty(this, \"panStart\", new Vector2());\n\n    _defineProperty(this, \"panEnd\", new Vector2());\n\n    _defineProperty(this, \"panDelta\", new Vector2());\n\n    _defineProperty(this, \"dollyStart\", new Vector2());\n\n    _defineProperty(this, \"dollyEnd\", new Vector2());\n\n    _defineProperty(this, \"dollyDelta\", new Vector2());\n\n    _defineProperty(this, \"offset\", new Vector3());\n\n    _defineProperty(this, \"lastPosition\", new Vector3());\n\n    _defineProperty(this, \"lastQuaternion\", new Quaternion());\n\n    _defineProperty(this, \"q\", new Quaternion());\n\n    _defineProperty(this, \"v\", new Vector3());\n\n    _defineProperty(this, \"vec\", new Vector3());\n\n    _defineProperty(this, \"quat\", void 0);\n\n    _defineProperty(this, \"quatInverse\", void 0);\n\n    _defineProperty(this, \"getPolarAngle\", () => this.spherical.phi);\n\n    _defineProperty(this, \"getAzimuthalAngle\", () => this.spherical.theta);\n\n    _defineProperty(this, \"saveState\", () => {\n      this.target0.copy(this.target);\n      this.position0.copy(this.object.position);\n      this.quaternion0.copy(this.object.quaternion);\n      this.zoom0 = this.object.zoom;\n    });\n\n    _defineProperty(this, \"reset\", () => {\n      this.target.copy(this.target0);\n      this.object.position.copy(this.position0);\n      this.object.quaternion.copy(this.quaternion0);\n      this.object.zoom = this.zoom0;\n      this.object.updateProjectionMatrix();\n      this.dispatchEvent(this.changeEvent);\n      this.update();\n      this.state = STATE.NONE;\n    });\n\n    _defineProperty(this, \"dispose\", () => {\n      this.domElement.removeEventListener('contextmenu', this.onContextMenu, false);\n      this.domElement.removeEventListener('mousedown', this.onMouseDown, false);\n      this.domElement.removeEventListener('wheel', this.onMouseWheel, false);\n      this.domElement.removeEventListener('touchstart', this.onTouchStart, false);\n      this.domElement.removeEventListener('touchend', this.onTouchEnd, false);\n      this.domElement.removeEventListener('touchmove', this.onTouchMove, false);\n      document.removeEventListener('mousemove', this.onMouseMove, false);\n      document.removeEventListener('mouseup', this.onMouseUp, false);\n      this.domElement.removeEventListener('keydown', this.onKeyDown, false); //this.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n    });\n\n    _defineProperty(this, \"update\", () => {\n      const position = this.object.position;\n      this.offset.copy(position).sub(this.target);\n\n      if (this.trackball) {\n        // rotate around screen-space y-axis\n        if (this.sphericalDelta.theta) {\n          this.vec.set(0, 1, 0).applyQuaternion(this.object.quaternion);\n          const factor = this.enableDamping ? this.dampingFactor : 1;\n          this.q.setFromAxisAngle(this.vec, this.sphericalDelta.theta * factor);\n          this.object.quaternion.premultiply(this.q);\n          this.offset.applyQuaternion(this.q);\n        } // rotate around screen-space x-axis\n\n\n        if (this.sphericalDelta.phi) {\n          this.vec.set(1, 0, 0).applyQuaternion(this.object.quaternion);\n          const factor = this.enableDamping ? this.dampingFactor : 1;\n          this.q.setFromAxisAngle(this.vec, this.sphericalDelta.phi * factor);\n          this.object.quaternion.premultiply(this.q);\n          this.offset.applyQuaternion(this.q);\n        }\n\n        this.offset.multiplyScalar(this.scale);\n        this.offset.clampLength(this.minDistance, this.maxDistance);\n      } else {\n        // rotate offset to \"y-axis-is-up\" space\n        this.offset.applyQuaternion(this.quat);\n\n        if (this.autoRotate && this.state === STATE.NONE) {\n          this.rotateLeft(this.getAutoRotationAngle());\n        }\n\n        this.spherical.setFromVector3(this.offset);\n\n        if (this.enableDamping) {\n          this.spherical.theta += this.sphericalDelta.theta * this.dampingFactor;\n          this.spherical.phi += this.sphericalDelta.phi * this.dampingFactor;\n        } else {\n          this.spherical.theta += this.sphericalDelta.theta;\n          this.spherical.phi += this.sphericalDelta.phi;\n        } // restrict theta to be between desired limits\n\n\n        this.spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, this.spherical.theta)); // restrict phi to be between desired limits\n\n        this.spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this.spherical.phi));\n        this.spherical.makeSafe();\n        this.spherical.radius *= this.scale; // restrict radius to be between desired limits\n\n        this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));\n        this.offset.setFromSpherical(this.spherical); // rotate offset back to \"camera-up-vector-is-up\" space\n\n        this.offset.applyQuaternion(this.quatInverse);\n      } // move target to panned location\n\n\n      if (this.enableDamping === true) {\n        this.target.addScaledVector(this.panOffset, this.dampingFactor);\n      } else {\n        this.target.add(this.panOffset);\n      }\n\n      position.copy(this.target).add(this.offset);\n\n      if (this.trackball === false) {\n        this.object.lookAt(this.target);\n      }\n\n      if (this.enableDamping === true) {\n        this.sphericalDelta.theta *= 1 - this.dampingFactor;\n        this.sphericalDelta.phi *= 1 - this.dampingFactor;\n        this.panOffset.multiplyScalar(1 - this.dampingFactor);\n      } else {\n        this.sphericalDelta.set(0, 0, 0);\n        this.panOffset.set(0, 0, 0);\n      }\n\n      this.scale = 1; // update condition is:\n      // min(camera displacement, camera rotation in radians)^2 > EPS\n      // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n      if (this.zoomChanged || this.lastPosition.distanceToSquared(this.object.position) > this.EPS || 8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > this.EPS) {\n        this.dispatchEvent(this.changeEvent);\n        this.lastPosition.copy(this.object.position);\n        this.lastQuaternion.copy(this.object.quaternion);\n        this.zoomChanged = false;\n        return true;\n      }\n\n      return false;\n    });\n\n    _defineProperty(this, \"getAutoRotationAngle\", () => 2 * Math.PI / 60 / 60 * this.autoRotateSpeed);\n\n    _defineProperty(this, \"getZoomScale\", () => Math.pow(0.95, this.zoomSpeed));\n\n    _defineProperty(this, \"rotateLeft\", angle => {\n      this.sphericalDelta.theta -= angle;\n    });\n\n    _defineProperty(this, \"rotateUp\", angle => {\n      this.sphericalDelta.phi -= angle;\n    });\n\n    _defineProperty(this, \"panLeft\", (distance, objectMatrix) => {\n      this.v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n\n      this.v.multiplyScalar(-distance);\n      this.panOffset.add(this.v);\n    });\n\n    _defineProperty(this, \"panUp\", (distance, objectMatrix) => {\n      if (this.screenSpacePanning === true) {\n        this.v.setFromMatrixColumn(objectMatrix, 1);\n      } else {\n        this.v.setFromMatrixColumn(objectMatrix, 0);\n        this.v.crossVectors(this.object.up, this.v);\n      }\n\n      this.v.multiplyScalar(distance);\n      this.panOffset.add(this.v);\n    });\n\n    _defineProperty(this, \"pan\", (deltaX, deltaY) => {\n      const element = this.domElement;\n\n      if (this.object instanceof PerspectiveCamera) {\n        // perspective\n        const position = this.object.position;\n        this.offset.copy(position).sub(this.target);\n        let targetDistance = this.offset.length(); // half of the fov is center to top of screen\n\n        targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180.0); // we use only clientHeight here so aspect ratio does not distort speed\n\n        this.panLeft(2 * deltaX * targetDistance / element.clientHeight, this.object.matrix);\n        this.panUp(2 * deltaY * targetDistance / element.clientHeight, this.object.matrix);\n      } else if (this.object.isOrthographicCamera) {\n        // orthographic\n        this.panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element.clientWidth, this.object.matrix);\n        this.panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element.clientHeight, this.object.matrix);\n      } else {\n        // camera neither orthographic nor perspective\n        console.warn('WARNING: CameraControls.js encountered an unknown camera type - pan disabled.');\n        this.enablePan = false;\n      }\n    });\n\n    _defineProperty(this, \"dollyIn\", dollyScale => {\n      // TODO: replace w/.isPerspectiveCamera ?\n      if (this.object instanceof PerspectiveCamera) {\n        this.scale /= dollyScale; // TODO: replace w/.isOrthographicCamera ?\n      } else if (this.object instanceof OrthographicCamera) {\n        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));\n        this.object.updateProjectionMatrix();\n        this.zoomChanged = true;\n      } else {\n        console.warn('WARNING: CameraControls.js encountered an unknown camera type - dolly/zoom disabled.');\n        this.enableZoom = false;\n      }\n    });\n\n    _defineProperty(this, \"dollyOut\", dollyScale => {\n      // TODO: replace w/.isPerspectiveCamera ?\n      if (this.object instanceof PerspectiveCamera) {\n        this.scale *= dollyScale; // TODO: replace w/.isOrthographicCamera ?\n      } else if (this.object instanceof OrthographicCamera) {\n        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));\n        this.object.updateProjectionMatrix();\n        this.zoomChanged = true;\n      } else {\n        console.warn('WARNING: CameraControls.js encountered an unknown camera type - dolly/zoom disabled.');\n        this.enableZoom = false;\n      }\n    });\n\n    _defineProperty(this, \"handleMouseDownRotate\", event => {\n      this.rotateStart.set(event.clientX, event.clientY);\n    });\n\n    _defineProperty(this, \"handleMouseDownDolly\", event => {\n      this.dollyStart.set(event.clientX, event.clientY);\n    });\n\n    _defineProperty(this, \"handleMouseDownPan\", event => {\n      this.panStart.set(event.clientX, event.clientY);\n    });\n\n    _defineProperty(this, \"handleMouseMoveRotate\", event => {\n      this.rotateEnd.set(event.clientX, event.clientY);\n      this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);\n      const element = this.domElement;\n      this.rotateLeft(2 * Math.PI * this.rotateDelta.x / element.clientHeight); // yes, height\n\n      this.rotateUp(2 * Math.PI * this.rotateDelta.y / element.clientHeight);\n      this.rotateStart.copy(this.rotateEnd);\n      this.update();\n    });\n\n    _defineProperty(this, \"handleMouseMoveDolly\", event => {\n      this.dollyEnd.set(event.clientX, event.clientY);\n      this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart);\n\n      if (this.dollyDelta.y > 0) {\n        this.dollyIn(this.getZoomScale());\n      } else if (this.dollyDelta.y < 0) {\n        this.dollyOut(this.getZoomScale());\n      }\n\n      this.dollyStart.copy(this.dollyEnd);\n      this.update();\n    });\n\n    _defineProperty(this, \"handleMouseMovePan\", event => {\n      this.panEnd.set(event.clientX, event.clientY);\n      this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed);\n      this.pan(this.panDelta.x, this.panDelta.y);\n      this.panStart.copy(this.panEnd);\n      this.update();\n    });\n\n    _defineProperty(this, \"handleMouseWheel\", event => {\n      if (event.deltaY < 0) {\n        this.dollyOut(this.getZoomScale());\n      } else if (event.deltaY > 0) {\n        this.dollyIn(this.getZoomScale());\n      }\n\n      this.update();\n    });\n\n    _defineProperty(this, \"handleKeyDown\", event => {\n      let needsUpdate = false;\n\n      switch (event.code) {\n        case this.keys.UP:\n          this.pan(0, this.keyPanSpeed);\n          needsUpdate = true;\n          break;\n\n        case this.keys.BOTTOM:\n          this.pan(0, -this.keyPanSpeed);\n          needsUpdate = true;\n          break;\n\n        case this.keys.LEFT:\n          this.pan(this.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n\n        case this.keys.RIGHT:\n          this.pan(-this.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n      }\n\n      if (needsUpdate) {\n        // prevent the browser from scrolling on cursor keys\n        event.preventDefault();\n        this.update();\n      }\n    });\n\n    _defineProperty(this, \"handleTouchStartRotate\", event => {\n      if (event.touches.length == 1) {\n        this.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n      } else {\n        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n        this.rotateStart.set(x, y);\n      }\n    });\n\n    _defineProperty(this, \"handleTouchStartPan\", event => {\n      if (event.touches.length == 1) {\n        this.panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n      } else {\n        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n        this.panStart.set(x, y);\n      }\n    });\n\n    _defineProperty(this, \"handleTouchStartDolly\", event => {\n      const dx = event.touches[0].pageX - event.touches[1].pageX;\n      const dy = event.touches[0].pageY - event.touches[1].pageY;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      this.dollyStart.set(0, distance);\n    });\n\n    _defineProperty(this, \"handleTouchStartDollyPan\", event => {\n      if (this.enableZoom) this.handleTouchStartDolly(event);\n      if (this.enablePan) this.handleTouchStartPan(event);\n    });\n\n    _defineProperty(this, \"handleTouchStartDollyRotate\", event => {\n      if (this.enableZoom) this.handleTouchStartDolly(event);\n      if (this.enableRotate) this.handleTouchStartRotate(event);\n    });\n\n    _defineProperty(this, \"handleTouchMoveRotate\", event => {\n      if (event.touches.length == 1) {\n        this.rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n      } else {\n        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n        this.rotateEnd.set(x, y);\n      }\n\n      this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);\n      const element = this.domElement;\n      this.rotateLeft(2 * Math.PI * this.rotateDelta.x / element.clientHeight); // yes, height\n\n      this.rotateUp(2 * Math.PI * this.rotateDelta.y / element.clientHeight);\n      this.rotateStart.copy(this.rotateEnd);\n    });\n\n    _defineProperty(this, \"handleTouchMovePan\", event => {\n      if (event.touches.length == 1) {\n        this.panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n      } else {\n        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n        this.panEnd.set(x, y);\n      }\n\n      this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed);\n      this.pan(this.panDelta.x, this.panDelta.y);\n      this.panStart.copy(this.panEnd);\n    });\n\n    _defineProperty(this, \"handleTouchMoveDolly\", event => {\n      const dx = event.touches[0].pageX - event.touches[1].pageX;\n      const dy = event.touches[0].pageY - event.touches[1].pageY;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      this.dollyEnd.set(0, distance);\n      this.dollyDelta.set(0, Math.pow(this.dollyEnd.y / this.dollyStart.y, this.zoomSpeed));\n      this.dollyIn(this.dollyDelta.y);\n      this.dollyStart.copy(this.dollyEnd);\n    });\n\n    _defineProperty(this, \"handleTouchMoveDollyPan\", event => {\n      if (this.enableZoom) this.handleTouchMoveDolly(event);\n      if (this.enablePan) this.handleTouchMovePan(event);\n    });\n\n    _defineProperty(this, \"handleTouchMoveDollyRotate\", event => {\n      if (this.enableZoom) this.handleTouchMoveDolly(event);\n      if (this.enableRotate) this.handleTouchMoveRotate(event);\n    });\n\n    _defineProperty(this, \"onMouseDown\", event => {\n      if (this.enabled === false) return; // Prevent the browser from scrolling.\n\n      event.preventDefault(); // Manually set the focus since calling preventDefault above\n      // prevents the browser from setting it automatically.\n\n      this.domElement.focus ? this.domElement.focus() : window.focus();\n      let mouseAction;\n\n      switch (event.button) {\n        case 0:\n          mouseAction = this.mouseButtons.LEFT;\n          break;\n\n        case 1:\n          mouseAction = this.mouseButtons.MIDDLE;\n          break;\n\n        case 2:\n          mouseAction = this.mouseButtons.RIGHT;\n          break;\n\n        default:\n          mouseAction = -1;\n      }\n\n      switch (mouseAction) {\n        case MOUSE.DOLLY:\n          if (this.enableZoom === false) return;\n          this.handleMouseDownDolly(event);\n          this.state = STATE.DOLLY;\n          break;\n\n        case MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (this.enablePan === false) return;\n            this.handleMouseDownPan(event);\n            this.state = STATE.PAN;\n          } else {\n            if (this.enableRotate === false) return;\n            this.handleMouseDownRotate(event);\n            this.state = STATE.ROTATE;\n          }\n\n          break;\n\n        case MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (this.enableRotate === false) return;\n            this.handleMouseDownRotate(event);\n            this.state = STATE.ROTATE;\n          } else {\n            if (this.enablePan === false) return;\n            this.handleMouseDownPan(event);\n            this.state = STATE.PAN;\n          }\n\n          break;\n\n        default:\n          this.state = STATE.NONE;\n      }\n\n      if (this.state !== STATE.NONE) {\n        document.addEventListener('mousemove', this.onMouseMove, false);\n        document.addEventListener('mouseup', this.onMouseUp, false);\n        this.dispatchEvent(this.startEvent);\n      }\n    });\n\n    _defineProperty(this, \"onMouseMove\", event => {\n      if (this.enabled === false) return;\n      event.preventDefault();\n\n      switch (this.state) {\n        case STATE.ROTATE:\n          if (this.enableRotate === false) return;\n          this.handleMouseMoveRotate(event);\n          break;\n\n        case STATE.DOLLY:\n          if (this.enableZoom === false) return;\n          this.handleMouseMoveDolly(event);\n          break;\n\n        case STATE.PAN:\n          if (this.enablePan === false) return;\n          this.handleMouseMovePan(event);\n          break;\n      }\n    });\n\n    _defineProperty(this, \"onMouseUp\", () => {\n      if (this.enabled === false) return; // this.handleMouseUp()\n\n      document.removeEventListener('mousemove', this.onMouseMove, false);\n      document.removeEventListener('mouseup', this.onMouseUp, false);\n      this.dispatchEvent(this.endEvent);\n      this.state = STATE.NONE;\n    });\n\n    _defineProperty(this, \"onMouseWheel\", event => {\n      if (this.enabled === false || this.enableZoom === false || this.state !== STATE.NONE && this.state !== STATE.ROTATE) {\n        return;\n      }\n\n      event.preventDefault();\n      this.dispatchEvent(this.startEvent);\n      this.handleMouseWheel(event);\n      this.dispatchEvent(this.endEvent);\n    });\n\n    _defineProperty(this, \"onKeyDown\", event => {\n      if (this.enabled === false || this.enableKeys === false || this.enablePan === false) return;\n      this.handleKeyDown(event);\n    });\n\n    _defineProperty(this, \"onTouchStart\", event => {\n      if (this.enabled === false) return;\n      event.preventDefault();\n\n      switch (event.touches.length) {\n        case 1:\n          switch (this.touches.ONE) {\n            case TOUCH.ROTATE:\n              if (this.enableRotate === false) return;\n              this.handleTouchStartRotate(event);\n              this.state = STATE.TOUCH_ROTATE;\n              break;\n\n            case TOUCH.PAN:\n              if (this.enablePan === false) return;\n              this.handleTouchStartPan(event);\n              this.state = STATE.TOUCH_PAN;\n              break;\n\n            default:\n              this.state = STATE.NONE;\n          }\n\n          break;\n\n        case 2:\n          switch (this.touches.TWO) {\n            case TOUCH.DOLLY_PAN:\n              if (this.enableZoom === false && this.enablePan === false) return;\n              this.handleTouchStartDollyPan(event);\n              this.state = STATE.TOUCH_DOLLY_PAN;\n              break;\n\n            case TOUCH.DOLLY_ROTATE:\n              if (this.enableZoom === false && this.enableRotate === false) return;\n              this.handleTouchStartDollyRotate(event);\n              this.state = STATE.TOUCH_DOLLY_ROTATE;\n              break;\n\n            default:\n              this.state = STATE.NONE;\n          }\n\n          break;\n\n        default:\n          this.state = STATE.NONE;\n      }\n\n      if (this.state !== STATE.NONE) {\n        this.dispatchEvent(this.startEvent);\n      }\n    });\n\n    _defineProperty(this, \"onTouchMove\", event => {\n      if (this.enabled === false) return;\n      event.preventDefault();\n\n      switch (this.state) {\n        case STATE.TOUCH_ROTATE:\n          if (this.enableRotate === false) return;\n          this.handleTouchMoveRotate(event);\n          this.update();\n          break;\n\n        case STATE.TOUCH_PAN:\n          if (this.enablePan === false) return;\n          this.handleTouchMovePan(event);\n          this.update();\n          break;\n\n        case STATE.TOUCH_DOLLY_PAN:\n          if (this.enableZoom === false && this.enablePan === false) return;\n          this.handleTouchMoveDollyPan(event);\n          this.update();\n          break;\n\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (this.enableZoom === false && this.enableRotate === false) return;\n          this.handleTouchMoveDollyRotate(event);\n          this.update();\n          break;\n\n        default:\n          this.state = STATE.NONE;\n      }\n    });\n\n    _defineProperty(this, \"onTouchEnd\", () => {\n      if (this.enabled === false) return; // this.handleTouchEnd()\n\n      this.dispatchEvent(this.endEvent);\n      this.state = STATE.NONE;\n    });\n\n    _defineProperty(this, \"onContextMenu\", event => {\n      if (this.enabled === false) return;\n      event.preventDefault();\n    });\n\n    if (domElement === undefined) {\n      console.warn('THREE.CameraControls: The second parameter \"domElement\" is now mandatory.');\n    }\n\n    if (domElement instanceof Document) {\n      console.error('THREE.CameraControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\n    }\n\n    this.object = object;\n    this.domElement = domElement;\n    this.mouseButtons = {\n      LEFT: MOUSE.ROTATE,\n      MIDDLE: MOUSE.DOLLY,\n      RIGHT: MOUSE.PAN\n    }; // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.quaternion0 = this.object.quaternion.clone();\n    this.zoom0 = this.object.zoom; //\n    // internals\n    //\n    // so camera.up is the orbit axis\n\n    this.quat = new Quaternion().setFromUnitVectors(this.object.up, new Vector3(0, 1, 0));\n    this.quatInverse = this.quat.clone().invert();\n    this.lastPosition = new Vector3();\n    this.lastQuaternion = new Quaternion();\n    this.domElement.addEventListener('contextmenu', this.onContextMenu, false);\n    this.domElement.addEventListener('mousedown', this.onMouseDown, false);\n    this.domElement.addEventListener('wheel', this.onMouseWheel, false);\n    this.domElement.addEventListener('touchstart', this.onTouchStart, false);\n    this.domElement.addEventListener('touchend', this.onTouchEnd, false);\n    this.domElement.addEventListener('touchmove', this.onTouchMove, false);\n    this.domElement.addEventListener('keydown', this.onKeyDown, false); // make sure element can receive keys.\n\n    if (this.domElement.tabIndex === -1) {\n      this.domElement.tabIndex = 0;\n    } // force an update at start\n\n\n    this.object.lookAt(this.target);\n    this.update();\n    this.saveState();\n  }\n\n  handleMouseUp() {// no-op\n  }\n\n  handleTouchEnd() {// no-op\n  } //\n  // event handlers - FSM: listen for events and reset state\n  //\n\n\n}\n/**\n * OrbitControls maintains the \"up\" direction, camera.up (+Y by default).\n *\n * @event Orbit - left mouse / touch: one-finger move\n * @event Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n * @event Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n */\n\n\nclass OrbitControlsExp extends CameraControls {\n  constructor(object, domElement) {\n    super(object, domElement);\n\n    _defineProperty(this, \"mouseButtons\", void 0);\n\n    _defineProperty(this, \"touches\", void 0);\n\n    this.mouseButtons = {\n      LEFT: MOUSE.ROTATE,\n      RIGHT: MOUSE.PAN\n    };\n    this.touches = {\n      ONE: TOUCH.ROTATE,\n      TWO: TOUCH.DOLLY_PAN\n    };\n  }\n\n}\n/**\n * MapControls maintains the \"up\" direction, camera.up (+Y by default)\n *\n * @event Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n * @event Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n * @event Pan - left mouse, or left right + ctrl/meta/shiftKey, or arrow keys / touch: one-finger move\n */\n\n\nclass MapControlsExp extends CameraControls {\n  constructor(object, domElement) {\n    super(object, domElement);\n\n    _defineProperty(this, \"mouseButtons\", void 0);\n\n    _defineProperty(this, \"touches\", void 0);\n\n    this.mouseButtons = {\n      LEFT: MOUSE.PAN,\n      RIGHT: MOUSE.ROTATE\n    };\n    this.touches = {\n      ONE: TOUCH.PAN,\n      TWO: TOUCH.DOLLY_ROTATE\n    };\n  }\n\n}\n/**\n * TrackballControls allows the camera to rotate over the polls and does not maintain camera.up\n *\n * @event Orbit - left mouse / touch: one-finger move\n * @event Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n * @event Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n */\n\n\nclass TrackballControlsExp extends CameraControls {\n  constructor(object, domElement) {\n    super(object, domElement);\n\n    _defineProperty(this, \"trackball\", void 0);\n\n    _defineProperty(this, \"screenSpacePanning\", void 0);\n\n    _defineProperty(this, \"autoRotate\", void 0);\n\n    _defineProperty(this, \"mouseButtons\", void 0);\n\n    _defineProperty(this, \"touches\", void 0);\n\n    this.trackball = true;\n    this.screenSpacePanning = true;\n    this.autoRotate = false;\n    this.mouseButtons = {\n      LEFT: MOUSE.ROTATE,\n      RIGHT: MOUSE.PAN\n    };\n    this.touches = {\n      ONE: TOUCH.ROTATE,\n      TWO: TOUCH.DOLLY_PAN\n    };\n  }\n\n}\n\nexport { CameraControls, MapControlsExp, OrbitControlsExp, STATE, TrackballControlsExp };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, EventDispatcher, Spherical, MathUtils } from 'three';\n\nconst targetPosition = new Vector3();\nclass FirstPersonControls extends EventDispatcher {\n  // internals\n  constructor(object, _domElement) {\n    super();\n\n    _defineProperty(this, \"object\", void 0);\n\n    _defineProperty(this, \"domElement\", void 0);\n\n    _defineProperty(this, \"enabled\", true);\n\n    _defineProperty(this, \"movementSpeed\", 1.0);\n\n    _defineProperty(this, \"lookSpeed\", 0.005);\n\n    _defineProperty(this, \"lookVertical\", true);\n\n    _defineProperty(this, \"autoForward\", false);\n\n    _defineProperty(this, \"activeLook\", true);\n\n    _defineProperty(this, \"heightSpeed\", false);\n\n    _defineProperty(this, \"heightCoef\", 1.0);\n\n    _defineProperty(this, \"heightMin\", 0.0);\n\n    _defineProperty(this, \"heightMax\", 1.0);\n\n    _defineProperty(this, \"constrainVertical\", false);\n\n    _defineProperty(this, \"verticalMin\", 0);\n\n    _defineProperty(this, \"verticalMax\", Math.PI);\n\n    _defineProperty(this, \"mouseDragOn\", false);\n\n    _defineProperty(this, \"autoSpeedFactor\", 0.0);\n\n    _defineProperty(this, \"mouseX\", 0);\n\n    _defineProperty(this, \"mouseY\", 0);\n\n    _defineProperty(this, \"moveForward\", false);\n\n    _defineProperty(this, \"moveBackward\", false);\n\n    _defineProperty(this, \"moveLeft\", false);\n\n    _defineProperty(this, \"moveRight\", false);\n\n    _defineProperty(this, \"moveUp\", false);\n\n    _defineProperty(this, \"moveDown\", false);\n\n    _defineProperty(this, \"viewHalfX\", 0);\n\n    _defineProperty(this, \"viewHalfY\", 0);\n\n    _defineProperty(this, \"lat\", 0);\n\n    _defineProperty(this, \"lon\", 0);\n\n    _defineProperty(this, \"lookDirection\", new Vector3());\n\n    _defineProperty(this, \"spherical\", new Spherical());\n\n    _defineProperty(this, \"target\", new Vector3());\n\n    _defineProperty(this, \"connect\", domElement => {\n      domElement.setAttribute('tabindex', '-1');\n      domElement.style.touchAction = 'none';\n      domElement.addEventListener('contextmenu', this.contextmenu);\n      domElement.addEventListener('mousemove', this.onMouseMove);\n      domElement.addEventListener('mousedown', this.onMouseDown);\n      domElement.addEventListener('mouseup', this.onMouseUp);\n      this.domElement = domElement;\n      window.addEventListener('keydown', this.onKeyDown);\n      window.addEventListener('keyup', this.onKeyUp);\n      this.handleResize();\n    });\n\n    _defineProperty(this, \"dispose\", () => {\n      var _this$domElement, _this$domElement2, _this$domElement3, _this$domElement4;\n\n      (_this$domElement = this.domElement) === null || _this$domElement === void 0 ? void 0 : _this$domElement.removeEventListener('contextmenu', this.contextmenu);\n      (_this$domElement2 = this.domElement) === null || _this$domElement2 === void 0 ? void 0 : _this$domElement2.removeEventListener('mousedown', this.onMouseDown);\n      (_this$domElement3 = this.domElement) === null || _this$domElement3 === void 0 ? void 0 : _this$domElement3.removeEventListener('mousemove', this.onMouseMove);\n      (_this$domElement4 = this.domElement) === null || _this$domElement4 === void 0 ? void 0 : _this$domElement4.removeEventListener('mouseup', this.onMouseUp);\n      window.removeEventListener('keydown', this.onKeyDown);\n      window.removeEventListener('keyup', this.onKeyUp);\n    });\n\n    _defineProperty(this, \"handleResize\", () => {\n      if (this.domElement) {\n        this.viewHalfX = this.domElement.offsetWidth / 2;\n        this.viewHalfY = this.domElement.offsetHeight / 2;\n      }\n    });\n\n    _defineProperty(this, \"onMouseDown\", event => {\n      var _this$domElement5;\n\n      (_this$domElement5 = this.domElement) === null || _this$domElement5 === void 0 ? void 0 : _this$domElement5.focus();\n\n      if (this.activeLook) {\n        switch (event.button) {\n          case 0:\n            this.moveForward = true;\n            break;\n\n          case 2:\n            this.moveBackward = true;\n            break;\n        }\n      }\n\n      this.mouseDragOn = true;\n    });\n\n    _defineProperty(this, \"onMouseUp\", event => {\n      if (this.activeLook) {\n        switch (event.button) {\n          case 0:\n            this.moveForward = false;\n            break;\n\n          case 2:\n            this.moveBackward = false;\n            break;\n        }\n      }\n\n      this.mouseDragOn = false;\n    });\n\n    _defineProperty(this, \"onMouseMove\", event => {\n      if (this.domElement) {\n        this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;\n        this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;\n      }\n    });\n\n    _defineProperty(this, \"onKeyDown\", event => {\n      switch (event.code) {\n        case 'ArrowUp':\n        case 'KeyW':\n          this.moveForward = true;\n          break;\n\n        case 'ArrowLeft':\n        case 'KeyA':\n          this.moveLeft = true;\n          break;\n\n        case 'ArrowDown':\n        case 'KeyS':\n          this.moveBackward = true;\n          break;\n\n        case 'ArrowRight':\n        case 'KeyD':\n          this.moveRight = true;\n          break;\n\n        case 'KeyR':\n          this.moveUp = true;\n          break;\n\n        case 'KeyF':\n          this.moveDown = true;\n          break;\n      }\n    });\n\n    _defineProperty(this, \"onKeyUp\", event => {\n      switch (event.code) {\n        case 'ArrowUp':\n        case 'KeyW':\n          this.moveForward = false;\n          break;\n\n        case 'ArrowLeft':\n        case 'KeyA':\n          this.moveLeft = false;\n          break;\n\n        case 'ArrowDown':\n        case 'KeyS':\n          this.moveBackward = false;\n          break;\n\n        case 'ArrowRight':\n        case 'KeyD':\n          this.moveRight = false;\n          break;\n\n        case 'KeyR':\n          this.moveUp = false;\n          break;\n\n        case 'KeyF':\n          this.moveDown = false;\n          break;\n      }\n    });\n\n    _defineProperty(this, \"lookAt\", (x, y, z) => {\n      if (x instanceof Vector3) {\n        this.target.copy(x);\n      } else if (y && z) {\n        this.target.set(x, y, z);\n      }\n\n      this.object.lookAt(this.target);\n      this.setOrientation();\n      return this;\n    });\n\n    _defineProperty(this, \"update\", delta => {\n      if (!this.enabled) return;\n\n      if (this.heightSpeed) {\n        const y = MathUtils.clamp(this.object.position.y, this.heightMin, this.heightMax);\n        const heightDelta = y - this.heightMin;\n        this.autoSpeedFactor = delta * (heightDelta * this.heightCoef);\n      } else {\n        this.autoSpeedFactor = 0.0;\n      }\n\n      const actualMoveSpeed = delta * this.movementSpeed;\n\n      if (this.moveForward || this.autoForward && !this.moveBackward) {\n        this.object.translateZ(-(actualMoveSpeed + this.autoSpeedFactor));\n      }\n\n      if (this.moveBackward) this.object.translateZ(actualMoveSpeed);\n      if (this.moveLeft) this.object.translateX(-actualMoveSpeed);\n      if (this.moveRight) this.object.translateX(actualMoveSpeed);\n      if (this.moveUp) this.object.translateY(actualMoveSpeed);\n      if (this.moveDown) this.object.translateY(-actualMoveSpeed);\n      let actualLookSpeed = delta * this.lookSpeed;\n\n      if (!this.activeLook) {\n        actualLookSpeed = 0;\n      }\n\n      let verticalLookRatio = 1;\n\n      if (this.constrainVertical) {\n        verticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin);\n      }\n\n      this.lon -= this.mouseX * actualLookSpeed;\n      if (this.lookVertical) this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;\n      this.lat = Math.max(-85, Math.min(85, this.lat));\n      let phi = MathUtils.degToRad(90 - this.lat);\n      const theta = MathUtils.degToRad(this.lon);\n\n      if (this.constrainVertical) {\n        phi = MathUtils.mapLinear(phi, 0, Math.PI, this.verticalMin, this.verticalMax);\n      }\n\n      const position = this.object.position;\n      targetPosition.setFromSphericalCoords(1, phi, theta).add(position);\n      this.object.lookAt(targetPosition);\n    });\n\n    _defineProperty(this, \"contextmenu\", event => event.preventDefault());\n\n    _defineProperty(this, \"setOrientation\", () => {\n      this.lookDirection.set(0, 0, -1).applyQuaternion(this.object.quaternion);\n      this.spherical.setFromVector3(this.lookDirection);\n      this.lat = 90 - MathUtils.radToDeg(this.spherical.phi);\n      this.lon = MathUtils.radToDeg(this.spherical.theta);\n    });\n\n    this.object = object;\n    this.domElement = _domElement;\n    this.setOrientation();\n    if (_domElement) this.connect(_domElement);\n  }\n\n}\n\nexport { FirstPersonControls };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Euler, Vector3, EventDispatcher } from 'three';\n\nconst _euler = new Euler(0, 0, 0, 'YXZ');\n\nconst _vector = new Vector3();\n\nconst _changeEvent = {\n  type: 'change'\n};\nconst _lockEvent = {\n  type: 'lock'\n};\nconst _unlockEvent = {\n  type: 'unlock'\n};\n\nconst _PI_2 = Math.PI / 2;\n\nclass PointerLockControls extends EventDispatcher {\n  constructor(camera, _domElement) {\n    super();\n\n    _defineProperty(this, \"camera\", void 0);\n\n    _defineProperty(this, \"domElement\", void 0);\n\n    _defineProperty(this, \"isLocked\", void 0);\n\n    _defineProperty(this, \"minPolarAngle\", void 0);\n\n    _defineProperty(this, \"maxPolarAngle\", void 0);\n\n    _defineProperty(this, \"pointerSpeed\", void 0);\n\n    _defineProperty(this, \"onMouseMove\", event => {\n      if (!this.domElement || this.isLocked === false) return;\n      const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;\n      const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;\n\n      _euler.setFromQuaternion(this.camera.quaternion);\n\n      _euler.y -= movementX * 0.002 * this.pointerSpeed;\n      _euler.x -= movementY * 0.002 * this.pointerSpeed;\n      _euler.x = Math.max(_PI_2 - this.maxPolarAngle, Math.min(_PI_2 - this.minPolarAngle, _euler.x));\n      this.camera.quaternion.setFromEuler(_euler);\n      this.dispatchEvent(_changeEvent);\n    });\n\n    _defineProperty(this, \"onPointerlockChange\", () => {\n      if (!this.domElement) return;\n\n      if (this.domElement.ownerDocument.pointerLockElement === this.domElement) {\n        this.dispatchEvent(_lockEvent);\n        this.isLocked = true;\n      } else {\n        this.dispatchEvent(_unlockEvent);\n        this.isLocked = false;\n      }\n    });\n\n    _defineProperty(this, \"onPointerlockError\", () => {\n      console.error('THREE.PointerLockControls: Unable to use Pointer Lock API');\n    });\n\n    _defineProperty(this, \"connect\", domElement => {\n      this.domElement = domElement || this.domElement;\n      if (!this.domElement) return;\n      this.domElement.ownerDocument.addEventListener('mousemove', this.onMouseMove);\n      this.domElement.ownerDocument.addEventListener('pointerlockchange', this.onPointerlockChange);\n      this.domElement.ownerDocument.addEventListener('pointerlockerror', this.onPointerlockError);\n    });\n\n    _defineProperty(this, \"disconnect\", () => {\n      if (!this.domElement) return;\n      this.domElement.ownerDocument.removeEventListener('mousemove', this.onMouseMove);\n      this.domElement.ownerDocument.removeEventListener('pointerlockchange', this.onPointerlockChange);\n      this.domElement.ownerDocument.removeEventListener('pointerlockerror', this.onPointerlockError);\n    });\n\n    _defineProperty(this, \"dispose\", () => {\n      this.disconnect();\n    });\n\n    _defineProperty(this, \"getObject\", () => {\n      // retaining this method for backward compatibility\n      return this.camera;\n    });\n\n    _defineProperty(this, \"direction\", new Vector3(0, 0, -1));\n\n    _defineProperty(this, \"getDirection\", v => {\n      return v.copy(this.direction).applyQuaternion(this.camera.quaternion);\n    });\n\n    _defineProperty(this, \"moveForward\", distance => {\n      // move forward parallel to the xz-plane\n      // assumes camera.up is y-up\n      _vector.setFromMatrixColumn(this.camera.matrix, 0);\n\n      _vector.crossVectors(this.camera.up, _vector);\n\n      this.camera.position.addScaledVector(_vector, distance);\n    });\n\n    _defineProperty(this, \"moveRight\", distance => {\n      _vector.setFromMatrixColumn(this.camera.matrix, 0);\n\n      this.camera.position.addScaledVector(_vector, distance);\n    });\n\n    _defineProperty(this, \"lock\", () => {\n      if (this.domElement) this.domElement.requestPointerLock();\n    });\n\n    _defineProperty(this, \"unlock\", () => {\n      if (this.domElement) this.domElement.ownerDocument.exitPointerLock();\n    });\n\n    this.camera = camera;\n    this.domElement = _domElement;\n    this.isLocked = false; // Set to constrain the pitch of the camera\n    // Range is 0 to Math.PI radians\n\n    this.minPolarAngle = 0; // radians\n\n    this.maxPolarAngle = Math.PI; // radians\n\n    this.pointerSpeed = 1.0;\n    if (_domElement) this.connect(_domElement);\n  }\n\n}\n\nexport { PointerLockControls };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Matrix4, EventDispatcher, EllipseCurve, BufferGeometry, MathUtils, Vector3, GridHelper, LineBasicMaterial, Line, Raycaster, Vector2, Quaternion, Group, Box3, Sphere } from 'three';\n\n//trackball state\nconst STATE = {\n  IDLE: Symbol(),\n  ROTATE: Symbol(),\n  PAN: Symbol(),\n  SCALE: Symbol(),\n  FOV: Symbol(),\n  FOCUS: Symbol(),\n  ZROTATE: Symbol(),\n  TOUCH_MULTI: Symbol(),\n  ANIMATION_FOCUS: Symbol(),\n  ANIMATION_ROTATE: Symbol()\n};\nconst INPUT = {\n  NONE: Symbol(),\n  ONE_FINGER: Symbol(),\n  ONE_FINGER_SWITCHED: Symbol(),\n  TWO_FINGER: Symbol(),\n  MULT_FINGER: Symbol(),\n  CURSOR: Symbol()\n}; //cursor center coordinates\n\nconst _center = {\n  x: 0,\n  y: 0\n}; //transformation matrices for gizmos and camera\n\nconst _transformation = {\n  camera: new Matrix4(),\n  gizmos: new Matrix4()\n}; //events\n\nconst _changeEvent = {\n  type: 'change'\n};\nconst _startEvent = {\n  type: 'start'\n};\nconst _endEvent = {\n  type: 'end'\n};\n/**\n *\n * @param {CamOrthographicCamera | PerspectiveCameraera} camera Virtual camera used in the scene\n * @param {HTMLElement=null} domElement Renderer's dom element\n * @param {Scene=null} scene The scene to be rendered\n */\n\nclass ArcballControls extends EventDispatcher {\n  constructor(_camera, _domElement = null, scene = null) {\n    super();\n\n    _defineProperty(this, \"camera\", void 0);\n\n    _defineProperty(this, \"domElement\", void 0);\n\n    _defineProperty(this, \"scene\", void 0);\n\n    _defineProperty(this, \"mouseActions\", void 0);\n\n    _defineProperty(this, \"_mouseOp\", void 0);\n\n    _defineProperty(this, \"_v2_1\", void 0);\n\n    _defineProperty(this, \"_v3_1\", void 0);\n\n    _defineProperty(this, \"_v3_2\", void 0);\n\n    _defineProperty(this, \"_m4_1\", void 0);\n\n    _defineProperty(this, \"_m4_2\", void 0);\n\n    _defineProperty(this, \"_quat\", void 0);\n\n    _defineProperty(this, \"_translationMatrix\", void 0);\n\n    _defineProperty(this, \"_rotationMatrix\", void 0);\n\n    _defineProperty(this, \"_scaleMatrix\", void 0);\n\n    _defineProperty(this, \"_rotationAxis\", void 0);\n\n    _defineProperty(this, \"_cameraMatrixState\", void 0);\n\n    _defineProperty(this, \"_cameraProjectionState\", void 0);\n\n    _defineProperty(this, \"_fovState\", void 0);\n\n    _defineProperty(this, \"_upState\", void 0);\n\n    _defineProperty(this, \"_zoomState\", void 0);\n\n    _defineProperty(this, \"_nearPos\", void 0);\n\n    _defineProperty(this, \"_farPos\", void 0);\n\n    _defineProperty(this, \"_gizmoMatrixState\", void 0);\n\n    _defineProperty(this, \"_up0\", void 0);\n\n    _defineProperty(this, \"_zoom0\", void 0);\n\n    _defineProperty(this, \"_fov0\", void 0);\n\n    _defineProperty(this, \"_initialNear\", void 0);\n\n    _defineProperty(this, \"_nearPos0\", void 0);\n\n    _defineProperty(this, \"_initialFar\", void 0);\n\n    _defineProperty(this, \"_farPos0\", void 0);\n\n    _defineProperty(this, \"_cameraMatrixState0\", void 0);\n\n    _defineProperty(this, \"_gizmoMatrixState0\", void 0);\n\n    _defineProperty(this, \"_button\", void 0);\n\n    _defineProperty(this, \"_touchStart\", void 0);\n\n    _defineProperty(this, \"_touchCurrent\", void 0);\n\n    _defineProperty(this, \"_input\", void 0);\n\n    _defineProperty(this, \"_switchSensibility\", void 0);\n\n    _defineProperty(this, \"_startFingerDistance\", void 0);\n\n    _defineProperty(this, \"_currentFingerDistance\", void 0);\n\n    _defineProperty(this, \"_startFingerRotation\", void 0);\n\n    _defineProperty(this, \"_currentFingerRotation\", void 0);\n\n    _defineProperty(this, \"_devPxRatio\", void 0);\n\n    _defineProperty(this, \"_downValid\", void 0);\n\n    _defineProperty(this, \"_nclicks\", void 0);\n\n    _defineProperty(this, \"_downEvents\", void 0);\n\n    _defineProperty(this, \"_clickStart\", void 0);\n\n    _defineProperty(this, \"_maxDownTime\", void 0);\n\n    _defineProperty(this, \"_maxInterval\", void 0);\n\n    _defineProperty(this, \"_posThreshold\", void 0);\n\n    _defineProperty(this, \"_movementThreshold\", void 0);\n\n    _defineProperty(this, \"_currentCursorPosition\", void 0);\n\n    _defineProperty(this, \"_startCursorPosition\", void 0);\n\n    _defineProperty(this, \"_grid\", void 0);\n\n    _defineProperty(this, \"_gridPosition\", void 0);\n\n    _defineProperty(this, \"_gizmos\", void 0);\n\n    _defineProperty(this, \"_curvePts\", void 0);\n\n    _defineProperty(this, \"_timeStart\", void 0);\n\n    _defineProperty(this, \"_animationId\", void 0);\n\n    _defineProperty(this, \"focusAnimationTime\", void 0);\n\n    _defineProperty(this, \"_timePrev\", void 0);\n\n    _defineProperty(this, \"_timeCurrent\", void 0);\n\n    _defineProperty(this, \"_anglePrev\", void 0);\n\n    _defineProperty(this, \"_angleCurrent\", void 0);\n\n    _defineProperty(this, \"_cursorPosPrev\", void 0);\n\n    _defineProperty(this, \"_cursorPosCurr\", void 0);\n\n    _defineProperty(this, \"_wPrev\", void 0);\n\n    _defineProperty(this, \"_wCurr\", void 0);\n\n    _defineProperty(this, \"adjustNearFar\", void 0);\n\n    _defineProperty(this, \"scaleFactor\", void 0);\n\n    _defineProperty(this, \"dampingFactor\", void 0);\n\n    _defineProperty(this, \"wMax\", void 0);\n\n    _defineProperty(this, \"enableAnimations\", void 0);\n\n    _defineProperty(this, \"enableGrid\", void 0);\n\n    _defineProperty(this, \"cursorZoom\", void 0);\n\n    _defineProperty(this, \"minFov\", void 0);\n\n    _defineProperty(this, \"maxFov\", void 0);\n\n    _defineProperty(this, \"enabled\", void 0);\n\n    _defineProperty(this, \"enablePan\", void 0);\n\n    _defineProperty(this, \"enableRotate\", void 0);\n\n    _defineProperty(this, \"enableZoom\", void 0);\n\n    _defineProperty(this, \"minDistance\", void 0);\n\n    _defineProperty(this, \"maxDistance\", void 0);\n\n    _defineProperty(this, \"minZoom\", void 0);\n\n    _defineProperty(this, \"maxZoom\", void 0);\n\n    _defineProperty(this, \"target\", void 0);\n\n    _defineProperty(this, \"_currentTarget\", void 0);\n\n    _defineProperty(this, \"_tbRadius\", void 0);\n\n    _defineProperty(this, \"_state\", void 0);\n\n    _defineProperty(this, \"onWindowResize\", () => {\n      const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n\n      if (this.camera) {\n        const tbRadius = this.calculateTbRadius(this.camera);\n\n        if (tbRadius !== undefined) {\n          this._tbRadius = tbRadius;\n        }\n      }\n\n      const newRadius = this._tbRadius / scale; // @ts-expect-error\n\n      const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n      const points = curve.getPoints(this._curvePts);\n      const curveGeometry = new BufferGeometry().setFromPoints(points);\n\n      for (const gizmo in this._gizmos.children) {\n        const child = this._gizmos.children[gizmo];\n        child.geometry = curveGeometry;\n      }\n\n      this.dispatchEvent(_changeEvent);\n    });\n\n    _defineProperty(this, \"onContextMenu\", event => {\n      if (!this.enabled) {\n        return;\n      }\n\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        if (this.mouseActions[i].mouse == 2) {\n          //prevent only if button 2 is actually used\n          event.preventDefault();\n          break;\n        }\n      }\n    });\n\n    _defineProperty(this, \"onPointerCancel\", () => {\n      this._touchStart.splice(0, this._touchStart.length);\n\n      this._touchCurrent.splice(0, this._touchCurrent.length);\n\n      this._input = INPUT.NONE;\n    });\n\n    _defineProperty(this, \"onPointerDown\", event => {\n      if (event.button == 0 && event.isPrimary) {\n        this._downValid = true;\n\n        this._downEvents.push(event);\n      } else {\n        this._downValid = false;\n      }\n\n      if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n        this._touchStart.push(event);\n\n        this._touchCurrent.push(event);\n\n        switch (this._input) {\n          case INPUT.NONE:\n            //singleStart\n            this._input = INPUT.ONE_FINGER;\n            this.onSinglePanStart(event, 'ROTATE');\n            window.addEventListener('pointermove', this.onPointerMove);\n            window.addEventListener('pointerup', this.onPointerUp);\n            break;\n\n          case INPUT.ONE_FINGER:\n          case INPUT.ONE_FINGER_SWITCHED:\n            //doubleStart\n            this._input = INPUT.TWO_FINGER;\n            this.onRotateStart();\n            this.onPinchStart();\n            this.onDoublePanStart();\n            break;\n\n          case INPUT.TWO_FINGER:\n            //multipleStart\n            this._input = INPUT.MULT_FINGER;\n            this.onTriplePanStart();\n            break;\n        }\n      } else if (event.pointerType != 'touch' && this._input == INPUT.NONE) {\n        let modifier = null;\n\n        if (event.ctrlKey || event.metaKey) {\n          modifier = 'CTRL';\n        } else if (event.shiftKey) {\n          modifier = 'SHIFT';\n        }\n\n        this._mouseOp = this.getOpFromAction(event.button, modifier);\n\n        if (this._mouseOp) {\n          window.addEventListener('pointermove', this.onPointerMove);\n          window.addEventListener('pointerup', this.onPointerUp); //singleStart\n\n          this._input = INPUT.CURSOR;\n          this._button = event.button;\n          this.onSinglePanStart(event, this._mouseOp);\n        }\n      }\n    });\n\n    _defineProperty(this, \"onPointerMove\", event => {\n      if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n        switch (this._input) {\n          case INPUT.ONE_FINGER:\n            //singleMove\n            this.updateTouchEvent(event);\n            this.onSinglePanMove(event, STATE.ROTATE);\n            break;\n\n          case INPUT.ONE_FINGER_SWITCHED:\n            const movement = this.calculatePointersDistance(this._touchCurrent[0], event) * this._devPxRatio;\n\n            if (movement >= this._switchSensibility) {\n              //singleMove\n              this._input = INPUT.ONE_FINGER;\n              this.updateTouchEvent(event);\n              this.onSinglePanStart(event, 'ROTATE');\n              break;\n            }\n\n            break;\n\n          case INPUT.TWO_FINGER:\n            //rotate/pan/pinchMove\n            this.updateTouchEvent(event);\n            this.onRotateMove();\n            this.onPinchMove();\n            this.onDoublePanMove();\n            break;\n\n          case INPUT.MULT_FINGER:\n            //multMove\n            this.updateTouchEvent(event);\n            this.onTriplePanMove();\n            break;\n        }\n      } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n        let modifier = null;\n\n        if (event.ctrlKey || event.metaKey) {\n          modifier = 'CTRL';\n        } else if (event.shiftKey) {\n          modifier = 'SHIFT';\n        }\n\n        const mouseOpState = this.getOpStateFromAction(this._button, modifier);\n\n        if (mouseOpState) {\n          this.onSinglePanMove(event, mouseOpState);\n        }\n      } //checkDistance\n\n\n      if (this._downValid) {\n        const movement = this.calculatePointersDistance(this._downEvents[this._downEvents.length - 1], event) * this._devPxRatio;\n\n        if (movement > this._movementThreshold) {\n          this._downValid = false;\n        }\n      }\n    });\n\n    _defineProperty(this, \"onPointerUp\", event => {\n      if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n        const nTouch = this._touchCurrent.length;\n\n        for (let i = 0; i < nTouch; i++) {\n          if (this._touchCurrent[i].pointerId == event.pointerId) {\n            this._touchCurrent.splice(i, 1);\n\n            this._touchStart.splice(i, 1);\n\n            break;\n          }\n        }\n\n        switch (this._input) {\n          case INPUT.ONE_FINGER:\n          case INPUT.ONE_FINGER_SWITCHED:\n            //singleEnd\n            window.removeEventListener('pointermove', this.onPointerMove);\n            window.removeEventListener('pointerup', this.onPointerUp);\n            this._input = INPUT.NONE;\n            this.onSinglePanEnd();\n            break;\n\n          case INPUT.TWO_FINGER:\n            //doubleEnd\n            this.onDoublePanEnd();\n            this.onPinchEnd();\n            this.onRotateEnd(); //switching to singleStart\n\n            this._input = INPUT.ONE_FINGER_SWITCHED;\n            break;\n\n          case INPUT.MULT_FINGER:\n            if (this._touchCurrent.length == 0) {\n              window.removeEventListener('pointermove', this.onPointerMove);\n              window.removeEventListener('pointerup', this.onPointerUp); //multCancel\n\n              this._input = INPUT.NONE;\n              this.onTriplePanEnd();\n            }\n\n            break;\n        }\n      } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n        window.removeEventListener('pointermove', this.onPointerMove);\n        window.removeEventListener('pointerup', this.onPointerUp);\n        this._input = INPUT.NONE;\n        this.onSinglePanEnd();\n        this._button = -1;\n      }\n\n      if (event.isPrimary) {\n        if (this._downValid) {\n          const downTime = event.timeStamp - this._downEvents[this._downEvents.length - 1].timeStamp;\n\n          if (downTime <= this._maxDownTime) {\n            if (this._nclicks == 0) {\n              //first valid click detected\n              this._nclicks = 1;\n              this._clickStart = performance.now();\n            } else {\n              const clickInterval = event.timeStamp - this._clickStart;\n\n              const movement = this.calculatePointersDistance(this._downEvents[1], this._downEvents[0]) * this._devPxRatio;\n\n              if (clickInterval <= this._maxInterval && movement <= this._posThreshold) {\n                //second valid click detected\n                //fire double tap and reset values\n                this._nclicks = 0;\n\n                this._downEvents.splice(0, this._downEvents.length);\n\n                this.onDoubleTap(event);\n              } else {\n                //new 'first click'\n                this._nclicks = 1;\n\n                this._downEvents.shift();\n\n                this._clickStart = performance.now();\n              }\n            }\n          } else {\n            this._downValid = false;\n            this._nclicks = 0;\n\n            this._downEvents.splice(0, this._downEvents.length);\n          }\n        } else {\n          this._nclicks = 0;\n\n          this._downEvents.splice(0, this._downEvents.length);\n        }\n      }\n    });\n\n    _defineProperty(this, \"onWheel\", event => {\n      var _this$camera3;\n\n      if (this.enabled && this.enableZoom && this.domElement) {\n        let modifier = null;\n\n        if (event.ctrlKey || event.metaKey) {\n          modifier = 'CTRL';\n        } else if (event.shiftKey) {\n          modifier = 'SHIFT';\n        }\n\n        const mouseOp = this.getOpFromAction('WHEEL', modifier);\n\n        if (mouseOp) {\n          event.preventDefault();\n          this.dispatchEvent(_startEvent);\n          const notchDeltaY = 125; //distance of one notch of mouse wheel\n\n          let sgn = event.deltaY / notchDeltaY;\n          let size = 1;\n\n          if (sgn > 0) {\n            size = 1 / this.scaleFactor;\n          } else if (sgn < 0) {\n            size = this.scaleFactor;\n          }\n\n          switch (mouseOp) {\n            case 'ZOOM':\n              this.updateTbState(STATE.SCALE, true);\n\n              if (sgn > 0) {\n                size = 1 / Math.pow(this.scaleFactor, sgn);\n              } else if (sgn < 0) {\n                size = Math.pow(this.scaleFactor, -sgn);\n              }\n\n              if (this.cursorZoom && this.enablePan) {\n                var _this$camera, _this$camera2;\n\n                let scalePoint;\n\n                if (((_this$camera = this.camera) === null || _this$camera === void 0 ? void 0 : _this$camera.type) === 'OrthographicCamera') {\n                  var _this$unprojectOnTbPl;\n\n                  scalePoint = (_this$unprojectOnTbPl = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)) === null || _this$unprojectOnTbPl === void 0 ? void 0 : _this$unprojectOnTbPl.applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\n                }\n\n                if (((_this$camera2 = this.camera) === null || _this$camera2 === void 0 ? void 0 : _this$camera2.type) === 'PerspectiveCamera') {\n                  var _this$unprojectOnTbPl2;\n\n                  scalePoint = (_this$unprojectOnTbPl2 = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)) === null || _this$unprojectOnTbPl2 === void 0 ? void 0 : _this$unprojectOnTbPl2.applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\n                }\n\n                if (scalePoint !== undefined) this.applyTransformMatrix(this.applyScale(size, scalePoint));\n              } else {\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\n              }\n\n              if (this._grid) {\n                this.disposeGrid();\n                this.drawGrid();\n              }\n\n              this.updateTbState(STATE.IDLE, false);\n              this.dispatchEvent(_changeEvent);\n              this.dispatchEvent(_endEvent);\n              break;\n\n            case 'FOV':\n              if (((_this$camera3 = this.camera) === null || _this$camera3 === void 0 ? void 0 : _this$camera3.type) === 'PerspectiveCamera') {\n                this.updateTbState(STATE.FOV, true); //Vertigo effect\n                //\t  fov / 2\n                //\t\t|\\\n                //\t\t| \\\n                //\t\t|  \\\n                //\tx\t|\t\\\n                //\t\t| \t \\\n                //\t\t| \t  \\\n                //\t\t| _ _ _\\\n                //\t\t\ty\n                //check for iOs shift shortcut\n\n                if (event.deltaX != 0) {\n                  sgn = event.deltaX / notchDeltaY;\n                  size = 1;\n\n                  if (sgn > 0) {\n                    size = 1 / Math.pow(this.scaleFactor, sgn);\n                  } else if (sgn < 0) {\n                    size = Math.pow(this.scaleFactor, -sgn);\n                  }\n                }\n\n                this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n                const x = this._v3_1.distanceTo(this._gizmos.position);\n\n                let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n                //check min and max distance\n\n                xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n                const y = x * Math.tan(MathUtils.DEG2RAD * this.camera.fov * 0.5); //calculate new fov\n\n                let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\n\n                if (newFov > this.maxFov) {\n                  newFov = this.maxFov;\n                } else if (newFov < this.minFov) {\n                  newFov = this.minFov;\n                }\n\n                const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n                size = x / newDistance;\n                this.setFov(newFov);\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position, false));\n              }\n\n              if (this._grid) {\n                this.disposeGrid();\n                this.drawGrid();\n              }\n\n              this.updateTbState(STATE.IDLE, false);\n              this.dispatchEvent(_changeEvent);\n              this.dispatchEvent(_endEvent);\n              break;\n          }\n        }\n      }\n    });\n\n    _defineProperty(this, \"onSinglePanStart\", (event, operation) => {\n      var _this$camera4;\n\n      if (this.enabled && this.domElement) {\n        this.dispatchEvent(_startEvent);\n        this.setCenter(event.clientX, event.clientY);\n\n        switch (operation) {\n          case 'PAN':\n            if (!this.enablePan) return;\n\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n              this.activateGizmos(false);\n              this.dispatchEvent(_changeEvent);\n            }\n\n            if (this.camera) {\n              this.updateTbState(STATE.PAN, true);\n              const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement);\n\n              if (rayDir !== undefined) {\n                this._startCursorPosition.copy(rayDir);\n              }\n\n              if (this.enableGrid) {\n                this.drawGrid();\n                this.dispatchEvent(_changeEvent);\n              }\n            }\n\n            break;\n\n          case 'ROTATE':\n            if (!this.enableRotate) return;\n\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n            }\n\n            if (this.camera) {\n              this.updateTbState(STATE.ROTATE, true);\n              const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius);\n\n              if (rayDir !== undefined) {\n                this._startCursorPosition.copy(rayDir);\n              }\n\n              this.activateGizmos(true);\n\n              if (this.enableAnimations) {\n                this._timePrev = this._timeCurrent = performance.now();\n                this._angleCurrent = this._anglePrev = 0;\n\n                this._cursorPosPrev.copy(this._startCursorPosition);\n\n                this._cursorPosCurr.copy(this._cursorPosPrev);\n\n                this._wCurr = 0;\n                this._wPrev = this._wCurr;\n              }\n            }\n\n            this.dispatchEvent(_changeEvent);\n            break;\n\n          case 'FOV':\n            if (!this.enableZoom) return;\n\n            if (((_this$camera4 = this.camera) === null || _this$camera4 === void 0 ? void 0 : _this$camera4.type) === 'PerspectiveCamera') {\n              if (this._animationId != -1) {\n                cancelAnimationFrame(this._animationId);\n                this._animationId = -1;\n                this._timeStart = -1;\n                this.activateGizmos(false);\n                this.dispatchEvent(_changeEvent);\n              }\n\n              this.updateTbState(STATE.FOV, true);\n\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n              this._currentCursorPosition.copy(this._startCursorPosition);\n            }\n\n            break;\n\n          case 'ZOOM':\n            if (!this.enableZoom) return;\n\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId);\n              this._animationId = -1;\n              this._timeStart = -1;\n              this.activateGizmos(false);\n              this.dispatchEvent(_changeEvent);\n            }\n\n            this.updateTbState(STATE.SCALE, true);\n\n            this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n            this._currentCursorPosition.copy(this._startCursorPosition);\n\n            break;\n        }\n      }\n    });\n\n    _defineProperty(this, \"onSinglePanMove\", (event, opState) => {\n      var _this$camera5;\n\n      if (this.enabled && this.domElement) {\n        const restart = opState != this._state;\n        this.setCenter(event.clientX, event.clientY);\n\n        switch (opState) {\n          case STATE.PAN:\n            if (this.enablePan && this.camera) {\n              if (restart) {\n                //switch to pan operation\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n                const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement);\n\n                if (rayDir !== undefined) {\n                  this._startCursorPosition.copy(rayDir);\n                }\n\n                if (this.enableGrid) {\n                  this.drawGrid();\n                }\n\n                this.activateGizmos(false);\n              } else {\n                //continue with pan operation\n                const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement);\n\n                if (rayDir !== undefined) {\n                  this._currentCursorPosition.copy(rayDir);\n                }\n\n                this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition));\n              }\n            }\n\n            break;\n\n          case STATE.ROTATE:\n            if (this.enableRotate && this.camera) {\n              if (restart) {\n                //switch to rotate operation\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n                const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius);\n\n                if (rayDir !== undefined) {\n                  this._startCursorPosition.copy(rayDir);\n                }\n\n                if (this.enableGrid) {\n                  this.disposeGrid();\n                }\n\n                this.activateGizmos(true);\n              } else {\n                //continue with rotate operation\n                const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius);\n\n                if (rayDir !== undefined) {\n                  this._currentCursorPosition.copy(rayDir);\n                }\n\n                const distance = this._startCursorPosition.distanceTo(this._currentCursorPosition);\n\n                const angle = this._startCursorPosition.angleTo(this._currentCursorPosition);\n\n                const amount = Math.max(distance / this._tbRadius, angle); //effective rotation angle\n\n                this.applyTransformMatrix(this.rotate(this.calculateRotationAxis(this._startCursorPosition, this._currentCursorPosition), amount));\n\n                if (this.enableAnimations) {\n                  this._timePrev = this._timeCurrent;\n                  this._timeCurrent = performance.now();\n                  this._anglePrev = this._angleCurrent;\n                  this._angleCurrent = amount;\n\n                  this._cursorPosPrev.copy(this._cursorPosCurr);\n\n                  this._cursorPosCurr.copy(this._currentCursorPosition);\n\n                  this._wPrev = this._wCurr;\n                  this._wCurr = this.calculateAngularSpeed(this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent);\n                }\n              }\n            }\n\n            break;\n\n          case STATE.SCALE:\n            if (this.enableZoom) {\n              if (restart) {\n                //switch to zoom operation\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n\n                this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n                this._currentCursorPosition.copy(this._startCursorPosition);\n\n                if (this.enableGrid) {\n                  this.disposeGrid();\n                }\n\n                this.activateGizmos(false);\n              } else {\n                //continue with zoom operation\n                const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n\n                this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n                const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n                let size = 1;\n\n                if (movement < 0) {\n                  size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n                } else if (movement > 0) {\n                  size = Math.pow(this.scaleFactor, movement * screenNotches);\n                }\n\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\n              }\n            }\n\n            break;\n\n          case STATE.FOV:\n            if (this.enableZoom && ((_this$camera5 = this.camera) === null || _this$camera5 === void 0 ? void 0 : _this$camera5.type) === 'PerspectiveCamera') {\n              if (restart) {\n                //switch to fov operation\n                this.dispatchEvent(_endEvent);\n                this.dispatchEvent(_startEvent);\n                this.updateTbState(opState, true);\n\n                this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n                this._currentCursorPosition.copy(this._startCursorPosition);\n\n                if (this.enableGrid) {\n                  this.disposeGrid();\n                }\n\n                this.activateGizmos(false);\n              } else {\n                //continue with fov operation\n                const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n\n                this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n                const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n                let size = 1;\n\n                if (movement < 0) {\n                  size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n                } else if (movement > 0) {\n                  size = Math.pow(this.scaleFactor, movement * screenNotches);\n                }\n\n                this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n                const x = this._v3_1.distanceTo(this._gizmos.position);\n\n                let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n                //check min and max distance\n\n                xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n                const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5); //calculate new fov\n\n                let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\n\n                newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n                const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n                size = x / newDistance;\n\n                this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n                this.setFov(newFov);\n                this.applyTransformMatrix(this.applyScale(size, this._v3_2, false)); //adjusting distance\n\n                const direction = this._gizmos.position.clone().sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\n\n                this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n              }\n            }\n\n            break;\n        }\n\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onSinglePanEnd\", () => {\n      if (this._state == STATE.ROTATE) {\n        if (!this.enableRotate) {\n          return;\n        }\n\n        if (this.enableAnimations) {\n          //perform rotation animation\n          const deltaTime = performance.now() - this._timeCurrent;\n\n          if (deltaTime < 120) {\n            const w = Math.abs((this._wPrev + this._wCurr) / 2);\n            const self = this;\n            this._animationId = window.requestAnimationFrame(function (t) {\n              self.updateTbState(STATE.ANIMATION_ROTATE, true);\n              const rotationAxis = self.calculateRotationAxis(self._cursorPosPrev, self._cursorPosCurr);\n              self.onRotationAnim(t, rotationAxis, Math.min(w, self.wMax));\n            });\n          } else {\n            //cursor has been standing still for over 120 ms since last movement\n            this.updateTbState(STATE.IDLE, false);\n            this.activateGizmos(false);\n            this.dispatchEvent(_changeEvent);\n          }\n        } else {\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      } else if (this._state == STATE.PAN || this._state == STATE.IDLE) {\n        this.updateTbState(STATE.IDLE, false);\n\n        if (this.enableGrid) {\n          this.disposeGrid();\n        }\n\n        this.activateGizmos(false);\n        this.dispatchEvent(_changeEvent);\n      }\n\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onDoubleTap\", event => {\n      if (this.enabled && this.enablePan && this.scene && this.camera && this.domElement) {\n        this.dispatchEvent(_startEvent);\n        this.setCenter(event.clientX, event.clientY);\n        const hitP = this.unprojectOnObj(this.getCursorNDC(_center.x, _center.y, this.domElement), this.camera);\n\n        if (hitP && this.enableAnimations) {\n          const self = this;\n\n          if (this._animationId != -1) {\n            window.cancelAnimationFrame(this._animationId);\n          }\n\n          this._timeStart = -1;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.updateTbState(STATE.ANIMATION_FOCUS, true);\n            self.onFocusAnim(t, hitP, self._cameraMatrixState, self._gizmoMatrixState);\n          });\n        } else if (hitP && !this.enableAnimations) {\n          this.updateTbState(STATE.FOCUS, true);\n          this.focus(hitP, this.scaleFactor);\n          this.updateTbState(STATE.IDLE, false);\n          this.dispatchEvent(_changeEvent);\n        }\n      }\n\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onDoublePanStart\", () => {\n      if (this.enabled && this.enablePan && this.camera && this.domElement) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.PAN, true);\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n        const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true);\n\n        if (rayDir !== undefined) {\n          this._startCursorPosition.copy(rayDir);\n        }\n\n        this._currentCursorPosition.copy(this._startCursorPosition);\n\n        this.activateGizmos(false);\n      }\n    });\n\n    _defineProperty(this, \"onDoublePanMove\", () => {\n      if (this.enabled && this.enablePan && this.camera && this.domElement) {\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n\n        if (this._state != STATE.PAN) {\n          this.updateTbState(STATE.PAN, true);\n\n          this._startCursorPosition.copy(this._currentCursorPosition);\n        }\n\n        const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true);\n        if (rayDir !== undefined) this._currentCursorPosition.copy(rayDir);\n        this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition, true));\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onDoublePanEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onRotateStart\", () => {\n      if (this.enabled && this.enableRotate) {\n        var _this$camera6;\n\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.ZROTATE, true); //this._startFingerRotation = event.rotation;\n\n        this._startFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n        this._currentFingerRotation = this._startFingerRotation;\n        (_this$camera6 = this.camera) === null || _this$camera6 === void 0 ? void 0 : _this$camera6.getWorldDirection(this._rotationAxis); //rotation axis\n\n        if (!this.enablePan && !this.enableZoom) {\n          this.activateGizmos(true);\n        }\n      }\n    });\n\n    _defineProperty(this, \"onRotateMove\", () => {\n      if (this.enabled && this.enableRotate && this.camera && this.domElement) {\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n        let rotationPoint;\n\n        if (this._state != STATE.ZROTATE) {\n          this.updateTbState(STATE.ZROTATE, true);\n          this._startFingerRotation = this._currentFingerRotation;\n        } //this._currentFingerRotation = event.rotation;\n\n\n        this._currentFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\n\n        if (!this.enablePan) {\n          rotationPoint = new Vector3().setFromMatrixPosition(this._gizmoMatrixState);\n        } else if (this.camera) {\n          var _this$unprojectOnTbPl3;\n\n          this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n          rotationPoint = (_this$unprojectOnTbPl3 = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)) === null || _this$unprojectOnTbPl3 === void 0 ? void 0 : _this$unprojectOnTbPl3.applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._v3_2);\n        }\n\n        const amount = MathUtils.DEG2RAD * (this._startFingerRotation - this._currentFingerRotation);\n\n        if (rotationPoint !== undefined) {\n          this.applyTransformMatrix(this.zRotate(rotationPoint, amount));\n        }\n\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onRotateEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.activateGizmos(false);\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onPinchStart\", () => {\n      if (this.enabled && this.enableZoom) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.SCALE, true);\n        this._startFingerDistance = this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]);\n        this._currentFingerDistance = this._startFingerDistance;\n        this.activateGizmos(false);\n      }\n    });\n\n    _defineProperty(this, \"onPinchMove\", () => {\n      if (this.enabled && this.enableZoom && this.domElement) {\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\n        const minDistance = 12; //minimum distance between fingers (in css pixels)\n\n        if (this._state != STATE.SCALE) {\n          this._startFingerDistance = this._currentFingerDistance;\n          this.updateTbState(STATE.SCALE, true);\n        }\n\n        this._currentFingerDistance = Math.max(this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]), minDistance * this._devPxRatio);\n        const amount = this._currentFingerDistance / this._startFingerDistance;\n        let scalePoint;\n\n        if (!this.enablePan) {\n          scalePoint = this._gizmos.position;\n        } else {\n          var _this$camera7, _this$camera8;\n\n          if (((_this$camera7 = this.camera) === null || _this$camera7 === void 0 ? void 0 : _this$camera7.type) === 'OrthographicCamera') {\n            var _this$unprojectOnTbPl4;\n\n            scalePoint = (_this$unprojectOnTbPl4 = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)) === null || _this$unprojectOnTbPl4 === void 0 ? void 0 : _this$unprojectOnTbPl4.applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\n          } else if (((_this$camera8 = this.camera) === null || _this$camera8 === void 0 ? void 0 : _this$camera8.type) === 'PerspectiveCamera') {\n            var _this$unprojectOnTbPl5;\n\n            scalePoint = (_this$unprojectOnTbPl5 = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)) === null || _this$unprojectOnTbPl5 === void 0 ? void 0 : _this$unprojectOnTbPl5.applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\n          }\n        }\n\n        if (scalePoint !== undefined) {\n          this.applyTransformMatrix(this.applyScale(amount, scalePoint));\n        }\n\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onPinchEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_endEvent);\n    });\n\n    _defineProperty(this, \"onTriplePanStart\", () => {\n      if (this.enabled && this.enableZoom && this.domElement) {\n        this.dispatchEvent(_startEvent);\n        this.updateTbState(STATE.SCALE, true); //const center = event.center;\n\n        let clientX = 0;\n        let clientY = 0;\n        const nFingers = this._touchCurrent.length;\n\n        for (let i = 0; i < nFingers; i++) {\n          clientX += this._touchCurrent[i].clientX;\n          clientY += this._touchCurrent[i].clientY;\n        }\n\n        this.setCenter(clientX / nFingers, clientY / nFingers);\n\n        this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n        this._currentCursorPosition.copy(this._startCursorPosition);\n      }\n    });\n\n    _defineProperty(this, \"onTriplePanMove\", () => {\n      if (this.enabled && this.enableZoom && this.camera && this.domElement) {\n        //\t  fov / 2\n        //\t\t|\\\n        //\t\t| \\\n        //\t\t|  \\\n        //\tx\t|\t\\\n        //\t\t| \t \\\n        //\t\t| \t  \\\n        //\t\t| _ _ _\\\n        //\t\t\ty\n        //const center = event.center;\n        let clientX = 0;\n        let clientY = 0;\n        const nFingers = this._touchCurrent.length;\n\n        for (let i = 0; i < nFingers; i++) {\n          clientX += this._touchCurrent[i].clientX;\n          clientY += this._touchCurrent[i].clientY;\n        }\n\n        this.setCenter(clientX / nFingers, clientY / nFingers);\n        const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\n\n        this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\n\n        const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\n        let size = 1;\n\n        if (movement < 0) {\n          size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\n        } else if (movement > 0) {\n          size = Math.pow(this.scaleFactor, movement * screenNotches);\n        }\n\n        this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n        const x = this._v3_1.distanceTo(this._gizmos.position);\n\n        let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\n        //check min and max distance\n\n        xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\n        const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5); //calculate new fov\n\n        let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\n\n        newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\n        const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n        size = x / newDistance;\n\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\n\n        this.setFov(newFov);\n        this.applyTransformMatrix(this.applyScale(size, this._v3_2, false)); //adjusting distance\n\n        const direction = this._gizmos.position.clone().sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\n\n        this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"onTriplePanEnd\", () => {\n      this.updateTbState(STATE.IDLE, false);\n      this.dispatchEvent(_endEvent); //this.dispatchEvent( _changeEvent );\n    });\n\n    _defineProperty(this, \"setCenter\", (clientX, clientY) => {\n      _center.x = clientX;\n      _center.y = clientY;\n    });\n\n    _defineProperty(this, \"initializeMouseActions\", () => {\n      this.setMouseAction('PAN', 0, 'CTRL');\n      this.setMouseAction('PAN', 2);\n      this.setMouseAction('ROTATE', 0);\n      this.setMouseAction('ZOOM', 'WHEEL');\n      this.setMouseAction('ZOOM', 1);\n      this.setMouseAction('FOV', 'WHEEL', 'SHIFT');\n      this.setMouseAction('FOV', 1, 'SHIFT');\n    });\n\n    _defineProperty(this, \"setMouseAction\", (operation, mouse, key = null) => {\n      const operationInput = ['PAN', 'ROTATE', 'ZOOM', 'FOV'];\n      const mouseInput = [0, 1, 2, 'WHEEL'];\n      const keyInput = ['CTRL', 'SHIFT', null];\n      let state;\n\n      if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {\n        //invalid parameters\n        return false;\n      }\n\n      if (mouse == 'WHEEL') {\n        if (operation != 'ZOOM' && operation != 'FOV') {\n          //cannot associate 2D operation to 1D input\n          return false;\n        }\n      }\n\n      switch (operation) {\n        case 'PAN':\n          state = STATE.PAN;\n          break;\n\n        case 'ROTATE':\n          state = STATE.ROTATE;\n          break;\n\n        case 'ZOOM':\n          state = STATE.SCALE;\n          break;\n\n        case 'FOV':\n          state = STATE.FOV;\n          break;\n      }\n\n      const action = {\n        operation: operation,\n        mouse: mouse,\n        key: key,\n        state: state\n      };\n\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        if (this.mouseActions[i].mouse == action.mouse && this.mouseActions[i].key == action.key) {\n          this.mouseActions.splice(i, 1, action);\n          return true;\n        }\n      }\n\n      this.mouseActions.push(action);\n      return true;\n    });\n\n    _defineProperty(this, \"getOpFromAction\", (mouse, key) => {\n      let action;\n\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n\n        if (action.mouse == mouse && action.key == key) {\n          return action.operation;\n        }\n      }\n\n      if (key) {\n        for (let i = 0; i < this.mouseActions.length; i++) {\n          action = this.mouseActions[i];\n\n          if (action.mouse == mouse && action.key == null) {\n            return action.operation;\n          }\n        }\n      }\n\n      return null;\n    });\n\n    _defineProperty(this, \"getOpStateFromAction\", (mouse, key) => {\n      let action;\n\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i];\n\n        if (action.mouse == mouse && action.key == key) {\n          return action.state;\n        }\n      }\n\n      if (key) {\n        for (let i = 0; i < this.mouseActions.length; i++) {\n          action = this.mouseActions[i];\n\n          if (action.mouse == mouse && action.key == null) {\n            return action.state;\n          }\n        }\n      }\n\n      return null;\n    });\n\n    _defineProperty(this, \"getAngle\", (p1, p2) => {\n      return Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180 / Math.PI;\n    });\n\n    _defineProperty(this, \"updateTouchEvent\", event => {\n      for (let i = 0; i < this._touchCurrent.length; i++) {\n        if (this._touchCurrent[i].pointerId == event.pointerId) {\n          this._touchCurrent.splice(i, 1, event);\n\n          break;\n        }\n      }\n    });\n\n    _defineProperty(this, \"calculateAngularSpeed\", (p0, p1, t0, t1) => {\n      const s = p1 - p0;\n      const t = (t1 - t0) / 1000;\n\n      if (t == 0) {\n        return 0;\n      }\n\n      return s / t;\n    });\n\n    _defineProperty(this, \"calculatePointersDistance\", (p0, p1) => {\n      return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2));\n    });\n\n    _defineProperty(this, \"calculateRotationAxis\", (vec1, vec2) => {\n      this._rotationMatrix.extractRotation(this._cameraMatrixState);\n\n      this._quat.setFromRotationMatrix(this._rotationMatrix);\n\n      this._rotationAxis.crossVectors(vec1, vec2).applyQuaternion(this._quat);\n\n      return this._rotationAxis.normalize().clone();\n    });\n\n    _defineProperty(this, \"calculateTbRadius\", camera => {\n      const factor = 0.67;\n      const distance = camera.position.distanceTo(this._gizmos.position);\n\n      if (camera.type == 'PerspectiveCamera') {\n        const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5; //vertical fov/2 in radians\n\n        const halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV)); //horizontal fov/2 in radians\n\n        return Math.tan(Math.min(halfFovV, halfFovH)) * distance * factor;\n      } else if (camera.type == 'OrthographicCamera') {\n        return Math.min(camera.top, camera.right) * factor;\n      }\n    });\n\n    _defineProperty(this, \"focus\", (point, size, amount = 1) => {\n      if (this.camera) {\n        const focusPoint = point.clone(); //move center of camera (along with gizmos) towards point of interest\n\n        focusPoint.sub(this._gizmos.position).multiplyScalar(amount);\n\n        this._translationMatrix.makeTranslation(focusPoint.x, focusPoint.y, focusPoint.z);\n\n        const gizmoStateTemp = this._gizmoMatrixState.clone();\n\n        this._gizmoMatrixState.premultiply(this._translationMatrix);\n\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n        const cameraStateTemp = this._cameraMatrixState.clone();\n\n        this._cameraMatrixState.premultiply(this._translationMatrix);\n\n        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale); //apply zoom\n\n\n        if (this.enableZoom) {\n          this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\n        }\n\n        this._gizmoMatrixState.copy(gizmoStateTemp);\n\n        this._cameraMatrixState.copy(cameraStateTemp);\n      }\n    });\n\n    _defineProperty(this, \"drawGrid\", () => {\n      if (this.scene) {\n        var _this$camera9, _this$camera10;\n\n        const color = 0x888888;\n        const multiplier = 3;\n        let size, divisions, maxLength, tick;\n\n        if (((_this$camera9 = this.camera) === null || _this$camera9 === void 0 ? void 0 : _this$camera9.type) === 'OrthographicCamera') {\n          const width = this.camera.right - this.camera.left;\n          const height = this.camera.bottom - this.camera.top;\n          maxLength = Math.max(width, height);\n          tick = maxLength / 20;\n          size = maxLength / this.camera.zoom * multiplier;\n          divisions = size / tick * this.camera.zoom;\n        } else if (((_this$camera10 = this.camera) === null || _this$camera10 === void 0 ? void 0 : _this$camera10.type) === 'PerspectiveCamera') {\n          const distance = this.camera.position.distanceTo(this._gizmos.position);\n          const halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5;\n          const halfFovH = Math.atan(this.camera.aspect * Math.tan(halfFovV));\n          maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance * 2;\n          tick = maxLength / 20;\n          size = maxLength * multiplier;\n          divisions = size / tick;\n        }\n\n        if (this._grid == null && this.camera) {\n          this._grid = new GridHelper(size, divisions, color, color);\n\n          this._grid.position.copy(this._gizmos.position);\n\n          this._gridPosition.copy(this._grid.position);\n\n          this._grid.quaternion.copy(this.camera.quaternion);\n\n          this._grid.rotateX(Math.PI * 0.5);\n\n          this.scene.add(this._grid);\n        }\n      }\n    });\n\n    _defineProperty(this, \"connect\", domElement => {\n      // https://github.com/mrdoob/three.js/issues/20575\n      if (domElement === document) {\n        console.error('THREE.ArcballControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\n      }\n\n      this.domElement = domElement; // disables touch scroll\n      // touch-action needs to be defined for pointer events to work on mobile\n      // https://stackoverflow.com/a/48254578\n\n      this.domElement.style.touchAction = 'none';\n      this.domElement.addEventListener('contextmenu', this.onContextMenu);\n      this.domElement.addEventListener('pointerdown', this.onPointerDown);\n      this.domElement.addEventListener('pointercancel', this.onPointerCancel);\n      this.domElement.addEventListener('wheel', this.onWheel);\n    });\n\n    _defineProperty(this, \"dispose\", () => {\n      var _this$domElement, _this$domElement2, _this$domElement3, _this$domElement4, _this$scene;\n\n      if (this._animationId != -1) {\n        window.cancelAnimationFrame(this._animationId);\n      }\n\n      (_this$domElement = this.domElement) === null || _this$domElement === void 0 ? void 0 : _this$domElement.removeEventListener('pointerdown', this.onPointerDown);\n      (_this$domElement2 = this.domElement) === null || _this$domElement2 === void 0 ? void 0 : _this$domElement2.removeEventListener('pointercancel', this.onPointerCancel);\n      (_this$domElement3 = this.domElement) === null || _this$domElement3 === void 0 ? void 0 : _this$domElement3.removeEventListener('wheel', this.onWheel);\n      (_this$domElement4 = this.domElement) === null || _this$domElement4 === void 0 ? void 0 : _this$domElement4.removeEventListener('contextmenu', this.onContextMenu);\n      window.removeEventListener('pointermove', this.onPointerMove);\n      window.removeEventListener('pointerup', this.onPointerUp);\n      window.removeEventListener('resize', this.onWindowResize);\n      (_this$scene = this.scene) === null || _this$scene === void 0 ? void 0 : _this$scene.remove(this._gizmos);\n      this.disposeGrid();\n    });\n\n    _defineProperty(this, \"disposeGrid\", () => {\n      if (this._grid && this.scene) {\n        this.scene.remove(this._grid);\n        this._grid = null;\n      }\n    });\n\n    _defineProperty(this, \"easeOutCubic\", t => {\n      return 1 - Math.pow(1 - t, 3);\n    });\n\n    _defineProperty(this, \"activateGizmos\", isActive => {\n      for (const gizmo of this._gizmos.children) {\n        gizmo.material.setValues({\n          opacity: isActive ? 1 : 0.6\n        });\n      }\n    });\n\n    _defineProperty(this, \"getCursorNDC\", (cursorX, cursorY, canvas) => {\n      const canvasRect = canvas.getBoundingClientRect();\n\n      this._v2_1.setX((cursorX - canvasRect.left) / canvasRect.width * 2 - 1);\n\n      this._v2_1.setY((canvasRect.bottom - cursorY) / canvasRect.height * 2 - 1);\n\n      return this._v2_1.clone();\n    });\n\n    _defineProperty(this, \"getCursorPosition\", (cursorX, cursorY, canvas) => {\n      var _this$camera11;\n\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n\n      if (((_this$camera11 = this.camera) === null || _this$camera11 === void 0 ? void 0 : _this$camera11.type) === 'OrthographicCamera') {\n        this._v2_1.x *= (this.camera.right - this.camera.left) * 0.5;\n        this._v2_1.y *= (this.camera.top - this.camera.bottom) * 0.5;\n      }\n\n      return this._v2_1.clone();\n    });\n\n    _defineProperty(this, \"setCamera\", camera => {\n      if (camera) {\n        camera.lookAt(this.target);\n        camera.updateMatrix(); //setting state\n\n        if ((camera === null || camera === void 0 ? void 0 : camera.type) == 'PerspectiveCamera') {\n          this._fov0 = camera.fov;\n          this._fovState = camera.fov;\n        }\n\n        this._cameraMatrixState0.copy(camera.matrix);\n\n        this._cameraMatrixState.copy(this._cameraMatrixState0);\n\n        this._cameraProjectionState.copy(camera.projectionMatrix);\n\n        this._zoom0 = camera.zoom;\n        this._zoomState = this._zoom0;\n        this._initialNear = camera.near;\n        this._nearPos0 = camera.position.distanceTo(this.target) - camera.near;\n        this._nearPos = this._initialNear;\n        this._initialFar = camera.far;\n        this._farPos0 = camera.position.distanceTo(this.target) - camera.far;\n        this._farPos = this._initialFar;\n\n        this._up0.copy(camera.up);\n\n        this._upState.copy(camera.up);\n\n        this.camera = camera;\n        this.camera.updateProjectionMatrix(); //making gizmos\n\n        const tbRadius = this.calculateTbRadius(camera);\n\n        if (tbRadius !== undefined) {\n          this._tbRadius = tbRadius;\n        }\n\n        this.makeGizmos(this.target, this._tbRadius);\n      }\n    });\n\n    _defineProperty(this, \"makeGizmos\", (tbCenter, tbRadius) => {\n      // @ts-expect-error\n      const curve = new EllipseCurve(0, 0, tbRadius, tbRadius);\n      const points = curve.getPoints(this._curvePts); //geometry\n\n      const curveGeometry = new BufferGeometry().setFromPoints(points); //material\n\n      const curveMaterialX = new LineBasicMaterial({\n        color: 0xff8080,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      const curveMaterialY = new LineBasicMaterial({\n        color: 0x80ff80,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      const curveMaterialZ = new LineBasicMaterial({\n        color: 0x8080ff,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      }); //line\n\n      const gizmoX = new Line(curveGeometry, curveMaterialX);\n      const gizmoY = new Line(curveGeometry, curveMaterialY);\n      const gizmoZ = new Line(curveGeometry, curveMaterialZ);\n      const rotation = Math.PI * 0.5;\n      gizmoX.rotation.x = rotation;\n      gizmoY.rotation.y = rotation; //setting state\n\n      this._gizmoMatrixState0.identity().setPosition(tbCenter);\n\n      this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n\n      if (this.camera && this.camera.zoom != 1) {\n        //adapt gizmos size to camera zoom\n        const size = 1 / this.camera.zoom;\n\n        this._scaleMatrix.makeScale(size, size, size);\n\n        this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z);\n\n        this._gizmoMatrixState.premultiply(this._translationMatrix).premultiply(this._scaleMatrix);\n\n        this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z);\n\n        this._gizmoMatrixState.premultiply(this._translationMatrix);\n      }\n\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n      this._gizmos.clear();\n\n      this._gizmos.add(gizmoX);\n\n      this._gizmos.add(gizmoY);\n\n      this._gizmos.add(gizmoZ);\n    });\n\n    _defineProperty(this, \"onFocusAnim\", (time, point, cameraMatrix, gizmoMatrix) => {\n      if (this._timeStart == -1) {\n        //animation start\n        this._timeStart = time;\n      }\n\n      if (this._state == STATE.ANIMATION_FOCUS) {\n        const deltaTime = time - this._timeStart;\n        const animTime = deltaTime / this.focusAnimationTime;\n\n        this._gizmoMatrixState.copy(gizmoMatrix);\n\n        if (animTime >= 1) {\n          //animation end\n          this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n          this.focus(point, this.scaleFactor);\n          this._timeStart = -1;\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        } else {\n          const amount = this.easeOutCubic(animTime);\n          const size = 1 - amount + this.scaleFactor * amount;\n\n          this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n          this.focus(point, size, amount);\n          this.dispatchEvent(_changeEvent);\n          const self = this;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.onFocusAnim(t, point, cameraMatrix, gizmoMatrix.clone());\n          });\n        }\n      } else {\n        //interrupt animation\n        this._animationId = -1;\n        this._timeStart = -1;\n      }\n    });\n\n    _defineProperty(this, \"onRotationAnim\", (time, rotationAxis, w0) => {\n      if (this._timeStart == -1) {\n        //animation start\n        this._anglePrev = 0;\n        this._angleCurrent = 0;\n        this._timeStart = time;\n      }\n\n      if (this._state == STATE.ANIMATION_ROTATE) {\n        //w = w0 + alpha * t\n        const deltaTime = (time - this._timeStart) / 1000;\n        const w = w0 + -this.dampingFactor * deltaTime;\n\n        if (w > 0) {\n          //tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\n          this._angleCurrent = 0.5 * -this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0;\n          this.applyTransformMatrix(this.rotate(rotationAxis, this._angleCurrent));\n          this.dispatchEvent(_changeEvent);\n          const self = this;\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.onRotationAnim(t, rotationAxis, w0);\n          });\n        } else {\n          this._animationId = -1;\n          this._timeStart = -1;\n          this.updateTbState(STATE.IDLE, false);\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      } else {\n        //interrupt animation\n        this._animationId = -1;\n        this._timeStart = -1;\n\n        if (this._state != STATE.ROTATE) {\n          this.activateGizmos(false);\n          this.dispatchEvent(_changeEvent);\n        }\n      }\n    });\n\n    _defineProperty(this, \"pan\", (p0, p1, adjust = false) => {\n      if (this.camera) {\n        const movement = p0.clone().sub(p1);\n\n        if (this.camera.type === 'OrthographicCamera') {\n          //adjust movement amount\n          movement.multiplyScalar(1 / this.camera.zoom);\n        }\n\n        if (this.camera.type === 'PerspectiveCamera' && adjust) {\n          //adjust movement amount\n          this._v3_1.setFromMatrixPosition(this._cameraMatrixState0); //camera's initial position\n\n\n          this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0); //gizmo's initial position\n\n\n          const distanceFactor = this._v3_1.distanceTo(this._v3_2) / this.camera.position.distanceTo(this._gizmos.position);\n          movement.multiplyScalar(1 / distanceFactor);\n        }\n\n        this._v3_1.set(movement.x, movement.y, 0).applyQuaternion(this.camera.quaternion);\n\n        this._m4_1.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z);\n\n        this.setTransformationMatrices(this._m4_1, this._m4_1);\n      }\n\n      return _transformation;\n    });\n\n    _defineProperty(this, \"reset\", () => {\n      if (this.camera) {\n        this.camera.zoom = this._zoom0;\n\n        if (this.camera.type === 'PerspectiveCamera') {\n          this.camera.fov = this._fov0;\n        }\n\n        this.camera.near = this._nearPos;\n        this.camera.far = this._farPos;\n\n        this._cameraMatrixState.copy(this._cameraMatrixState0);\n\n        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n\n        this.camera.up.copy(this._up0);\n        this.camera.updateMatrix();\n        this.camera.updateProjectionMatrix();\n\n        this._gizmoMatrixState.copy(this._gizmoMatrixState0);\n\n        this._gizmoMatrixState0.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n        this._gizmos.updateMatrix();\n\n        const tbRadius = this.calculateTbRadius(this.camera);\n\n        if (tbRadius !== undefined) {\n          this._tbRadius = tbRadius;\n        }\n\n        this.makeGizmos(this._gizmos.position, this._tbRadius);\n        this.camera.lookAt(this._gizmos.position);\n        this.updateTbState(STATE.IDLE, false);\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    _defineProperty(this, \"rotate\", (axis, angle) => {\n      const point = this._gizmos.position; //rotation center\n\n      this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n\n      this._rotationMatrix.makeRotationAxis(axis, -angle); //rotate camera\n\n\n      this._m4_1.makeTranslation(point.x, point.y, point.z);\n\n      this._m4_1.multiply(this._rotationMatrix);\n\n      this._m4_1.multiply(this._translationMatrix);\n\n      this.setTransformationMatrices(this._m4_1);\n      return _transformation;\n    });\n\n    _defineProperty(this, \"copyState\", () => {\n      if (this.camera) {\n        var _this$camera12;\n\n        const state = JSON.stringify(((_this$camera12 = this.camera) === null || _this$camera12 === void 0 ? void 0 : _this$camera12.type) === 'OrthographicCamera' ? {\n          arcballState: {\n            cameraFar: this.camera.far,\n            cameraMatrix: this.camera.matrix,\n            cameraNear: this.camera.near,\n            cameraUp: this.camera.up,\n            cameraZoom: this.camera.zoom,\n            gizmoMatrix: this._gizmos.matrix\n          }\n        } : {\n          arcballState: {\n            cameraFar: this.camera.far,\n            cameraFov: this.camera.fov,\n            cameraMatrix: this.camera.matrix,\n            cameraNear: this.camera.near,\n            cameraUp: this.camera.up,\n            cameraZoom: this.camera.zoom,\n            gizmoMatrix: this._gizmos.matrix\n          }\n        });\n        navigator.clipboard.writeText(state);\n      }\n    });\n\n    _defineProperty(this, \"pasteState\", () => {\n      const self = this;\n      navigator.clipboard.readText().then(function resolved(value) {\n        self.setStateFromJSON(value);\n      });\n    });\n\n    _defineProperty(this, \"saveState\", () => {\n      if (!this.camera) return;\n\n      this._cameraMatrixState0.copy(this.camera.matrix);\n\n      this._gizmoMatrixState0.copy(this._gizmos.matrix);\n\n      this._nearPos = this.camera.near;\n      this._farPos = this.camera.far;\n      this._zoom0 = this.camera.zoom;\n\n      this._up0.copy(this.camera.up);\n\n      if (this.camera.type === 'PerspectiveCamera') {\n        this._fov0 = this.camera.fov;\n      }\n    });\n\n    _defineProperty(this, \"applyScale\", (size, point, scaleGizmos = true) => {\n      if (!this.camera) return;\n      const scalePoint = point.clone();\n      let sizeInverse = 1 / size;\n\n      if (this.camera.type === 'OrthographicCamera') {\n        //camera zoom\n        this.camera.zoom = this._zoomState;\n        this.camera.zoom *= size; //check min and max zoom\n\n        if (this.camera.zoom > this.maxZoom) {\n          this.camera.zoom = this.maxZoom;\n          sizeInverse = this._zoomState / this.maxZoom;\n        } else if (this.camera.zoom < this.minZoom) {\n          this.camera.zoom = this.minZoom;\n          sizeInverse = this._zoomState / this.minZoom;\n        }\n\n        this.camera.updateProjectionMatrix();\n\n        this._v3_1.setFromMatrixPosition(this._gizmoMatrixState); //gizmos position\n        //scale gizmos so they appear in the same spot having the same dimension\n\n\n        this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n\n        this._translationMatrix.makeTranslation(-this._v3_1.x, -this._v3_1.y, -this._v3_1.z);\n\n        this._m4_2.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z).multiply(this._scaleMatrix);\n\n        this._m4_2.multiply(this._translationMatrix); //move camera and gizmos to obtain pinch effect\n\n\n        scalePoint.sub(this._v3_1);\n        const amount = scalePoint.clone().multiplyScalar(sizeInverse);\n        scalePoint.sub(amount);\n\n        this._m4_1.makeTranslation(scalePoint.x, scalePoint.y, scalePoint.z);\n\n        this._m4_2.premultiply(this._m4_1);\n\n        this.setTransformationMatrices(this._m4_1, this._m4_2);\n        return _transformation;\n      }\n\n      if (this.camera.type === 'PerspectiveCamera') {\n        this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\n\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState); //move camera\n\n\n        let distance = this._v3_1.distanceTo(scalePoint);\n\n        let amount = distance - distance * sizeInverse; //check min and max distance\n\n        const newDistance = distance - amount;\n\n        if (newDistance < this.minDistance) {\n          sizeInverse = this.minDistance / distance;\n          amount = distance - distance * sizeInverse;\n        } else if (newDistance > this.maxDistance) {\n          sizeInverse = this.maxDistance / distance;\n          amount = distance - distance * sizeInverse;\n        }\n\n        let direction = scalePoint.clone().sub(this._v3_1).normalize().multiplyScalar(amount);\n\n        this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n\n        if (scaleGizmos) {\n          //scale gizmos so they appear in the same spot having the same dimension\n          const pos = this._v3_2;\n          distance = pos.distanceTo(scalePoint);\n          amount = distance - distance * sizeInverse;\n          direction = scalePoint.clone().sub(this._v3_2).normalize().multiplyScalar(amount);\n\n          this._translationMatrix.makeTranslation(pos.x, pos.y, pos.z);\n\n          this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n\n          this._m4_2.makeTranslation(direction.x, direction.y, direction.z).multiply(this._translationMatrix);\n\n          this._m4_2.multiply(this._scaleMatrix);\n\n          this._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z);\n\n          this._m4_2.multiply(this._translationMatrix);\n\n          this.setTransformationMatrices(this._m4_1, this._m4_2);\n        } else {\n          this.setTransformationMatrices(this._m4_1);\n        }\n\n        return _transformation;\n      }\n    });\n\n    _defineProperty(this, \"setFov\", value => {\n      var _this$camera13;\n\n      if (((_this$camera13 = this.camera) === null || _this$camera13 === void 0 ? void 0 : _this$camera13.type) === 'PerspectiveCamera') {\n        this.camera.fov = MathUtils.clamp(value, this.minFov, this.maxFov);\n        this.camera.updateProjectionMatrix();\n      }\n    });\n\n    _defineProperty(this, \"setTarget\", (x, y, z) => {\n      if (this.camera) {\n        this.target.set(x, y, z);\n\n        this._gizmos.position.set(x, y, z); //for correct radius calculation\n\n\n        const tbRadius = this.calculateTbRadius(this.camera);\n\n        if (tbRadius !== undefined) {\n          this._tbRadius = tbRadius;\n        }\n\n        this.makeGizmos(this.target, this._tbRadius);\n        this.camera.lookAt(this.target);\n      }\n    });\n\n    _defineProperty(this, \"zRotate\", (point, angle) => {\n      this._rotationMatrix.makeRotationAxis(this._rotationAxis, angle);\n\n      this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n\n      this._m4_1.makeTranslation(point.x, point.y, point.z);\n\n      this._m4_1.multiply(this._rotationMatrix);\n\n      this._m4_1.multiply(this._translationMatrix);\n\n      this._v3_1.setFromMatrixPosition(this._gizmoMatrixState).sub(point); //vector from rotation center to gizmos position\n\n\n      this._v3_2.copy(this._v3_1).applyAxisAngle(this._rotationAxis, angle); //apply rotation\n\n\n      this._v3_2.sub(this._v3_1);\n\n      this._m4_2.makeTranslation(this._v3_2.x, this._v3_2.y, this._v3_2.z);\n\n      this.setTransformationMatrices(this._m4_1, this._m4_2);\n      return _transformation;\n    });\n\n    _defineProperty(this, \"unprojectOnObj\", (cursor, camera) => {\n      if (!this.scene) return null;\n      const raycaster = new Raycaster();\n      raycaster.near = camera.near;\n      raycaster.far = camera.far;\n      raycaster.setFromCamera(cursor, camera);\n      const intersect = raycaster.intersectObjects(this.scene.children, true);\n\n      for (let i = 0; i < intersect.length; i++) {\n        if (intersect[i].object.uuid != this._gizmos.uuid && intersect[i].face) {\n          return intersect[i].point.clone();\n        }\n      }\n\n      return null;\n    });\n\n    _defineProperty(this, \"unprojectOnTbSurface\", (camera, cursorX, cursorY, canvas, tbRadius) => {\n      if (camera.type == 'OrthographicCamera') {\n        this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\n\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\n\n        const x2 = Math.pow(this._v2_1.x, 2);\n        const y2 = Math.pow(this._v2_1.y, 2);\n        const r2 = Math.pow(this._tbRadius, 2);\n\n        if (x2 + y2 <= r2 * 0.5) {\n          //intersection with sphere\n          this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)));\n        } else {\n          //intersection with hyperboloid\n          this._v3_1.setZ(r2 * 0.5 / Math.sqrt(x2 + y2));\n        }\n\n        return this._v3_1;\n      }\n\n      if (camera.type == 'PerspectiveCamera') {\n        //unproject cursor on the near plane\n        this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\n\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\n\n        this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n\n        const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n\n\n        const cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\n        const radius2 = Math.pow(tbRadius, 2); //\t  camera\n        //\t\t|\\\n        //\t\t| \\\n        //\t\t|  \\\n        //\th\t|\t\\\n        //\t\t| \t \\\n        //\t\t| \t  \\\n        //\t_ _ | _ _ _\\ _ _  near plane\n        //\t\t\tl\n\n        const h = this._v3_1.z;\n        const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\n\n        if (l == 0) {\n          //ray aligned with camera\n          rayDir.set(this._v3_1.x, this._v3_1.y, tbRadius);\n          return rayDir;\n        }\n\n        const m = h / l;\n        const q = cameraGizmoDistance;\n        /*\n         * calculate intersection point between unprojected ray and trackball surface\n         *|y = m * x + q\n         *|x^2 + y^2 = r^2\n         *\n         * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\n         */\n\n        let a = Math.pow(m, 2) + 1;\n        let b = 2 * m * q;\n        let c = Math.pow(q, 2) - radius2;\n        let delta = Math.pow(b, 2) - 4 * a * c;\n\n        if (delta >= 0) {\n          //intersection with sphere\n          this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n\n          this._v2_1.setY(m * this._v2_1.x + q);\n\n          const angle = MathUtils.RAD2DEG * this._v2_1.angle();\n\n          if (angle >= 45) {\n            //if angle between intersection point and X' axis is >= 45°, return that point\n            //otherwise, calculate intersection point with hyperboloid\n            const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n            rayDir.multiplyScalar(rayLength);\n            rayDir.z += cameraGizmoDistance;\n            return rayDir;\n          }\n        } //intersection with hyperboloid\n\n        /*\n         *|y = m * x + q\n         *|y = (1 / x) * (r^2 / 2)\n         *\n         * m * x^2 + q * x - r^2 / 2 = 0\n         */\n\n\n        a = m;\n        b = q;\n        c = -radius2 * 0.5;\n        delta = Math.pow(b, 2) - 4 * a * c;\n\n        this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n\n        this._v2_1.setY(m * this._v2_1.x + q);\n\n        const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\n        rayDir.multiplyScalar(rayLength);\n        rayDir.z += cameraGizmoDistance;\n        return rayDir;\n      }\n    });\n\n    _defineProperty(this, \"unprojectOnTbPlane\", (camera, cursorX, cursorY, canvas, initialDistance = false) => {\n      if (camera.type == 'OrthographicCamera') {\n        this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\n\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\n\n        return this._v3_1.clone();\n      }\n\n      if (camera.type == 'PerspectiveCamera') {\n        this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas)); //unproject cursor on the near plane\n\n\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\n\n        this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n\n        const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\n        //\t  camera\n        //\t\t|\\\n        //\t\t| \\\n        //\t\t|  \\\n        //\th\t|\t\\\n        //\t\t| \t \\\n        //\t\t| \t  \\\n        //\t_ _ | _ _ _\\ _ _  near plane\n        //\t\t\tl\n\n\n        const h = this._v3_1.z;\n        const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\n        let cameraGizmoDistance;\n\n        if (initialDistance) {\n          cameraGizmoDistance = this._v3_1.setFromMatrixPosition(this._cameraMatrixState0).distanceTo(this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0));\n        } else {\n          cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\n        }\n        /*\n         * calculate intersection point between unprojected ray and the plane\n         *|y = mx + q\n         *|y = 0\n         *\n         * x = -q/m\n         */\n\n\n        if (l == 0) {\n          //ray aligned with camera\n          rayDir.set(0, 0, 0);\n          return rayDir;\n        }\n\n        const m = h / l;\n        const q = cameraGizmoDistance;\n        const x = -q / m;\n        const rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2));\n        rayDir.multiplyScalar(rayLength);\n        rayDir.z = 0;\n        return rayDir;\n      }\n    });\n\n    _defineProperty(this, \"updateMatrixState\", () => {\n      if (!this.camera) return; //update camera and gizmos state\n\n      this._cameraMatrixState.copy(this.camera.matrix);\n\n      this._gizmoMatrixState.copy(this._gizmos.matrix);\n\n      if (this.camera.type === 'OrthographicCamera') {\n        this._cameraProjectionState.copy(this.camera.projectionMatrix);\n\n        this.camera.updateProjectionMatrix();\n        this._zoomState = this.camera.zoom;\n      }\n\n      if (this.camera.type === 'PerspectiveCamera') {\n        this._fovState = this.camera.fov;\n      }\n    });\n\n    _defineProperty(this, \"updateTbState\", (newState, updateMatrices) => {\n      this._state = newState;\n\n      if (updateMatrices) {\n        this.updateMatrixState();\n      }\n    });\n\n    _defineProperty(this, \"update\", () => {\n      const EPS = 0.000001; // Update target and gizmos state\n\n      if (!this.target.equals(this._currentTarget) && this.camera) {\n        this._gizmos.position.set(this.target.x, this.target.y, this.target.z); //for correct radius calculation\n\n\n        const tbRadius = this.calculateTbRadius(this.camera);\n\n        if (tbRadius !== undefined) {\n          this._tbRadius = tbRadius;\n        }\n\n        this.makeGizmos(this.target, this._tbRadius);\n\n        this._currentTarget.copy(this.target);\n      }\n\n      if (!this.camera) return; //check min/max parameters\n\n      if (this.camera.type === 'OrthographicCamera') {\n        //check zoom\n        if (this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom) {\n          const newZoom = MathUtils.clamp(this.camera.zoom, this.minZoom, this.maxZoom);\n          this.applyTransformMatrix(this.applyScale(newZoom / this.camera.zoom, this._gizmos.position, true));\n        }\n      }\n\n      if (this.camera.type === 'PerspectiveCamera') {\n        //check distance\n        const distance = this.camera.position.distanceTo(this._gizmos.position);\n\n        if (distance > this.maxDistance + EPS || distance < this.minDistance - EPS) {\n          const newDistance = MathUtils.clamp(distance, this.minDistance, this.maxDistance);\n          this.applyTransformMatrix(this.applyScale(newDistance / distance, this._gizmos.position));\n          this.updateMatrixState();\n        } //check fov\n\n\n        if (this.camera.fov < this.minFov || this.camera.fov > this.maxFov) {\n          this.camera.fov = MathUtils.clamp(this.camera.fov, this.minFov, this.maxFov);\n          this.camera.updateProjectionMatrix();\n        }\n\n        const oldRadius = this._tbRadius;\n        const tbRadius = this.calculateTbRadius(this.camera);\n\n        if (tbRadius !== undefined) {\n          this._tbRadius = tbRadius;\n        }\n\n        if (oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS) {\n          const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\n          const newRadius = this._tbRadius / scale; // @ts-expect-error\n\n          const curve = new EllipseCurve(0, 0, newRadius, newRadius);\n          const points = curve.getPoints(this._curvePts);\n          const curveGeometry = new BufferGeometry().setFromPoints(points);\n\n          for (const gizmo in this._gizmos.children) {\n            const child = this._gizmos.children[gizmo];\n            child.geometry = curveGeometry;\n          }\n        }\n      }\n\n      this.camera.lookAt(this._gizmos.position);\n    });\n\n    _defineProperty(this, \"setStateFromJSON\", json => {\n      const state = JSON.parse(json);\n\n      if (state.arcballState && this.camera) {\n        this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements);\n\n        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n\n        this.camera.up.copy(state.arcballState.cameraUp);\n        this.camera.near = state.arcballState.cameraNear;\n        this.camera.far = state.arcballState.cameraFar;\n        this.camera.zoom = state.arcballState.cameraZoom;\n\n        if (this.camera.type === 'PerspectiveCamera') {\n          this.camera.fov = state.arcballState.cameraFov;\n        }\n\n        this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements);\n\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n        this.camera.updateMatrix();\n        this.camera.updateProjectionMatrix();\n\n        this._gizmos.updateMatrix();\n\n        const tbRadius = this.calculateTbRadius(this.camera);\n\n        if (tbRadius !== undefined) {\n          this._tbRadius = tbRadius;\n        }\n\n        const gizmoTmp = new Matrix4().copy(this._gizmoMatrixState0);\n        this.makeGizmos(this._gizmos.position, this._tbRadius);\n\n        this._gizmoMatrixState0.copy(gizmoTmp);\n\n        this.camera.lookAt(this._gizmos.position);\n        this.updateTbState(STATE.IDLE, false);\n        this.dispatchEvent(_changeEvent);\n      }\n    });\n\n    this.camera = null;\n    this.domElement = _domElement;\n    this.scene = scene;\n    this.mouseActions = [];\n    this._mouseOp = null; //global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\n\n    this._v2_1 = new Vector2();\n    this._v3_1 = new Vector3();\n    this._v3_2 = new Vector3();\n    this._m4_1 = new Matrix4();\n    this._m4_2 = new Matrix4();\n    this._quat = new Quaternion(); //transformation matrices\n\n    this._translationMatrix = new Matrix4(); //matrix for translation operation\n\n    this._rotationMatrix = new Matrix4(); //matrix for rotation operation\n\n    this._scaleMatrix = new Matrix4(); //matrix for scaling operation\n\n    this._rotationAxis = new Vector3(); //axis for rotate operation\n    //camera state\n\n    this._cameraMatrixState = new Matrix4();\n    this._cameraProjectionState = new Matrix4();\n    this._fovState = 1;\n    this._upState = new Vector3();\n    this._zoomState = 1;\n    this._nearPos = 0;\n    this._farPos = 0;\n    this._gizmoMatrixState = new Matrix4(); //initial values\n\n    this._up0 = new Vector3();\n    this._zoom0 = 1;\n    this._fov0 = 0;\n    this._initialNear = 0;\n    this._nearPos0 = 0;\n    this._initialFar = 0;\n    this._farPos0 = 0;\n    this._cameraMatrixState0 = new Matrix4();\n    this._gizmoMatrixState0 = new Matrix4(); //pointers array\n\n    this._button = -1;\n    this._touchStart = [];\n    this._touchCurrent = [];\n    this._input = INPUT.NONE; //two fingers touch interaction\n\n    this._switchSensibility = 32; //minimum movement to be performed to fire single pan start after the second finger has been released\n\n    this._startFingerDistance = 0; //distance between two fingers\n\n    this._currentFingerDistance = 0;\n    this._startFingerRotation = 0; //amount of rotation performed with two fingers\n\n    this._currentFingerRotation = 0; //double tap\n\n    this._devPxRatio = 0;\n    this._downValid = true;\n    this._nclicks = 0;\n    this._downEvents = [];\n    this._clickStart = 0; //first click time\n\n    this._maxDownTime = 250;\n    this._maxInterval = 300;\n    this._posThreshold = 24;\n    this._movementThreshold = 24; //cursor positions\n\n    this._currentCursorPosition = new Vector3();\n    this._startCursorPosition = new Vector3(); //grid\n\n    this._grid = null; //grid to be visualized during pan operation\n\n    this._gridPosition = new Vector3(); //gizmos\n\n    this._gizmos = new Group();\n    this._curvePts = 128; //animations\n\n    this._timeStart = -1; //initial time\n\n    this._animationId = -1; //focus animation\n\n    this.focusAnimationTime = 500; //duration of focus animation in ms\n    //rotate animation\n\n    this._timePrev = 0; //time at which previous rotate operation has been detected\n\n    this._timeCurrent = 0; //time at which current rotate operation has been detected\n\n    this._anglePrev = 0; //angle of previous rotation\n\n    this._angleCurrent = 0; //angle of current rotation\n\n    this._cursorPosPrev = new Vector3(); //cursor position when previous rotate operation has been detected\n\n    this._cursorPosCurr = new Vector3(); //cursor position when current rotate operation has been detected\n\n    this._wPrev = 0; //angular velocity of the previous rotate operation\n\n    this._wCurr = 0; //angular velocity of the current rotate operation\n    //parameters\n\n    this.adjustNearFar = false;\n    this.scaleFactor = 1.1; //zoom/distance multiplier\n\n    this.dampingFactor = 25;\n    this.wMax = 20; //maximum angular velocity allowed\n\n    this.enableAnimations = true; //if animations should be performed\n\n    this.enableGrid = false; //if grid should be showed during pan operation\n\n    this.cursorZoom = false; //if wheel zoom should be cursor centered\n\n    this.minFov = 5;\n    this.maxFov = 90;\n    this.enabled = true;\n    this.enablePan = true;\n    this.enableRotate = true;\n    this.enableZoom = true;\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n    this.minZoom = 0;\n    this.maxZoom = Infinity; //trackball parameters\n\n    this.target = new Vector3(0, 0, 0);\n    this._currentTarget = new Vector3(0, 0, 0);\n    this._tbRadius = 1; //FSA\n\n    this._state = STATE.IDLE;\n    this.setCamera(_camera);\n\n    if (this.scene) {\n      this.scene.add(this._gizmos);\n    }\n\n    this._devPxRatio = window.devicePixelRatio;\n    this.initializeMouseActions();\n    if (this.domElement) this.connect(this.domElement);\n    window.addEventListener('resize', this.onWindowResize);\n  } //listeners\n\n\n  /**\n   * Apply a transformation matrix, to the camera and gizmos\n   * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n   */\n  applyTransformMatrix(transformation) {\n    if (transformation !== null && transformation !== void 0 && transformation.camera && this.camera) {\n      this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera);\n\n      this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n\n      this.camera.updateMatrix(); //update camera up vector\n\n      if (this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE) {\n        this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion);\n      }\n    }\n\n    if (transformation !== null && transformation !== void 0 && transformation.gizmos) {\n      this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos);\n\n      this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n\n      this._gizmos.updateMatrix();\n    }\n\n    if ((this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS) && this.camera) {\n      const tbRadius = this.calculateTbRadius(this.camera);\n\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius;\n      }\n\n      if (this.adjustNearFar) {\n        const cameraDistance = this.camera.position.distanceTo(this._gizmos.position);\n        const bb = new Box3();\n        bb.setFromObject(this._gizmos);\n        const sphere = new Sphere();\n        bb.getBoundingSphere(sphere);\n        const adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length());\n        const regularNearPosition = cameraDistance - this._initialNear;\n        const minNearPos = Math.min(adjustedNearPosition, regularNearPosition);\n        this.camera.near = cameraDistance - minNearPos;\n        const adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length());\n        const regularFarPosition = cameraDistance - this._initialFar;\n        const minFarPos = Math.min(adjustedFarPosition, regularFarPosition);\n        this.camera.far = cameraDistance - minFarPos;\n        this.camera.updateProjectionMatrix();\n      } else {\n        let update = false;\n\n        if (this.camera.near != this._initialNear) {\n          this.camera.near = this._initialNear;\n          update = true;\n        }\n\n        if (this.camera.far != this._initialFar) {\n          this.camera.far = this._initialFar;\n          update = true;\n        }\n\n        if (update) {\n          this.camera.updateProjectionMatrix();\n        }\n      }\n    }\n  }\n  /**\n   * Calculate the angular speed\n   * @param {Number} p0 Position at t0\n   * @param {Number} p1 Position at t1\n   * @param {Number} t0 Initial time in milliseconds\n   * @param {Number} t1 Ending time in milliseconds\n   */\n\n\n  /**\n   * Set gizmos visibility\n   * @param {Boolean} value Value of gizmos visibility\n   */\n  setGizmosVisible(value) {\n    this._gizmos.visible = value;\n    this.dispatchEvent(_changeEvent);\n  }\n  /**\n   * Creates the rotation gizmos matching trackball center and radius\n   * @param {Vector3} tbCenter The trackball center\n   * @param {number} tbRadius The trackball radius\n   */\n\n\n  /**\n   * Set values in transformation object\n   * @param {Matrix4} camera Transformation to be applied to the camera\n   * @param {Matrix4} gizmos Transformation to be applied to gizmos\n   */\n  setTransformationMatrices(camera = null, gizmos = null) {\n    if (camera) {\n      if (_transformation.camera) {\n        _transformation.camera.copy(camera);\n      } else {\n        _transformation.camera = camera.clone();\n      }\n    } else {\n      _transformation.camera = null;\n    }\n\n    if (gizmos) {\n      if (_transformation.gizmos) {\n        _transformation.gizmos.copy(gizmos);\n      } else {\n        _transformation.gizmos = gizmos.clone();\n      }\n    } else {\n      _transformation.gizmos = null;\n    }\n  }\n  /**\n   * Rotate camera around its direction axis passing by a given point by a given angle\n   * @param {Vector3} point The point where the rotation axis is passing trough\n   * @param {Number} angle Angle in radians\n   * @returns The computed transormation matix\n   */\n\n\n}\n\nexport { ArcballControls };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { OrthographicCamera, PlaneGeometry, Mesh } from 'three';\n\nclass Pass {\n  constructor() {\n    _defineProperty(this, \"enabled\", true);\n\n    _defineProperty(this, \"needsSwap\", true);\n\n    _defineProperty(this, \"clear\", false);\n\n    _defineProperty(this, \"renderToScreen\", false);\n  }\n\n  setSize(\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable no-unused-vars */\n  width, height) {}\n\n  render(\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n\n  /* eslint-disable no-unused-vars */\n  renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    console.error('THREE.Pass: .render() must be implemented in derived pass.');\n  }\n\n} // Helper for passes that need to fill the viewport with a single quad.\n\n\nclass FullScreenQuad {\n  constructor(material) {\n    _defineProperty(this, \"camera\", new OrthographicCamera(-1, 1, 1, -1, 0, 1));\n\n    _defineProperty(this, \"geometry\", new PlaneGeometry(2, 2));\n\n    _defineProperty(this, \"mesh\", void 0);\n\n    this.mesh = new Mesh(this.geometry, material);\n  }\n\n  get material() {\n    return this.mesh.material;\n  }\n\n  set material(value) {\n    this.mesh.material = value;\n  }\n\n  dispose() {\n    this.mesh.geometry.dispose();\n  }\n\n  render(renderer) {\n    renderer.render(this.mesh, this.camera);\n  }\n\n}\n\nexport { FullScreenQuad, Pass };\n", "/**\n * RGB Halftone shader for three.js.\n *\tNOTE:\n * \t\tShape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)\n *\t\tBlending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)\n */\nconst HalftoneShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    shape: {\n      value: 1\n    },\n    radius: {\n      value: 4\n    },\n    rotateR: {\n      value: Math.PI / 12 * 1\n    },\n    rotateG: {\n      value: Math.PI / 12 * 2\n    },\n    rotateB: {\n      value: Math.PI / 12 * 3\n    },\n    scatter: {\n      value: 0\n    },\n    width: {\n      value: 1\n    },\n    height: {\n      value: 1\n    },\n    blending: {\n      value: 1\n    },\n    blendingMode: {\n      value: 1\n    },\n    greyscale: {\n      value: false\n    },\n    disable: {\n      value: false\n    }\n  },\n  vertexShader: ['varying vec2 vUV;', 'void main() {', '\tvUV = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);', '}'].join('\\n'),\n  fragmentShader: ['#define SQRT2_MINUS_ONE 0.41421356', '#define SQRT2_HALF_MINUS_ONE 0.20710678', '#define PI2 6.28318531', '#define SHAPE_DOT 1', '#define SHAPE_ELLIPSE 2', '#define SHAPE_LINE 3', '#define SHAPE_SQUARE 4', '#define BLENDING_LINEAR 1', '#define BLENDING_MULTIPLY 2', '#define BLENDING_ADD 3', '#define BLENDING_LIGHTER 4', '#define BLENDING_DARKER 5', 'uniform sampler2D tDiffuse;', 'uniform float radius;', 'uniform float rotateR;', 'uniform float rotateG;', 'uniform float rotateB;', 'uniform float scatter;', 'uniform float width;', 'uniform float height;', 'uniform int shape;', 'uniform bool disable;', 'uniform float blending;', 'uniform int blendingMode;', 'varying vec2 vUV;', 'uniform bool greyscale;', 'const int samples = 8;', 'float blend( float a, float b, float t ) {', // linear blend\n  '\treturn a * ( 1.0 - t ) + b * t;', '}', 'float hypot( float x, float y ) {', // vector magnitude\n  '\treturn sqrt( x * x + y * y );', '}', 'float rand( vec2 seed ){', // get pseudo-random number\n  'return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );', '}', 'float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {', // apply shape-specific transforms\n  '\tfloat dist = hypot( coord.x - p.x, coord.y - p.y );', '\tfloat rad = channel;', '\tif ( shape == SHAPE_DOT ) {', '\t\trad = pow( abs( rad ), 1.125 ) * rad_max;', '\t} else if ( shape == SHAPE_ELLIPSE ) {', '\t\trad = pow( abs( rad ), 1.125 ) * rad_max;', '\t\tif ( dist != 0.0 ) {', '\t\t\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );', '\t\t\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;', '\t\t}', '\t} else if ( shape == SHAPE_LINE ) {', '\t\trad = pow( abs( rad ), 1.5) * rad_max;', '\t\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;', '\t\tdist = hypot( normal.x * dot_p, normal.y * dot_p );', '\t} else if ( shape == SHAPE_SQUARE ) {', '\t\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;', '\t\tfloat sin_t = abs( sin( theta ) );', '\t\tfloat cos_t = abs( cos( theta ) );', '\t\trad = pow( abs( rad ), 1.4 );', '\t\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );', '\t}', '\treturn rad - dist;', '}', 'struct Cell {', // grid sample positions\n  '\tvec2 normal;', '\tvec2 p1;', '\tvec2 p2;', '\tvec2 p3;', '\tvec2 p4;', '\tfloat samp2;', '\tfloat samp1;', '\tfloat samp3;', '\tfloat samp4;', '};', 'vec4 getSample( vec2 point ) {', // multi-sampled point\n  '\tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );', '\tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;', '\tfloat step = PI2 / float( samples );', '\tfloat dist = radius * 0.66;', '\tfor ( int i = 0; i < samples; ++i ) {', '\t\tfloat r = base + step * float( i );', '\t\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );', '\t\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );', '\t}', '\ttex /= float( samples ) + 1.0;', '\treturn tex;', '}', 'float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {', // get colour for given point\n  '\tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;', '\tif ( channel == 0 ) {', '\t\tc.samp1 = getSample( c.p1 ).r;', '\t\tc.samp2 = getSample( c.p2 ).r;', '\t\tc.samp3 = getSample( c.p3 ).r;', '\t\tc.samp4 = getSample( c.p4 ).r;', '\t} else if (channel == 1) {', '\t\tc.samp1 = getSample( c.p1 ).g;', '\t\tc.samp2 = getSample( c.p2 ).g;', '\t\tc.samp3 = getSample( c.p3 ).g;', '\t\tc.samp4 = getSample( c.p4 ).g;', '\t} else {', '\t\tc.samp1 = getSample( c.p1 ).b;', '\t\tc.samp3 = getSample( c.p3 ).b;', '\t\tc.samp2 = getSample( c.p2 ).b;', '\t\tc.samp4 = getSample( c.p4 ).b;', '\t}', '\tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );', '\tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );', '\tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );', '\tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );', '\tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;', '\tres = clamp( res, 0.0, 1.0 );', '\treturn res;', '}', 'Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {', // get containing cell\n  '\tCell c;', // calc grid\n  '\tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );', '\tfloat threshold = step * 0.5;', '\tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );', '\tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );', '\tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );', '\tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );', '\tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;', '\tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;', '\tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );', '\tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;', '\tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;', // get closest corner\n  '\tc.normal = n;', '\tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;', '\tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;', // scatter\n  '\tif ( scatter != 0.0 ) {', '\t\tfloat off_mag = scatter * threshold * 0.5;', '\t\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;', '\t\tc.p1.x += cos( off_angle ) * off_mag;', '\t\tc.p1.y += sin( off_angle ) * off_mag;', '\t}', // find corners\n  '\tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );', '\tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );', '\tc.p2.x = c.p1.x - n.x * normal_step;', '\tc.p2.y = c.p1.y - n.y * normal_step;', '\tc.p3.x = c.p1.x + n.y * line_step;', '\tc.p3.y = c.p1.y - n.x * line_step;', '\tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;', '\tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;', '\treturn c;', '}', 'float blendColour( float a, float b, float t ) {', // blend colours\n  '\tif ( blendingMode == BLENDING_LINEAR ) {', '\t\treturn blend( a, b, 1.0 - t );', '\t} else if ( blendingMode == BLENDING_ADD ) {', '\t\treturn blend( a, min( 1.0, a + b ), t );', '\t} else if ( blendingMode == BLENDING_MULTIPLY ) {', '\t\treturn blend( a, max( 0.0, a * b ), t );', '\t} else if ( blendingMode == BLENDING_LIGHTER ) {', '\t\treturn blend( a, max( a, b ), t );', '\t} else if ( blendingMode == BLENDING_DARKER ) {', '\t\treturn blend( a, min( a, b ), t );', '\t} else {', '\t\treturn blend( a, b, 1.0 - t );', '\t}', '}', 'void main() {', '\tif ( ! disable ) {', // setup\n  '\t\tvec2 p = vec2( vUV.x * width, vUV.y * height );', '\t\tvec2 origin = vec2( 0, 0 );', '\t\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;', // get channel samples\n  '\t\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );', '\t\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );', '\t\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );', '\t\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );', '\t\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );', '\t\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );', // blend with original\n  '\t\tvec4 colour = texture2D( tDiffuse, vUV );', '\t\tr = blendColour( r, colour.r, blending );', '\t\tg = blendColour( g, colour.g, blending );', '\t\tb = blendColour( b, colour.b, blending );', '\t\tif ( greyscale ) {', '\t\t\tr = g = b = (r + b + g) / 3.0;', '\t\t}', '\t\tgl_FragColor = vec4( r, g, b, 1.0 );', '\t} else {', '\t\tgl_FragColor = texture2D( tDiffuse, vUV );', '\t}', '}'].join('\\n')\n};\n\nexport { HalftoneShader };\n", "import { Vector2 } from 'three';\n\n/**\n * WebGL port of Subpixel Morphological Antialiasing (SMAA) v2.8\n * Preset: SMAA 1x Medium (with color edge detection)\n * https://github.com/iryoku/smaa/releases/tag/v2.8\n */\n\nconst SMAAEdgesShader = {\n  defines: {\n    SMAA_THRESHOLD: '0.1'\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2(1 / 1024, 1 / 512)\n    }\n  },\n  vertexShader: ['uniform vec2 resolution;', 'varying vec2 vUv;', 'varying vec4 vOffset[ 3 ];', 'void SMAAEdgeDetectionVS( vec2 texcoord ) {', '\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );', // WebGL port note: Changed sign in W component\n  '\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );', // WebGL port note: Changed sign in W component\n  '\tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );', // WebGL port note: Changed sign in W component\n  '}', 'void main() {', '\tvUv = uv;', '\tSMAAEdgeDetectionVS( vUv );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'varying vec4 vOffset[ 3 ];', 'vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {', '\tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );', // Calculate color deltas:\n  '\tvec4 delta;', '\tvec3 C = texture2D( colorTex, texcoord ).rgb;', '\tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;', '\tvec3 t = abs( C - Cleft );', '\tdelta.x = max( max( t.r, t.g ), t.b );', '\tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;', '\tt = abs( C - Ctop );', '\tdelta.y = max( max( t.r, t.g ), t.b );', // We do the usual threshold:\n  '\tvec2 edges = step( threshold, delta.xy );', // Then discard if there is no edge:\n  '\tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )', '\t\tdiscard;', // Calculate right and bottom deltas:\n  '\tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;', '\tt = abs( C - Cright );', '\tdelta.z = max( max( t.r, t.g ), t.b );', '\tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;', '\tt = abs( C - Cbottom );', '\tdelta.w = max( max( t.r, t.g ), t.b );', // Calculate the maximum delta in the direct neighborhood:\n  '\tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );', // Calculate left-left and top-top deltas:\n  '\tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;', '\tt = abs( C - Cleftleft );', '\tdelta.z = max( max( t.r, t.g ), t.b );', '\tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;', '\tt = abs( C - Ctoptop );', '\tdelta.w = max( max( t.r, t.g ), t.b );', // Calculate the final maximum delta:\n  '\tmaxDelta = max( max( maxDelta, delta.z ), delta.w );', // Local contrast adaptation in action:\n  '\tedges.xy *= step( 0.5 * maxDelta, delta.xy );', '\treturn vec4( edges, 0.0, 0.0 );', '}', 'void main() {', '\tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );', '}'].join('\\n')\n};\nconst SMAAWeightsShader = {\n  defines: {\n    SMAA_MAX_SEARCH_STEPS: '8',\n    SMAA_AREATEX_MAX_DISTANCE: '16',\n    SMAA_AREATEX_PIXEL_SIZE: '( 1.0 / vec2( 160.0, 560.0 ) )',\n    SMAA_AREATEX_SUBTEX_SIZE: '( 1.0 / 7.0 )'\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tArea: {\n      value: null\n    },\n    tSearch: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2(1 / 1024, 1 / 512)\n    }\n  },\n  vertexShader: ['uniform vec2 resolution;', 'varying vec2 vUv;', 'varying vec4 vOffset[ 3 ];', 'varying vec2 vPixcoord;', 'void SMAABlendingWeightCalculationVS( vec2 texcoord ) {', '\tvPixcoord = texcoord / resolution;', // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n  '\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );', // WebGL port note: Changed sign in Y and W components\n  '\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );', // WebGL port note: Changed sign in Y and W components\n  // And these for the searches, they indicate the ends of the loops:\n  '\tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );', '}', 'void main() {', '\tvUv = uv;', '\tSMAABlendingWeightCalculationVS( vUv );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tArea;', 'uniform sampler2D tSearch;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'varying vec4 vOffset[3];', 'varying vec2 vPixcoord;', '#if __VERSION__ == 100', 'vec2 round( vec2 x ) {', '\treturn sign( x ) * floor( abs( x ) + 0.5 );', '}', '#endif', 'float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {', // Not required if searchTex accesses are set to point:\n  // float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\n  // e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\n  //     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\n  '\te.r = bias + e.r * scale;', '\treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;', '}', 'float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\n  /**\n   * @PSEUDO_GATHER4\n   * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n   * sample between edge, thus fetching four edges in a row.\n   * Sampling with different offsets in each direction allows to disambiguate\n   * which edges are active from the four fetched ones.\n   */\n  '\tvec2 e = vec2( 0.0, 1.0 );', '\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {', // WebGL port note: Changed while to for\n  '\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;', '\t\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;', '\t\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;', '\t}', // We correct the previous (-0.25, -0.125) offset we applied:\n  '\ttexcoord.x += 0.25 * resolution.x;', // The searches are bias by 1, so adjust the coords accordingly:\n  '\ttexcoord.x += resolution.x;', // Disambiguate the length added by the last step:\n  '\ttexcoord.x += 2.0 * resolution.x;', // Undo last step\n  '\ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);', '\treturn texcoord.x;', '}', 'float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {', '\tvec2 e = vec2( 0.0, 1.0 );', '\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {', // WebGL port note: Changed while to for\n  '\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;', '\t\ttexcoord += vec2( 2.0, 0.0 ) * resolution;', '\t\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;', '\t}', '\ttexcoord.x -= 0.25 * resolution.x;', '\ttexcoord.x -= resolution.x;', '\ttexcoord.x -= 2.0 * resolution.x;', '\ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );', '\treturn texcoord.x;', '}', 'float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {', '\tvec2 e = vec2( 1.0, 0.0 );', '\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {', // WebGL port note: Changed while to for\n  '\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;', '\t\ttexcoord += vec2( 0.0, 2.0 ) * resolution;', // WebGL port note: Changed sign\n  '\t\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;', '\t}', '\ttexcoord.y -= 0.25 * resolution.y;', // WebGL port note: Changed sign\n  '\ttexcoord.y -= resolution.y;', // WebGL port note: Changed sign\n  '\ttexcoord.y -= 2.0 * resolution.y;', // WebGL port note: Changed sign\n  '\ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );', // WebGL port note: Changed sign\n  '\treturn texcoord.y;', '}', 'float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {', '\tvec2 e = vec2( 1.0, 0.0 );', '\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {', // WebGL port note: Changed while to for\n  '\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;', '\t\ttexcoord -= vec2( 0.0, 2.0 ) * resolution;', // WebGL port note: Changed sign\n  '\t\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;', '\t}', '\ttexcoord.y += 0.25 * resolution.y;', // WebGL port note: Changed sign\n  '\ttexcoord.y += resolution.y;', // WebGL port note: Changed sign\n  '\ttexcoord.y += 2.0 * resolution.y;', // WebGL port note: Changed sign\n  '\ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );', // WebGL port note: Changed sign\n  '\treturn texcoord.y;', '}', 'vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {', // Rounding prevents precision errors of bilinear filtering:\n  '\tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;', // We do a scale and bias for mapping to texel space:\n  '\ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );', // Move to proper place, according to the subpixel offset:\n  '\ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;', '\treturn texture2D( areaTex, texcoord, 0.0 ).rg;', '}', 'vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {', '\tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );', '\tvec2 e = texture2D( edgesTex, texcoord ).rg;', '\tif ( e.g > 0.0 ) {', // Edge at north\n  '\t\tvec2 d;', // Find the distance to the left:\n  '\t\tvec2 coords;', '\t\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );', '\t\tcoords.y = offset[ 1 ].y;', // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\n  '\t\td.x = coords.x;', // Now fetch the left crossing edges, two at a time using bilinear\n  // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n  // discern what value each edge has:\n  '\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;', // Find the distance to the right:\n  '\t\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );', '\t\td.y = coords.x;', // We want the distances to be in pixel units (doing this here allow to\n  // better interleave arithmetic and memory accesses):\n  '\t\td = d / resolution.x - pixcoord.x;', // SMAAArea below needs a sqrt, as the areas texture is compressed\n  // quadratically:\n  '\t\tvec2 sqrt_d = sqrt( abs( d ) );', // Fetch the right crossing edges:\n  '\t\tcoords.y -= 1.0 * resolution.y;', // WebGL port note: Added\n  '\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;', // Ok, we know how this pattern looks like, now it is time for getting\n  // the actual area:\n  '\t\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );', '\t}', '\tif ( e.r > 0.0 ) {', // Edge at west\n  '\t\tvec2 d;', // Find the distance to the top:\n  '\t\tvec2 coords;', '\t\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );', '\t\tcoords.x = offset[ 0 ].x;', // offset[1].x = texcoord.x - 0.25 * resolution.x;\n  '\t\td.x = coords.y;', // Fetch the top crossing edges:\n  '\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;', // Find the distance to the bottom:\n  '\t\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );', '\t\td.y = coords.y;', // We want the distances to be in pixel units:\n  '\t\td = d / resolution.y - pixcoord.y;', // SMAAArea below needs a sqrt, as the areas texture is compressed\n  // quadratically:\n  '\t\tvec2 sqrt_d = sqrt( abs( d ) );', // Fetch the bottom crossing edges:\n  '\t\tcoords.y -= 1.0 * resolution.y;', // WebGL port note: Added\n  '\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;', // Get the area for this direction:\n  '\t\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );', '\t}', '\treturn weights;', '}', 'void main() {', '\tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );', '}'].join('\\n')\n};\nconst SMAABlendShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tColor: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2(1 / 1024, 1 / 512)\n    }\n  },\n  vertexShader: ['uniform vec2 resolution;', 'varying vec2 vUv;', 'varying vec4 vOffset[ 2 ];', 'void SMAANeighborhoodBlendingVS( vec2 texcoord ) {', '\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );', // WebGL port note: Changed sign in W component\n  '\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );', // WebGL port note: Changed sign in W component\n  '}', 'void main() {', '\tvUv = uv;', '\tSMAANeighborhoodBlendingVS( vUv );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform sampler2D tColor;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'varying vec4 vOffset[ 2 ];', 'vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {', // Fetch the blending weights for current pixel:\n  '\tvec4 a;', '\ta.xz = texture2D( blendTex, texcoord ).xz;', '\ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;', '\ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;', // Is there any blending weight with a value greater than 0.0?\n  '\tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {', '\t\treturn texture2D( colorTex, texcoord, 0.0 );', '\t} else {', // Up to 4 lines can be crossing a pixel (one through each edge). We\n  // favor blending by choosing the line with the maximum weight for each\n  // direction:\n  '\t\tvec2 offset;', '\t\toffset.x = a.a > a.b ? a.a : -a.b;', // left vs. right\n  '\t\toffset.y = a.g > a.r ? -a.g : a.r;', // top vs. bottom // WebGL port note: Changed signs\n  // Then we go in the direction that has the maximum weight:\n  '\t\tif ( abs( offset.x ) > abs( offset.y )) {', // horizontal vs. vertical\n  '\t\t\toffset.y = 0.0;', '\t\t} else {', '\t\t\toffset.x = 0.0;', '\t\t}', // Fetch the opposite color and lerp by hand:\n  '\t\tvec4 C = texture2D( colorTex, texcoord, 0.0 );', '\t\ttexcoord += sign( offset ) * resolution;', '\t\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );', '\t\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );', // WebGL port note: Added gamma correction\n  '\t\tC.xyz = pow(C.xyz, vec3(2.2));', '\t\tCop.xyz = pow(Cop.xyz, vec3(2.2));', '\t\tvec4 mixed = mix(C, Cop, s);', '\t\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));', '\t\treturn mixed;', '\t}', '}', 'void main() {', '\tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );', '}'].join('\\n')\n};\n\nexport { SMAABlendShader, SMAAEdgesShader, SMAAWeightsShader };\n", "/**\n * Film grain & scanlines shader\n *\n * - ported from HLSL to WebGL / GLSL\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n *\n * Screen Space Static Postprocessor\n *\n * Produces an analogue noise overlay similar to a film grain / TV static\n *\n * Original implementation and noise algorithm\n * Pat 'Hawthorne' Shearon\n *\n * Optimized scanlines + noise version with intensity scaling\n * Georg 'Leviathan' Steinrohder\n *\n * This version is provided under a Creative Commons Attribution 3.0 License\n * http://creativecommons.org/licenses/by/3.0/\n */\nconst FilmShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    time: {\n      value: 0.0\n    },\n    nIntensity: {\n      value: 0.5\n    },\n    sIntensity: {\n      value: 0.05\n    },\n    sCount: {\n      value: 4096\n    },\n    grayscale: {\n      value: 1\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', // control parameter\n  'uniform float time;', 'uniform bool grayscale;', // noise effect intensity value (0 = no effect, 1 = full effect)\n  'uniform float nIntensity;', // scanlines effect intensity value (0 = no effect, 1 = full effect)\n  'uniform float sIntensity;', // scanlines effect count value (0 = no effect, 4096 = full effect)\n  'uniform float sCount;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', // sample the source\n  '\tvec4 cTextureScreen = texture2D( tDiffuse, vUv );', // make some noise\n  '\tfloat dx = rand( vUv + time );', // add noise\n  '\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );', // get us a sine and cosine\n  '\tvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );', // add scanlines\n  '\tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;', // interpolate between source and result by intensity\n  '\tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );', // convert to grayscale if desired\n  '\tif( grayscale ) {', '\t\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );', '\t}', '\tgl_FragColor =  vec4( cResult, cTextureScreen.a );', '}'].join('\\n')\n};\n\nexport { FilmShader };\n", "/**\n * Full-screen textured quad shader\n */\nconst CopyShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    opacity: {\n      value: 1.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float opacity;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tgl_FragColor = opacity * texel;', '}'].join('\\n')\n};\n\nexport { CopyShader };\n", "import { Vector2, Matrix4 } from 'three';\n\n/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\n\nconst SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    tNoise: {\n      value: null\n    },\n    kernel: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    kernelRadius: {\n      value: 8\n    },\n    minDistance: {\n      value: 0.005\n    },\n    maxDistance: {\n      value: 0.05\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform sampler2D tNormal;', 'uniform sampler2D tDepth;', 'uniform sampler2D tNoise;', 'uniform vec3 kernel[ KERNEL_SIZE ];', 'uniform vec2 resolution;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float kernelRadius;', 'uniform float minDistance;', // avoid artifacts caused by neighbour fragments with minimal depth difference\n  'uniform float maxDistance;', // avoid the influence of fragments which are too far away\n  'varying vec2 vUv;', '#include <packing>', 'float getDepth( const in vec2 screenPosition ) {', '\treturn texture2D( tDepth, screenPosition ).x;', '}', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec2 screenPosition ) {', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tfloat viewZ = getViewZ( depth );', '\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );', '\tvec3 viewNormal = getViewNormal( vUv );', ' vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );', '\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;', // compute matrix used to reorient a kernel vector\n  '\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );', '\tvec3 bitangent = cross( viewNormal, tangent );', '\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );', ' float occlusion = 0.0;', ' for ( int i = 0; i < KERNEL_SIZE; i ++ ) {', '\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];', // reorient sample vector in view space\n  '\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );', // calculate sample point\n  '\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );', // project point and calculate NDC\n  '\t\tsamplePointNDC /= samplePointNDC.w;', '\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;', // compute uv coordinates\n  '\t\tfloat realDepth = getLinearDepth( samplePointUv );', // get linear depth from depth texture\n  '\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );', // compute linear depth of the sample view Z value\n  '\t\tfloat delta = sampleDepth - realDepth;', '\t\tif ( delta > minDistance && delta < maxDistance ) {', // if fragment is before sample point, increase occlusion\n  '\t\t\tocclusion += 1.0;', '\t\t}', '\t}', '\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );', '\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );', '}'].join('\\n')\n};\nconst SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'varying vec2 vUv;', '#include <packing>', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'void main() {', '\tfloat depth = getLinearDepth( vUv );', '\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );', '}'].join('\\n')\n};\nconst SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\tvec2 texelSize = ( 1.0 / resolution );', '\tfloat result = 0.0;', '\tfor ( int i = - 2; i <= 2; i ++ ) {', '\t\tfor ( int j = - 2; j <= 2; j ++ ) {', '\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;', '\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;', '\t\t}', '\t}', '\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );', '}'].join('\\n')\n};\n\nexport { SSAOBlurShader, SSAODepthShader, SSAOShader };\n", "import { DepthTexture, DepthStencilFormat, UnsignedInt248Type, WebGLRenderTarget, NearestFilter, ShaderMaterial, UniformsUtils, NoBlending, MeshNormalMaterial, DstColorFactor, ZeroFactor, AddEquation, DstAlphaFactor, Color, LuminanceFormat, CustomBlending, Vector3, MathUtils, DataTexture, RedFormat, FloatType, RepeatWrapping } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { SimplexNoise } from '../math/SimplexNoise.js';\nimport { SSAOShader, SSAOBlurShader, SSAODepthShader } from '../shaders/SSAOShader.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nclass SSAOPass extends Pass {\n  constructor(scene, camera, width, height) {\n    super();\n    this.width = width !== undefined ? width : 512;\n    this.height = height !== undefined ? height : 512;\n    this.clear = true;\n    this.camera = camera;\n    this.scene = scene;\n    this.kernelRadius = 8;\n    this.kernelSize = 32;\n    this.kernel = [];\n    this.noiseTexture = null;\n    this.output = 0;\n    this.minDistance = 0.005;\n    this.maxDistance = 0.1;\n    this._visibilityCache = new Map(); //\n\n    this.generateSampleKernel();\n    this.generateRandomKernelRotations(); // beauty render target\n\n    const depthTexture = new DepthTexture();\n    depthTexture.format = DepthStencilFormat;\n    depthTexture.type = UnsignedInt248Type;\n    this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height); // normal render target with depth buffer\n\n    this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n      minFilter: NearestFilter,\n      magFilter: NearestFilter,\n      depthTexture: depthTexture\n    }); // ssao render target\n\n    this.ssaoRenderTarget = new WebGLRenderTarget(this.width, this.height);\n    this.blurRenderTarget = this.ssaoRenderTarget.clone(); // ssao material\n\n    if (SSAOShader === undefined) {\n      console.error('THREE.SSAOPass: The pass relies on SSAOShader.');\n    }\n\n    this.ssaoMaterial = new ShaderMaterial({\n      defines: Object.assign({}, SSAOShader.defines),\n      uniforms: UniformsUtils.clone(SSAOShader.uniforms),\n      vertexShader: SSAOShader.vertexShader,\n      fragmentShader: SSAOShader.fragmentShader,\n      blending: NoBlending\n    });\n    this.ssaoMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n    this.ssaoMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture;\n    this.ssaoMaterial.uniforms['tDepth'].value = this.normalRenderTarget.depthTexture;\n    this.ssaoMaterial.uniforms['tNoise'].value = this.noiseTexture;\n    this.ssaoMaterial.uniforms['kernel'].value = this.kernel;\n    this.ssaoMaterial.uniforms['cameraNear'].value = this.camera.near;\n    this.ssaoMaterial.uniforms['cameraFar'].value = this.camera.far;\n    this.ssaoMaterial.uniforms['resolution'].value.set(this.width, this.height);\n    this.ssaoMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);\n    this.ssaoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse); // normal material\n\n    this.normalMaterial = new MeshNormalMaterial();\n    this.normalMaterial.blending = NoBlending; // blur material\n\n    this.blurMaterial = new ShaderMaterial({\n      defines: Object.assign({}, SSAOBlurShader.defines),\n      uniforms: UniformsUtils.clone(SSAOBlurShader.uniforms),\n      vertexShader: SSAOBlurShader.vertexShader,\n      fragmentShader: SSAOBlurShader.fragmentShader\n    });\n    this.blurMaterial.uniforms['tDiffuse'].value = this.ssaoRenderTarget.texture;\n    this.blurMaterial.uniforms['resolution'].value.set(this.width, this.height); // material for rendering the depth\n\n    this.depthRenderMaterial = new ShaderMaterial({\n      defines: Object.assign({}, SSAODepthShader.defines),\n      uniforms: UniformsUtils.clone(SSAODepthShader.uniforms),\n      vertexShader: SSAODepthShader.vertexShader,\n      fragmentShader: SSAODepthShader.fragmentShader,\n      blending: NoBlending\n    });\n    this.depthRenderMaterial.uniforms['tDepth'].value = this.normalRenderTarget.depthTexture;\n    this.depthRenderMaterial.uniforms['cameraNear'].value = this.camera.near;\n    this.depthRenderMaterial.uniforms['cameraFar'].value = this.camera.far; // material for rendering the content of a render target\n\n    this.copyMaterial = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(CopyShader.uniforms),\n      vertexShader: CopyShader.vertexShader,\n      fragmentShader: CopyShader.fragmentShader,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false,\n      blendSrc: DstColorFactor,\n      blendDst: ZeroFactor,\n      blendEquation: AddEquation,\n      blendSrcAlpha: DstAlphaFactor,\n      blendDstAlpha: ZeroFactor,\n      blendEquationAlpha: AddEquation\n    });\n    this.fsQuad = new FullScreenQuad(null);\n    this.originalClearColor = new Color();\n  }\n\n  dispose() {\n    // dispose render targets\n    this.beautyRenderTarget.dispose();\n    this.normalRenderTarget.dispose();\n    this.ssaoRenderTarget.dispose();\n    this.blurRenderTarget.dispose(); // dispose materials\n\n    this.normalMaterial.dispose();\n    this.blurMaterial.dispose();\n    this.copyMaterial.dispose();\n    this.depthRenderMaterial.dispose(); // dipsose full screen quad\n\n    this.fsQuad.dispose();\n  }\n\n  render(renderer, writeBuffer\n  /*, readBuffer, deltaTime, maskActive */\n  ) {\n    if (renderer.capabilities.isWebGL2 === false) this.noiseTexture.format = LuminanceFormat; // render beauty\n\n    renderer.setRenderTarget(this.beautyRenderTarget);\n    renderer.clear();\n    renderer.render(this.scene, this.camera); // render normals and depth (honor only meshes, points and lines do not contribute to SSAO)\n\n    this.overrideVisibility();\n    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0);\n    this.restoreVisibility(); // render SSAO\n\n    this.ssaoMaterial.uniforms['kernelRadius'].value = this.kernelRadius;\n    this.ssaoMaterial.uniforms['minDistance'].value = this.minDistance;\n    this.ssaoMaterial.uniforms['maxDistance'].value = this.maxDistance;\n    this.renderPass(renderer, this.ssaoMaterial, this.ssaoRenderTarget); // render blur\n\n    this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget); // output result to screen\n\n    switch (this.output) {\n      case SSAOPass.OUTPUT.SSAO:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.ssaoRenderTarget.texture;\n        this.copyMaterial.blending = NoBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      case SSAOPass.OUTPUT.Blur:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget.texture;\n        this.copyMaterial.blending = NoBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      case SSAOPass.OUTPUT.Beauty:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n        this.copyMaterial.blending = NoBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      case SSAOPass.OUTPUT.Depth:\n        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      case SSAOPass.OUTPUT.Normal:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;\n        this.copyMaterial.blending = NoBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      case SSAOPass.OUTPUT.Default:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n        this.copyMaterial.blending = NoBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget.texture;\n        this.copyMaterial.blending = CustomBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      default:\n        console.warn('THREE.SSAOPass: Unknown output type.');\n    }\n  }\n\n  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\n    // save original state\n    renderer.getClearColor(this.originalClearColor);\n    const originalClearAlpha = renderer.getClearAlpha();\n    const originalAutoClear = renderer.autoClear;\n    renderer.setRenderTarget(renderTarget); // setup pass state\n\n    renderer.autoClear = false;\n\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor);\n      renderer.setClearAlpha(clearAlpha || 0.0);\n      renderer.clear();\n    }\n\n    this.fsQuad.material = passMaterial;\n    this.fsQuad.render(renderer); // restore original state\n\n    renderer.autoClear = originalAutoClear;\n    renderer.setClearColor(this.originalClearColor);\n    renderer.setClearAlpha(originalClearAlpha);\n  }\n\n  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n    renderer.getClearColor(this.originalClearColor);\n    const originalClearAlpha = renderer.getClearAlpha();\n    const originalAutoClear = renderer.autoClear;\n    renderer.setRenderTarget(renderTarget);\n    renderer.autoClear = false;\n    clearColor = overrideMaterial.clearColor || clearColor;\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;\n\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor);\n      renderer.setClearAlpha(clearAlpha || 0.0);\n      renderer.clear();\n    }\n\n    this.scene.overrideMaterial = overrideMaterial;\n    renderer.render(this.scene, this.camera);\n    this.scene.overrideMaterial = null; // restore original state\n\n    renderer.autoClear = originalAutoClear;\n    renderer.setClearColor(this.originalClearColor);\n    renderer.setClearAlpha(originalClearAlpha);\n  }\n\n  setSize(width, height) {\n    this.width = width;\n    this.height = height;\n    this.beautyRenderTarget.setSize(width, height);\n    this.ssaoRenderTarget.setSize(width, height);\n    this.normalRenderTarget.setSize(width, height);\n    this.blurRenderTarget.setSize(width, height);\n    this.ssaoMaterial.uniforms['resolution'].value.set(width, height);\n    this.ssaoMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);\n    this.ssaoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);\n    this.blurMaterial.uniforms['resolution'].value.set(width, height);\n  }\n\n  generateSampleKernel() {\n    const kernelSize = this.kernelSize;\n    const kernel = this.kernel;\n\n    for (let i = 0; i < kernelSize; i++) {\n      const sample = new Vector3();\n      sample.x = Math.random() * 2 - 1;\n      sample.y = Math.random() * 2 - 1;\n      sample.z = Math.random();\n      sample.normalize();\n      let scale = i / kernelSize;\n      scale = MathUtils.lerp(0.1, 1, scale * scale);\n      sample.multiplyScalar(scale);\n      kernel.push(sample);\n    }\n  }\n\n  generateRandomKernelRotations() {\n    const width = 4,\n          height = 4;\n\n    if (SimplexNoise === undefined) {\n      console.error('THREE.SSAOPass: The pass relies on SimplexNoise.');\n    }\n\n    const simplex = new SimplexNoise();\n    const size = width * height;\n    const data = new Float32Array(size);\n\n    for (let i = 0; i < size; i++) {\n      const x = Math.random() * 2 - 1;\n      const y = Math.random() * 2 - 1;\n      const z = 0;\n      data[i] = simplex.noise3d(x, y, z);\n    }\n\n    this.noiseTexture = new DataTexture(data, width, height, RedFormat, FloatType);\n    this.noiseTexture.wrapS = RepeatWrapping;\n    this.noiseTexture.wrapT = RepeatWrapping;\n    this.noiseTexture.needsUpdate = true;\n  }\n\n  overrideVisibility() {\n    const scene = this.scene;\n    const cache = this._visibilityCache;\n    scene.traverse(function (object) {\n      cache.set(object, object.visible);\n      if (object.isPoints || object.isLine) object.visible = false;\n    });\n  }\n\n  restoreVisibility() {\n    const scene = this.scene;\n    const cache = this._visibilityCache;\n    scene.traverse(function (object) {\n      const visible = cache.get(object);\n      object.visible = visible;\n    });\n    cache.clear();\n  }\n\n}\n\nSSAOPass.OUTPUT = {\n  Default: 0,\n  SSAO: 1,\n  Blur: 2,\n  Beauty: 3,\n  Depth: 4,\n  Normal: 5\n};\n\nexport { SSAOPass };\n", "/**\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html\n */\nconst BokehShader = {\n  defines: {\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tColor: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    focus: {\n      value: 1.0\n    },\n    aspect: {\n      value: 1.0\n    },\n    aperture: {\n      value: 0.025\n    },\n    maxblur: {\n      value: 0.01\n    },\n    nearClip: {\n      value: 1.0\n    },\n    farClip: {\n      value: 1000.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', 'uniform sampler2D tColor;', 'uniform sampler2D tDepth;', 'uniform float maxblur;', // max blur amount\n  'uniform float aperture;', // aperture - bigger values for shallower depth of field\n  'uniform float nearClip;', 'uniform float farClip;', 'uniform float focus;', 'uniform float aspect;', '#include <packing>', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );', '\t#else', '\treturn orthographicDepthToViewZ( depth, nearClip, farClip );', '\t#endif', '}', 'void main() {', '\tvec2 aspectcorrect = vec2( 1.0, aspect );', '\tfloat viewZ = getViewZ( getDepth( vUv ) );', '\tfloat factor = ( focus + viewZ );', // viewZ is <= 0, so this is a difference equation\n  '\tvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );', '\tvec2 dofblur9 = dofblur * 0.9;', '\tvec2 dofblur7 = dofblur * 0.7;', '\tvec2 dofblur4 = dofblur * 0.4;', '\tvec4 col = vec4( 0.0 );', '\tcol += texture2D( tColor, vUv.xy );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );', '\tgl_FragColor = col / 41.0;', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\n};\n\nexport { BokehShader };\n", "import { UniformsUtils, ShaderMaterial } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nvar TexturePass = function (map, opacity) {\n  if (CopyShader === undefined) console.error('THREE.TexturePass relies on CopyShader');\n  var shader = CopyShader;\n  this.map = map;\n  this.opacity = opacity !== undefined ? opacity : 1.0;\n  this.uniforms = UniformsUtils.clone(shader.uniforms);\n  this.material = new ShaderMaterial({\n    uniforms: this.uniforms,\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    depthTest: false,\n    depthWrite: false\n  });\n  this.needsSwap = false;\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nTexturePass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: TexturePass,\n  render: function (renderer, writeBuffer, readBuffer\n  /*, deltaTime, maskActive */\n  ) {\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    this.fsQuad.material = this.material;\n    this.uniforms['opacity'].value = this.opacity;\n    this.uniforms['tDiffuse'].value = this.map;\n    this.material.transparent = this.opacity < 1.0;\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n    if (this.clear) renderer.clear();\n    this.fsQuad.render(renderer);\n    renderer.autoClear = oldAutoClear;\n  }\n});\n\nexport { TexturePass };\n", "/**\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\nconst LuminosityShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tfloat l = linearToRelativeLuminance( texel.rgb );', '\tgl_FragColor = vec4( l, l, l, texel.w );', '}'].join('\\n')\n};\n\nexport { LuminosityShader };\n", "/**\n * Full-screen tone-mapping shader based on http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf\n */\nconst ToneMapShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    averageLuminance: {\n      value: 1.0\n    },\n    luminanceMap: {\n      value: null\n    },\n    maxLuminance: {\n      value: 16.0\n    },\n    minLuminance: {\n      value: 0.01\n    },\n    middleGrey: {\n      value: 0.6\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'uniform float middleGrey;', 'uniform float minLuminance;', 'uniform float maxLuminance;', '#ifdef ADAPTED_LUMINANCE', '\tuniform sampler2D luminanceMap;', '#else', '\tuniform float averageLuminance;', '#endif', 'vec3 ToneMap( vec3 vColor ) {', '\t#ifdef ADAPTED_LUMINANCE', // Get the calculated average luminance\n  '\t\tfloat fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;', '\t#else', '\t\tfloat fLumAvg = averageLuminance;', '\t#endif', // Calculate the luminance of the current pixel\n  '\tfloat fLumPixel = linearToRelativeLuminance( vColor );', // Apply the modified operator (Eq. 4)\n  '\tfloat fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );', '\tfloat fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);', '\treturn fLumCompressed * vColor;', '}', 'void main() {', '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tgl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );', '}'].join('\\n')\n};\n\nexport { ToneMapShader };\n", "import { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, LinearMipmapLinearFilter, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityShader } from '../shaders/LuminosityShader.js';\nimport { ToneMapShader } from '../shaders/ToneMapShader.js';\n\n/**\n * Generate a texture that represents the luminosity of the current scene, adapted over time\n * to simulate the optic nerve responding to the amount of light it is receiving.\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n *\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n */\n\nvar AdaptiveToneMappingPass = function (adaptive, resolution) {\n  this.resolution = resolution !== undefined ? resolution : 256;\n  this.needsInit = true;\n  this.adaptive = adaptive !== undefined ? !!adaptive : true;\n  this.luminanceRT = null;\n  this.previousLuminanceRT = null;\n  this.currentLuminanceRT = null;\n  if (CopyShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: NoBlending,\n    depthTest: false\n  });\n  if (LuminosityShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on LuminosityShader');\n  this.materialLuminance = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n    vertexShader: LuminosityShader.vertexShader,\n    fragmentShader: LuminosityShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.adaptLuminanceShader = {\n    defines: {\n      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\n    },\n    uniforms: {\n      lastLum: {\n        value: null\n      },\n      currentLum: {\n        value: null\n      },\n      minLuminance: {\n        value: 0.01\n      },\n      delta: {\n        value: 0.016\n      },\n      tau: {\n        value: 1.0\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D lastLum;', 'uniform sampler2D currentLum;', 'uniform float minLuminance;', 'uniform float delta;', 'uniform float tau;', 'void main() {', '\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );', '\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );', '\tfloat fLastLum = max( minLuminance, lastLum.r );', '\tfloat fCurrentLum = max( minLuminance, currentLum.r );', //The adaption seems to work better in extreme lighting differences\n    //if the input luminance is squared.\n    '\tfCurrentLum *= fCurrentLum;', // Adapt the luminance using Pattanaik's technique\n    '\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));', // \"fAdaptedLum = sqrt(fAdaptedLum);\",\n    '\tgl_FragColor.r = fAdaptedLum;', '}'].join('\\n')\n  };\n  this.materialAdaptiveLum = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n    vertexShader: this.adaptLuminanceShader.vertexShader,\n    fragmentShader: this.adaptLuminanceShader.fragmentShader,\n    defines: Object.assign({}, this.adaptLuminanceShader.defines),\n    blending: NoBlending\n  });\n  if (ToneMapShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on ToneMapShader');\n  this.materialToneMap = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n    vertexShader: ToneMapShader.vertexShader,\n    fragmentShader: ToneMapShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nAdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: AdaptiveToneMappingPass,\n  render: function (renderer, writeBuffer, readBuffer, deltaTime\n  /*, maskActive*/\n  ) {\n    if (this.needsInit) {\n      this.reset(renderer);\n      this.luminanceRT.texture.type = readBuffer.texture.type;\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n      this.needsInit = false;\n    }\n\n    if (this.adaptive) {\n      //Render the luminance of the current scene into a render target with mipmapping enabled\n      this.fsQuad.material = this.materialLuminance;\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n      renderer.setRenderTarget(this.currentLuminanceRT);\n      this.fsQuad.render(renderer); //Use the new luminance values, the previous luminance and the frame delta to\n      //adapt the luminance over time.\n\n      this.fsQuad.material = this.materialAdaptiveLum;\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n      renderer.setRenderTarget(this.luminanceRT);\n      this.fsQuad.render(renderer); //Copy the new adapted luminance value so that it can be used by the next frame.\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n      renderer.setRenderTarget(this.previousLuminanceRT);\n      this.fsQuad.render(renderer);\n    }\n\n    this.fsQuad.material = this.materialToneMap;\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  },\n  reset: function () {\n    // render targets\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    var pars = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat\n    }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\n\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l';\n    this.luminanceRT.texture.generateMipmaps = false;\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl';\n    this.previousLuminanceRT.texture.generateMipmaps = false; // We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\n    pars.minFilter = LinearMipmapLinearFilter;\n    pars.generateMipmaps = true;\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl';\n\n    if (this.adaptive) {\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } //Put something in the adaptive luminance texture so that the scene can render initially\n\n\n    this.fsQuad.material = new MeshBasicMaterial({\n      color: 0x777777\n    });\n    this.materialLuminance.needsUpdate = true;\n    this.materialAdaptiveLum.needsUpdate = true;\n    this.materialToneMap.needsUpdate = true; // renderer.render( this.scene, this.camera, this.luminanceRT );\n    // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n    // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n  },\n  setAdaptive: function (adaptive) {\n    if (adaptive) {\n      this.adaptive = true;\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } else {\n      this.adaptive = false;\n      delete this.materialToneMap.defines['ADAPTED_LUMINANCE'];\n      this.materialToneMap.uniforms.luminanceMap.value = null;\n    }\n\n    this.materialToneMap.needsUpdate = true;\n  },\n  setAdaptionRate: function (rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n    }\n  },\n  setMinLuminance: function (minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n    }\n  },\n  setMaxLuminance: function (maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n    }\n  },\n  setAverageLuminance: function (avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n    }\n  },\n  setMiddleGrey: function (middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n    }\n  },\n  dispose: function () {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose();\n    }\n\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose();\n    }\n\n    if (this.materialCopy) {\n      this.materialCopy.dispose();\n    }\n\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose();\n    }\n  }\n});\n\nexport { AdaptiveToneMappingPass };\n", "import { Color } from 'three';\n\n/**\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nconst LuminosityHighPassShader = {\n  shaderID: 'luminosityHighPass',\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    luminosityThreshold: {\n      value: 1.0\n    },\n    smoothWidth: {\n      value: 1.0\n    },\n    defaultColor: {\n      value: new Color(0x000000)\n    },\n    defaultOpacity: {\n      value: 0.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec3 defaultColor;', 'uniform float defaultOpacity;', 'uniform float luminosityThreshold;', 'uniform float smoothWidth;', 'varying vec2 vUv;', 'void main() {', '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tvec3 luma = vec3( 0.299, 0.587, 0.114 );', '\tfloat v = dot( texel.xyz, luma );', '\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );', '\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );', '\tgl_FragColor = mix( outputColor, texel, alpha );', '}'].join('\\n')\n};\n\nexport { LuminosityHighPassShader };\n", "import { Vector2, Color, WebGLRenderTarget, UniformsUtils, ShaderMaterial, Vector3, AdditiveBlending, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\n\nvar UnrealBloomPass = function (resolution, strength, radius, threshold) {\n  this.strength = strength !== undefined ? strength : 1;\n  this.radius = radius;\n  this.threshold = threshold;\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256); // create color only once here, reuse it later inside the render function\n\n  this.clearColor = new Color(0, 0, 0); // render targets\n\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  this.renderTargetsHorizontal = [];\n  this.renderTargetsVertical = [];\n  this.nMips = 5;\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n  this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n  this.renderTargetBright.texture.generateMipmaps = false;\n\n  for (let i = 0; i < this.nMips; i++) {\n    var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n    renderTargetHorizonal.texture.generateMipmaps = false;\n    this.renderTargetsHorizontal.push(renderTargetHorizonal);\n    var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n    renderTargetVertical.texture.generateMipmaps = false;\n    this.renderTargetsVertical.push(renderTargetVertical);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // luminosity high pass material\n\n\n  if (LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');\n  var highPassShader = LuminosityHighPassShader;\n  this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n  this.highPassUniforms['luminosityThreshold'].value = threshold;\n  this.highPassUniforms['smoothWidth'].value = 0.01;\n  this.materialHighPassFilter = new ShaderMaterial({\n    uniforms: this.highPassUniforms,\n    vertexShader: highPassShader.vertexShader,\n    fragmentShader: highPassShader.fragmentShader,\n    defines: {}\n  }); // Gaussian Blur Materials\n\n  this.separableBlurMaterials = [];\n  var kernelSizeArray = [3, 5, 7, 9, 11];\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n\n  for (let i = 0; i < this.nMips; i++) {\n    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n    this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // Composite material\n\n\n  this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n  this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\n  this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\n  this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\n  this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\n  this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\n  this.compositeMaterial.uniforms['bloomStrength'].value = strength;\n  this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\n  this.compositeMaterial.needsUpdate = true;\n  var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n  this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\n  this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n  this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors; // copy material\n\n  if (CopyShader === undefined) {\n    console.error('THREE.UnrealBloomPass relies on CopyShader');\n  }\n\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = 1.0;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: AdditiveBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this._oldClearColor = new Color();\n  this.oldClearAlpha = 1;\n  this.basic = new MeshBasicMaterial();\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nUnrealBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: UnrealBloomPass,\n  dispose: function () {\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose();\n    }\n\n    this.renderTargetBright.dispose();\n  },\n  setSize: function (width, height) {\n    var resx = Math.round(width / 2);\n    var resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  },\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor);\n    this.oldClearAlpha = renderer.getClearAlpha();\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic;\n      this.basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    } // 1. Extract Bright Areas\n\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\n    this.fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this.fsQuad.render(renderer); // 2. Blur All the mips progressively\n\n    var inputRenderTarget = this.renderTargetBright;\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    } // Composite All the mips\n\n\n    this.fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n    } // Restore renderer settings\n\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  },\n  getSeperableBlurMaterial: function (kernelRadius) {\n    return new ShaderMaterial({\n      defines: {\n        KERNEL_RADIUS: kernelRadius,\n        SIGMA: kernelRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n' + 'void main() {\\n' + '\tvUv = uv;\\n' + '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n' + '}',\n      fragmentShader: '#include <common>' + 'varying vec2 vUv;\\n' + 'uniform sampler2D colorTexture;\\n' + 'uniform vec2 texSize;' + 'uniform vec2 direction;' + '\\n' + 'float gaussianPdf(in float x, in float sigma) {' + '\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;' + '}' + 'void main() {\\n' + '\tvec2 invSize = 1.0 / texSize;' + '\tfloat fSigma = float(SIGMA);' + '\tfloat weightSum = gaussianPdf(0.0, fSigma);' + '\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;' + '\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {' + '\t\tfloat x = float(i);' + '\t\tfloat w = gaussianPdf(x, fSigma);' + '\t\tvec2 uvOffset = direction * invSize * x;' + '\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;' + '\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;' + '\t\tdiffuseSum += (sample1 + sample2) * w;' + '\t\tweightSum += 2.0 * w;' + '\t}' + '\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n' + '}'\n    });\n  },\n  getCompositeMaterial: function (nMips) {\n    return new ShaderMaterial({\n      defines: {\n        NUM_MIPS: nMips\n      },\n      uniforms: {\n        blurTexture1: {\n          value: null\n        },\n        blurTexture2: {\n          value: null\n        },\n        blurTexture3: {\n          value: null\n        },\n        blurTexture4: {\n          value: null\n        },\n        blurTexture5: {\n          value: null\n        },\n        dirtTexture: {\n          value: null\n        },\n        bloomStrength: {\n          value: 1.0\n        },\n        bloomFactors: {\n          value: null\n        },\n        bloomTintColors: {\n          value: null\n        },\n        bloomRadius: {\n          value: 0.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n' + 'void main() {\\n' + '\tvUv = uv;\\n' + '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n' + '}',\n      fragmentShader: 'varying vec2 vUv;' + 'uniform sampler2D blurTexture1;' + 'uniform sampler2D blurTexture2;' + 'uniform sampler2D blurTexture3;' + 'uniform sampler2D blurTexture4;' + 'uniform sampler2D blurTexture5;' + 'uniform sampler2D dirtTexture;' + 'uniform float bloomStrength;' + 'uniform float bloomRadius;' + 'uniform float bloomFactors[NUM_MIPS];' + 'uniform vec3 bloomTintColors[NUM_MIPS];' + '' + 'float lerpBloomFactor(const in float factor) { ' + '\tfloat mirrorFactor = 1.2 - factor;' + '\treturn mix(factor, mirrorFactor, bloomRadius);' + '}' + '' + 'void main() {' + '\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );' + '}'\n    });\n  }\n});\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\n\nexport { UnrealBloomPass };\n", "import { ShaderLib, Mesh, BoxGeometry, ShaderMaterial, UniformsUtils, BackSide, Scene, PerspectiveCamera } from 'three';\nimport { Pass } from './Pass.js';\n\nvar CubeTexturePass = function (camera, envMap, opacity) {\n  this.camera = camera;\n  this.needsSwap = false;\n  this.cubeShader = ShaderLib['cube'];\n  this.cubeMesh = new Mesh(new BoxGeometry(10, 10, 10), new ShaderMaterial({\n    uniforms: UniformsUtils.clone(this.cubeShader.uniforms),\n    vertexShader: this.cubeShader.vertexShader,\n    fragmentShader: this.cubeShader.fragmentShader,\n    depthTest: false,\n    depthWrite: false,\n    side: BackSide\n  }));\n  Object.defineProperty(this.cubeMesh.material, 'envMap', {\n    get: function () {\n      return this.uniforms.envMap.value;\n    }\n  });\n  this.envMap = envMap;\n  this.opacity = opacity !== undefined ? opacity : 1.0;\n  this.cubeScene = new Scene();\n  this.cubeCamera = new PerspectiveCamera();\n  this.cubeScene.add(this.cubeMesh);\n};\n\nCubeTexturePass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: CubeTexturePass,\n  render: function (renderer, writeBuffer, readBuffer\n  /*, deltaTime, maskActive*/\n  ) {\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\n    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\n    this.cubeMesh.material.uniforms.envMap.value = this.envMap;\n    this.cubeMesh.material.uniforms.flipEnvMap.value = this.envMap.isCubeTexture && this.envMap._needsFlipEnvMap ? -1 : 1;\n    this.cubeMesh.material.uniforms.opacity.value = this.opacity;\n    this.cubeMesh.material.transparent = this.opacity < 1.0;\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.cubeScene, this.cubeCamera);\n    renderer.autoClear = oldAutoClear;\n  }\n});\n\nexport { CubeTexturePass };\n", "import { Vector2, Matrix4 } from 'three';\n\nconst SAOShader = {\n  defines: {\n    NUM_SAMPLES: 7,\n    NUM_RINGS: 4,\n    NORMAL_TEXTURE: 0,\n    DIFFUSE_TEXTURE: 0,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    cameraNear: {\n      value: 1\n    },\n    cameraFar: {\n      value: 100\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    scale: {\n      value: 1.0\n    },\n    intensity: {\n      value: 0.1\n    },\n    bias: {\n      value: 0.5\n    },\n    minResolution: {\n      value: 0.0\n    },\n    kernelRadius: {\n      value: 100.0\n    },\n    randomSeed: {\n      value: 0.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', '#if DIFFUSE_TEXTURE == 1', 'uniform sampler2D tDiffuse;', '#endif', 'uniform sampler2D tDepth;', '#if NORMAL_TEXTURE == 1', 'uniform sampler2D tNormal;', '#endif', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float scale;', 'uniform float intensity;', 'uniform float bias;', 'uniform float kernelRadius;', 'uniform float minResolution;', 'uniform vec2 size;', 'uniform float randomSeed;', '// RGBA depth', '#include <packing>', 'vec4 getDefaultColor( const in vec2 screenPosition ) {', '\t#if DIFFUSE_TEXTURE == 1', '\treturn texture2D( tDiffuse, vUv );', '\t#else', '\treturn vec4( 1.0 );', '\t#endif', '}', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {', '\t#if NORMAL_TEXTURE == 1', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '\t#else', '\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );', '\t#endif', '}', 'float scaleDividedByCameraFar;', 'float minResolutionMultipliedByCameraFar;', 'float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {', '\tvec3 viewDelta = sampleViewPosition - centerViewPosition;', '\tfloat viewDistance = length( viewDelta );', '\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;', '\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );', '}', '// moving costly divides into consts', 'const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );', 'const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );', 'float getAmbientOcclusion( const in vec3 centerViewPosition ) {', '\t// precompute some variables require in getOcclusion.', '\tscaleDividedByCameraFar = scale / cameraFar;', '\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;', '\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );', '\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/', '\tfloat angle = rand( vUv + randomSeed ) * PI2;', '\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;', '\tvec2 radiusStep = radius;', '\tfloat occlusionSum = 0.0;', '\tfloat weightSum = 0.0;', '\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {', '\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;', '\t\tradius += radiusStep;', '\t\tangle += ANGLE_STEP;', '\t\tfloat sampleDepth = getDepth( sampleUv );', '\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {', '\t\t\tcontinue;', '\t\t}', '\t\tfloat sampleViewZ = getViewZ( sampleDepth );', '\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );', '\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );', '\t\tweightSum += 1.0;', '\t}', '\tif( weightSum == 0.0 ) discard;', '\treturn occlusionSum * ( intensity / weightSum );', '}', 'void main() {', '\tfloat centerDepth = getDepth( vUv );', '\tif( centerDepth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = getViewZ( centerDepth );', '\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );', '\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );', '\tgl_FragColor = getDefaultColor( vUv );', '\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;', '}'].join('\\n')\n};\n\nexport { SAOShader };\n", "import { Vector2 } from 'three';\n\nconst DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: new Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [new Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1.0]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1000\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: ['#include <common>', 'uniform vec2 size;', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'void main() {', '\tvUv = uv;', '\tvInvSize = 1.0 / size;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#include <packing>', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform float depthCutoff;', 'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];', 'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tif( depth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = -getViewZ( depth );', '\tbool rBreak = false, lBreak = false;', '\tfloat weightSum = sampleWeights[0];', '\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;', '\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {', '\t\tfloat sampleWeight = sampleWeights[i];', '\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;', '\t\tvec2 sampleUv = vUv + sampleUvOffset;', '\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;', '\t\tif( ! rBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t\tsampleUv = vUv - sampleUvOffset;', '\t\tviewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;', '\t\tif( ! lBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t}', '\tgl_FragColor = diffuseSum / weightSum;', '}'].join('\\n')\n};\nconst BlurShaderUtils = {\n  createSampleWeights: (kernelRadius, stdDev) => {\n    const gaussian = (x, stdDev) => {\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);\n    };\n\n    const weights = [];\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n\n    return weights;\n  },\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\n    const offsets = [];\n\n    for (let i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n\n    return offsets;\n  },\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\n    shader.defines['KERNEL_RADIUS'] = kernelRadius;\n    shader.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    shader.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    shader.needsUpdate = true;\n  }\n};\n\nexport { BlurShaderUtils, DepthLimitedBlurShader };\n", "import { Color, Vector2, WebGLRenderTarget, LinearFilter, RGBAFormat, NearestFilter, DepthTexture, UnsignedShortType, MeshDepthMaterial, RGBADepthPacking, NoBlending, MeshNormalMaterial, ShaderMaterial, UniformsUtils, CustomBlending, DstColorFactor, ZeroFactor, AddEquation, DstAlphaFactor } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { SAOShader } from '../shaders/SAOShader.js';\nimport { DepthLimitedBlurShader, BlurShaderUtils } from '../shaders/DepthLimitedBlurShader.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';\n\n/**\n * SAO implementation inspired from bhouston previous SAO work\n */\n\nvar SAOPass = function (scene, camera, depthTexture, useNormals, resolution) {\n  this.scene = scene;\n  this.camera = camera;\n  this.clear = true;\n  this.needsSwap = false;\n  this.supportsDepthTextureExtension = depthTexture !== undefined ? depthTexture : false;\n  this.supportsNormalTexture = useNormals !== undefined ? useNormals : false;\n  this.originalClearColor = new Color();\n  this._oldClearColor = new Color();\n  this.oldClearAlpha = 1;\n  this.params = {\n    output: 0,\n    saoBias: 0.5,\n    saoIntensity: 0.18,\n    saoScale: 1,\n    saoKernelRadius: 100,\n    saoMinResolution: 0,\n    saoBlur: true,\n    saoBlurRadius: 8,\n    saoBlurStdDev: 4,\n    saoBlurDepthCutoff: 0.01\n  };\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n  this.saoRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  });\n  this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();\n  this.beautyRenderTarget = this.saoRenderTarget.clone();\n  this.normalRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {\n    minFilter: NearestFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  });\n  this.depthRenderTarget = this.normalRenderTarget.clone();\n\n  if (this.supportsDepthTextureExtension) {\n    var depthTexture = new DepthTexture();\n    depthTexture.type = UnsignedShortType;\n    this.beautyRenderTarget.depthTexture = depthTexture;\n    this.beautyRenderTarget.depthBuffer = true;\n  }\n\n  this.depthMaterial = new MeshDepthMaterial();\n  this.depthMaterial.depthPacking = RGBADepthPacking;\n  this.depthMaterial.blending = NoBlending;\n  this.normalMaterial = new MeshNormalMaterial();\n  this.normalMaterial.blending = NoBlending;\n\n  if (SAOShader === undefined) {\n    console.error('THREE.SAOPass relies on SAOShader');\n  }\n\n  this.saoMaterial = new ShaderMaterial({\n    defines: Object.assign({}, SAOShader.defines),\n    fragmentShader: SAOShader.fragmentShader,\n    vertexShader: SAOShader.vertexShader,\n    uniforms: UniformsUtils.clone(SAOShader.uniforms)\n  });\n  this.saoMaterial.extensions.derivatives = true;\n  this.saoMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;\n  this.saoMaterial.defines['NORMAL_TEXTURE'] = this.supportsNormalTexture ? 1 : 0;\n  this.saoMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;\n  this.saoMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\n  this.saoMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture;\n  this.saoMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);\n  this.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);\n  this.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix;\n  this.saoMaterial.blending = NoBlending;\n\n  if (DepthLimitedBlurShader === undefined) {\n    console.error('THREE.SAOPass relies on DepthLimitedBlurShader');\n  }\n\n  this.vBlurMaterial = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),\n    defines: Object.assign({}, DepthLimitedBlurShader.defines),\n    vertexShader: DepthLimitedBlurShader.vertexShader,\n    fragmentShader: DepthLimitedBlurShader.fragmentShader\n  });\n  this.vBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;\n  this.vBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;\n  this.vBlurMaterial.uniforms['tDiffuse'].value = this.saoRenderTarget.texture;\n  this.vBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\n  this.vBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);\n  this.vBlurMaterial.blending = NoBlending;\n  this.hBlurMaterial = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),\n    defines: Object.assign({}, DepthLimitedBlurShader.defines),\n    vertexShader: DepthLimitedBlurShader.vertexShader,\n    fragmentShader: DepthLimitedBlurShader.fragmentShader\n  });\n  this.hBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;\n  this.hBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;\n  this.hBlurMaterial.uniforms['tDiffuse'].value = this.blurIntermediateRenderTarget.texture;\n  this.hBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\n  this.hBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);\n  this.hBlurMaterial.blending = NoBlending;\n\n  if (CopyShader === undefined) {\n    console.error('THREE.SAOPass relies on CopyShader');\n  }\n\n  this.materialCopy = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(CopyShader.uniforms),\n    vertexShader: CopyShader.vertexShader,\n    fragmentShader: CopyShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.materialCopy.transparent = true;\n  this.materialCopy.depthTest = false;\n  this.materialCopy.depthWrite = false;\n  this.materialCopy.blending = CustomBlending;\n  this.materialCopy.blendSrc = DstColorFactor;\n  this.materialCopy.blendDst = ZeroFactor;\n  this.materialCopy.blendEquation = AddEquation;\n  this.materialCopy.blendSrcAlpha = DstAlphaFactor;\n  this.materialCopy.blendDstAlpha = ZeroFactor;\n  this.materialCopy.blendEquationAlpha = AddEquation;\n\n  if (UnpackDepthRGBAShader === undefined) {\n    console.error('THREE.SAOPass relies on UnpackDepthRGBAShader');\n  }\n\n  this.depthCopy = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(UnpackDepthRGBAShader.uniforms),\n    vertexShader: UnpackDepthRGBAShader.vertexShader,\n    fragmentShader: UnpackDepthRGBAShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nSAOPass.OUTPUT = {\n  Beauty: 1,\n  Default: 0,\n  SAO: 2,\n  Depth: 3,\n  Normal: 4\n};\nSAOPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: SAOPass,\n  render: function (renderer, writeBuffer, readBuffer\n  /*, deltaTime, maskActive*/\n  ) {\n    // Rendering readBuffer first when rendering to screen\n    if (this.renderToScreen) {\n      this.materialCopy.blending = NoBlending;\n      this.materialCopy.uniforms['tDiffuse'].value = readBuffer.texture;\n      this.materialCopy.needsUpdate = true;\n      this.renderPass(renderer, this.materialCopy, null);\n    }\n\n    if (this.params.output === 1) {\n      return;\n    }\n\n    renderer.getClearColor(this._oldClearColor);\n    this.oldClearAlpha = renderer.getClearAlpha();\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setRenderTarget(this.depthRenderTarget);\n    renderer.clear();\n    this.saoMaterial.uniforms['bias'].value = this.params.saoBias;\n    this.saoMaterial.uniforms['intensity'].value = this.params.saoIntensity;\n    this.saoMaterial.uniforms['scale'].value = this.params.saoScale;\n    this.saoMaterial.uniforms['kernelRadius'].value = this.params.saoKernelRadius;\n    this.saoMaterial.uniforms['minResolution'].value = this.params.saoMinResolution;\n    this.saoMaterial.uniforms['cameraNear'].value = this.camera.near;\n    this.saoMaterial.uniforms['cameraFar'].value = this.camera.far; // this.saoMaterial.uniforms['randomSeed'].value = Math.random();\n\n    var depthCutoff = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);\n    this.vBlurMaterial.uniforms['depthCutoff'].value = depthCutoff;\n    this.hBlurMaterial.uniforms['depthCutoff'].value = depthCutoff;\n    this.vBlurMaterial.uniforms['cameraNear'].value = this.camera.near;\n    this.vBlurMaterial.uniforms['cameraFar'].value = this.camera.far;\n    this.hBlurMaterial.uniforms['cameraNear'].value = this.camera.near;\n    this.hBlurMaterial.uniforms['cameraFar'].value = this.camera.far;\n    this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius);\n\n    if (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) {\n      BlurShaderUtils.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(0, 1));\n      BlurShaderUtils.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(1, 0));\n      this.prevStdDev = this.params.saoBlurStdDev;\n      this.prevNumSamples = this.params.saoBlurRadius;\n    } // Rendering scene to depth texture\n\n\n    renderer.setClearColor(0x000000);\n    renderer.setRenderTarget(this.beautyRenderTarget);\n    renderer.clear();\n    renderer.render(this.scene, this.camera); // Re-render scene if depth texture extension is not supported\n\n    if (!this.supportsDepthTextureExtension) {\n      // Clear rule : far clipping plane in both RGBA and Basic encoding\n      this.renderOverride(renderer, this.depthMaterial, this.depthRenderTarget, 0x000000, 1.0);\n    }\n\n    if (this.supportsNormalTexture) {\n      // Clear rule : default normal is facing the camera\n      this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0);\n    } // Rendering SAO texture\n\n\n    this.renderPass(renderer, this.saoMaterial, this.saoRenderTarget, 0xffffff, 1.0); // Blurring SAO texture\n\n    if (this.params.saoBlur) {\n      this.renderPass(renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 0xffffff, 1.0);\n      this.renderPass(renderer, this.hBlurMaterial, this.saoRenderTarget, 0xffffff, 1.0);\n    }\n\n    var outputMaterial = this.materialCopy; // Setting up SAO rendering\n\n    if (this.params.output === 3) {\n      if (this.supportsDepthTextureExtension) {\n        this.materialCopy.uniforms['tDiffuse'].value = this.beautyRenderTarget.depthTexture;\n        this.materialCopy.needsUpdate = true;\n      } else {\n        this.depthCopy.uniforms['tDiffuse'].value = this.depthRenderTarget.texture;\n        this.depthCopy.needsUpdate = true;\n        outputMaterial = this.depthCopy;\n      }\n    } else if (this.params.output === 4) {\n      this.materialCopy.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;\n      this.materialCopy.needsUpdate = true;\n    } else {\n      this.materialCopy.uniforms['tDiffuse'].value = this.saoRenderTarget.texture;\n      this.materialCopy.needsUpdate = true;\n    } // Blending depends on output, only want a CustomBlending when showing SAO\n\n\n    if (this.params.output === 0) {\n      outputMaterial.blending = CustomBlending;\n    } else {\n      outputMaterial.blending = NoBlending;\n    } // Rendering SAOPass result on top of previous pass\n\n\n    this.renderPass(renderer, outputMaterial, this.renderToScreen ? null : readBuffer);\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  },\n  renderPass: function (renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\n    // save original state\n    renderer.getClearColor(this.originalClearColor);\n    var originalClearAlpha = renderer.getClearAlpha();\n    var originalAutoClear = renderer.autoClear;\n    renderer.setRenderTarget(renderTarget); // setup pass state\n\n    renderer.autoClear = false;\n\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor);\n      renderer.setClearAlpha(clearAlpha || 0.0);\n      renderer.clear();\n    }\n\n    this.fsQuad.material = passMaterial;\n    this.fsQuad.render(renderer); // restore original state\n\n    renderer.autoClear = originalAutoClear;\n    renderer.setClearColor(this.originalClearColor);\n    renderer.setClearAlpha(originalClearAlpha);\n  },\n  renderOverride: function (renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n    renderer.getClearColor(this.originalClearColor);\n    var originalClearAlpha = renderer.getClearAlpha();\n    var originalAutoClear = renderer.autoClear;\n    renderer.setRenderTarget(renderTarget);\n    renderer.autoClear = false;\n    clearColor = overrideMaterial.clearColor || clearColor;\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;\n\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor);\n      renderer.setClearAlpha(clearAlpha || 0.0);\n      renderer.clear();\n    }\n\n    this.scene.overrideMaterial = overrideMaterial;\n    renderer.render(this.scene, this.camera);\n    this.scene.overrideMaterial = null; // restore original state\n\n    renderer.autoClear = originalAutoClear;\n    renderer.setClearColor(this.originalClearColor);\n    renderer.setClearAlpha(originalClearAlpha);\n  },\n  setSize: function (width, height) {\n    this.beautyRenderTarget.setSize(width, height);\n    this.saoRenderTarget.setSize(width, height);\n    this.blurIntermediateRenderTarget.setSize(width, height);\n    this.normalRenderTarget.setSize(width, height);\n    this.depthRenderTarget.setSize(width, height);\n    this.saoMaterial.uniforms['size'].value.set(width, height);\n    this.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);\n    this.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix;\n    this.saoMaterial.needsUpdate = true;\n    this.vBlurMaterial.uniforms['size'].value.set(width, height);\n    this.vBlurMaterial.needsUpdate = true;\n    this.hBlurMaterial.uniforms['size'].value.set(width, height);\n    this.hBlurMaterial.needsUpdate = true;\n  }\n});\n\nexport { SAOPass };\n", "/**\n * Afterimage shader\n * I created this effect inspired by a demo on codepen:\n * https://codepen.io/brunoimbrizi/pen/MoRJaN?page=1&\n */\nconst AfterimageShader = {\n  uniforms: {\n    damp: {\n      value: 0.96\n    },\n    tOld: {\n      value: null\n    },\n    tNew: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float damp;', 'uniform sampler2D tOld;', 'uniform sampler2D tNew;', 'varying vec2 vUv;', 'vec4 when_gt( vec4 x, float y ) {', '\treturn max( sign( x - y ), 0.0 );', '}', 'void main() {', '\tvec4 texelOld = texture2D( tOld, vUv );', '\tvec4 texelNew = texture2D( tNew, vUv );', '\ttexelOld *= damp * when_gt( texelOld, 0.1 );', '\tgl_FragColor = max(texelNew, texelOld);', '}'].join('\\n')\n};\n\nexport { AfterimageShader };\n", "import { Vector2 } from 'three';\n\n/**\n * Dot screen shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\n\nconst DotScreenShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tSize: {\n      value: new Vector2(256, 256)\n    },\n    center: {\n      value: new Vector2(0.5, 0.5)\n    },\n    angle: {\n      value: 1.57\n    },\n    scale: {\n      value: 1.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec2 center;', 'uniform float angle;', 'uniform float scale;', 'uniform vec2 tSize;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'float pattern() {', '\tfloat s = sin( angle ), c = cos( angle );', '\tvec2 tex = vUv * tSize - center;', '\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;', '\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;', '}', 'void main() {', '\tvec4 color = texture2D( tDiffuse, vUv );', '\tfloat average = ( color.r + color.g + color.b ) / 3.0;', '\tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );', '}'].join('\\n')\n};\n\nexport { DotScreenShader };\n", "import { Vector2, Matrix4 } from 'three';\n\n/**\n * References:\n * https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html\n */\n\nconst SSRShader = {\n  defines: {\n    MAX_STEP: 0,\n    isPerspectiveCamera: true,\n    isDistanceAttenuation: true,\n    isFresnel: true,\n    isInfiniteThick: false,\n    isSelective: false\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    tMetalness: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    },\n    cameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new Matrix4()\n    },\n    opacity: {\n      value: 0.5\n    },\n    maxDistance: {\n      value: 180\n    },\n    cameraRange: {\n      value: 0\n    },\n    surfDist: {\n      value: 0.007\n    },\n    thickTolerance: {\n      value: 0.03\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n    varying vec2 vUv;\n\n    void main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  `,\n  fragmentShader:\n  /* glsl */\n  `\n\t\t// precision highp float;\n\t\tprecision highp sampler2D;\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D tDepth;\n\t\tuniform sampler2D tNormal;\n\t\tuniform sampler2D tMetalness;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float cameraRange;\n\t\tuniform vec2 resolution;\n\t\tuniform float opacity;\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform float maxDistance;\n\t\tuniform float surfDist;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\t\tuniform float thickTolerance;\n\t\t#include <packing>\n\t\tfloat pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {\n\t\t\t//x0: point, x1: linePointA, x2: linePointB\n\t\t\t//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n\t\t\treturn length(cross(x0-x1,x0-x2))/length(x2-x1);\n\t\t}\n\t\tfloat pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){\n\t\t\t// https://mathworld.wolfram.com/Point-PlaneDistance.html\n\t\t\t//// https://en.wikipedia.org/wiki/Plane_(geometry)\n\t\t\t//// http://paulbourke.net/geometry/pointlineplane/\n\t\t\tfloat a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;\n\t\t\tfloat x0=point.x,y0=point.y,z0=point.z;\n\t\t\tfloat x=planePoint.x,y=planePoint.y,z=planePoint.z;\n\t\t\tfloat d=-(a*x+b*y+c*z);\n\t\t\tfloat distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);\n\t\t\treturn distance;\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#else\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\t\t\t#endif\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view\n\t\t}\n\t\tvec3 getViewNormal( const in vec2 uv ) {\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, uv ).xyz );\n\t\t}\n\t\tvec2 viewPositionToXY(vec3 viewPosition){\n\t\t\tvec2 xy;\n\t\t\tvec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);\n\t\t\txy=clip.xy;//clip\n\t\t\tfloat clipW=clip.w;\n\t\t\txy/=clipW;//NDC\n\t\t\txy=(xy+1.)/2.;//uv\n\t\t\txy*=resolution;//screen\n\t\t\treturn xy;\n\t\t}\n\t\tvoid main(){\n\t\t\t#ifdef isSelective\n\t\t\t\tfloat metalness=texture2D(tMetalness,vUv).r;\n\t\t\t\tif(metalness==0.) return;\n\t\t\t#endif\n\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\tif(-viewZ>=cameraFar) return;\n\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];\n\t\t\tvec3 viewPosition=getViewPosition( vUv, depth, clipW );\n\n\t\t\tvec2 d0=gl_FragCoord.xy;\n\t\t\tvec2 d1;\n\n\t\t\tvec3 viewNormal=getViewNormal( vUv );\n\n\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\tvec3 viewIncidenceDir=normalize(viewPosition);\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);\n\t\t\t#else\n\t\t\t\tvec3 viewIncidenceDir=vec3(0,0,-1);\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);\n\t\t\t#endif\n\n\t\t\tfloat maxReflectRayLen=maxDistance/dot(-viewIncidenceDir,viewNormal);\n\t\t\t// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html\n\t\t\t// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)\n\t\t\t// maxDistance/maxReflectRayLen=cos(theta)\n\t\t\t// maxDistance/maxReflectRayLen==dot(a,b)\n\t\t\t// maxReflectRayLen==maxDistance/dot(a,b)\n\n\t\t\tvec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;\n\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\tif(d1viewPosition.z>-cameraNear){\n\t\t\t\t\t//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx\n\t\t\t\t\tfloat t=(-cameraNear-viewPosition.z)/viewReflectDir.z;\n\t\t\t\t\td1viewPosition=viewPosition+viewReflectDir*t;\n\t\t\t\t}\n\t\t\t#endif\n\t\t\td1=viewPositionToXY(d1viewPosition);\n\n\t\t\tfloat totalLen=length(d1-d0);\n\t\t\tfloat xLen=d1.x-d0.x;\n\t\t\tfloat yLen=d1.y-d0.y;\n\t\t\tfloat totalStep=max(abs(xLen),abs(yLen));\n\t\t\tfloat xSpan=xLen/totalStep;\n\t\t\tfloat ySpan=yLen/totalStep;\n\t\t\tfor(float i=0.;i<MAX_STEP;i++){\n\t\t\t\tif(i>=totalStep) break;\n\t\t\t\tvec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);\n\t\t\t\tif(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;\n\t\t\t\tfloat s=length(xy-d0)/totalLen;\n\t\t\t\tvec2 uv=xy/resolution;\n\n\t\t\t\tfloat d = getDepth(uv);\n\t\t\t\tfloat vZ = getViewZ( d );\n\t\t\t\tif(-vZ>=cameraFar) continue;\n\t\t\t\tfloat cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];\n\t\t\t\tvec3 vP=getViewPosition( uv, d, cW );\n\n\t\t\t\t#ifdef isPerspectiveCamera\n\t\t\t\t\t// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf\n\t\t\t\t\tfloat recipVPZ=1./viewPosition.z;\n\t\t\t\t\tfloat viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));\n\t\t\t\t\tfloat sD=surfDist*cW;\n\t\t\t\t#else\n\t\t\t\t\tfloat viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);\n\t\t\t\t\tfloat sD=surfDist;\n\t\t\t\t#endif\n\t\t\t\tif(viewReflectRayZ-sD>vZ) continue;\n\n\t\t\t\t#ifdef isInfiniteThick\n\t\t\t\t\tif(viewReflectRayZ+thickTolerance*clipW<vP.z) break;\n\t\t\t\t#endif\n\t\t\t\tfloat away=pointToLineDistance(vP,viewPosition,d1viewPosition);\n\n\t\t\t\tfloat op=opacity;\n\n\t\t\t\tif(away<sD){\n\t\t\t\t\tvec3 vN=getViewNormal( uv );\n\t\t\t\t\tif(dot(viewReflectDir,vN)>=0.) continue;\n\t\t\t\t\tfloat distance=pointPlaneDistance(vP,viewPosition,viewNormal);\n\t\t\t\t\tif(distance>maxDistance) break;\n\t\t\t\t\t#ifdef isDistanceAttenuation\n\t\t\t\t\t\tfloat ratio=1.-(distance/maxDistance);\n\t\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t\t#endif\n\t\t\t\t\t#ifdef isFresnel\n\t\t\t\t\t\tfloat fresnel=(dot(viewIncidenceDir,viewReflectDir)+1.)/2.;\n\t\t\t\t\t\top*=fresnel;\n\t\t\t\t\t#endif\n\t\t\t\t\tvec4 reflectColor=texture2D(tDiffuse,uv);\n\t\t\t\t\tgl_FragColor.xyz=reflectColor.xyz;\n\t\t\t\t\tgl_FragColor.a=op;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t`\n};\nconst SSRDepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  `,\n  fragmentShader:\n  /* glsl */\n  `\n\n    uniform sampler2D tDepth;\n\n    uniform float cameraNear;\n    uniform float cameraFar;\n\n    varying vec2 vUv;\n\n    #include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 uv ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, uv ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, uv ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n    void main() {\n\n    \tfloat depth = getLinearDepth( vUv );\n\t\t\tfloat d = 1.0 - depth;\n\t\t\t// d=(d-.999)*1000.;\n    \tgl_FragColor = vec4( vec3( d ), 1.0 );\n\n    }\n\n  `\n};\nconst SSRBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    },\n    opacity: {\n      value: 0.5\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvUv = uv;\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n\n  `,\n  fragmentShader:\n  /* glsl */\n  `\n\n    uniform sampler2D tDiffuse;\n    uniform vec2 resolution;\n    varying vec2 vUv;\n    void main() {\n\t\t\t//reverse engineering from PhotoShop blur filter, then change coefficient\n\n    \tvec2 texelSize = ( 1.0 / resolution );\n\n\t\t\tvec4 c=texture2D(tDiffuse,vUv);\n\n\t\t\tvec2 offset;\n\n\t\t\toffset=(vec2(-1,0))*texelSize;\n\t\t\tvec4 cl=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(1,0))*texelSize;\n\t\t\tvec4 cr=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(0,-1))*texelSize;\n\t\t\tvec4 cb=texture2D(tDiffuse,vUv+offset);\n\n\t\t\toffset=(vec2(0,1))*texelSize;\n\t\t\tvec4 ct=texture2D(tDiffuse,vUv+offset);\n\n\t\t\t// float coeCenter=.5;\n\t\t\t// float coeSide=.125;\n\t\t\tfloat coeCenter=.2;\n\t\t\tfloat coeSide=.2;\n\t\t\tfloat a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;\n\t\t\tvec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;\n\t\t\tgl_FragColor=vec4(rgb,a);\n\n\t\t}\n\t`\n};\n\nexport { SSRBlurShader, SSRDepthShader, SSRShader };\n", "import { Color, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, LinearFilter, RGBAFormat, HalfFloatType, ShaderMaterial, UniformsUtils, NoBlending, MeshNormalMaterial, MeshBasicMaterial, SrcAlphaFactor, OneMinusSrcAlphaFactor, AddEquation, NormalBlending } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { SSRShader, SSRBlurShader, SSRDepthShader } from '../shaders/SSRShader.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nvar SSRPass = function ({\n  renderer,\n  scene,\n  camera,\n  width,\n  height,\n  selects,\n  encoding,\n  isPerspectiveCamera = true,\n  isBouncing = false,\n  morphTargets = false,\n  groundReflector\n}) {\n  this.width = width !== undefined ? width : 512;\n  this.height = height !== undefined ? height : 512;\n  this.clear = true;\n  this.renderer = renderer;\n  this.scene = scene;\n  this.camera = camera;\n  this.groundReflector = groundReflector;\n  this.opacity = SSRShader.uniforms.opacity.value;\n  this.output = 0;\n  this.maxDistance = SSRShader.uniforms.maxDistance.value;\n  this.surfDist = SSRShader.uniforms.surfDist.value;\n  this.encoding = encoding;\n  this.tempColor = new Color();\n  this._selects = selects;\n  this.isSelective = Array.isArray(this._selects);\n  Object.defineProperty(this, 'selects', {\n    get() {\n      return this._selects;\n    },\n\n    set(val) {\n      if (this._selects === val) return;\n      this._selects = val;\n\n      if (Array.isArray(val)) {\n        this.isSelective = true;\n        this.ssrMaterial.defines.isSelective = true;\n        this.ssrMaterial.needsUpdate = true;\n      } else {\n        this.isSelective = false;\n        this.ssrMaterial.defines.isSelective = false;\n        this.ssrMaterial.needsUpdate = true;\n      }\n    }\n\n  });\n  this._isBouncing = isBouncing; ///todo: don't need defineProperty\n\n  Object.defineProperty(this, 'isBouncing', {\n    get() {\n      return this._isBouncing;\n    },\n\n    set(val) {\n      if (this._isBouncing === val) return;\n      this._isBouncing = val;\n\n      if (val) {\n        this.ssrMaterial.uniforms['tDiffuse'].value = this.prevRenderTarget.texture;\n      } else {\n        this.ssrMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n      }\n    }\n\n  });\n  this.isBlur = true;\n  this._isDistanceAttenuation = SSRShader.defines.isDistanceAttenuation;\n  Object.defineProperty(this, 'isDistanceAttenuation', {\n    get() {\n      return this._isDistanceAttenuation;\n    },\n\n    set(val) {\n      if (this._isDistanceAttenuation === val) return;\n      this._isDistanceAttenuation = val;\n      this.ssrMaterial.defines.isDistanceAttenuation = val;\n      this.ssrMaterial.needsUpdate = true;\n    }\n\n  });\n  this._isFresnel = SSRShader.defines.isFresnel;\n  Object.defineProperty(this, 'isFresnel', {\n    get() {\n      return this._isFresnel;\n    },\n\n    set(val) {\n      if (this._isFresnel === val) return;\n      this._isFresnel = val;\n      this.ssrMaterial.defines.isFresnel = val;\n      this.ssrMaterial.needsUpdate = true;\n    }\n\n  });\n  this._isInfiniteThick = SSRShader.defines.isInfiniteThick;\n  Object.defineProperty(this, 'isInfiniteThick', {\n    get() {\n      return this._isInfiniteThick;\n    },\n\n    set(val) {\n      if (this._isInfiniteThick === val) return;\n      this._isInfiniteThick = val;\n      this.ssrMaterial.defines.isInfiniteThick = val;\n      this.ssrMaterial.needsUpdate = true;\n    }\n\n  });\n  this.thickTolerance = SSRShader.uniforms.thickTolerance.value; // beauty render target with depth buffer\n\n  var depthTexture = new DepthTexture();\n  depthTexture.type = UnsignedShortType;\n  depthTexture.minFilter = NearestFilter;\n  depthTexture.maxFilter = NearestFilter;\n  this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat,\n    depthTexture: depthTexture,\n    depthBuffer: true\n  }); //for bouncing\n\n  this.prevRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  }); // normal render target\n\n  this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n    minFilter: NearestFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat,\n    type: HalfFloatType\n  }); // metalness render target\n  // if (this.isSelective) {\n\n  this.metalnessRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n    minFilter: NearestFilter,\n    magFilter: NearestFilter,\n    format: RGBAFormat\n  }); // }\n  // ssr render target\n\n  this.ssrRenderTarget = new WebGLRenderTarget(this.width, this.height, {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  });\n  this.blurRenderTarget = this.ssrRenderTarget.clone();\n  this.blurRenderTarget2 = this.ssrRenderTarget.clone(); // this.blurRenderTarget3 = this.ssrRenderTarget.clone();\n  // ssr material\n\n  if (SSRShader === undefined) {\n    console.error('THREE.SSRPass: The pass relies on SSRShader.');\n  }\n\n  this.ssrMaterial = new ShaderMaterial({\n    defines: Object.assign({\n      MAX_STEP: Math.sqrt(window.innerWidth * window.innerWidth + window.innerHeight * window.innerHeight)\n    }, SSRShader.defines),\n    uniforms: UniformsUtils.clone(SSRShader.uniforms),\n    vertexShader: SSRShader.vertexShader,\n    fragmentShader: SSRShader.fragmentShader,\n    blending: NoBlending\n  });\n\n  if (!isPerspectiveCamera) {\n    this.ssrMaterial.defines.isPerspectiveCamera = isPerspectiveCamera;\n    this.ssrMaterial.needsUpdate = true;\n  }\n\n  this.ssrMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n  this.ssrMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture; // if (this.isSelective) {\n\n  this.ssrMaterial.defines.isSelective = this.isSelective;\n  this.ssrMaterial.needsUpdate = true;\n  this.ssrMaterial.uniforms['tMetalness'].value = this.metalnessRenderTarget.texture; // }\n\n  this.ssrMaterial.uniforms['tDepth'].value = this.beautyRenderTarget.depthTexture;\n  this.ssrMaterial.uniforms['cameraNear'].value = this.camera.near;\n  this.ssrMaterial.uniforms['cameraFar'].value = this.camera.far;\n  this.ssrMaterial.uniforms['surfDist'].value = this.surfDist;\n  this.ssrMaterial.uniforms['resolution'].value.set(this.width, this.height);\n  this.ssrMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);\n  this.ssrMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse); // normal material\n\n  this.normalMaterial = new MeshNormalMaterial({\n    morphTargets\n  });\n  this.normalMaterial.blending = NoBlending; // if (this.isSelective) {\n  // metalnessOn material\n\n  this.metalnessOnMaterial = new MeshBasicMaterial({\n    color: 'white'\n  }); // metalnessOff material\n\n  this.metalnessOffMaterial = new MeshBasicMaterial({\n    color: 'black'\n  }); // }\n  // blur material\n\n  this.blurMaterial = new ShaderMaterial({\n    defines: Object.assign({}, SSRBlurShader.defines),\n    uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),\n    vertexShader: SSRBlurShader.vertexShader,\n    fragmentShader: SSRBlurShader.fragmentShader\n  });\n  this.blurMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\n  this.blurMaterial.uniforms['resolution'].value.set(this.width, this.height); // blur material 2\n\n  this.blurMaterial2 = new ShaderMaterial({\n    defines: Object.assign({}, SSRBlurShader.defines),\n    uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),\n    vertexShader: SSRBlurShader.vertexShader,\n    fragmentShader: SSRBlurShader.fragmentShader\n  });\n  this.blurMaterial2.uniforms['tDiffuse'].value = this.blurRenderTarget.texture;\n  this.blurMaterial2.uniforms['resolution'].value.set(this.width, this.height); // // blur material 3\n  // this.blurMaterial3 = new ShaderMaterial({\n  //   defines: Object.assign({}, SSRBlurShader.defines),\n  //   uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),\n  //   vertexShader: SSRBlurShader.vertexShader,\n  //   fragmentShader: SSRBlurShader.fragmentShader\n  // });\n  // this.blurMaterial3.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;\n  // this.blurMaterial3.uniforms['resolution'].value.set(this.width, this.height);\n  // material for rendering the depth\n\n  this.depthRenderMaterial = new ShaderMaterial({\n    defines: Object.assign({}, SSRDepthShader.defines),\n    uniforms: UniformsUtils.clone(SSRDepthShader.uniforms),\n    vertexShader: SSRDepthShader.vertexShader,\n    fragmentShader: SSRDepthShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.depthRenderMaterial.uniforms['tDepth'].value = this.beautyRenderTarget.depthTexture;\n  this.depthRenderMaterial.uniforms['cameraNear'].value = this.camera.near;\n  this.depthRenderMaterial.uniforms['cameraFar'].value = this.camera.far; // material for rendering the content of a render target\n\n  this.copyMaterial = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(CopyShader.uniforms),\n    vertexShader: CopyShader.vertexShader,\n    fragmentShader: CopyShader.fragmentShader,\n    transparent: true,\n    depthTest: false,\n    depthWrite: false,\n    blendSrc: SrcAlphaFactor,\n    blendDst: OneMinusSrcAlphaFactor,\n    blendEquation: AddEquation,\n    blendSrcAlpha: SrcAlphaFactor,\n    blendDstAlpha: OneMinusSrcAlphaFactor,\n    blendEquationAlpha: AddEquation // premultipliedAlpha:true,\n\n  });\n  this.fsQuad = new FullScreenQuad(null);\n  this.originalClearColor = new Color();\n};\n\nSSRPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: SSRPass,\n  dispose: function () {\n    // dispose render targets\n    this.beautyRenderTarget.dispose();\n    this.prevRenderTarget.dispose();\n    this.normalRenderTarget.dispose(); // if (this.isSelective)\n\n    this.metalnessRenderTarget.dispose();\n    this.ssrRenderTarget.dispose();\n    this.blurRenderTarget.dispose();\n    this.blurRenderTarget2.dispose(); // this.blurRenderTarget3.dispose();\n    // dispose materials\n\n    this.normalMaterial.dispose(); // if (this.isSelective) {\n\n    this.metalnessOnMaterial.dispose();\n    this.metalnessOffMaterial.dispose(); // }\n\n    this.blurMaterial.dispose();\n    this.blurMaterial2.dispose();\n    this.copyMaterial.dispose();\n    this.depthRenderMaterial.dispose(); // dipsose full screen quad\n\n    this.fsQuad.dispose();\n  },\n  render: function (renderer, writeBuffer\n  /*, readBuffer, deltaTime, maskActive */\n  ) {\n    // render beauty and depth\n    if (this.encoding) this.beautyRenderTarget.texture.encoding = this.encoding;\n    renderer.setRenderTarget(this.beautyRenderTarget);\n    renderer.clear();\n\n    if (this.groundReflector) {\n      this.groundReflector.doRender(this.renderer, this.scene, this.camera);\n      this.groundReflector.visible = true;\n    }\n\n    renderer.render(this.scene, this.camera);\n    if (this.groundReflector) this.groundReflector.visible = false; // render normals\n\n    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0, 0); // render metalnesses\n\n    if (this.isSelective) {\n      this.renderMetalness(renderer, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0);\n    } // render SSR\n\n\n    this.ssrMaterial.uniforms['opacity'].value = this.opacity;\n    this.ssrMaterial.uniforms['maxDistance'].value = this.maxDistance;\n    this.ssrMaterial.uniforms['surfDist'].value = this.surfDist;\n    this.ssrMaterial.uniforms['thickTolerance'].value = this.thickTolerance;\n    this.renderPass(renderer, this.ssrMaterial, this.ssrRenderTarget); // render blur\n\n    if (this.isBlur) {\n      this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);\n      this.renderPass(renderer, this.blurMaterial2, this.blurRenderTarget2); // this.renderPass(renderer, this.blurMaterial3, this.blurRenderTarget3);\n    } // output result to screen\n\n\n    switch (this.output) {\n      case SSRPass.OUTPUT.Default:\n        if (this.isBouncing) {\n          this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n          this.copyMaterial.blending = NoBlending;\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);\n          if (this.isBlur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\n          this.copyMaterial.blending = NormalBlending;\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);\n          this.copyMaterial.uniforms['tDiffuse'].value = this.prevRenderTarget.texture;\n          this.copyMaterial.blending = NoBlending;\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        } else {\n          this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n          this.copyMaterial.blending = NoBlending;\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n          if (this.isBlur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\n          this.copyMaterial.blending = NormalBlending;\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        }\n\n        break;\n\n      case SSRPass.OUTPUT.SSR:\n        if (this.isBlur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\n        this.copyMaterial.blending = NoBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n\n        if (this.isBouncing) {\n          if (this.isBlur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;else this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n          this.copyMaterial.blending = NoBlending;\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);\n          this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\n          this.copyMaterial.blending = NormalBlending;\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);\n        }\n\n        break;\n\n      case SSRPass.OUTPUT.Beauty:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\n        this.copyMaterial.blending = NoBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      case SSRPass.OUTPUT.Depth:\n        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      case SSRPass.OUTPUT.Normal:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;\n        this.copyMaterial.blending = NoBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      case SSRPass.OUTPUT.Metalness:\n        this.copyMaterial.uniforms['tDiffuse'].value = this.metalnessRenderTarget.texture;\n        this.copyMaterial.blending = NoBlending;\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\n        break;\n\n      default:\n        console.warn('THREE.SSRPass: Unknown output type.');\n    }\n  },\n  renderPass: function (renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\n    // save original state\n    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));\n    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);\n    var originalAutoClear = renderer.autoClear;\n    renderer.setRenderTarget(renderTarget); // setup pass state\n\n    renderer.autoClear = false;\n\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor);\n      renderer.setClearAlpha(clearAlpha || 0.0);\n      renderer.clear();\n    }\n\n    this.fsQuad.material = passMaterial;\n    this.fsQuad.render(renderer); // restore original state\n\n    renderer.autoClear = originalAutoClear;\n    renderer.setClearColor(this.originalClearColor);\n    renderer.setClearAlpha(originalClearAlpha);\n  },\n  renderOverride: function (renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));\n    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);\n    var originalAutoClear = renderer.autoClear;\n    renderer.setRenderTarget(renderTarget);\n    renderer.autoClear = false;\n    clearColor = overrideMaterial.clearColor || clearColor;\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;\n\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor);\n      renderer.setClearAlpha(clearAlpha || 0.0);\n      renderer.clear();\n    }\n\n    this.scene.overrideMaterial = overrideMaterial;\n    renderer.render(this.scene, this.camera);\n    this.scene.overrideMaterial = null; // restore original state\n\n    renderer.autoClear = originalAutoClear;\n    renderer.setClearColor(this.originalClearColor);\n    renderer.setClearAlpha(originalClearAlpha);\n  },\n  renderMetalness: function (renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));\n    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);\n    var originalAutoClear = renderer.autoClear;\n    renderer.setRenderTarget(renderTarget);\n    renderer.autoClear = false;\n    clearColor = overrideMaterial.clearColor || clearColor;\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;\n\n    if (clearColor !== undefined && clearColor !== null) {\n      renderer.setClearColor(clearColor);\n      renderer.setClearAlpha(clearAlpha || 0.0);\n      renderer.clear();\n    }\n\n    this.scene.traverseVisible(child => {\n      child._SSRPassMaterialBack = child.material;\n\n      if (this._selects.includes(child)) {\n        child.material = this.metalnessOnMaterial;\n      } else {\n        child.material = this.metalnessOffMaterial;\n      }\n    });\n    renderer.render(this.scene, this.camera);\n    this.scene.traverseVisible(child => {\n      child.material = child._SSRPassMaterialBack;\n    }); // restore original state\n\n    renderer.autoClear = originalAutoClear;\n    renderer.setClearColor(this.originalClearColor);\n    renderer.setClearAlpha(originalClearAlpha);\n  },\n  setSize: function (width, height) {\n    this.width = width;\n    this.height = height;\n    this.ssrMaterial.defines.MAX_STEP = Math.sqrt(width * width + height * height);\n    this.ssrMaterial.needsUpdate = true;\n    this.beautyRenderTarget.setSize(width, height);\n    this.prevRenderTarget.setSize(width, height);\n    this.ssrRenderTarget.setSize(width, height);\n    this.normalRenderTarget.setSize(width, height); // if (this.isSelective)\n\n    this.metalnessRenderTarget.setSize(width, height);\n    this.blurRenderTarget.setSize(width, height);\n    this.blurRenderTarget2.setSize(width, height); // this.blurRenderTarget3.setSize(width, height);\n\n    this.ssrMaterial.uniforms['resolution'].value.set(width, height);\n    this.ssrMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);\n    this.ssrMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);\n    this.blurMaterial.uniforms['resolution'].value.set(width, height);\n    this.blurMaterial2.uniforms['resolution'].value.set(width, height);\n  }\n});\nSSRPass.OUTPUT = {\n  Default: 0,\n  SSR: 1,\n  Beauty: 3,\n  Depth: 4,\n  Normal: 5,\n  Metalness: 7\n};\n\nexport { SSRPass };\n", "import { Color, UniformsUtils, ShaderMaterial, AdditiveBlending, WebGLRenderTarget, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\n/**\n *\n * Supersample Anti-Aliasing Render Pass\n *\n * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n *\n * References: https://en.wikipedia.org/wiki/Supersampling\n *\n */\n\nvar SSAARenderPass = function (scene, camera, clearColor, clearAlpha) {\n  this.scene = scene;\n  this.camera = camera;\n  this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n\n  this.unbiased = true; // as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\n\n  this.clearColor = clearColor !== undefined ? clearColor : 0x000000;\n  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n  this._oldClearColor = new Color();\n  if (CopyShader === undefined) console.error('THREE.SSAARenderPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyMaterial = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    premultipliedAlpha: true,\n    transparent: true,\n    blending: AdditiveBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  this.fsQuad = new FullScreenQuad(this.copyMaterial);\n};\n\nSSAARenderPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: SSAARenderPass,\n  dispose: function () {\n    if (this.sampleRenderTarget) {\n      this.sampleRenderTarget.dispose();\n      this.sampleRenderTarget = null;\n    }\n  },\n  setSize: function (width, height) {\n    if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);\n  },\n  render: function (renderer, writeBuffer, readBuffer) {\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n        minFilter: LinearFilter,\n        magFilter: LinearFilter,\n        format: RGBAFormat\n      });\n      this.sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\n    }\n\n    var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.getClearColor(this._oldClearColor);\n    var oldClearAlpha = renderer.getClearAlpha();\n    var baseSampleWeight = 1.0 / jitterOffsets.length;\n    var roundingRange = 1 / 32;\n    this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n    var width = readBuffer.width,\n        height = readBuffer.height; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n    for (let i = 0; i < jitterOffsets.length; i++) {\n      var jitterOffset = jitterOffsets[i];\n\n      if (this.camera.setViewOffset) {\n        this.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n        width, height);\n      }\n\n      var sampleWeight = baseSampleWeight;\n\n      if (this.unbiased) {\n        // the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n        // The following equation varies the sampleWeight per sample so that it is uniformly distributed\n        // across a range of values whose rounding errors cancel each other out.\n        var uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\n        sampleWeight += roundingRange * uniformCenteredDistribution;\n      }\n\n      this.copyUniforms['opacity'].value = sampleWeight;\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\n      renderer.setRenderTarget(this.sampleRenderTarget);\n      renderer.clear();\n      renderer.render(this.scene, this.camera);\n      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n\n      if (i === 0) {\n        renderer.setClearColor(0x000000, 0.0);\n        renderer.clear();\n      }\n\n      this.fsQuad.render(renderer);\n    }\n\n    if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    renderer.autoClear = autoClear;\n    renderer.setClearColor(this._oldClearColor, oldClearAlpha);\n  }\n}); // These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n\nSSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\n\nexport { SSAARenderPass };\n", "import { WebGLRenderTarget } from 'three';\nimport { SSAARenderPass } from './SSAARenderPass.js';\n\n/**\n *\n * Temporal Anti-Aliasing Render Pass\n *\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\n *\n * References:\n *\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\n *\n */\n\nvar TAARenderPass = function (scene, camera, clearColor, clearAlpha) {\n  if (SSAARenderPass === undefined) {\n    console.error('THREE.TAARenderPass relies on SSAARenderPass');\n  }\n\n  SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);\n  this.sampleLevel = 0;\n  this.accumulate = false;\n};\n\nTAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;\nTAARenderPass.prototype = Object.assign(Object.create(SSAARenderPass.prototype), {\n  constructor: TAARenderPass,\n  render: function (renderer, writeBuffer, readBuffer, deltaTime) {\n    if (!this.accumulate) {\n      SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);\n      this.accumulateIndex = -1;\n      return;\n    }\n\n    var jitterOffsets = TAARenderPass.JitterVectors[5];\n\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\n    }\n\n    if (!this.holdRenderTarget) {\n      this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.holdRenderTarget.texture.name = 'TAARenderPass.hold';\n    }\n\n    if (this.accumulate && this.accumulateIndex === -1) {\n      SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\n      this.accumulateIndex = 0;\n    }\n\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    var sampleWeight = 1.0 / jitterOffsets.length;\n\n    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\n      this.copyUniforms['opacity'].value = sampleWeight;\n      this.copyUniforms['tDiffuse'].value = writeBuffer.texture; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n      var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\n\n      for (let i = 0; i < numSamplesPerFrame; i++) {\n        var j = this.accumulateIndex;\n        var jitterOffset = jitterOffsets[j];\n\n        if (this.camera.setViewOffset) {\n          this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n          readBuffer.width, readBuffer.height);\n        }\n\n        renderer.setRenderTarget(writeBuffer);\n        renderer.clear();\n        renderer.render(this.scene, this.camera);\n        renderer.setRenderTarget(this.sampleRenderTarget);\n        if (this.accumulateIndex === 0) renderer.clear();\n        this.fsQuad.render(renderer);\n        this.accumulateIndex++;\n        if (this.accumulateIndex >= jitterOffsets.length) break;\n      }\n\n      if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    }\n\n    var accumulationWeight = this.accumulateIndex * sampleWeight;\n\n    if (accumulationWeight > 0) {\n      this.copyUniforms['opacity'].value = 1.0;\n      this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    if (accumulationWeight < 1.0) {\n      this.copyUniforms['opacity'].value = 1.0 - accumulationWeight;\n      this.copyUniforms['tDiffuse'].value = this.holdRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      if (accumulationWeight === 0) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    renderer.autoClear = autoClear;\n  }\n});\n\nexport { TAARenderPass };\n", "import { Vector2 } from 'three';\n\n/**\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nconst ConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: '25.0',\n    KERNEL_SIZE_INT: '25'\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    uImageIncrement: {\n      value: new Vector2(0.001953125, 0.0)\n    },\n    cKernel: {\n      value: []\n    }\n  },\n  vertexShader: ['uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float cKernel[ KERNEL_SIZE_INT ];', 'uniform sampler2D tDiffuse;', 'uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvec2 imageCoord = vUv;', '\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );', '\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {', '\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];', '\t\timageCoord += uImageIncrement;', '\t}', '\tgl_FragColor = sum;', '}'].join('\\n'),\n  buildKernel: function (sigma) {\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n    function gauss(x, sigma) {\n      return Math.exp(-(x * x) / (2.0 * sigma * sigma));\n    }\n\n    const kMaxKernelSize = 25;\n    const kernelSize = Math.min(2 * Math.ceil(sigma * 3.0) + 1, kMaxKernelSize);\n    const halfWidth = (kernelSize - 1) * 0.5;\n    const values = new Array(kernelSize);\n    let sum = 0.0;\n\n    for (let i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    } // normalize the kernel\n\n\n    for (let i = 0; i < kernelSize; ++i) values[i] /= sum;\n\n    return values;\n  }\n};\n\nexport { ConvolutionShader };\n", "import { Loader, LoaderUtils, FileLoader, Color, SpotLight, PointLight, DirectionalLight, MeshBasicMaterial, sRGBEncoding, MeshPhysicalMaterial, Vector2, TangentSpaceNormalMap, Quaternion, TextureLoader, ImageBitmapLoader, InterleavedBuffer, InterleavedBufferAttribute, BufferAttribute, LinearFilter, LinearMipmapLinearFilter, RepeatWrapping, PointsMaterial, Material, LineBasicMaterial, MeshStandardMaterial, DoubleSide, PropertyBinding, BufferGeometry, SkinnedMesh, Mesh, LineSegments, Line, LineLoop, Points, Group, PerspectiveCamera, MathUtils, OrthographicCamera, InterpolateLinear, AnimationClip, Bone, Object3D, Matrix4, Skeleton, TriangleFanDrawMode, NearestFilter, NearestMipmapNearestFilter, LinearMipmapNearestFilter, NearestMipmapLinearFilter, ClampToEdgeWrapping, MirroredRepeatWrapping, InterpolateDiscrete, FrontSide, Texture, TriangleStripDrawMode, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Box3, Vector3, Sphere, Interpolant } from 'three';\n\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsSheenExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMaterialsIridescenceExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== '') {\n      resourcePath = this.path;\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url);\n    } // Tells the LoadingManager to track an extra item, which resolves after\n    // the model is fully loaded. This means the count of items loaded will\n    // be incorrect, but ensures manager.onLoad() does not fire early.\n\n\n    this.manager.itemStart(url);\n\n    const _onError = function (e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        scope.parse(data, resourcePath, function (gltf) {\n          onLoad(gltf);\n          scope.manager.itemEnd(url);\n        }, _onError);\n      } catch (e) {\n        _onError(e);\n      }\n    }, onProgress, _onError);\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n\n    return this;\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n\n    return this;\n  }\n\n  parse(data, path, onLoad, onError) {\n    let content;\n    const extensions = {};\n    const plugins = {};\n\n    if (typeof data === 'string') {\n      content = data;\n    } else {\n      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError) onError(error);\n          return;\n        }\n\n        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n      } else {\n        content = LoaderUtils.decodeText(new Uint8Array(data));\n      }\n    }\n\n    const json = JSON.parse(content);\n\n    if (json.asset === undefined || json.asset.version[0] < 2) {\n      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));\n      return;\n    }\n\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || '',\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      plugins[plugin.name] = plugin; // Workaround to avoid determining as unknown extension\n      // in addUnknownExtensionsToUserData().\n      // Remove this workaround if we move all the existing\n      // extension handlers to plugin system\n\n      extensions[plugin.name] = true;\n    }\n\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n            break;\n\n          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n            break;\n\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n\n        }\n      }\n    }\n\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n\n  parseAsync(data, path) {\n    const scope = this;\n    return new Promise(function (resolve, reject) {\n      scope.parse(data, path, resolve, reject);\n    });\n  }\n\n}\n/* GLTFREGISTRY */\n\n\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function (key) {\n      return objects[key];\n    },\n    add: function (key, object) {\n      objects[key] = object;\n    },\n    remove: function (key) {\n      delete objects[key];\n    },\n    removeAll: function () {\n      objects = {};\n    }\n  };\n}\n/*********************************/\n\n/********** EXTENSIONS ***********/\n\n/*********************************/\n\n\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\n  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\n};\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\n\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; // Object3D instance caches\n\n    this.cache = {\n      refs: {},\n      uses: {}\n    };\n  }\n\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = 'light:' + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency) return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new Color(0xffffff);\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color);\n    const range = lightDef.range !== undefined ? lightDef.range : 0;\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      case 'point':\n        lightNode = new PointLight(color);\n        lightNode.distance = range;\n        break;\n\n      case 'spot':\n        lightNode = new SpotLight(color);\n        lightNode.distance = range; // Handle spotlight properties.\n\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type);\n    } // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n\n\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n\n  createNodeAttachment(nodeIndex) {\n    const self = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === undefined) return null;\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self.cache, lightIndex, light);\n    });\n  }\n\n}\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\n\n\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n\n  getMaterialType() {\n    return MeshBasicMaterial;\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding));\n      }\n    }\n\n    return Promise.all(pending);\n  }\n\n}\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\n\n\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n\n    if (emissiveStrength !== undefined) {\n      materialParams.emissiveIntensity = emissiveStrength;\n    }\n\n    return Promise.resolve();\n  }\n\n}\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\n\n\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        const scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale);\n      }\n    }\n\n    return Promise.all(pending);\n  }\n\n}\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\n\n\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n\n    if (extension.iridescenceFactor !== undefined) {\n      materialParams.iridescence = extension.iridescenceFactor;\n    }\n\n    if (extension.iridescenceTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'iridescenceMap', extension.iridescenceTexture));\n    }\n\n    if (extension.iridescenceIor !== undefined) {\n      materialParams.iridescenceIOR = extension.iridescenceIor;\n    }\n\n    if (materialParams.iridescenceThicknessRange === undefined) {\n      materialParams.iridescenceThicknessRange = [100, 400];\n    }\n\n    if (extension.iridescenceThicknessMinimum !== undefined) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n    }\n\n    if (extension.iridescenceThicknessMaximum !== undefined) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n    }\n\n    if (extension.iridescenceThicknessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture));\n    }\n\n    return Promise.all(pending);\n  }\n\n}\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\n\n\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n    materialParams.sheenColor = new Color(0, 0, 0);\n    materialParams.sheenRoughness = 0;\n    materialParams.sheen = 1;\n    const extension = materialDef.extensions[this.name];\n\n    if (extension.sheenColorFactor !== undefined) {\n      materialParams.sheenColor.fromArray(extension.sheenColorFactor);\n    }\n\n    if (extension.sheenRoughnessFactor !== undefined) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n    }\n\n    if (extension.sheenColorTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture, sRGBEncoding));\n    }\n\n    if (extension.sheenRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture));\n    }\n\n    return Promise.all(pending);\n  }\n\n}\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\n\n\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n\n    if (extension.transmissionFactor !== undefined) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n\n    if (extension.transmissionTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));\n    }\n\n    return Promise.all(pending);\n  }\n\n}\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\n\n\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n    if (extension.thicknessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture));\n    }\n\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);\n    return Promise.all(pending);\n  }\n\n}\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\n\n\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const extension = materialDef.extensions[this.name];\n    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n    return Promise.resolve();\n  }\n\n}\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\n\n\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n    if (extension.specularTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture));\n    }\n\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);\n\n    if (extension.specularColorTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture, sRGBEncoding));\n    }\n\n    return Promise.all(pending);\n  }\n\n}\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\n\n\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n\n    const extension = textureDef.extensions[this.name];\n    const loader = parser.options.ktx2Loader;\n\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');\n      } else {\n        // Assumes that the extension is optional and that a fallback texture is present\n        return null;\n      }\n    }\n\n    return parser.loadTextureImage(textureIndex, extension.source, loader);\n  }\n\n}\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\n\n\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null) loader = handler;\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');\n      } // Fall back to PNG or JPEG.\n\n\n      return parser.loadTexture(textureIndex);\n    });\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image(); // Lossy test image. Support for lossy images doesn't guarantee support for all\n        // WebP images, unfortunately.\n\n        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1);\n        };\n      });\n    }\n\n    return this.isSupported;\n  }\n\n}\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\n\n\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');\n        } else {\n          // Assumes that the extension is optional and that fallback buffer data is present\n          return null;\n        }\n      }\n\n      return buffer.then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const source = new Uint8Array(res, byteOffset, byteLength);\n\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function (res) {\n            return res.buffer;\n          });\n        } else {\n          // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n          return decoder.ready.then(function () {\n            const result = new ArrayBuffer(count * stride);\n            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n            return result;\n          });\n        }\n      });\n    } else {\n      return null;\n    }\n  }\n\n}\n/* BINARY EXTENSION */\n\n\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = {\n  JSON: 0x4e4f534a,\n  BIN: 0x004e4942\n};\n\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.');\n    }\n\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      } // Clients must ignore chunks with unknown types.\n\n\n      chunkIndex += chunkLength;\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.');\n    }\n  }\n\n}\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\n\n\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType.name;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve) {\n        dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n          for (const attributeName in geometry.attributes) {\n            const attribute = geometry.attributes[attributeName];\n            const normalized = attributeNormalizedMap[attributeName];\n            if (normalized !== undefined) attribute.normalized = normalized;\n          }\n\n          resolve(geometry);\n        }, threeAttributeMap, attributeTypeMap);\n      });\n    });\n  }\n\n}\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\n\n\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n\n  extendTexture(texture, transform) {\n    if (transform.texCoord !== undefined) {\n      console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n    }\n\n    if (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {\n      // See https://github.com/mrdoob/three.js/issues/21819.\n      return texture;\n    }\n\n    texture = texture.clone();\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset);\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation;\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale);\n    }\n\n    texture.needsUpdate = true;\n    return texture;\n  }\n\n}\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness\n */\n\n/**\n * A sub class of StandardMaterial with some of the functionality\n * changed via the `onBeforeCompile` callback\n * @pailhead\n */\n\n\nclass GLTFMeshStandardSGMaterial extends MeshStandardMaterial {\n  constructor(params) {\n    super();\n    this.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing\n\n    const specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n    const glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n    const specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n    const glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n    const lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.roughness += geometryRoughness;', 'material.roughness = min( material.roughness, 1.0 );', 'material.specularColor = specularFactor;'].join('\\n');\n    const uniforms = {\n      specular: {\n        value: new Color().setHex(0xffffff)\n      },\n      glossiness: {\n        value: 1\n      },\n      specularMap: {\n        value: null\n      },\n      glossinessMap: {\n        value: null\n      }\n    };\n    this._extraUniforms = uniforms;\n\n    this.onBeforeCompile = function (shader) {\n      for (const uniformName in uniforms) {\n        shader.uniforms[uniformName] = uniforms[uniformName];\n      }\n\n      shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n    };\n\n    Object.defineProperties(this, {\n      specular: {\n        get: function () {\n          return uniforms.specular.value;\n        },\n        set: function (v) {\n          uniforms.specular.value = v;\n        }\n      },\n      specularMap: {\n        get: function () {\n          return uniforms.specularMap.value;\n        },\n        set: function (v) {\n          uniforms.specularMap.value = v;\n\n          if (v) {\n            this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\n          } else {\n            delete this.defines.USE_SPECULARMAP;\n          }\n        }\n      },\n      glossiness: {\n        get: function () {\n          return uniforms.glossiness.value;\n        },\n        set: function (v) {\n          uniforms.glossiness.value = v;\n        }\n      },\n      glossinessMap: {\n        get: function () {\n          return uniforms.glossinessMap.value;\n        },\n        set: function (v) {\n          uniforms.glossinessMap.value = v;\n\n          if (v) {\n            this.defines.USE_GLOSSINESSMAP = '';\n            this.defines.USE_UV = '';\n          } else {\n            delete this.defines.USE_GLOSSINESSMAP;\n            delete this.defines.USE_UV;\n          }\n        }\n      }\n    });\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n    this.setValues(params);\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.specularMap = source.specularMap;\n    this.specular.copy(source.specular);\n    this.glossinessMap = source.glossinessMap;\n    this.glossiness = source.glossiness;\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n    return this;\n  }\n\n}\n\nclass GLTFMaterialsPbrSpecularGlossinessExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n    this.specularGlossinessParams = ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'];\n  }\n\n  getMaterialType() {\n    return GLTFMeshStandardSGMaterial;\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pbrSpecularGlossiness = materialDef.extensions[this.name];\n    materialParams.color = new Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n    const pending = [];\n\n    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n      const array = pbrSpecularGlossiness.diffuseFactor;\n      materialParams.color.fromArray(array);\n      materialParams.opacity = array[3];\n    }\n\n    if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture, sRGBEncoding));\n    }\n\n    materialParams.emissive = new Color(0.0, 0.0, 0.0);\n    materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n    materialParams.specular = new Color(1.0, 1.0, 1.0);\n\n    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n    }\n\n    if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n      pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\n      pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef, sRGBEncoding));\n    }\n\n    return Promise.all(pending);\n  }\n\n  createMaterial(materialParams) {\n    const material = new GLTFMeshStandardSGMaterial(materialParams);\n    material.fog = true;\n    material.color = materialParams.color;\n    material.map = materialParams.map === undefined ? null : materialParams.map;\n    material.lightMap = null;\n    material.lightMapIntensity = 1.0;\n    material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n    material.aoMapIntensity = 1.0;\n    material.emissive = materialParams.emissive;\n    material.emissiveIntensity = materialParams.emissiveIntensity === undefined ? 1.0 : materialParams.emissiveIntensity;\n    material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n    material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n    material.bumpScale = 1;\n    material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n    material.normalMapType = TangentSpaceNormalMap;\n    if (materialParams.normalScale) material.normalScale = materialParams.normalScale;\n    material.displacementMap = null;\n    material.displacementScale = 1;\n    material.displacementBias = 0;\n    material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n    material.specular = materialParams.specular;\n    material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n    material.glossiness = materialParams.glossiness;\n    material.alphaMap = null;\n    material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n    material.envMapIntensity = 1.0;\n    material.refractionRatio = 0.98;\n    return material;\n  }\n\n}\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\n\n\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n\n}\n/*********************************/\n\n/********** INTERPOLATION ********/\n\n/*********************************/\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\n\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  copySampleValue_(index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n    const result = this.resultBuffer,\n          values = this.sampleValues,\n          valueSize = this.valueSize,\n          offset = index * valueSize * 3 + valueSize;\n\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n\n    return result;\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const stride2 = stride * 2;\n    const stride3 = stride * 3;\n    const td = t1 - t0;\n    const p = (t - t0) / td;\n    const pp = p * p;\n    const ppp = pp * p;\n    const offset1 = i1 * stride3;\n    const offset0 = offset1 - stride3;\n    const s2 = -2 * ppp + 3 * pp;\n    const s3 = ppp - pp;\n    const s0 = 1 - s2;\n    const s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride]; // splineVertex_k\n\n      const m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\n      const p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\n      const m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n\n    return result;\n  }\n\n}\n\nconst _q = new Quaternion();\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1);\n\n    _q.fromArray(result).normalize().toArray(result);\n\n    return result;\n  }\n\n}\n/*********************************/\n\n/********** INTERNALS ************/\n\n/*********************************/\n\n/* CONSTANTS */\n\n\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  TEXCOORD_0: 'uv',\n  TEXCOORD_1: 'uv2',\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex'\n};\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences'\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: undefined,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND'\n};\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\n\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\n      color: 0xffffff,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide\n    });\n  }\n\n  return cache['DefaultMaterial'];\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\n\n\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (typeof gltfDef.extras === 'object') {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\n    }\n  }\n}\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\n\n\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n  let hasMorphColor = false;\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== undefined) hasMorphPosition = true;\n    if (target.NORMAL !== undefined) hasMorphNormal = true;\n    if (target.COLOR_0 !== undefined) hasMorphColor = true;\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n  const pendingColorAccessors = [];\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n\n    if (hasMorphColor) {\n      const pendingAccessor = target.COLOR_0 !== undefined ? parser.getDependency('accessor', target.COLOR_0) : geometry.attributes.color;\n      pendingColorAccessors.push(pendingAccessor);\n    }\n  }\n\n  return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors), Promise.all(pendingColorAccessors)]).then(function (accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    const morphColors = accessors[2];\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n    if (hasMorphColor) geometry.morphAttributes.color = morphColors;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\n\n\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n\n  if (meshDef.weights !== undefined) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  } // .extras has user-defined data, so check that .extras.targetNames is an array.\n\n\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  let geometryKey;\n\n  if (dracoExtension) {\n    geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\n  }\n\n  return geometryKey;\n}\n\nfunction createAttributesKey(attributes) {\n  let attributesKey = '';\n  const keys = Object.keys(attributes).sort();\n\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n  }\n\n  return attributesKey;\n}\n\nfunction getNormalizedComponentScale(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n\n    case Uint8Array:\n      return 1 / 255;\n\n    case Int16Array:\n      return 1 / 32767;\n\n    case Uint16Array:\n      return 1 / 65535;\n\n    default:\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');\n  }\n}\n\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return 'image/jpeg';\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return 'image/webp';\n  return 'image/png';\n}\n/* GLTF PARSER */\n\n\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    var _navigator$userAgent, _navigator$userAgent2;\n\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options; // loader object cache\n\n    this.cache = new GLTFRegistry(); // associations between Three.js objects and glTF elements\n\n    this.associations = new Map(); // BufferGeometry caching\n\n    this.primitiveCache = {}; // Object3D instance caches\n\n    this.meshCache = {\n      refs: {},\n      uses: {}\n    };\n    this.cameraCache = {\n      refs: {},\n      uses: {}\n    };\n    this.lightCache = {\n      refs: {},\n      uses: {}\n    };\n    this.sourceCache = {};\n    this.textureCache = {}; // Track node names, to ensure no duplicates\n\n    this.nodeNamesUsed = {}; // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n\n    const isSafari = typeof navigator !== 'undefined' && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n    const isFirefox = typeof navigator !== 'undefined' && ((_navigator$userAgent = navigator.userAgent) === null || _navigator$userAgent === void 0 ? void 0 : _navigator$userAgent.indexOf('Firefox')) > -1;\n    const firefoxVersion = typeof navigator !== 'undefined' && isFirefox ? (_navigator$userAgent2 = navigator.userAgent) === null || _navigator$userAgent2 === void 0 ? void 0 : _navigator$userAgent2.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n\n    if (typeof createImageBitmap === 'undefined' || isSafari || isFirefox && firefoxVersion < 98) {\n      this.textureLoader = new TextureLoader(this.options.manager);\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager);\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new FileLoader(this.options.manager);\n    this.fileLoader.setResponseType('arraybuffer');\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions; // Clear the loader cache\n\n    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\n\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n\n    Promise.all(this._invokeAll(function (ext) {\n      return ext.beforeRoot && ext.beforeRoot();\n    })).then(function () {\n      return Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera')]);\n    }).then(function (dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser: parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      Promise.all(parser._invokeAll(function (ext) {\n        return ext.afterRoot && ext.afterRoot(result);\n      })).then(function () {\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n\n\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || []; // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    } // Iterate over all nodes, marking references to shared resources,\n    // as well as skeleton joints.\n\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.mesh !== undefined) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh); // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n\n\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n\n      if (nodeDef.camera !== undefined) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n\n\n  _addNodeRef(cache, index) {\n    if (index === undefined) return;\n\n    if (cache.refs[index] === undefined) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n\n    cache.refs[index]++;\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n\n\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object;\n    const ref = object.clone(); // Propagates mappings to the cloned object, prevents mappings on the\n    // original object from being lost.\n\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original);\n\n      if (mappings != null) {\n        this.associations.set(clone, mappings);\n      }\n\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i]);\n      }\n    };\n\n    updateMappings(object, ref);\n    ref.name += '_instance_' + cache.uses[index]++;\n    return ref;\n  }\n\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result) return result;\n    }\n\n    return null;\n  }\n\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result) pending.push(result);\n    }\n\n    return pending;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n\n\n  getDependency(type, index) {\n    const cacheKey = type + ':' + index;\n    let dependency = this.cache.get(cacheKey);\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index);\n          break;\n\n        case 'node':\n          dependency = this.loadNode(index);\n          break;\n\n        case 'mesh':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n\n        case 'accessor':\n          dependency = this.loadAccessor(index);\n          break;\n\n        case 'bufferView':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n\n        case 'buffer':\n          dependency = this.loadBuffer(index);\n          break;\n\n        case 'material':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n\n        case 'texture':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n\n        case 'skin':\n          dependency = this.loadSkin(index);\n          break;\n\n        case 'animation':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadAnimation && ext.loadAnimation(index);\n          });\n          break;\n\n        case 'camera':\n          dependency = this.loadCamera(index);\n          break;\n\n        default:\n          throw new Error('Unknown type: ' + type);\n      }\n\n      this.cache.add(cacheKey, dependency);\n    }\n\n    return dependency;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n\n\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n      dependencies = Promise.all(defs.map(function (def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n\n    return dependencies;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n    } // If present, GLB container is required to be the first buffer.\n\n\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n\n    const options = this.options;\n    return new Promise(function (resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n\n\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      // Ignore empty accessors, which may be used to declare runtime\n      // information about attributes coming from another source (e.g. Draco\n      // compression extension).\n      return Promise.resolve(null);\n    }\n\n    const pendingBufferViews = [];\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\n\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\n      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\n\n      if (accessorDef.sparse !== undefined) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n        }\n\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n        }\n      }\n\n      return bufferAttribute;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture>}\n   */\n\n\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const sourceIndex = textureDef.source;\n    const sourceDef = json.images[sourceIndex];\n    let loader = this.textureLoader;\n\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri);\n      if (handler !== null) loader = handler;\n    }\n\n    return this.loadTextureImage(textureIndex, sourceIndex, loader);\n  }\n\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const textureDef = json.textures[textureIndex];\n    const sourceDef = json.images[sourceIndex];\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler;\n\n    if (this.textureCache[cacheKey]) {\n      // See https://github.com/mrdoob/three.js/issues/21559.\n      return this.textureCache[cacheKey];\n    }\n\n    const promise = this.loadImageSource(sourceIndex, loader).then(function (texture) {\n      texture.flipY = false;\n      if (textureDef.name) texture.name = textureDef.name;\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\n      parser.associations.set(texture, {\n        textures: textureIndex\n      });\n      return texture;\n    }).catch(function () {\n      return null;\n    });\n    this.textureCache[cacheKey] = promise;\n    return promise;\n  }\n\n  loadImageSource(sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n\n    if (this.sourceCache[sourceIndex] !== undefined) {\n      return this.sourceCache[sourceIndex].then(texture => texture.clone());\n    }\n\n    const sourceDef = json.images[sourceIndex];\n    const URL = self.URL || self.webkitURL;\n    let sourceURI = sourceDef.uri || '';\n    let isObjectURL = false;\n\n    if (sourceDef.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n      sourceURI = parser.getDependency('bufferView', sourceDef.bufferView).then(function (bufferView) {\n        isObjectURL = true;\n        const blob = new Blob([bufferView], {\n          type: sourceDef.mimeType\n        });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (sourceDef.uri === undefined) {\n      throw new Error('THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView');\n    }\n\n    const promise = Promise.resolve(sourceURI).then(function (sourceURI) {\n      return new Promise(function (resolve, reject) {\n        let onLoad = resolve;\n\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function (imageBitmap) {\n            const texture = new Texture(imageBitmap);\n            texture.needsUpdate = true;\n            resolve(texture);\n          };\n        }\n\n        loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject);\n      });\n    }).then(function (texture) {\n      // Clean up resources and configure Texture.\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n\n      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n      return texture;\n    }).catch(function (error) {\n      console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n      throw error;\n    });\n    this.sourceCache[sourceIndex] = promise;\n    return promise;\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n\n\n  assignTexture(materialParams, mapName, mapDef, encoding) {\n    const parser = this;\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n      // However, we will copy UV set 0 to UV set 1 on demand for aoMap\n      if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {\n        console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n\n      if (encoding !== undefined) {\n        texture.encoding = encoding;\n      }\n\n      materialParams[mapName] = texture;\n      return texture;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n\n\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useDerivativeTangents = geometry.attributes.tangent === undefined;\n    const useVertexColors = geometry.attributes.color !== undefined;\n    const useFlatShading = geometry.attributes.normal === undefined;\n\n    if (mesh.isPoints) {\n      const cacheKey = 'PointsMaterial:' + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial();\n        Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = 'LineBasicMaterial:' + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial();\n        Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        this.cache.add(cacheKey, lineMaterial);\n      }\n\n      material = lineMaterial;\n    } // Clone the material if it will be modified\n\n\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n      if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';\n      if (useDerivativeTangents) cacheKey += 'derivative-tangents:';\n      if (useVertexColors) cacheKey += 'vertex-colors:';\n      if (useFlatShading) cacheKey += 'flat-shading:';\n      let cachedMaterial = this.cache.get(cacheKey);\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useVertexColors) cachedMaterial.vertexColors = true;\n        if (useFlatShading) cachedMaterial.flatShading = true;\n\n        if (useDerivativeTangents) {\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n\n      material = cachedMaterial;\n    } // workarounds for mesh and geometry\n\n\n    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n      geometry.setAttribute('uv2', geometry.attributes.uv);\n    }\n\n    mesh.material = material;\n  }\n\n  getMaterialType() {\n    return MeshStandardMaterial;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n\n\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n      const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n      materialType = sgExtension.getMaterialType();\n      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding));\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\n      }\n\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(Promise.all(this._invokeAll(function (ext) {\n        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n      })));\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide;\n    }\n\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706\n\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));\n      materialParams.normalScale = new Vector2(1, 1);\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        const scale = materialDef.normalTexture.scale;\n        materialParams.normalScale.set(scale, scale);\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture, sRGBEncoding));\n    }\n\n    return Promise.all(pending).then(function () {\n      let material;\n\n      if (materialType === GLTFMeshStandardSGMaterial) {\n        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n      } else {\n        material = new materialType(materialParams);\n      }\n\n      if (materialDef.name) material.name = materialDef.name;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, {\n        materials: materialIndex\n      });\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n\n\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '');\n    let name = sanitizedName;\n\n    for (let i = 1; this.nodeNamesUsed[name]; ++i) {\n      name = sanitizedName + '_' + i;\n    }\n\n    this.nodeNamesUsed[name] = true;\n    return name;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n\n\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n\n    const pending = [];\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\n\n      const cached = cache[cacheKey];\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);\n        } // Cache this geometry\n\n\n        cache[cacheKey] = {\n          primitive: primitive,\n          promise: geometryPromise\n        };\n        pending.push(geometryPromise);\n      }\n    }\n\n    return Promise.all(pending);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n\n\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);\n      pending.push(material);\n    }\n\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i]; // 1. create Mesh\n\n        let mesh;\n        const material = materials[i];\n\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);\n\n          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n            // we normalize floating point skin weight array to fix malformed assets (see #15319)\n            // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n            mesh.normalizeSkinWeights();\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material);\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n\n        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i\n        });\n      }\n\n      if (meshes.length === 1) {\n        return meshes[0];\n      }\n\n      const group = new Group();\n      parser.associations.set(group, {\n        meshes: meshIndex\n      });\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n\n      return group;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n\n\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.');\n      return;\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Object>}\n   */\n\n\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const skinEntry = {\n      joints: skinDef.joints\n    };\n\n    if (skinDef.inverseBindMatrices === undefined) {\n      return Promise.resolve(skinEntry);\n    }\n\n    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n      skinEntry.inverseBindMatrices = accessor;\n      return skinEntry;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n\n\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const animationDef = json.animations[animationIndex];\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node;\n      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n      pendingNodes.push(this.getDependency('node', name));\n      pendingInputAccessors.push(this.getDependency('accessor', input));\n      pendingOutputAccessors.push(this.getDependency('accessor', output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n\n    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === undefined) continue;\n        node.updateMatrix();\n        let TypedKeyframeTrack;\n\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = NumberKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = QuaternionKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack;\n            break;\n        }\n\n        const targetName = node.name ? node.name : node.uuid;\n        const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;\n        const targetNames = [];\n\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          node.traverse(function (object) {\n            if (object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n\n        let outputArray = outputAccessor.array;\n\n        if (outputAccessor.normalized) {\n          const scale = getNormalizedComponentScale(outputArray.constructor);\n          const scaled = new Float32Array(outputArray.length);\n\n          for (let j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale;\n          }\n\n          outputArray = scaled;\n        }\n\n        for (let j = 0, jl = targetNames.length; j < jl; j++) {\n          const track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.\n\n          if (sampler.interpolation === 'CUBICSPLINE') {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n              // must be divided by three to get the interpolant's sampleSize argument.\n              const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n            }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\n\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n\n          tracks.push(track);\n        }\n      }\n\n      const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n      return new AnimationClip(name, undefined, tracks);\n    });\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === undefined) return null;\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh); // if weights are provided on the node, override weights on the mesh.\n\n\n      if (nodeDef.weights !== undefined) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return;\n\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n\n\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex]; // reserve node's name before its dependencies, so the root has the intended name.\n\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';\n    return function () {\n      const pending = [];\n\n      const meshPromise = parser._invokeOne(function (ext) {\n        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n      });\n\n      if (meshPromise) {\n        pending.push(meshPromise);\n      }\n\n      if (nodeDef.camera !== undefined) {\n        pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n        }));\n      }\n\n      parser._invokeAll(function (ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n      }).forEach(function (promise) {\n        pending.push(promise);\n      });\n\n      return Promise.all(pending);\n    }().then(function (objects) {\n      let node; // .isBone isn't in glTF spec. See ._markDefs\n\n      if (nodeDef.isBone === true) {\n        node = new Bone();\n      } else if (objects.length > 1) {\n        node = new Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new Object3D();\n      }\n\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n\n      if (nodeDef.matrix !== undefined) {\n        const matrix = new Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation);\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {});\n      }\n\n      parser.associations.get(node).nodes = nodeIndex;\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n\n\n  loadScene(sceneIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this; // Loader returns Group, not Scene.\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\n    const scene = new Group();\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(buildNodeHierarchy(nodeIds[i], scene, json, parser));\n    }\n\n    return Promise.all(pending).then(function () {\n      // Removes dangling associations, associations that reference a node that\n      // didn't make it into the scene.\n      const reduceAssociations = node => {\n        const reducedAssociations = new Map();\n\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value);\n          }\n        }\n\n        node.traverse(node => {\n          const mappings = parser.associations.get(node);\n\n          if (mappings != null) {\n            reducedAssociations.set(node, mappings);\n          }\n        });\n        return reducedAssociations;\n      };\n\n      parser.associations = reduceAssociations(scene);\n      return scene;\n    });\n  }\n\n}\n\nfunction buildNodeHierarchy(nodeId, parentObject, json, parser) {\n  const nodeDef = json.nodes[nodeId];\n  return parser.getDependency('node', nodeId).then(function (node) {\n    if (nodeDef.skin === undefined) return node; // build skeleton here as well\n\n    let skinEntry;\n    return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\n      skinEntry = skin;\n      const pendingJoints = [];\n\n      for (let i = 0, il = skinEntry.joints.length; i < il; i++) {\n        pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\n      }\n\n      return Promise.all(pendingJoints);\n    }).then(function (jointNodes) {\n      node.traverse(function (mesh) {\n        if (!mesh.isMesh) return;\n        const bones = [];\n        const boneInverses = [];\n\n        for (let j = 0, jl = jointNodes.length; j < jl; j++) {\n          const jointNode = jointNodes[j];\n\n          if (jointNode) {\n            bones.push(jointNode);\n            const mat = new Matrix4();\n\n            if (skinEntry.inverseBindMatrices !== undefined) {\n              mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n            }\n\n            boneInverses.push(mat);\n          } else {\n            console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n          }\n        }\n\n        mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);\n      });\n      return node;\n    });\n  }).then(function (node) {\n    // build node hierachy\n    parentObject.add(node);\n    const pending = [];\n\n    if (nodeDef.children) {\n      const children = nodeDef.children;\n\n      for (let i = 0, il = children.length; i < il; i++) {\n        const child = children[i];\n        pending.push(buildNodeHierarchy(child, node, json, parser));\n      }\n    }\n\n    return Promise.all(pending);\n  });\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\n\n\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new Box3();\n\n  if (attributes.POSITION !== undefined) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));\n\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n      return;\n    }\n  } else {\n    return;\n  }\n\n  const targets = primitiveDef.targets;\n\n  if (targets !== undefined) {\n    const maxDisplacement = new Vector3();\n    const vector = new Vector3();\n\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n\n      if (target.POSITION !== undefined) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (min !== undefined && max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          } // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\n\n          maxDisplacement.max(vector);\n        } else {\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n        }\n      }\n    } // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\n\n    box.expandByVector(maxDisplacement);\n  }\n\n  geometry.boundingBox = box;\n  const sphere = new Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\n\n\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\n\n    if (threeAttributeName in geometry.attributes) continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n      geometry.setIndex(accessor);\n    });\n    pending.push(accessor);\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {Number} drawMode\n * @return {BufferGeometry}\n */\n\n\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  let index = geometry.getIndex(); // generate index if not present\n\n  if (index === null) {\n    const indices = [];\n    const position = geometry.getAttribute('position');\n\n    if (position !== undefined) {\n      for (let i = 0; i < position.count; i++) {\n        indices.push(i);\n      }\n\n      geometry.setIndex(indices);\n      index = geometry.getIndex();\n    } else {\n      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n      return geometry;\n    }\n  } //\n\n\n  const numberOfTriangles = index.count - 2;\n  const newIndices = [];\n\n  if (drawMode === TriangleFanDrawMode) {\n    // gl.TRIANGLE_FAN\n    for (let i = 1; i <= numberOfTriangles; i++) {\n      newIndices.push(index.getX(0));\n      newIndices.push(index.getX(i));\n      newIndices.push(index.getX(i + 1));\n    }\n  } else {\n    // gl.TRIANGLE_STRIP\n    for (let i = 0; i < numberOfTriangles; i++) {\n      if (i % 2 === 0) {\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n        newIndices.push(index.getX(i + 2));\n      } else {\n        newIndices.push(index.getX(i + 2));\n        newIndices.push(index.getX(i + 1));\n        newIndices.push(index.getX(i));\n      }\n    }\n  }\n\n  if (newIndices.length / 3 !== numberOfTriangles) {\n    console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n  } // build final geometry\n\n\n  const newGeometry = geometry.clone();\n  newGeometry.setIndex(newIndices);\n  return newGeometry;\n}\n\nexport { GLTFLoader };\n", "import * as THREE from 'three';\n\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 0.002;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 0.003;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = new THREE.Vector3(0, 1, 0);\nconst ZAXIS = new THREE.Vector3(0, 0, 1);\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\n\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super();\n    this.hand = hand;\n    this.controller = controller;\n    this.motionController = null;\n    this.envMap = null;\n    this.mesh = null;\n    this.pointerGeometry = null;\n    this.pointerMesh = null;\n    this.pointerObject = null;\n    this.pinched = false;\n    this.attached = false;\n    this.cursorObject = null;\n    this.raycaster = null;\n    hand.addEventListener('connected', event => {\n      const xrInputSource = event.data;\n\n      if (xrInputSource.hand) {\n        this.visible = true;\n        this.xrInputSource = xrInputSource;\n        this.createPointer();\n      }\n    });\n  }\n\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone();\n\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n      const vid = ringIndex * POINTER_SEGMENTS + i;\n      vertices[3 * vid] = segmentVector.x;\n      vertices[3 * vid + 1] = segmentVector.y;\n      vertices[3 * vid + 2] = segmentVector.z;\n    }\n  }\n\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array; // first ring for front face\n\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n\n    this._drawVerticesRing(vertices, frontFaceBase, 0); // rings for rear hemisphere\n\n\n    const rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1);\n\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n    } // front and rear face center vertices\n\n\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n    vertices[frontCenterIndex * 3] = frontCenter.x;\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\n    vertices[rearCenterIndex * 3] = rearCenter.x;\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); // verticesNeedUpdate = true;\n  }\n\n  createPointer() {\n    var i, j;\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0); // const vertices = [];\n\n    const indices = [];\n    this.pointerGeometry = new THREE.BufferGeometry();\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n    this._updatePointerVertices(POINTER_REAR_RADIUS); // construct faces to connect rings\n\n\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n      }\n\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n    } // construct front and rear face\n\n\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i);\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n    }\n\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n    const material = new THREE.MeshBasicMaterial();\n    material.transparent = true;\n    material.opacity = POINTER_OPACITY_MIN;\n    this.pointerGeometry.setIndex(indices);\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n    this.pointerObject = new THREE.Object3D();\n    this.pointerObject.add(this.pointerMesh);\n    this.raycaster = new THREE.Raycaster(); // create cursor\n\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n    const cursorMaterial = new THREE.MeshBasicMaterial();\n    cursorMaterial.transparent = true;\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n    this.pointerObject.add(this.cursorObject);\n    this.add(this.pointerObject);\n  }\n\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld;\n      const tempMatrix = new THREE.Matrix4();\n      tempMatrix.identity().extractRotation(pointerMatrix);\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    }\n  }\n\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible;\n    const indexTip = this.hand.joints['index-finger-tip'];\n    const thumbTip = this.hand.joints['thumb-tip'];\n    const distance = indexTip.position.distanceTo(thumbTip.position);\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n    this.pointerObject.position.copy(position);\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\n    this.pinched = distance <= PINCH_THRESHOLD;\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n\n      this._updatePointerVertices(rearRadius);\n\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n    }\n\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n  }\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n\n    if (this.pointerGeometry) {\n      this._updatePointer();\n\n      this._updateRaycaster();\n    }\n  }\n\n  isPinched() {\n    return this.pinched;\n  }\n\n  setAttached(attached) {\n    this.attached = attached;\n  }\n\n  isAttached() {\n    return this.attached;\n  }\n\n  intersectObject(object, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive);\n    }\n  }\n\n  intersectObjects(objects, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive);\n    }\n  }\n\n  checkIntersections(objects, recursive = false) {\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\n      const direction = new THREE.Vector3(0, 0, -1);\n\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const distance = intersection.distance;\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n      }\n    }\n  }\n\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1);\n\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\n    }\n  }\n\n}\n\nexport { OculusHandPointerModel };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\n\nclass VRButton {\n  static createButton(renderer, sessionInit = {}) {\n    const button = document.createElement('button');\n\n    function\n      /*device*/\n    showEnterVR() {\n      let currentSession = null;\n\n      async function onSessionStarted(session) {\n        session.addEventListener('end', onSessionEnded);\n        await renderer.xr.setSession(session);\n        button.textContent = 'EXIT VR';\n        currentSession = session;\n      }\n\n      function\n        /*event*/\n      onSessionEnded() {\n        currentSession.removeEventListener('end', onSessionEnded);\n        button.textContent = 'ENTER VR';\n        currentSession = null;\n      } //\n\n\n      button.style.display = '';\n      button.style.cursor = 'pointer';\n      button.style.left = 'calc(50% - 50px)';\n      button.style.width = '100px';\n      button.textContent = 'ENTER VR';\n\n      button.onmouseenter = () => {\n        button.style.opacity = '1.0';\n      };\n\n      button.onmouseleave = () => {\n        button.style.opacity = '0.5';\n      };\n\n      button.onclick = () => {\n        if (currentSession === null) {\n          var _xr;\n\n          // WebXR's requestReferenceSpace only works if the corresponding feature\n          // was requested at session creation time. For simplicity, just ask for\n          // the interesting ones as optional features, but be aware that the\n          // requestReferenceSpace call will fail if it turns out to be unavailable.\n          // ('local' is always available for immersive sessions and doesn't need to\n          // be requested separately.)\n          const optionalFeatures = [sessionInit.optionalFeatures, 'local-floor', 'bounded-floor', 'hand-tracking'].flat().filter(Boolean);\n          (_xr = navigator.xr) === null || _xr === void 0 ? void 0 : _xr.requestSession('immersive-vr', { ...sessionInit,\n            optionalFeatures\n          }).then(onSessionStarted);\n        } else {\n          currentSession.end();\n        }\n      };\n    }\n\n    function disableButton() {\n      button.style.display = '';\n      button.style.cursor = 'auto';\n      button.style.left = 'calc(50% - 75px)';\n      button.style.width = '150px';\n      button.onmouseenter = null;\n      button.onmouseleave = null;\n      button.onclick = null;\n    }\n\n    function showWebXRNotFound() {\n      disableButton();\n      button.textContent = 'VR NOT SUPPORTED';\n    }\n\n    function stylizeElement(element) {\n      element.style.position = 'absolute';\n      element.style.bottom = '20px';\n      element.style.padding = '12px 6px';\n      element.style.border = '1px solid #fff';\n      element.style.borderRadius = '4px';\n      element.style.background = 'rgba(0,0,0,0.1)';\n      element.style.color = '#fff';\n      element.style.font = 'normal 13px sans-serif';\n      element.style.textAlign = 'center';\n      element.style.opacity = '0.5';\n      element.style.outline = 'none';\n      element.style.zIndex = '999';\n    }\n\n    if ('xr' in navigator) {\n      stylizeElement(button);\n      button.id = 'VRButton';\n      button.style.display = 'none' // Query for session mode\n      ;\n      navigator.xr.isSessionSupported('immersive-vr').then(supported => {\n        supported ? showEnterVR() : showWebXRNotFound();\n\n        if (supported && VRButton.xrSessionIsGranted) {\n          button.click();\n        }\n      });\n      return button;\n    } else {\n      const message = document.createElement('a');\n\n      if (window.isSecureContext === false) {\n        message.href = document.location.href.replace(/^http:/, 'https:');\n        message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message\n      } else {\n        message.href = 'https://immersiveweb.dev/';\n        message.innerHTML = 'WEBXR NOT AVAILABLE';\n      }\n\n      message.style.left = 'calc(50% - 90px)';\n      message.style.width = '180px';\n      message.style.textDecoration = 'none';\n      stylizeElement(message);\n      return message;\n    }\n  }\n\n  static registerSessionGrantedListener() {\n    if ('xr' in navigator) {\n      navigator.xr.addEventListener('sessiongranted', () => {\n        VRButton.xrSessionIsGranted = true;\n      });\n    }\n  }\n\n}\n\n_defineProperty(VRButton, \"xrSessionIsGranted\", false);\n\nexport { VRButton };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\n\n/**\n * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles\n */\nconst MotionControllerConstants = {\n  Handedness: Object.freeze({\n    NONE: 'none',\n    LEFT: 'left',\n    RIGHT: 'right'\n  }),\n  ComponentState: Object.freeze({\n    DEFAULT: 'default',\n    TOUCHED: 'touched',\n    PRESSED: 'pressed'\n  }),\n  ComponentProperty: Object.freeze({\n    BUTTON: 'button',\n    X_AXIS: 'xAxis',\n    Y_AXIS: 'yAxis',\n    STATE: 'state'\n  }),\n  ComponentType: Object.freeze({\n    TRIGGER: 'trigger',\n    SQUEEZE: 'squeeze',\n    TOUCHPAD: 'touchpad',\n    THUMBSTICK: 'thumbstick',\n    BUTTON: 'button'\n  }),\n  ButtonTouchThreshold: 0.05,\n  AxisTouchThreshold: 0.1,\n  VisualResponseProperty: Object.freeze({\n    TRANSFORM: 'transform',\n    VISIBILITY: 'visibility'\n  })\n};\n/**\n * @description Static helper function to fetch a JSON file and turn it into a JS object\n * @param {string} path - Path to JSON file to be fetched\n */\n\nasync function fetchJsonFile(path) {\n  const response = await fetch(path);\n\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  } else {\n    return response.json();\n  }\n}\n\nasync function fetchProfilesList(basePath) {\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  }\n\n  const profileListFileName = 'profilesList.json';\n  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);\n  return profilesList;\n}\n\nasync function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {\n  if (!xrInputSource) {\n    throw new Error('No xrInputSource supplied');\n  }\n\n  if (!basePath) {\n    throw new Error('No basePath supplied');\n  } // Get the list of profiles\n\n\n  const supportedProfilesList = await fetchProfilesList(basePath); // Find the relative path to the first requested profile that is recognized\n\n  let match = undefined;\n  xrInputSource.profiles.some(profileId => {\n    const supportedProfile = supportedProfilesList[profileId];\n\n    if (supportedProfile) {\n      match = {\n        profileId,\n        profilePath: `${basePath}/${supportedProfile.path}`,\n        deprecated: !!supportedProfile.deprecated\n      };\n    }\n\n    return !!match;\n  });\n\n  if (!match) {\n    if (!defaultProfile) {\n      throw new Error('No matching profile name found');\n    }\n\n    const supportedProfile = supportedProfilesList[defaultProfile];\n\n    if (!supportedProfile) {\n      throw new Error(`No matching profile name found and default profile \"${defaultProfile}\" missing.`);\n    }\n\n    match = {\n      profileId: defaultProfile,\n      profilePath: `${basePath}/${supportedProfile.path}`,\n      deprecated: !!supportedProfile.deprecated\n    };\n  }\n\n  const profile = await fetchJsonFile(match.profilePath);\n  let assetPath = undefined;\n\n  if (getAssetPath) {\n    let layout;\n\n    if (xrInputSource.handedness === 'any') {\n      layout = profile.layouts[Object.keys(profile.layouts)[0]];\n    } else {\n      layout = profile.layouts[xrInputSource.handedness];\n    }\n\n    if (!layout) {\n      throw new Error(`No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`);\n    }\n\n    if (layout.assetPath) {\n      assetPath = match.profilePath.replace('profile.json', layout.assetPath);\n    }\n  }\n\n  return {\n    profile,\n    assetPath\n  };\n}\n/** @constant {Object} */\n\n\nconst defaultComponentValues = {\n  xAxis: 0,\n  yAxis: 0,\n  button: 0,\n  state: MotionControllerConstants.ComponentState.DEFAULT\n};\n/**\n * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad\n * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within\n * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical\n * range of motion and touchpads do not report touch locations off their physical bounds.\n * @param {number | undefined} x The original x coordinate in the range -1 to 1\n * @param {number | undefined} y The original y coordinate in the range -1 to 1\n */\n\nfunction normalizeAxes(x = 0, y = 0) {\n  let xAxis = x;\n  let yAxis = y; // Determine if the point is outside the bounds of the circle\n  // and, if so, place it on the edge of the circle\n\n  const hypotenuse = Math.sqrt(x * x + y * y);\n\n  if (hypotenuse > 1) {\n    const theta = Math.atan2(y, x);\n    xAxis = Math.cos(theta);\n    yAxis = Math.sin(theta);\n  } // Scale and move the circle so values are in the interpolation range.  The circle's origin moves\n  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.\n\n\n  const result = {\n    normalizedXAxis: xAxis * 0.5 + 0.5,\n    normalizedYAxis: yAxis * 0.5 + 0.5\n  };\n  return result;\n}\n/**\n * Contains the description of how the 3D model should visually respond to a specific user input.\n * This is accomplished by initializing the object with the name of a node in the 3D model and\n * property that need to be modified in response to user input, the name of the nodes representing\n * the allowable range of motion, and the name of the input which triggers the change. In response\n * to the named input changing, this object computes the appropriate weighting to use for\n * interpolating between the range of motion nodes.\n */\n\n\nclass VisualResponse {\n  constructor(visualResponseDescription) {\n    _defineProperty(this, \"value\", void 0);\n\n    _defineProperty(this, \"componentProperty\", void 0);\n\n    _defineProperty(this, \"states\", void 0);\n\n    _defineProperty(this, \"valueNodeName\", void 0);\n\n    _defineProperty(this, \"valueNodeProperty\", void 0);\n\n    _defineProperty(this, \"minNodeName\", void 0);\n\n    _defineProperty(this, \"maxNodeName\", void 0);\n\n    _defineProperty(this, \"valueNode\", void 0);\n\n    _defineProperty(this, \"minNode\", void 0);\n\n    _defineProperty(this, \"maxNode\", void 0);\n\n    this.componentProperty = visualResponseDescription.componentProperty;\n    this.states = visualResponseDescription.states;\n    this.valueNodeName = visualResponseDescription.valueNodeName;\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;\n\n    if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM) {\n      this.minNodeName = visualResponseDescription.minNodeName;\n      this.maxNodeName = visualResponseDescription.maxNodeName;\n    } // Initializes the response's current value based on default data\n\n\n    this.value = 0;\n    this.updateFromComponent(defaultComponentValues);\n  }\n  /**\n   * Computes the visual response's interpolation weight based on component state\n   * @param {Object} componentValues - The component from which to update\n   * @param {number | undefined} xAxis - The reported X axis value of the component\n   * @param {number | undefined} yAxis - The reported Y axis value of the component\n   * @param {number | undefined} button - The reported value of the component's button\n   * @param {string} state - The component's active state\n   */\n\n\n  updateFromComponent({\n    xAxis,\n    yAxis,\n    button,\n    state\n  }) {\n    const {\n      normalizedXAxis,\n      normalizedYAxis\n    } = normalizeAxes(xAxis, yAxis);\n\n    switch (this.componentProperty) {\n      case MotionControllerConstants.ComponentProperty.X_AXIS:\n        this.value = this.states.includes(state) ? normalizedXAxis : 0.5;\n        break;\n\n      case MotionControllerConstants.ComponentProperty.Y_AXIS:\n        this.value = this.states.includes(state) ? normalizedYAxis : 0.5;\n        break;\n\n      case MotionControllerConstants.ComponentProperty.BUTTON:\n        this.value = this.states.includes(state) && button ? button : 0;\n        break;\n\n      case MotionControllerConstants.ComponentProperty.STATE:\n        if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY) {\n          this.value = this.states.includes(state);\n        } else {\n          this.value = this.states.includes(state) ? 1.0 : 0.0;\n        }\n\n        break;\n\n      default:\n        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);\n    }\n  }\n\n}\n\nclass Component {\n  /**\n   * @param {string} componentId - Id of the component\n   * @param {InputProfileComponent} componentDescription - Description of the component to be created\n   */\n  constructor(componentId, componentDescription) {\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"values\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"gamepadIndices\", void 0);\n\n    _defineProperty(this, \"rootNodeName\", void 0);\n\n    _defineProperty(this, \"visualResponses\", void 0);\n\n    _defineProperty(this, \"touchPointNodeName\", void 0);\n\n    _defineProperty(this, \"touchPointNode\", void 0);\n\n    if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {\n      throw new Error('Invalid arguments supplied');\n    }\n\n    this.id = componentId;\n    this.type = componentDescription.type;\n    this.rootNodeName = componentDescription.rootNodeName;\n    this.touchPointNodeName = componentDescription.touchPointNodeName; // Build all the visual responses for this component\n\n    this.visualResponses = {};\n    Object.keys(componentDescription.visualResponses).forEach(responseName => {\n      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);\n      this.visualResponses[responseName] = visualResponse;\n    }); // Set default values\n\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);\n    this.values = {\n      state: MotionControllerConstants.ComponentState.DEFAULT,\n      button: this.gamepadIndices.button !== undefined ? 0 : undefined,\n      xAxis: this.gamepadIndices.xAxis !== undefined ? 0 : undefined,\n      yAxis: this.gamepadIndices.yAxis !== undefined ? 0 : undefined\n    };\n  }\n\n  get data() {\n    const data = {\n      id: this.id,\n      ...this.values\n    };\n    return data;\n  }\n  /**\n   * @description Poll for updated data based on current gamepad state\n   * @param {Object} gamepad - The gamepad object from which the component data should be polled\n   */\n\n\n  updateFromGamepad(gamepad) {\n    // Set the state to default before processing other data sources\n    this.values.state = MotionControllerConstants.ComponentState.DEFAULT; // Get and normalize button\n\n    if (this.gamepadIndices.button !== undefined && gamepad.buttons.length > this.gamepadIndices.button) {\n      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];\n      this.values.button = gamepadButton.value;\n      this.values.button = this.values.button < 0 ? 0 : this.values.button;\n      this.values.button = this.values.button > 1 ? 1 : this.values.button; // Set the state based on the button\n\n      if (gamepadButton.pressed || this.values.button === 1) {\n        this.values.state = MotionControllerConstants.ComponentState.PRESSED;\n      } else if (gamepadButton.touched || this.values.button > MotionControllerConstants.ButtonTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\n      }\n    } // Get and normalize x axis value\n\n\n    if (this.gamepadIndices.xAxis !== undefined && gamepad.axes.length > this.gamepadIndices.xAxis) {\n      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];\n      this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;\n      this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis; // If the state is still default, check if the xAxis makes it touched\n\n      if (this.values.state === MotionControllerConstants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > MotionControllerConstants.AxisTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\n      }\n    } // Get and normalize Y axis value\n\n\n    if (this.gamepadIndices.yAxis !== undefined && gamepad.axes.length > this.gamepadIndices.yAxis) {\n      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];\n      this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;\n      this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis; // If the state is still default, check if the yAxis makes it touched\n\n      if (this.values.state === MotionControllerConstants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > MotionControllerConstants.AxisTouchThreshold) {\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\n      }\n    } // Update the visual response weights based on the current component data\n\n\n    Object.values(this.visualResponses).forEach(visualResponse => {\n      visualResponse.updateFromComponent(this.values);\n    });\n  }\n\n}\n/**\n * @description Builds a motion controller with components and visual responses based on the\n * supplied profile description. Data is polled from the xrInputSource's gamepad.\n * @author Nell Waliczek / https://github.com/NellWaliczek\n */\n\n\nclass MotionController {\n  /**\n   * @param {XRInputSource} xrInputSource - The XRInputSource to build the MotionController around\n   * @param {Profile} profile - The best matched profile description for the supplied xrInputSource\n   * @param {string} assetUrl\n   */\n  constructor(xrInputSource, profile, assetUrl) {\n    _defineProperty(this, \"xrInputSource\", void 0);\n\n    _defineProperty(this, \"assetUrl\", void 0);\n\n    _defineProperty(this, \"layoutDescription\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"components\", void 0);\n\n    if (!xrInputSource) {\n      throw new Error('No xrInputSource supplied');\n    }\n\n    if (!profile) {\n      throw new Error('No profile supplied');\n    }\n\n    if (!profile.layouts[xrInputSource.handedness]) {\n      throw new Error('No layout for ' + xrInputSource.handedness + ' handedness');\n    }\n\n    this.xrInputSource = xrInputSource;\n    this.assetUrl = assetUrl;\n    this.id = profile.profileId; // Build child components as described in the profile description\n\n    this.layoutDescription = profile.layouts[xrInputSource.handedness];\n    this.components = {};\n    Object.keys(this.layoutDescription.components).forEach(componentId => {\n      const componentDescription = this.layoutDescription.components[componentId];\n      this.components[componentId] = new Component(componentId, componentDescription);\n    }); // Initialize components based on current gamepad state\n\n    this.updateFromGamepad();\n  }\n\n  get gripSpace() {\n    return this.xrInputSource.gripSpace;\n  }\n\n  get targetRaySpace() {\n    return this.xrInputSource.targetRaySpace;\n  }\n  /**\n   * @description Returns a subset of component data for simplified debugging\n   */\n\n\n  get data() {\n    const data = [];\n    Object.values(this.components).forEach(component => {\n      data.push(component.data);\n    });\n    return data;\n  }\n  /**\n   * @description Poll for updated data based on current gamepad state\n   */\n\n\n  updateFromGamepad() {\n    Object.values(this.components).forEach(component => {\n      component.updateFromGamepad(this.xrInputSource.gamepad);\n    });\n  }\n\n}\n\nexport { MotionController, MotionControllerConstants, fetchProfile, fetchProfilesList };\n", "import { Matrix4, Vector3, SphereGeometry, BoxGeometry, MeshStandardMaterial, InstancedMesh, DynamicDrawUsage } from 'three';\n\nconst _matrix = new Matrix4();\n\nconst _vector = new Vector3();\n\nclass XRHandPrimitiveModel {\n  constructor(handModel, controller, path, handedness, options) {\n    this.controller = controller;\n    this.handModel = handModel;\n    this.envMap = null;\n    let geometry;\n\n    if (!options || !options.primitive || options.primitive === 'sphere') {\n      geometry = new SphereGeometry(1, 10, 10);\n    } else if (options.primitive === 'box') {\n      geometry = new BoxGeometry(1, 1, 1);\n    }\n\n    const material = new MeshStandardMaterial();\n    this.handMesh = new InstancedMesh(geometry, material, 30);\n    this.handMesh.instanceMatrix.setUsage(DynamicDrawUsage); // will be updated every frame\n\n    this.handMesh.castShadow = true;\n    this.handMesh.receiveShadow = true;\n    this.handModel.add(this.handMesh);\n    this.joints = ['wrist', 'thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip', 'index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip', 'middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip', 'ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip', 'pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip'];\n  }\n\n  updateMesh() {\n    const defaultRadius = 0.008;\n    const joints = this.controller.joints;\n    let count = 0;\n\n    for (let i = 0; i < this.joints.length; i++) {\n      const joint = joints[this.joints[i]];\n\n      if (joint.visible) {\n        _vector.setScalar(joint.jointRadius || defaultRadius);\n\n        _matrix.compose(joint.position, joint.quaternion, _vector);\n\n        this.handMesh.setMatrixAt(i, _matrix);\n        count++;\n      }\n    }\n\n    this.handMesh.count = count;\n    this.handMesh.instanceMatrix.needsUpdate = true;\n  }\n\n}\n\nexport { XRHandPrimitiveModel };\n", "import { BufferGeometry, Vector3, Float32BufferAttribute } from 'three';\n\n/**\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\n */\n\nclass ParametricGeometry extends BufferGeometry {\n  constructor(func = (u, v, target) => target.set(u, v, Math.cos(u) * Math.sin(v)), slices = 8, stacks = 8) {\n    super();\n    this.type = 'ParametricGeometry';\n    this.parameters = {\n      func: func,\n      slices: slices,\n      stacks: stacks\n    }; // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const EPS = 0.00001;\n    const normal = new Vector3();\n    const p0 = new Vector3(),\n          p1 = new Vector3();\n    const pu = new Vector3(),\n          pv = new Vector3(); // generate vertices, normals and uvs\n\n    const sliceCount = slices + 1;\n\n    for (let i = 0; i <= stacks; i++) {\n      const v = i / stacks;\n\n      for (let j = 0; j <= slices; j++) {\n        const u = j / slices; // vertex\n\n        func(u, v, p0);\n        vertices.push(p0.x, p0.y, p0.z); // normal\n        // approximate tangent vectors via finite differences\n\n        if (u - EPS >= 0) {\n          func(u - EPS, v, p1);\n          pu.subVectors(p0, p1);\n        } else {\n          func(u + EPS, v, p1);\n          pu.subVectors(p1, p0);\n        }\n\n        if (v - EPS >= 0) {\n          func(u, v - EPS, p1);\n          pv.subVectors(p0, p1);\n        } else {\n          func(u, v + EPS, p1);\n          pv.subVectors(p1, p0);\n        } // cross product of tangent vectors returns surface normal\n\n\n        normal.crossVectors(pu, pv).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(u, v);\n      }\n    } // generate indices\n\n\n    for (let i = 0; i < stacks; i++) {\n      for (let j = 0; j < slices; j++) {\n        const a = i * sliceCount + j;\n        const b = i * sliceCount + j + 1;\n        const c = (i + 1) * sliceCount + j + 1;\n        const d = (i + 1) * sliceCount + j; // faces one and two\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n}\n\nexport { ParametricGeometry };\n", "import { Vector3, Curve } from 'three';\nimport { ParametricGeometry } from './ParametricGeometry.js';\n\n/**\n * Experimenting of primitive geometry creation using Surface Parametric equations\n */\n\nconst ParametricGeometries = {\n  klein: function (v, u, target) {\n    u *= Math.PI;\n    v *= 2 * Math.PI;\n    u = u * 2;\n    let x, z;\n\n    if (u < Math.PI) {\n      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v);\n      z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);\n    } else {\n      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI);\n      z = -8 * Math.sin(u);\n    }\n\n    const y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);\n    target.set(x, y, z);\n  },\n  plane: function (width, height) {\n    return function (u, v, target) {\n      const x = u * width;\n      const y = 0;\n      const z = v * height;\n      target.set(x, y, z);\n    };\n  },\n  mobius: function (u, t, target) {\n    // flat mobius strip\n    // http://www.wolframalpha.com/input/?i=M%C3%B6bius+strip+parametric+equations&lk=1&a=ClashPrefs_*Surface.MoebiusStrip.SurfaceProperty.ParametricEquations-\n    u = u - 0.5;\n    const v = 2 * Math.PI * t;\n    const a = 2;\n    const x = Math.cos(v) * (a + u * Math.cos(v / 2));\n    const y = Math.sin(v) * (a + u * Math.cos(v / 2));\n    const z = u * Math.sin(v / 2);\n    target.set(x, y, z);\n  },\n  mobius3d: function (u, t, target) {\n    // volumetric mobius strip\n    u *= Math.PI;\n    t *= 2 * Math.PI;\n    u = u * 2;\n    const phi = u / 2;\n    const major = 2.25,\n          a = 0.125,\n          b = 0.65;\n    let x = a * Math.cos(t) * Math.cos(phi) - b * Math.sin(t) * Math.sin(phi);\n    const z = a * Math.cos(t) * Math.sin(phi) + b * Math.sin(t) * Math.cos(phi);\n    const y = (major + x) * Math.sin(u);\n    x = (major + x) * Math.cos(u);\n    target.set(x, y, z);\n  }\n};\n/*********************************************\n *\n * Parametric Replacement for TubeGeometry\n *\n *********************************************/\n\nParametricGeometries.TubeGeometry = class TubeGeometry extends ParametricGeometry {\n  constructor(path, segments = 64, radius = 1, segmentsRadius = 8, closed = false) {\n    const numpoints = segments + 1;\n    const frames = path.computeFrenetFrames(segments, closed),\n          tangents = frames.tangents,\n          normals = frames.normals,\n          binormals = frames.binormals;\n    const position = new Vector3();\n\n    function ParametricTube(u, v, target) {\n      v *= 2 * Math.PI;\n      const i = Math.floor(u * (numpoints - 1));\n      path.getPointAt(u, position);\n      const normal = normals[i];\n      const binormal = binormals[i];\n      const cx = -radius * Math.cos(v); // TODO: Hack: Negating it so it faces outside.\n\n      const cy = radius * Math.sin(v);\n      position.x += cx * normal.x + cy * binormal.x;\n      position.y += cx * normal.y + cy * binormal.y;\n      position.z += cx * normal.z + cy * binormal.z;\n      target.copy(position);\n    }\n\n    super(ParametricTube, segments, segmentsRadius); // proxy internals\n\n    this.tangents = tangents;\n    this.normals = normals;\n    this.binormals = binormals;\n    this.path = path;\n    this.segments = segments;\n    this.radius = radius;\n    this.segmentsRadius = segmentsRadius;\n    this.closed = closed;\n  }\n\n};\n/*********************************************\n *\n * Parametric Replacement for TorusKnotGeometry\n *\n *********************************************/\n\nParametricGeometries.TorusKnotGeometry = class TorusKnotGeometry extends ParametricGeometries.TubeGeometry {\n  constructor(radius = 200, tube = 40, segmentsT = 64, segmentsR = 8, p = 2, q = 3) {\n    class TorusKnotCurve extends Curve {\n      getPoint(t, optionalTarget = new Vector3()) {\n        const point = optionalTarget;\n        t *= Math.PI * 2;\n        const r = 0.5;\n        const x = (1 + r * Math.cos(q * t)) * Math.cos(p * t);\n        const y = (1 + r * Math.cos(q * t)) * Math.sin(p * t);\n        const z = r * Math.sin(q * t);\n        return point.set(x, y, z).multiplyScalar(radius);\n      }\n\n    }\n\n    const segments = segmentsT;\n    const radiusSegments = segmentsR;\n    const extrudePath = new TorusKnotCurve();\n    super(extrudePath, segments, tube, radiusSegments, true, false);\n    this.radius = radius;\n    this.tube = tube;\n    this.segmentsT = segmentsT;\n    this.segmentsR = segmentsR;\n    this.p = p;\n    this.q = q;\n  }\n\n};\n/*********************************************\n *\n * Parametric Replacement for SphereGeometry\n *\n *********************************************/\n\nParametricGeometries.SphereGeometry = class SphereGeometry extends ParametricGeometry {\n  constructor(size, u, v) {\n    function sphere(u, v, target) {\n      u *= Math.PI;\n      v *= 2 * Math.PI;\n      const x = size * Math.sin(u) * Math.cos(v);\n      const y = size * Math.sin(u) * Math.sin(v);\n      const z = size * Math.cos(u);\n      target.set(x, y, z);\n    }\n\n    super(sphere, u, v);\n  }\n\n};\n/*********************************************\n *\n * Parametric Replacement for PlaneGeometry\n *\n *********************************************/\n\nParametricGeometries.PlaneGeometry = class PlaneGeometry extends ParametricGeometry {\n  constructor(width, depth, segmentsWidth, segmentsDepth) {\n    function plane(u, v, target) {\n      const x = u * width;\n      const y = 0;\n      const z = v * depth;\n      target.set(x, y, z);\n    }\n\n    super(plane, segmentsWidth, segmentsDepth);\n  }\n\n};\n\nexport { ParametricGeometries };\n", "import { Vector3, BoxGeometry } from 'three';\n\nconst tempNormal = new Vector3();\n\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  const totArcLength = 2 * Math.PI * radius / 4; // length of the planes between the arcs on each axis\n\n  const centerLength = Math.max(sideLength - 2 * radius, 0);\n  const halfArc = Math.PI / 4; // Get the vector projected onto the Y plane\n\n  tempNormal.copy(normal);\n  tempNormal[projectionAxis] = 0;\n  tempNormal.normalize(); // total amount of UV space alloted to a single arc\n\n  const arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength); // the distance along one arc the point is at\n\n  const arcAngleRatio = 1.0 - tempNormal.angleTo(faceDirVector) / halfArc;\n\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio;\n  } else {\n    // total amount of UV space alloted to the plane between the arcs\n    const lenUv = centerLength / (totArcLength + centerLength);\n    return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio);\n  }\n}\n\nclass RoundedBoxGeometry extends BoxGeometry {\n  constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1) {\n    // ensure segments is odd so we have a plane connecting the rounded corners\n    segments = segments * 2 + 1; // ensure radius isn't bigger than shortest side\n\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\n    super(1, 1, 1, segments, segments, segments); // if we just have one segment we're the same as a regular box\n\n    if (segments === 1) return;\n    const geometry2 = this.toNonIndexed();\n    this.index = null;\n    this.attributes.position = geometry2.attributes.position;\n    this.attributes.normal = geometry2.attributes.normal;\n    this.attributes.uv = geometry2.attributes.uv; //\n\n    const position = new Vector3();\n    const normal = new Vector3();\n    const box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius);\n    const positions = this.attributes.position.array;\n    const normals = this.attributes.normal.array;\n    const uvs = this.attributes.uv.array;\n    const faceTris = positions.length / 6;\n    const faceDirVector = new Vector3();\n    const halfSegmentSize = 0.5 / segments;\n\n    for (let i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i);\n      normal.copy(position);\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\n      normal.normalize();\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\n      normals[i + 0] = normal.x;\n      normals[i + 1] = normal.y;\n      normals[i + 2] = normal.z;\n      const side = Math.floor(i / faceTris);\n\n      switch (side) {\n        case 0:\n          // right\n          // generate UVs along Z then Y\n          faceDirVector.set(1, 0, 0);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n\n        case 1:\n          // left\n          // generate UVs along Z then Y\n          faceDirVector.set(-1, 0, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n\n        case 2:\n          // top\n          // generate UVs along X then Z\n          faceDirVector.set(0, 1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n\n        case 3:\n          // bottom\n          // generate UVs along X then Z\n          faceDirVector.set(0, -1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n\n        case 4:\n          // front\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, 1);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n\n        case 5:\n          // back\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, -1);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n      }\n    }\n  }\n\n}\n\nexport { RoundedBoxGeometry };\n", "import { Matrix4, Vector3 } from 'three';\n\nconst inverseProjectionMatrix = new Matrix4();\n\nclass CSMFrustum {\n  constructor(data) {\n    data = data || {};\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\n    };\n\n    if (data.projectionMatrix !== undefined) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000);\n    }\n  }\n\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n    inverseProjectionMatrix.copy(projectionMatrix).invert(); // 3 --- 0  vertices.near/far order\n    // |     |\n    // 2 --- 1\n    // clip space spans from [-1, 1]\n\n    this.vertices.near[0].set(1, 1, -1);\n    this.vertices.near[1].set(1, -1, -1);\n    this.vertices.near[2].set(-1, -1, -1);\n    this.vertices.near[3].set(-1, 1, -1);\n    this.vertices.near.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n    });\n    this.vertices.far[0].set(1, 1, 1);\n    this.vertices.far[1].set(1, -1, 1);\n    this.vertices.far[2].set(-1, -1, 1);\n    this.vertices.far[3].set(-1, 1, 1);\n    this.vertices.far.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix);\n      const absZ = Math.abs(v.z);\n\n      if (isOrthographic) {\n        v.z *= Math.min(maxFar / absZ, 1.0);\n      } else {\n        v.multiplyScalar(Math.min(maxFar / absZ, 1.0));\n      }\n    });\n    return this.vertices;\n  }\n\n  split(breaks, target) {\n    while (breaks.length > target.length) {\n      target.push(new CSMFrustum());\n    }\n\n    target.length = breaks.length;\n\n    for (let i = 0; i < breaks.length; i++) {\n      const cascade = target[i];\n\n      if (i === 0) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].copy(this.vertices.near[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);\n        }\n      }\n\n      if (i === breaks.length - 1) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].copy(this.vertices.far[j]);\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);\n        }\n      }\n    }\n  }\n\n  toSpace(cameraMatrix, target) {\n    for (let i = 0; i < 4; i++) {\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n    }\n  }\n\n}\n\nexport { CSMFrustum };\n", "import { ShaderChunk } from 'three';\n\nconst CSMShader = {\n  lights_fragment_begin:\n  /* glsl */\n  `\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef CLEARCOAT\n\n\tgeometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\n\tvec2 cascade;\n\tfloat cascadeCenter;\n\tfloat closestEdge;\n\tfloat margin;\n\tfloat csmx;\n\tfloat csmy;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t  \t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\t\t// NOTE: Depth gets larger away from the camera.\n\t\t\t// cascade.x is closer, cascade.y is further\n\t\t\tcascade = CSM_cascades[ i ];\n\t\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\n\t\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\n\t\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\n\t\t\tcsmx = cascade.x - margin / 2.0;\n\t\t\tcsmy = cascade.y + margin / 2.0;\n\t\t\tif( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\n\n\t\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\n\t\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\n\n\t\t\t\tvec3 prevColor = directLight.color;\n\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\n\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\n\n\t\t\t\tReflectedLight prevLight = reflectedLight;\n\t\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\n\t\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\n\n\t\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\n\t\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\n\t\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\n\t\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\n\n\t\t\t}\n\t  \t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\t#else\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\n\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t\t#endif\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)\n\t\t// compute the lights not casting shadows (if any)\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\n\t\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n`,\n  lights_pars_begin:\n  /* glsl */\n  `\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\nuniform vec2 CSM_cascades[CSM_CASCADES];\nuniform float cameraNear;\nuniform float shadowFar;\n#endif\n\t` + ShaderChunk.lights_pars_begin\n};\n\nexport { CSMShader };\n", "import { Matrix4, Vector3, Box3, DirectionalLight, MathUtils, ShaderChunk, Vector2 } from 'three';\nimport { CSMFrustum } from './CSMFrustum.js';\nimport { CSMShader } from './CSMShader.js';\n\nconst _cameraToLightMatrix = new Matrix4();\n\nconst _lightSpaceFrustum = new CSMFrustum();\n\nconst _center = new Vector3();\n\nconst _bbox = new Box3();\n\nconst _uniformArray = [];\nconst _logArray = [];\nclass CSM {\n  constructor(data) {\n    data = data || {};\n    this.camera = data.camera;\n    this.parent = data.parent;\n    this.cascades = data.cascades || 3;\n    this.maxFar = data.maxFar || 100000;\n    this.mode = data.mode || 'practical';\n    this.shadowMapSize = data.shadowMapSize || 2048;\n    this.shadowBias = data.shadowBias || 0.000001;\n    this.lightDirection = data.lightDirection || new Vector3(1, -1, 1).normalize();\n    this.lightIntensity = data.lightIntensity || 1;\n    this.lightNear = data.lightNear || 1;\n    this.lightFar = data.lightFar || 2000;\n    this.lightMargin = data.lightMargin || 200;\n    this.customSplitsCallback = data.customSplitsCallback;\n    this.fade = false;\n    this.mainFrustum = new CSMFrustum();\n    this.frustums = [];\n    this.breaks = [];\n    this.lights = [];\n    this.shaders = new Map();\n    this.createLights();\n    this.updateFrustums();\n    this.injectInclude();\n  }\n\n  createLights() {\n    for (let i = 0; i < this.cascades; i++) {\n      const light = new DirectionalLight(0xffffff, this.lightIntensity);\n      light.castShadow = true;\n      light.shadow.mapSize.width = this.shadowMapSize;\n      light.shadow.mapSize.height = this.shadowMapSize;\n      light.shadow.camera.near = this.lightNear;\n      light.shadow.camera.far = this.lightFar;\n      light.shadow.bias = this.shadowBias;\n      this.parent.add(light);\n      this.parent.add(light.target);\n      this.lights.push(light);\n    }\n  }\n\n  initCascades() {\n    const camera = this.camera;\n    camera.updateProjectionMatrix();\n    this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);\n    this.mainFrustum.split(this.breaks, this.frustums);\n  }\n\n  updateShadowBounds() {\n    const frustums = this.frustums;\n\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i];\n      const shadowCam = light.shadow.camera;\n      const frustum = this.frustums[i]; // Get the two points that represent that furthest points on the frustum assuming\n      // that's either the diagonal across the far plane or the diagonal across the whole\n      // frustum itself.\n\n      const nearVerts = frustum.vertices.near;\n      const farVerts = frustum.vertices.far;\n      const point1 = farVerts[0];\n      let point2;\n\n      if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {\n        point2 = farVerts[2];\n      } else {\n        point2 = nearVerts[2];\n      }\n\n      let squaredBBWidth = point1.distanceTo(point2);\n\n      if (this.fade) {\n        // expand the shadow extents by the fade margin if fade is enabled.\n        const camera = this.camera;\n        const far = Math.max(camera.far, this.maxFar);\n        const linearDepth = frustum.vertices.far[0].z / (far - camera.near);\n        const margin = 0.25 * Math.pow(linearDepth, 2.0) * (far - camera.near);\n        squaredBBWidth += margin;\n      }\n\n      shadowCam.left = -squaredBBWidth / 2;\n      shadowCam.right = squaredBBWidth / 2;\n      shadowCam.top = squaredBBWidth / 2;\n      shadowCam.bottom = -squaredBBWidth / 2;\n      shadowCam.updateProjectionMatrix();\n    }\n  }\n\n  getBreaks() {\n    const camera = this.camera;\n    const far = Math.min(camera.far, this.maxFar);\n    this.breaks.length = 0;\n\n    switch (this.mode) {\n      case 'uniform':\n        uniformSplit(this.cascades, camera.near, far, this.breaks);\n        break;\n\n      case 'logarithmic':\n        logarithmicSplit(this.cascades, camera.near, far, this.breaks);\n        break;\n\n      case 'practical':\n        practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);\n        break;\n\n      case 'custom':\n        if (this.customSplitsCallback === undefined) console.error('CSM: Custom split scheme callback not defined.');\n        this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);\n        break;\n    }\n\n    function uniformSplit(amount, near, far, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push((near + (far - near) * i / amount) / far);\n      }\n\n      target.push(1);\n    }\n\n    function logarithmicSplit(amount, near, far, target) {\n      for (let i = 1; i < amount; i++) {\n        target.push(near * (far / near) ** (i / amount) / far);\n      }\n\n      target.push(1);\n    }\n\n    function practicalSplit(amount, near, far, lambda, target) {\n      _uniformArray.length = 0;\n      _logArray.length = 0;\n      logarithmicSplit(amount, near, far, _logArray);\n      uniformSplit(amount, near, far, _uniformArray);\n\n      for (let i = 1; i < amount; i++) {\n        target.push(MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));\n      }\n\n      target.push(1);\n    }\n  }\n\n  update() {\n    const camera = this.camera;\n    const frustums = this.frustums;\n\n    for (let i = 0; i < frustums.length; i++) {\n      const light = this.lights[i];\n      const shadowCam = light.shadow.camera;\n      const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;\n      const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;\n      light.shadow.camera.updateMatrixWorld(true);\n\n      _cameraToLightMatrix.multiplyMatrices(light.shadow.camera.matrixWorldInverse, camera.matrixWorld);\n\n      frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);\n      const nearVerts = _lightSpaceFrustum.vertices.near;\n      const farVerts = _lightSpaceFrustum.vertices.far;\n\n      _bbox.makeEmpty();\n\n      for (let j = 0; j < 4; j++) {\n        _bbox.expandByPoint(nearVerts[j]);\n\n        _bbox.expandByPoint(farVerts[j]);\n      }\n\n      _bbox.getCenter(_center);\n\n      _center.z = _bbox.max.z + this.lightMargin;\n      _center.x = Math.floor(_center.x / texelWidth) * texelWidth;\n      _center.y = Math.floor(_center.y / texelHeight) * texelHeight;\n\n      _center.applyMatrix4(light.shadow.camera.matrixWorld);\n\n      light.position.copy(_center);\n      light.target.position.copy(_center);\n      light.target.position.x += this.lightDirection.x;\n      light.target.position.y += this.lightDirection.y;\n      light.target.position.z += this.lightDirection.z;\n    }\n  }\n\n  injectInclude() {\n    ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;\n    ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;\n  }\n\n  setupMaterial(material) {\n    material.defines = material.defines || {};\n    material.defines.USE_CSM = 1;\n    material.defines.CSM_CASCADES = this.cascades;\n\n    if (this.fade) {\n      material.defines.CSM_FADE = '';\n    }\n\n    const breaksVec2 = [];\n    const scope = this;\n    const shaders = this.shaders;\n\n    material.onBeforeCompile = function (shader) {\n      const far = Math.min(scope.camera.far, scope.maxFar);\n      scope.getExtendedBreaks(breaksVec2);\n      shader.uniforms.CSM_cascades = {\n        value: breaksVec2\n      };\n      shader.uniforms.cameraNear = {\n        value: scope.camera.near\n      };\n      shader.uniforms.shadowFar = {\n        value: far\n      };\n      shaders.set(material, shader);\n    };\n\n    shaders.set(material, null);\n  }\n\n  updateUniforms() {\n    const far = Math.min(this.camera.far, this.maxFar);\n    const shaders = this.shaders;\n    shaders.forEach(function (shader, material) {\n      if (shader !== null) {\n        const uniforms = shader.uniforms;\n        this.getExtendedBreaks(uniforms.CSM_cascades.value);\n        uniforms.cameraNear.value = this.camera.near;\n        uniforms.shadowFar.value = far;\n      }\n\n      if (!this.fade && 'CSM_FADE' in material.defines) {\n        delete material.defines.CSM_FADE;\n        material.needsUpdate = true;\n      } else if (this.fade && !('CSM_FADE' in material.defines)) {\n        material.defines.CSM_FADE = '';\n        material.needsUpdate = true;\n      }\n    }, this);\n  }\n\n  getExtendedBreaks(target) {\n    while (target.length < this.breaks.length) {\n      target.push(new Vector2());\n    }\n\n    target.length = this.breaks.length;\n\n    for (let i = 0; i < this.cascades; i++) {\n      const amount = this.breaks[i];\n      const prev = this.breaks[i - 1] || 0;\n      target[i].x = prev;\n      target[i].y = amount;\n    }\n  }\n\n  updateFrustums() {\n    this.getBreaks();\n    this.initCascades();\n    this.updateShadowBounds();\n    this.updateUniforms();\n  }\n\n  remove() {\n    for (let i = 0; i < this.lights.length; i++) {\n      this.parent.remove(this.lights[i]);\n    }\n  }\n\n  dispose() {\n    const shaders = this.shaders;\n    shaders.forEach(function (shader, material) {\n      delete material.onBeforeCompile;\n      delete material.defines.USE_CSM;\n      delete material.defines.CSM_CASCADES;\n      delete material.defines.CSM_FADE;\n\n      if (shader !== null) {\n        delete shader.uniforms.CSM_cascades;\n        delete shader.uniforms.cameraNear;\n        delete shader.uniforms.shadowFar;\n      }\n\n      material.needsUpdate = true;\n    });\n    shaders.clear();\n  }\n\n}\n\nexport { CSM };\n", "/**\n * ACES Filmic Tone Mapping Shader by Stephen Hill\n * source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\n *\n * this implementation of ACES is modified to accommodate a brighter viewing environment.\n * the scale factor of 1/0.6 is subjective. see discussion in #19621.\n */\nconst ACESFilmicToneMappingShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    exposure: {\n      value: 1.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#define saturate(a) clamp( a, 0.0, 1.0 )', 'uniform sampler2D tDiffuse;', 'uniform float exposure;', 'varying vec2 vUv;', 'vec3 RRTAndODTFit( vec3 v ) {', '\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;', '\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;', '\treturn a / b;', '}', 'vec3 ACESFilmicToneMapping( vec3 color ) {', // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n  '\tconst mat3 ACESInputMat = mat3(', '\t\tvec3( 0.59719, 0.07600, 0.02840 ),', // transposed from source\n  '\t\tvec3( 0.35458, 0.90834, 0.13383 ),', '\t\tvec3( 0.04823, 0.01566, 0.83777 )', '\t);', // ODT_SAT => XYZ => D60_2_D65 => sRGB\n  '\tconst mat3 ACESOutputMat = mat3(', '\t\tvec3(  1.60475, -0.10208, -0.00327 ),', // transposed from source\n  '\t\tvec3( -0.53108,  1.10813, -0.07276 ),', '\t\tvec3( -0.07367, -0.00605,  1.07602 )', '\t);', '\tcolor = ACESInputMat * color;', // Apply RRT and ODT\n  '\tcolor = RRTAndODTFit( color );', '\tcolor = ACESOutputMat * color;', // Clamp to [0, 1]\n  '\treturn saturate( color );', '}', 'void main() {', '\tvec4 tex = texture2D( tDiffuse, vUv );', '\ttex.rgb *= exposure / 0.6;', // pre-exposed, outside of the tone mapping function\n  '\tgl_FragColor = vec4( ACESFilmicToneMapping( tex.rgb ), tex.a );', '}'].join('\\n')\n};\n\nexport { ACESFilmicToneMappingShader };\n", "/**\n * Simple test shader\n */\nconst BasicShader = {\n  uniforms: {},\n  vertexShader: ['void main() {', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['void main() {', '\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );', '}'].join('\\n')\n};\n\nexport { BasicShader };\n", "/**\n * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]\n * - based on Nvidia example\n * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass\n */\nconst BleachBypassShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    opacity: {\n      value: 1.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float opacity;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 base = texture2D( tDiffuse, vUv );', '\tvec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );', '\tfloat lum = dot( lumCoeff, base.rgb );', '\tvec3 blend = vec3( lum );', '\tfloat L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );', '\tvec3 result1 = 2.0 * base.rgb * blend;', '\tvec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );', '\tvec3 newColor = mix( result1, result2, L );', '\tfloat A2 = opacity * base.a;', '\tvec3 mixRGB = A2 * newColor.rgb;', '\tmixRGB += ( ( 1.0 - A2 ) * base.rgb );', '\tgl_FragColor = vec4( mixRGB, base.a );', '}'].join('\\n')\n};\n\nexport { BleachBypassShader };\n", "/**\n * Blend two textures\n */\nconst BlendShader = {\n  uniforms: {\n    tDiffuse1: {\n      value: null\n    },\n    tDiffuse2: {\n      value: null\n    },\n    mixRatio: {\n      value: 0.5\n    },\n    opacity: {\n      value: 1.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float opacity;', 'uniform float mixRatio;', 'uniform sampler2D tDiffuse1;', 'uniform sampler2D tDiffuse2;', 'varying vec2 vUv;', 'void main() {', '\tvec4 texel1 = texture2D( tDiffuse1, vUv );', '\tvec4 texel2 = texture2D( tDiffuse2, vUv );', '\tgl_FragColor = opacity * mix( texel1, texel2, mixRatio );', '}'].join('\\n')\n};\n\nexport { BlendShader };\n", "/**\n * Brightness and contrast adjustment\n * https://github.com/evanw/glfx.js\n * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)\n * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\nconst BrightnessContrastShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    brightness: {\n      value: 0\n    },\n    contrast: {\n      value: 0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float brightness;', 'uniform float contrast;', 'varying vec2 vUv;', 'void main() {', '\tgl_FragColor = texture2D( tDiffuse, vUv );', '\tgl_FragColor.rgb += brightness;', '\tif (contrast > 0.0) {', '\t\tgl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;', '\t} else {', '\t\tgl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;', '\t}', '}'].join('\\n')\n};\n\nexport { BrightnessContrastShader };\n", "import { Vector3 } from 'three';\n\n/**\n * Color correction\n */\n\nconst ColorCorrectionShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    powRGB: {\n      value: new Vector3(2, 2, 2)\n    },\n    mulRGB: {\n      value: new Vector3(1, 1, 1)\n    },\n    addRGB: {\n      value: new Vector3(0, 0, 0)\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec3 powRGB;', 'uniform vec3 mulRGB;', 'uniform vec3 addRGB;', 'varying vec2 vUv;', 'void main() {', '\tgl_FragColor = texture2D( tDiffuse, vUv );', '\tgl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );', '}'].join('\\n')\n};\n\nexport { ColorCorrectionShader };\n", "import { Color } from 'three';\n\n/**\n * Colorify shader\n */\n\nconst ColorifyShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    color: {\n      value: new Color(0xffffff)\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tvec3 luma = vec3( 0.299, 0.587, 0.114 );', '\tfloat v = dot( texel.xyz, luma );', '\tgl_FragColor = vec4( v * color, texel.w );', '}'].join('\\n')\n};\n\nexport { ColorifyShader };\n", "/**\n * Depth-of-field shader using mipmaps\n * - from Matt Handley @applmak\n * - requires power-of-2 sized render target with enabled mipmaps\n */\nconst DOFMipMapShader = {\n  uniforms: {\n    tColor: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    focus: {\n      value: 1.0\n    },\n    maxblur: {\n      value: 1.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float focus;', 'uniform float maxblur;', 'uniform sampler2D tColor;', 'uniform sampler2D tDepth;', 'varying vec2 vUv;', 'void main() {', '\tvec4 depth = texture2D( tDepth, vUv );', '\tfloat factor = depth.x - focus;', '\tvec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );', '\tgl_FragColor = col;', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\n};\n\nexport { DOFMipMapShader };\n", "import { Vector2 } from 'three';\n\n/**\n * NVIDIA FXAA by Timothy Lottes\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\n * - WebGL port by @supereggbert\n * http://www.glge.org/demos/fxaa/\n */\n\nconst FXAAShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2(1 / 1024, 1 / 512)\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['precision highp float;', '', 'uniform sampler2D tDiffuse;', '', 'uniform vec2 resolution;', '', 'varying vec2 vUv;', '', '// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)', '', '//----------------------------------------------------------------------------------', '// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag', '// SDK Version: v3.00', '// Email:       gameworks@nvidia.com', '// Site:        http://developer.nvidia.com/', '//', '// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.', '//', '// Redistribution and use in source and binary forms, with or without', '// modification, are permitted provided that the following conditions', '// are met:', '//  * Redistributions of source code must retain the above copyright', '//    notice, this list of conditions and the following disclaimer.', '//  * Redistributions in binary form must reproduce the above copyright', '//    notice, this list of conditions and the following disclaimer in the', '//    documentation and/or other materials provided with the distribution.', '//  * Neither the name of NVIDIA CORPORATION nor the names of its', '//    contributors may be used to endorse or promote products derived', '//    from this software without specific prior written permission.', '//', \"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\", '// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE', '// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR', '// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR', '// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,', '// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,', '// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR', '// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY', '// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT', '// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE', '// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.', '//', '//----------------------------------------------------------------------------------', '', '#define FXAA_PC 1', '#define FXAA_GLSL_100 1', '#define FXAA_QUALITY_PRESET 12', '', '#define FXAA_GREEN_AS_LUMA 1', '', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_PC_CONSOLE', '    //', '    // The console algorithm for PC is included', '    // for developers targeting really low spec machines.', '    // Likely better to just run FXAA_PC, and use a really low preset.', '    //', '    #define FXAA_PC_CONSOLE 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_GLSL_120', '    #define FXAA_GLSL_120 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_GLSL_130', '    #define FXAA_GLSL_130 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_HLSL_3', '    #define FXAA_HLSL_3 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_HLSL_4', '    #define FXAA_HLSL_4 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_HLSL_5', '    #define FXAA_HLSL_5 0', '#endif', '/*==========================================================================*/', '#ifndef FXAA_GREEN_AS_LUMA', '    //', '    // For those using non-linear color,', '    // and either not able to get luma in alpha, or not wanting to,', '    // this enables FXAA to run using green as a proxy for luma.', '    // So with this enabled, no need to pack luma in alpha.', '    //', '    // This will turn off AA on anything which lacks some amount of green.', '    // Pure red and blue or combination of only R and B, will get no AA.', '    //', '    // Might want to lower the settings for both,', '    //    fxaaConsoleEdgeThresholdMin', '    //    fxaaQualityEdgeThresholdMin', '    // In order to insure AA does not get turned off on colors', '    // which contain a minor amount of green.', '    //', '    // 1 = On.', '    // 0 = Off.', '    //', '    #define FXAA_GREEN_AS_LUMA 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_EARLY_EXIT', '    //', \"    // Controls algorithm's early exit path.\", '    // On PS3 turning this ON adds 2 cycles to the shader.', '    // On 360 turning this OFF adds 10ths of a millisecond to the shader.', '    // Turning this off on console will result in a more blurry image.', '    // So this defaults to on.', '    //', '    // 1 = On.', '    // 0 = Off.', '    //', '    #define FXAA_EARLY_EXIT 1', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_DISCARD', '    //', '    // Only valid for PC OpenGL currently.', '    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.', '    //', \"    // 1 = Use discard on pixels which don't need AA.\", '    //     For APIs which enable concurrent TEX+ROP from same surface.', \"    // 0 = Return unchanged color on pixels which don't need AA.\", '    //', '    #define FXAA_DISCARD 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_FAST_PIXEL_OFFSET', '    //', '    // Used for GLSL 120 only.', '    //', '    // 1 = GL API supports fast pixel offsets', '    // 0 = do not use fast pixel offsets', '    //', '    #ifdef GL_EXT_gpu_shader4', '        #define FXAA_FAST_PIXEL_OFFSET 1', '    #endif', '    #ifdef GL_NV_gpu_shader5', '        #define FXAA_FAST_PIXEL_OFFSET 1', '    #endif', '    #ifdef GL_ARB_gpu_shader5', '        #define FXAA_FAST_PIXEL_OFFSET 1', '    #endif', '    #ifndef FXAA_FAST_PIXEL_OFFSET', '        #define FXAA_FAST_PIXEL_OFFSET 0', '    #endif', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_GATHER4_ALPHA', '    //', '    // 1 = API supports gather4 on alpha channel.', '    // 0 = API does not support gather4 on alpha channel.', '    //', '    #if (FXAA_HLSL_5 == 1)', '        #define FXAA_GATHER4_ALPHA 1', '    #endif', '    #ifdef GL_ARB_gpu_shader5', '        #define FXAA_GATHER4_ALPHA 1', '    #endif', '    #ifdef GL_NV_gpu_shader5', '        #define FXAA_GATHER4_ALPHA 1', '    #endif', '    #ifndef FXAA_GATHER4_ALPHA', '        #define FXAA_GATHER4_ALPHA 0', '    #endif', '#endif', '', '', '/*============================================================================', '                        FXAA QUALITY - TUNING KNOBS', '------------------------------------------------------------------------------', 'NOTE the other tuning knobs are now in the shader function inputs!', '============================================================================*/', '#ifndef FXAA_QUALITY_PRESET', '    //', '    // Choose the quality preset.', '    // This needs to be compiled into the shader as it effects code.', '    // Best option to include multiple presets is to', '    // in each shader define the preset, then include this file.', '    //', '    // OPTIONS', '    // -----------------------------------------------------------------------', '    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)', '    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)', '    // 39       - no dither, very expensive', '    //', '    // NOTES', '    // -----------------------------------------------------------------------', '    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)', '    // 13 = about same speed as FXAA 3.9 and better than 12', '    // 23 = closest to FXAA 3.9 visually and performance wise', '    //  _ = the lowest digit is directly related to performance', '    // _  = the highest digit is directly related to style', '    //', '    #define FXAA_QUALITY_PRESET 12', '#endif', '', '', '/*============================================================================', '', '                           FXAA QUALITY - PRESETS', '', '============================================================================*/', '', '/*============================================================================', '                     FXAA QUALITY - MEDIUM DITHER PRESETS', '============================================================================*/', '#if (FXAA_QUALITY_PRESET == 10)', '    #define FXAA_QUALITY_PS 3', '    #define FXAA_QUALITY_P0 1.5', '    #define FXAA_QUALITY_P1 3.0', '    #define FXAA_QUALITY_P2 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 11)', '    #define FXAA_QUALITY_PS 4', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 3.0', '    #define FXAA_QUALITY_P3 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 12)', '    #define FXAA_QUALITY_PS 5', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 4.0', '    #define FXAA_QUALITY_P4 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 13)', '    #define FXAA_QUALITY_PS 6', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 4.0', '    #define FXAA_QUALITY_P5 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 14)', '    #define FXAA_QUALITY_PS 7', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 4.0', '    #define FXAA_QUALITY_P6 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 15)', '    #define FXAA_QUALITY_PS 8', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 4.0', '    #define FXAA_QUALITY_P7 12.0', '#endif', '', '/*============================================================================', '                     FXAA QUALITY - LOW DITHER PRESETS', '============================================================================*/', '#if (FXAA_QUALITY_PRESET == 20)', '    #define FXAA_QUALITY_PS 3', '    #define FXAA_QUALITY_P0 1.5', '    #define FXAA_QUALITY_P1 2.0', '    #define FXAA_QUALITY_P2 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 21)', '    #define FXAA_QUALITY_PS 4', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 22)', '    #define FXAA_QUALITY_PS 5', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 23)', '    #define FXAA_QUALITY_PS 6', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 24)', '    #define FXAA_QUALITY_PS 7', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 3.0', '    #define FXAA_QUALITY_P6 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 25)', '    #define FXAA_QUALITY_PS 8', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 4.0', '    #define FXAA_QUALITY_P7 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 26)', '    #define FXAA_QUALITY_PS 9', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 4.0', '    #define FXAA_QUALITY_P8 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 27)', '    #define FXAA_QUALITY_PS 10', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 4.0', '    #define FXAA_QUALITY_P9 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 28)', '    #define FXAA_QUALITY_PS 11', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 2.0', '    #define FXAA_QUALITY_P9 4.0', '    #define FXAA_QUALITY_P10 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 29)', '    #define FXAA_QUALITY_PS 12', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 2.0', '    #define FXAA_QUALITY_P9 2.0', '    #define FXAA_QUALITY_P10 4.0', '    #define FXAA_QUALITY_P11 8.0', '#endif', '', '/*============================================================================', '                     FXAA QUALITY - EXTREME QUALITY', '============================================================================*/', '#if (FXAA_QUALITY_PRESET == 39)', '    #define FXAA_QUALITY_PS 12', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.0', '    #define FXAA_QUALITY_P2 1.0', '    #define FXAA_QUALITY_P3 1.0', '    #define FXAA_QUALITY_P4 1.0', '    #define FXAA_QUALITY_P5 1.5', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 2.0', '    #define FXAA_QUALITY_P9 2.0', '    #define FXAA_QUALITY_P10 4.0', '    #define FXAA_QUALITY_P11 8.0', '#endif', '', '', '', '/*============================================================================', '', '                                API PORTING', '', '============================================================================*/', '#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)', '    #define FxaaBool bool', '    #define FxaaDiscard discard', '    #define FxaaFloat float', '    #define FxaaFloat2 vec2', '    #define FxaaFloat3 vec3', '    #define FxaaFloat4 vec4', '    #define FxaaHalf float', '    #define FxaaHalf2 vec2', '    #define FxaaHalf3 vec3', '    #define FxaaHalf4 vec4', '    #define FxaaInt2 ivec2', '    #define FxaaSat(x) clamp(x, 0.0, 1.0)', '    #define FxaaTex sampler2D', '#else', '    #define FxaaBool bool', '    #define FxaaDiscard clip(-1)', '    #define FxaaFloat float', '    #define FxaaFloat2 float2', '    #define FxaaFloat3 float3', '    #define FxaaFloat4 float4', '    #define FxaaHalf half', '    #define FxaaHalf2 half2', '    #define FxaaHalf3 half3', '    #define FxaaHalf4 half4', '    #define FxaaSat(x) saturate(x)', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_GLSL_100 == 1)', '  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)', '  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_GLSL_120 == 1)', '    // Requires,', '    //  #version 120', '    // And at least,', '    //  #extension GL_EXT_gpu_shader4 : enable', '    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)', '    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)', '    #if (FXAA_FAST_PIXEL_OFFSET == 1)', '        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)', '    #else', '        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)', '    #endif', '    #if (FXAA_GATHER4_ALPHA == 1)', '        // use #extension GL_ARB_gpu_shader5 : enable', '        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)', '        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)', '        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)', '        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)', '    #endif', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_GLSL_130 == 1)', '    // Requires \"#version 130\" or better', '    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)', '    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)', '    #if (FXAA_GATHER4_ALPHA == 1)', '        // use #extension GL_ARB_gpu_shader5 : enable', '        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)', '        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)', '        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)', '        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)', '    #endif', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_HLSL_3 == 1)', '    #define FxaaInt2 float2', '    #define FxaaTex sampler2D', '    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))', '    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_HLSL_4 == 1)', '    #define FxaaInt2 int2', '    struct FxaaTex { SamplerState smpl; Texture2D tex; };', '    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)', '    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_HLSL_5 == 1)', '    #define FxaaInt2 int2', '    struct FxaaTex { SamplerState smpl; Texture2D tex; };', '    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)', '    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)', '    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)', '    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)', '    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)', '    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)', '#endif', '', '', '/*============================================================================', '                   GREEN AS LUMA OPTION SUPPORT FUNCTION', '============================================================================*/', '#if (FXAA_GREEN_AS_LUMA == 0)', '    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }', '#else', '    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }', '#endif', '', '', '', '', '/*============================================================================', '', '                             FXAA3 QUALITY - PC', '', '============================================================================*/', '#if (FXAA_PC == 1)', '/*--------------------------------------------------------------------------*/', 'FxaaFloat4 FxaaPixelShader(', '    //', '    // Use noperspective interpolation here (turn off perspective interpolation).', '    // {xy} = center of pixel', '    FxaaFloat2 pos,', '    //', '    // Used only for FXAA Console, and not used on the 360 version.', '    // Use noperspective interpolation here (turn off perspective interpolation).', '    // {xy_} = upper left of pixel', '    // {_zw} = lower right of pixel', '    FxaaFloat4 fxaaConsolePosPos,', '    //', '    // Input color texture.', '    // {rgb_} = color in linear or perceptual color space', '    // if (FXAA_GREEN_AS_LUMA == 0)', '    //     {__a} = luma in perceptual color space (not linear)', '    FxaaTex tex,', '    //', '    // Only used on the optimized 360 version of FXAA Console.', '    // For everything but 360, just use the same input here as for \"tex\".', '    // For 360, same texture, just alias with a 2nd sampler.', '    // This sampler needs to have an exponent bias of -1.', '    FxaaTex fxaaConsole360TexExpBiasNegOne,', '    //', '    // Only used on the optimized 360 version of FXAA Console.', '    // For everything but 360, just use the same input here as for \"tex\".', '    // For 360, same texture, just alias with a 3nd sampler.', '    // This sampler needs to have an exponent bias of -2.', '    FxaaTex fxaaConsole360TexExpBiasNegTwo,', '    //', '    // Only used on FXAA Quality.', '    // This must be from a constant/uniform.', '    // {x_} = 1.0/screenWidthInPixels', '    // {_y} = 1.0/screenHeightInPixels', '    FxaaFloat2 fxaaQualityRcpFrame,', '    //', '    // Only used on FXAA Console.', '    // This must be from a constant/uniform.', '    // This effects sub-pixel AA quality and inversely sharpness.', '    //   Where N ranges between,', '    //     N = 0.50 (default)', '    //     N = 0.33 (sharper)', '    // {x__} = -N/screenWidthInPixels', '    // {_y_} = -N/screenHeightInPixels', '    // {_z_} =  N/screenWidthInPixels', '    // {__w} =  N/screenHeightInPixels', '    FxaaFloat4 fxaaConsoleRcpFrameOpt,', '    //', '    // Only used on FXAA Console.', '    // Not used on 360, but used on PS3 and PC.', '    // This must be from a constant/uniform.', '    // {x__} = -2.0/screenWidthInPixels', '    // {_y_} = -2.0/screenHeightInPixels', '    // {_z_} =  2.0/screenWidthInPixels', '    // {__w} =  2.0/screenHeightInPixels', '    FxaaFloat4 fxaaConsoleRcpFrameOpt2,', '    //', '    // Only used on FXAA Console.', '    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.', '    // This must be from a constant/uniform.', '    // {x__} =  8.0/screenWidthInPixels', '    // {_y_} =  8.0/screenHeightInPixels', '    // {_z_} = -4.0/screenWidthInPixels', '    // {__w} = -4.0/screenHeightInPixels', '    FxaaFloat4 fxaaConsole360RcpFrameOpt2,', '    //', '    // Only used on FXAA Quality.', '    // This used to be the FXAA_QUALITY_SUBPIX define.', '    // It is here now to allow easier tuning.', '    // Choose the amount of sub-pixel aliasing removal.', '    // This can effect sharpness.', '    //   1.00 - upper limit (softer)', '    //   0.75 - default amount of filtering', '    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)', '    //   0.25 - almost off', '    //   0.00 - completely off', '    FxaaFloat fxaaQualitySubpix,', '    //', '    // Only used on FXAA Quality.', '    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.', '    // It is here now to allow easier tuning.', '    // The minimum amount of local contrast required to apply algorithm.', '    //   0.333 - too little (faster)', '    //   0.250 - low quality', '    //   0.166 - default', '    //   0.125 - high quality', '    //   0.063 - overkill (slower)', '    FxaaFloat fxaaQualityEdgeThreshold,', '    //', '    // Only used on FXAA Quality.', '    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.', '    // It is here now to allow easier tuning.', '    // Trims the algorithm from processing darks.', '    //   0.0833 - upper limit (default, the start of visible unfiltered edges)', '    //   0.0625 - high quality (faster)', '    //   0.0312 - visible limit (slower)', '    // Special notes when using FXAA_GREEN_AS_LUMA,', '    //   Likely want to set this to zero.', '    //   As colors that are mostly not-green', '    //   will appear very dark in the green channel!', '    //   Tune by looking at mostly non-green content,', '    //   then start at zero and increase until aliasing is a problem.', '    FxaaFloat fxaaQualityEdgeThresholdMin,', '    //', '    // Only used on FXAA Console.', '    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.', '    // It is here now to allow easier tuning.', '    // This does not effect PS3, as this needs to be compiled in.', '    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.', '    //   Due to the PS3 being ALU bound,', '    //   there are only three safe values here: 2 and 4 and 8.', '    //   These options use the shaders ability to a free *|/ by 2|4|8.', '    // For all other platforms can be a non-power of two.', '    //   8.0 is sharper (default!!!)', '    //   4.0 is softer', '    //   2.0 is really soft (good only for vector graphics inputs)', '    FxaaFloat fxaaConsoleEdgeSharpness,', '    //', '    // Only used on FXAA Console.', '    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.', '    // It is here now to allow easier tuning.', '    // This does not effect PS3, as this needs to be compiled in.', '    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.', '    //   Due to the PS3 being ALU bound,', '    //   there are only two safe values here: 1/4 and 1/8.', '    //   These options use the shaders ability to a free *|/ by 2|4|8.', '    // The console setting has a different mapping than the quality setting.', '    // Other platforms can use other values.', '    //   0.125 leaves less aliasing, but is softer (default!!!)', '    //   0.25 leaves more aliasing, and is sharper', '    FxaaFloat fxaaConsoleEdgeThreshold,', '    //', '    // Only used on FXAA Console.', '    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.', '    // It is here now to allow easier tuning.', '    // Trims the algorithm from processing darks.', '    // The console setting has a different mapping than the quality setting.', '    // This only applies when FXAA_EARLY_EXIT is 1.', '    // This does not apply to PS3,', '    // PS3 was simplified to avoid more shader instructions.', '    //   0.06 - faster but more aliasing in darks', '    //   0.05 - default', '    //   0.04 - slower and less aliasing in darks', '    // Special notes when using FXAA_GREEN_AS_LUMA,', '    //   Likely want to set this to zero.', '    //   As colors that are mostly not-green', '    //   will appear very dark in the green channel!', '    //   Tune by looking at mostly non-green content,', '    //   then start at zero and increase until aliasing is a problem.', '    FxaaFloat fxaaConsoleEdgeThresholdMin,', '    //', '    // Extra constants for 360 FXAA Console only.', '    // Use zeros or anything else for other platforms.', '    // These must be in physical constant registers and NOT immediates.', '    // Immediates will result in compiler un-optimizing.', '    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)', '    FxaaFloat4 fxaaConsole360ConstDir', ') {', '/*--------------------------------------------------------------------------*/', '    FxaaFloat2 posM;', '    posM.x = pos.x;', '    posM.y = pos.y;', '    #if (FXAA_GATHER4_ALPHA == 1)', '        #if (FXAA_DISCARD == 0)', '            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);', '            #if (FXAA_GREEN_AS_LUMA == 0)', '                #define lumaM rgbyM.w', '            #else', '                #define lumaM rgbyM.y', '            #endif', '        #endif', '        #if (FXAA_GREEN_AS_LUMA == 0)', '            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);', '            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));', '        #else', '            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);', '            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));', '        #endif', '        #if (FXAA_DISCARD == 1)', '            #define lumaM luma4A.w', '        #endif', '        #define lumaE luma4A.z', '        #define lumaS luma4A.x', '        #define lumaSE luma4A.y', '        #define lumaNW luma4B.w', '        #define lumaN luma4B.z', '        #define lumaW luma4B.x', '    #else', '        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);', '        #if (FXAA_GREEN_AS_LUMA == 0)', '            #define lumaM rgbyM.w', '        #else', '            #define lumaM rgbyM.y', '        #endif', '        #if (FXAA_GLSL_100 == 1)', '          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));', '        #else', '          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));', '        #endif', '    #endif', '/*--------------------------------------------------------------------------*/', '    FxaaFloat maxSM = max(lumaS, lumaM);', '    FxaaFloat minSM = min(lumaS, lumaM);', '    FxaaFloat maxESM = max(lumaE, maxSM);', '    FxaaFloat minESM = min(lumaE, minSM);', '    FxaaFloat maxWN = max(lumaN, lumaW);', '    FxaaFloat minWN = min(lumaN, lumaW);', '    FxaaFloat rangeMax = max(maxWN, maxESM);', '    FxaaFloat rangeMin = min(minWN, minESM);', '    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;', '    FxaaFloat range = rangeMax - rangeMin;', '    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);', '    FxaaBool earlyExit = range < rangeMaxClamped;', '/*--------------------------------------------------------------------------*/', '    if(earlyExit)', '        #if (FXAA_DISCARD == 1)', '            FxaaDiscard;', '        #else', '            return rgbyM;', '        #endif', '/*--------------------------------------------------------------------------*/', '    #if (FXAA_GATHER4_ALPHA == 0)', '        #if (FXAA_GLSL_100 == 1)', '          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));', '        #else', '          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));', '        #endif', '    #else', '        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));', '        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));', '    #endif', '/*--------------------------------------------------------------------------*/', '    FxaaFloat lumaNS = lumaN + lumaS;', '    FxaaFloat lumaWE = lumaW + lumaE;', '    FxaaFloat subpixRcpRange = 1.0/range;', '    FxaaFloat subpixNSWE = lumaNS + lumaWE;', '    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;', '    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat lumaNESE = lumaNE + lumaSE;', '    FxaaFloat lumaNWNE = lumaNW + lumaNE;', '    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;', '    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat lumaNWSW = lumaNW + lumaSW;', '    FxaaFloat lumaSWSE = lumaSW + lumaSE;', '    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);', '    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);', '    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;', '    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;', '    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;', '    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;', '    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;', '    FxaaBool horzSpan = edgeHorz >= edgeVert;', '    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;', '/*--------------------------------------------------------------------------*/', '    if(!horzSpan) lumaN = lumaW;', '    if(!horzSpan) lumaS = lumaE;', '    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;', '    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat gradientN = lumaN - lumaM;', '    FxaaFloat gradientS = lumaS - lumaM;', '    FxaaFloat lumaNN = lumaN + lumaM;', '    FxaaFloat lumaSS = lumaS + lumaM;', '    FxaaBool pairN = abs(gradientN) >= abs(gradientS);', '    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));', '    if(pairN) lengthSign = -lengthSign;', '    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);', '/*--------------------------------------------------------------------------*/', '    FxaaFloat2 posB;', '    posB.x = posM.x;', '    posB.y = posM.y;', '    FxaaFloat2 offNP;', '    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;', '    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;', '    if(!horzSpan) posB.x += lengthSign * 0.5;', '    if( horzSpan) posB.y += lengthSign * 0.5;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat2 posN;', '    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;', '    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;', '    FxaaFloat2 posP;', '    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;', '    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;', '    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;', '    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));', '    FxaaFloat subpixE = subpixC * subpixC;', '    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));', '/*--------------------------------------------------------------------------*/', '    if(!pairN) lumaNN = lumaSS;', '    FxaaFloat gradientScaled = gradient * 1.0/4.0;', '    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;', '    FxaaFloat subpixF = subpixD * subpixE;', '    FxaaBool lumaMLTZero = lumaMM < 0.0;', '/*--------------------------------------------------------------------------*/', '    lumaEndN -= lumaNN * 0.5;', '    lumaEndP -= lumaNN * 0.5;', '    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;', '    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;', '    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;', '    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;', '    FxaaBool doneNP = (!doneN) || (!doneP);', '    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;', '    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;', '/*--------------------------------------------------------------------------*/', '    if(doneNP) {', '        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '        doneN = abs(lumaEndN) >= gradientScaled;', '        doneP = abs(lumaEndP) >= gradientScaled;', '        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;', '        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;', '        doneNP = (!doneN) || (!doneP);', '        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;', '        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;', '/*--------------------------------------------------------------------------*/', '        #if (FXAA_QUALITY_PS > 3)', '        if(doneNP) {', '            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '            doneN = abs(lumaEndN) >= gradientScaled;', '            doneP = abs(lumaEndP) >= gradientScaled;', '            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;', '            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;', '            doneNP = (!doneN) || (!doneP);', '            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;', '            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;', '/*--------------------------------------------------------------------------*/', '            #if (FXAA_QUALITY_PS > 4)', '            if(doneNP) {', '                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                doneN = abs(lumaEndN) >= gradientScaled;', '                doneP = abs(lumaEndP) >= gradientScaled;', '                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;', '                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;', '                doneNP = (!doneN) || (!doneP);', '                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;', '                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;', '/*--------------------------------------------------------------------------*/', '                #if (FXAA_QUALITY_PS > 5)', '                if(doneNP) {', '                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                    doneN = abs(lumaEndN) >= gradientScaled;', '                    doneP = abs(lumaEndP) >= gradientScaled;', '                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;', '                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;', '                    doneNP = (!doneN) || (!doneP);', '                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;', '                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;', '/*--------------------------------------------------------------------------*/', '                    #if (FXAA_QUALITY_PS > 6)', '                    if(doneNP) {', '                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                        doneN = abs(lumaEndN) >= gradientScaled;', '                        doneP = abs(lumaEndP) >= gradientScaled;', '                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;', '                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;', '                        doneNP = (!doneN) || (!doneP);', '                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;', '                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;', '/*--------------------------------------------------------------------------*/', '                        #if (FXAA_QUALITY_PS > 7)', '                        if(doneNP) {', '                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                            doneN = abs(lumaEndN) >= gradientScaled;', '                            doneP = abs(lumaEndP) >= gradientScaled;', '                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;', '                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;', '                            doneNP = (!doneN) || (!doneP);', '                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;', '                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;', '/*--------------------------------------------------------------------------*/', '    #if (FXAA_QUALITY_PS > 8)', '    if(doneNP) {', '        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '        doneN = abs(lumaEndN) >= gradientScaled;', '        doneP = abs(lumaEndP) >= gradientScaled;', '        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;', '        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;', '        doneNP = (!doneN) || (!doneP);', '        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;', '        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;', '/*--------------------------------------------------------------------------*/', '        #if (FXAA_QUALITY_PS > 9)', '        if(doneNP) {', '            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '            doneN = abs(lumaEndN) >= gradientScaled;', '            doneP = abs(lumaEndP) >= gradientScaled;', '            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;', '            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;', '            doneNP = (!doneN) || (!doneP);', '            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;', '            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;', '/*--------------------------------------------------------------------------*/', '            #if (FXAA_QUALITY_PS > 10)', '            if(doneNP) {', '                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                doneN = abs(lumaEndN) >= gradientScaled;', '                doneP = abs(lumaEndP) >= gradientScaled;', '                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;', '                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;', '                doneNP = (!doneN) || (!doneP);', '                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;', '                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;', '/*--------------------------------------------------------------------------*/', '                #if (FXAA_QUALITY_PS > 11)', '                if(doneNP) {', '                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                    doneN = abs(lumaEndN) >= gradientScaled;', '                    doneP = abs(lumaEndP) >= gradientScaled;', '                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;', '                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;', '                    doneNP = (!doneN) || (!doneP);', '                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;', '                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;', '/*--------------------------------------------------------------------------*/', '                    #if (FXAA_QUALITY_PS > 12)', '                    if(doneNP) {', '                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                        doneN = abs(lumaEndN) >= gradientScaled;', '                        doneP = abs(lumaEndP) >= gradientScaled;', '                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;', '                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;', '                        doneNP = (!doneN) || (!doneP);', '                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;', '                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;', '/*--------------------------------------------------------------------------*/', '                    }', '                    #endif', '/*--------------------------------------------------------------------------*/', '                }', '                #endif', '/*--------------------------------------------------------------------------*/', '            }', '            #endif', '/*--------------------------------------------------------------------------*/', '        }', '        #endif', '/*--------------------------------------------------------------------------*/', '    }', '    #endif', '/*--------------------------------------------------------------------------*/', '                        }', '                        #endif', '/*--------------------------------------------------------------------------*/', '                    }', '                    #endif', '/*--------------------------------------------------------------------------*/', '                }', '                #endif', '/*--------------------------------------------------------------------------*/', '            }', '            #endif', '/*--------------------------------------------------------------------------*/', '        }', '        #endif', '/*--------------------------------------------------------------------------*/', '    }', '/*--------------------------------------------------------------------------*/', '    FxaaFloat dstN = posM.x - posN.x;', '    FxaaFloat dstP = posP.x - posM.x;', '    if(!horzSpan) dstN = posM.y - posN.y;', '    if(!horzSpan) dstP = posP.y - posM.y;', '/*--------------------------------------------------------------------------*/', '    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;', '    FxaaFloat spanLength = (dstP + dstN);', '    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;', '    FxaaFloat spanLengthRcp = 1.0/spanLength;', '/*--------------------------------------------------------------------------*/', '    FxaaBool directionN = dstN < dstP;', '    FxaaFloat dst = min(dstN, dstP);', '    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;', '    FxaaFloat subpixG = subpixF * subpixF;', '    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;', '    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;', '    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);', '    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;', '    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;', '    #if (FXAA_DISCARD == 1)', '        return FxaaTexTop(tex, posM);', '    #else', '        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);', '    #endif', '}', '/*==========================================================================*/', '#endif', '', 'void main() {', '  gl_FragColor = FxaaPixelShader(', '    vUv,', '    vec4(0.0),', '    tDiffuse,', '    tDiffuse,', '    tDiffuse,', '    resolution,', '    vec4(0.0),', '    vec4(0.0),', '    vec4(0.0),', '    0.75,', '    0.166,', '    0.0833,', '    0.0,', '    0.0,', '    0.0,', '    vec4(0.0)', '  );', '', '  // TODO avoid querying texture twice for same texel', '  gl_FragColor.a = texture2D(tDiffuse, vUv).a;', '}'].join('\\n')\n};\n\nexport { FXAAShader };\n", "/**\n * Focus shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\nconst FocusShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    screenWidth: {\n      value: 1024\n    },\n    screenHeight: {\n      value: 1024\n    },\n    sampleDistance: {\n      value: 0.94\n    },\n    waveFactor: {\n      value: 0.00125\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float screenWidth;', 'uniform float screenHeight;', 'uniform float sampleDistance;', 'uniform float waveFactor;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 color, org, tmp, add;', '\tfloat sample_dist, f;', '\tvec2 vin;', '\tvec2 uv = vUv;', '\tadd = color = org = texture2D( tDiffuse, uv );', '\tvin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );', '\tsample_dist = dot( vin, vin ) * 2.0;', '\tf = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;', '\tvec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tcolor = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );', '\tcolor = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );', '\tgl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );', '}'].join('\\n')\n};\n\nexport { FocusShader };\n", "import { Vector2 } from 'three';\n\n/**\n * Edge Detection Shader using Frei-Chen filter\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n *\n * aspect: vec2 of (1/width, 1/height)\n */\n\nconst FreiChenShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    aspect: {\n      value: new Vector2(512, 512)\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'uniform vec2 aspect;', 'vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);', 'mat3 G[9];', // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n  'const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );', 'const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );', 'const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );', 'const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );', 'const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );', 'const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );', 'const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );', 'const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );', 'const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );', 'void main(void)', '{', '\tG[0] = g0,', '\tG[1] = g1,', '\tG[2] = g2,', '\tG[3] = g3,', '\tG[4] = g4,', '\tG[5] = g5,', '\tG[6] = g6,', '\tG[7] = g7,', '\tG[8] = g8;', '\tmat3 I;', '\tfloat cnv[9];', '\tvec3 sample;',\n  /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n  '\tfor (float i=0.0; i<3.0; i++) {', '\t\tfor (float j=0.0; j<3.0; j++) {', '\t\t\tsample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;', '\t\t\tI[int(i)][int(j)] = length(sample);', '\t\t}', '\t}',\n  /* calculate the convolution values for all the masks */\n  '\tfor (int i=0; i<9; i++) {', '\t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);', '\t\tcnv[i] = dp3 * dp3;', '\t}', '\tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);', '\tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);', '\tgl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);', '}'].join('\\n')\n};\n\nexport { FreiChenShader };\n", "/**\n * Based on Nvidia Cg tutorial\n */\nconst FresnelShader = {\n  uniforms: {\n    mRefractionRatio: {\n      value: 1.02\n    },\n    mFresnelBias: {\n      value: 0.1\n    },\n    mFresnelPower: {\n      value: 2.0\n    },\n    mFresnelScale: {\n      value: 1.0\n    },\n    tCube: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform float mRefractionRatio;', 'uniform float mFresnelBias;', 'uniform float mFresnelScale;', 'uniform float mFresnelPower;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );', '\tvec3 I = worldPosition.xyz - cameraPosition;', '\tvReflect = reflect( I, worldNormal );', '\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );', '\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );', '\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );', '\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\n  fragmentShader: ['uniform samplerCube tCube;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );', '\tvec4 refractedColor = vec4( 1.0 );', '\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;', '\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;', '\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;', '\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );', '}'].join('\\n')\n};\n\nexport { FresnelShader };\n", "/**\n * Gamma Correction Shader\n * http://en.wikipedia.org/wiki/gamma_correction\n */\nconst GammaCorrectionShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 tex = texture2D( tDiffuse, vUv );', '\tgl_FragColor = LinearTosRGB( tex );', '}'].join('\\n')\n};\n\nexport { GammaCorrectionShader };\n", "import { Vector3, Color } from 'three';\n\n/**\n * God-rays (crepuscular rays)\n *\n * Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].\n * Blurs a mask generated from the depth map along radial lines emanating from the light\n * source. The blur repeatedly applies a blur filter of increasing support but constant\n * sample count to produce a blur filter with large support.\n *\n * My implementation performs 3 passes, similar to the implementation from Sousa. I found\n * just 6 samples per pass produced acceptible results. The blur is applied three times,\n * with decreasing filter support. The result is equivalent to a single pass with\n * 6*6*6 = 216 samples.\n *\n * References:\n *\n * Sousa2008 - Crysis Next Gen Effects, GDC2008, http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt\n */\n\nconst GodRaysDepthMaskShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = uv;', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D tInput;', 'void main() {', '\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );', '}'].join('\\n')\n};\n/**\n * The god-ray generation shader.\n *\n * First pass:\n *\n * The depth map is blurred along radial lines towards the \"sun\". The\n * output is written to a temporary render target (I used a 1/4 sized\n * target).\n *\n * Pass two & three:\n *\n * The results of the previous pass are re-blurred, each time with a\n * decreased distance between samples.\n */\n\nconst GodRaysGenerateShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    },\n    fStepSize: {\n      value: 1.0\n    },\n    vSunPositionScreenSpace: {\n      value: new Vector3()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = uv;', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#define TAPS_PER_PASS 6.0', 'varying vec2 vUv;', 'uniform sampler2D tInput;', 'uniform vec3 vSunPositionScreenSpace;', 'uniform float fStepSize;', // filter step size\n  'void main() {', // delta from current pixel to \"sun\" position\n  '\tvec2 delta = vSunPositionScreenSpace.xy - vUv;', '\tfloat dist = length( delta );', // Step vector (uv space)\n  '\tvec2 stepv = fStepSize * delta / dist;', // Number of iterations between pixel and sun\n  '\tfloat iters = dist/fStepSize;', '\tvec2 uv = vUv.xy;', '\tfloat col = 0.0;', // This breaks ANGLE in Chrome 22\n  //\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n  /*\n  // Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n  // so i've just left the loop\n  \"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\",\n  // Accumulate samples, making sure we dont walk past the light source.\n  // The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n  // mode, with a black border color. I don't think this is currently\n  // exposed by three.js. As a result there might be artifacts when the\n  // sun is to the left, right or bottom of screen as these cases are\n  // not specifically handled.\n  \"\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\",\n  \"\tuv += stepv;\",\n  \"}\",\n  */\n  // Unrolling loop manually makes it work in ANGLE\n  '\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );', // used to fade out godrays\n  '\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', // Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\n  // objectionable artifacts, in particular near the sun position. The side\n  // effect is that the result is darker than it should be around the sun, as\n  // TAPS_PER_PASS is greater than the number of samples actually accumulated.\n  // When the result is inverted (in the shader 'godrays_combine', this produces\n  // a slight bright spot at the position of the sun, even when it is occluded.\n  '\tgl_FragColor = vec4( col/TAPS_PER_PASS );', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\n};\n/**\n * Additively applies god rays from texture tGodRays to a background (tColors).\n * fGodRayIntensity attenuates the god rays.\n */\n\nconst GodRaysCombineShader = {\n  uniforms: {\n    tColors: {\n      value: null\n    },\n    tGodRays: {\n      value: null\n    },\n    fGodRayIntensity: {\n      value: 0.69\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D tColors;', 'uniform sampler2D tGodRays;', 'uniform float fGodRayIntensity;', 'void main() {', // Since THREE.MeshDepthMaterial renders foreground objects white and background\n  // objects black, the god-rays will be white streaks. Therefore value is inverted\n  // before being combined with tColors\n  '\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\n};\n/**\n * A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be\n * cheaper/faster/simpler to implement this as a simple sun sprite.\n */\n\nconst GodRaysFakeSunShader = {\n  uniforms: {\n    vSunPositionScreenSpace: {\n      value: new Vector3()\n    },\n    fAspect: {\n      value: 1.0\n    },\n    sunColor: {\n      value: new Color(0xffee00)\n    },\n    bgColor: {\n      value: new Color(0x000000)\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['varying vec2 vUv;', 'uniform vec3 vSunPositionScreenSpace;', 'uniform float fAspect;', 'uniform vec3 sunColor;', 'uniform vec3 bgColor;', 'void main() {', '\tvec2 diff = vUv - vSunPositionScreenSpace.xy;', // Correct for aspect ratio\n  '\tdiff.x *= fAspect;', '\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );', '\tprop = 0.35 * pow( 1.0 - prop, 3.0 );', '\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;', '\tgl_FragColor.w = 1.0;', '}'].join('\\n')\n};\n\nexport { GodRaysCombineShader, GodRaysDepthMaskShader, GodRaysFakeSunShader, GodRaysGenerateShader };\n", "/**\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\nconst HorizontalBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    h: {\n      value: 1.0 / 512.0\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n      varying vec2 vUv;\n\n      void main() {\n\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n      }\n  `,\n  fragmentShader:\n  /* glsl */\n  `\n    uniform sampler2D tDiffuse;\n    uniform float h;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `\n};\n\nexport { HorizontalBlurShader };\n", "/**\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\nconst HorizontalTiltShiftShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    h: {\n      value: 1.0 / 512.0\n    },\n    r: {\n      value: 0.35\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float h;', 'uniform float r;', 'varying vec2 vUv;', 'void main() {', '\tvec4 sum = vec4( 0.0 );', '\tfloat hh = h * abs( r - vUv.y );', '\tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;', '\tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;', '\tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;', '\tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;', '\tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;', '\tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;', '\tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;', '\tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;', '\tgl_FragColor = sum;', '}'].join('\\n')\n};\n\nexport { HorizontalTiltShiftShader };\n", "/**\n * Hue and saturation adjustment\n * https://github.com/evanw/glfx.js\n * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.\n * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\nconst HueSaturationShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    hue: {\n      value: 0\n    },\n    saturation: {\n      value: 0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float hue;', 'uniform float saturation;', 'varying vec2 vUv;', 'void main() {', '\tgl_FragColor = texture2D( tDiffuse, vUv );', // hue\n  '\tfloat angle = hue * 3.14159265;', '\tfloat s = sin(angle), c = cos(angle);', '\tvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;', '\tfloat len = length(gl_FragColor.rgb);', '\tgl_FragColor.rgb = vec3(', '\t\tdot(gl_FragColor.rgb, weights.xyz),', '\t\tdot(gl_FragColor.rgb, weights.zxy),', '\t\tdot(gl_FragColor.rgb, weights.yzx)', '\t);', // saturation\n  '\tfloat average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;', '\tif (saturation > 0.0) {', '\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));', '\t} else {', '\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);', '\t}', '}'].join('\\n')\n};\n\nexport { HueSaturationShader };\n", "/**\n * Kaleidoscope Shader\n * Radial reflection around center point\n * Ported from: http://pixelshaders.com/editor/\n * by Toby Schachman / http://tobyschachman.com/\n *\n * sides: number of reflections\n * angle: initial angle in radians\n */\nconst KaleidoShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    sides: {\n      value: 6.0\n    },\n    angle: {\n      value: 0.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float sides;', 'uniform float angle;', 'varying vec2 vUv;', 'void main() {', '\tvec2 p = vUv - 0.5;', '\tfloat r = length(p);', '\tfloat a = atan(p.y, p.x) + angle;', '\tfloat tau = 2. * 3.1416 ;', '\ta = mod(a, tau/sides);', '\ta = abs(a - tau/sides/2.) ;', '\tp = r * vec2(cos(a), sin(a));', '\tvec4 color = texture2D(tDiffuse, p + 0.5);', '\tgl_FragColor = color;', '}'].join('\\n')\n};\n\nexport { KaleidoShader };\n", "/**\n * Mirror Shader\n * Copies half the input to the other half\n *\n * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)\n */\nconst MirrorShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    side: {\n      value: 1\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform int side;', 'varying vec2 vUv;', 'void main() {', '\tvec2 p = vUv;', '\tif (side == 0){', '\t\tif (p.x > 0.5) p.x = 1.0 - p.x;', '\t}else if (side == 1){', '\t\tif (p.x < 0.5) p.x = 1.0 - p.x;', '\t}else if (side == 2){', '\t\tif (p.y < 0.5) p.y = 1.0 - p.y;', '\t}else if (side == 3){', '\t\tif (p.y > 0.5) p.y = 1.0 - p.y;', '\t} ', '\tvec4 color = texture2D(tDiffuse, p);', '\tgl_FragColor = color;', '}'].join('\\n')\n};\n\nexport { MirrorShader };\n", "import { Vector2 } from 'three';\n\n/**\n * Normal map shader\n * - compute normals from heightmap\n */\n\nconst NormalMapShader = {\n  uniforms: {\n    heightMap: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2(512, 512)\n    },\n    scale: {\n      value: new Vector2(1, 1)\n    },\n    height: {\n      value: 0.05\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float height;', 'uniform vec2 resolution;', 'uniform sampler2D heightMap;', 'varying vec2 vUv;', 'void main() {', '\tfloat val = texture2D( heightMap, vUv ).x;', '\tfloat valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;', '\tfloat valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;', '\tgl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );', '}'].join('\\n')\n};\n\nexport { NormalMapShader };\n", "// Parallax Occlusion shaders from\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\n// No tangent-space transforms logic based on\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\nconst ParallaxShader = {\n  // Ordered from fastest to best quality.\n  modes: {\n    none: 'NO_PARALLAX',\n    basic: 'USE_BASIC_PARALLAX',\n    steep: 'USE_STEEP_PARALLAX',\n    occlusion: 'USE_OCLUSION_PARALLAX',\n    // a.k.a. POM\n    relief: 'USE_RELIEF_PARALLAX'\n  },\n  uniforms: {\n    bumpMap: {\n      value: null\n    },\n    map: {\n      value: null\n    },\n    parallaxScale: {\n      value: null\n    },\n    parallaxMinLayers: {\n      value: null\n    },\n    parallaxMaxLayers: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', 'void main() {', '\tvUv = uv;', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvViewPosition = -mvPosition.xyz;', '\tvNormal = normalize( normalMatrix * normal );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D bumpMap;', 'uniform sampler2D map;', 'uniform float parallaxScale;', 'uniform float parallaxMinLayers;', 'uniform float parallaxMaxLayers;', 'varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', '#ifdef USE_BASIC_PARALLAX', '\tvec2 parallaxMap( in vec3 V ) {', '\t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;', // No Offset Limitting: messy, floating output at grazing angles.\n  //\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n  // Offset Limiting\n  '\t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;', '\t\treturn vUv - texCoordOffset;', '\t}', '#else', '\tvec2 parallaxMap( in vec3 V ) {', // Determine number of layers from angle between V and N\n  '\t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );', '\t\tfloat layerHeight = 1.0 / numLayers;', '\t\tfloat currentLayerHeight = 0.0;', // Shift of texture coordinates for each iteration\n  '\t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;', '\t\tvec2 currentTextureCoords = vUv;', '\t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // while ( heightFromTexture > currentLayerHeight )\n  // Infinite loops are not well supported. Do a \"large\" finite\n  // loop, but not too large, as it slows down some compilers.\n  '\t\tfor ( int i = 0; i < 30; i += 1 ) {', '\t\t\tif ( heightFromTexture <= currentLayerHeight ) {', '\t\t\t\tbreak;', '\t\t\t}', '\t\t\tcurrentLayerHeight += layerHeight;', // Shift texture coordinates along vector V\n  '\t\t\tcurrentTextureCoords -= dtex;', '\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', '\t\t}', '\t\t#ifdef USE_STEEP_PARALLAX', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_RELIEF_PARALLAX )', '\t\t\tvec2 deltaTexCoord = dtex / 2.0;', '\t\t\tfloat deltaHeight = layerHeight / 2.0;', // Return to the mid point of previous layer\n  '\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\tcurrentLayerHeight -= deltaHeight;', // Binary search to increase precision of Steep Parallax Mapping\n  '\t\t\tconst int numSearches = 5;', '\t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {', '\t\t\t\tdeltaTexCoord /= 2.0;', '\t\t\t\tdeltaHeight /= 2.0;', '\t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // Shift along or against vector V\n  '\t\t\t\tif( heightFromTexture > currentLayerHeight ) {', // Below the surface\n  '\t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight += deltaHeight;', '\t\t\t\t} else {', // above the surface\n  '\t\t\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight -= deltaHeight;', '\t\t\t\t}', '\t\t\t}', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_OCLUSION_PARALLAX )', '\t\t\tvec2 prevTCoords = currentTextureCoords + dtex;', // Heights for linear interpolation\n  '\t\t\tfloat nextH = heightFromTexture - currentLayerHeight;', '\t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;', // Proportions for linear interpolation\n  '\t\t\tfloat weight = nextH / ( nextH - prevH );', // Interpolation of texture coordinates\n  '\t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );', '\t\t#else', // NO_PARALLAX\n  '\t\t\treturn vUv;', '\t\t#endif', '\t}', '#endif', 'vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {', '\tvec2 texDx = dFdx( vUv );', '\tvec2 texDy = dFdy( vUv );', '\tvec3 vSigmaX = dFdx( surfPosition );', '\tvec3 vSigmaY = dFdy( surfPosition );', '\tvec3 vR1 = cross( vSigmaY, surfNormal );', '\tvec3 vR2 = cross( surfNormal, vSigmaX );', '\tfloat fDet = dot( vSigmaX, vR1 );', '\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );', '\tvec3 vProjVtex;', '\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;', '\tvProjVtex.z = dot( surfNormal, viewPosition );', '\treturn parallaxMap( vProjVtex );', '}', 'void main() {', '\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );', '\tgl_FragColor = texture2D( map, mapUv );', '}'].join('\\n')\n};\n\nexport { ParallaxShader };\n", "/**\n * Pixelation shader\n */\nconst PixelShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: null\n    },\n    pixelSize: {\n      value: 1\n    }\n  },\n  vertexShader: ['varying highp vec2 vUv;', 'void main() {', 'vUv = uv;', 'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float pixelSize;', 'uniform vec2 resolution;', 'varying highp vec2 vUv;', 'void main(){', 'vec2 dxy = pixelSize / resolution;', 'vec2 coord = dxy * floor( vUv / dxy );', 'gl_FragColor = texture2D(tDiffuse, coord);', '}'].join('\\n')\n};\n\nexport { PixelShader };\n", "/**\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\nconst RGBShiftShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    amount: {\n      value: 0.005\n    },\n    angle: {\n      value: 0.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float amount;', 'uniform float angle;', 'varying vec2 vUv;', 'void main() {', '\tvec2 offset = amount * vec2( cos(angle), sin(angle));', '\tvec4 cr = texture2D(tDiffuse, vUv + offset);', '\tvec4 cga = texture2D(tDiffuse, vUv);', '\tvec4 cb = texture2D(tDiffuse, vUv - offset);', '\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);', '}'].join('\\n')\n};\n\nexport { RGBShiftShader };\n", "/**\n * Sepia tone shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\nconst SepiaShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    amount: {\n      value: 1.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float amount;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 color = texture2D( tDiffuse, vUv );', '\tvec3 c = color.rgb;', '\tcolor.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );', '\tcolor.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );', '\tcolor.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );', '\tgl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );', '}'].join('\\n')\n};\n\nexport { SepiaShader };\n", "import { Vector2 } from 'three';\n\n/**\n * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\n *\n * As mentioned in the video the Sobel operator expects a grayscale image as input.\n *\n */\n\nconst SobelOperatorShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );', // kernel definition (in glsl matrices are filled in column-major order)\n  '\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );', // x direction kernel\n  '\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );', // y direction kernel\n  // fetch the 3x3 neighbourhood of a fragment\n  // first column\n  '\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;', '\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;', '\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;', // second column\n  '\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;', '\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;', '\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;', // third column\n  '\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;', '\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;', '\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;', // gradient value in x direction\n  '\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ', '\t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ', '\t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ', // gradient value in y direction\n  '\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ', '\t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ', '\t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ', // magnitute of the total gradient\n  '\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );', '\tgl_FragColor = vec4( vec3( G ), 1 );', '}'].join('\\n')\n};\n\nexport { SobelOperatorShader };\n", "import { ShaderChunk, UniformsUtils, ShaderLib, Color } from 'three';\n\n/**\n * ------------------------------------------------------------------------------------------\n * Subsurface Scattering shader\n * Based on GDC 2011 – Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look\n * https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/\n *------------------------------------------------------------------------------------------\n */\n\nfunction replaceAll(string, find, replace) {\n  return string.split(find).join(replace);\n}\n\nconst meshphong_frag_head = ShaderChunk['meshphong_frag'].slice(0, ShaderChunk['meshphong_frag'].indexOf('void main() {'));\nconst meshphong_frag_body = ShaderChunk['meshphong_frag'].slice(ShaderChunk['meshphong_frag'].indexOf('void main() {'));\nconst SubsurfaceScatteringShader = {\n  uniforms: UniformsUtils.merge([ShaderLib['phong'].uniforms, {\n    thicknessMap: {\n      value: null\n    },\n    thicknessColor: {\n      value: new Color(0xffffff)\n    },\n    thicknessDistortion: {\n      value: 0.1\n    },\n    thicknessAmbient: {\n      value: 0.0\n    },\n    thicknessAttenuation: {\n      value: 0.1\n    },\n    thicknessPower: {\n      value: 2.0\n    },\n    thicknessScale: {\n      value: 10.0\n    }\n  }]),\n  vertexShader: ['#define USE_UV', ShaderChunk['meshphong_vert']].join('\\n'),\n  fragmentShader: ['#define USE_UV', '#define SUBSURFACE', meshphong_frag_head, 'uniform sampler2D thicknessMap;', 'uniform float thicknessPower;', 'uniform float thicknessScale;', 'uniform float thicknessDistortion;', 'uniform float thicknessAmbient;', 'uniform float thicknessAttenuation;', 'uniform vec3 thicknessColor;', 'void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {', '\tvec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;', '\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));', '\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;', '\tvec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;', '\treflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;', '}', meshphong_frag_body.replace('#include <lights_fragment_begin>', replaceAll(ShaderChunk['lights_fragment_begin'], 'RE_Direct( directLight, geometry, material, reflectedLight );', ['RE_Direct( directLight, geometry, material, reflectedLight );', '#if defined( SUBSURFACE ) && defined( USE_UV )', ' RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);', '#endif'].join('\\n')))].join('\\n')\n};\n\nexport { SubsurfaceScatteringShader };\n", "/**\n * Technicolor Shader\n * Simulates the look of the two-strip technicolor process popular in early 20th century films.\n * More historical info here: http://www.widescreenmuseum.com/oldcolor/technicolor1.htm\n * Demo here: http://charliehoey.com/technicolor_shader/shader_test.html\n */\nconst TechnicolorShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );', '\tvec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);', '\tgl_FragColor = newTex;', '}'].join('\\n')\n};\n\nexport { TechnicolorShader };\n", "import { Vector3, Color } from 'three';\n\n/**\n * Currently contains:\n *\n *\ttoon1\n *\ttoon2\n *\thatching\n *\tdotted\n */\n\nconst ToonShader1 = {\n  uniforms: {\n    uDirLightPos: {\n      value: new Vector3()\n    },\n    uDirLightColor: {\n      value: new Color(0xeeeeee)\n    },\n    uAmbientLightColor: {\n      value: new Color(0x050505)\n    },\n    uBaseColor: {\n      value: new Color(0xffffff)\n    }\n  },\n  vertexShader: ['varying vec3 vNormal;', 'varying vec3 vRefract;', 'void main() {', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );', '\tvNormal = normalize( normalMatrix * normal );', '\tvec3 I = worldPosition.xyz - cameraPosition;', '\tvRefract = refract( normalize( I ), worldNormal, 1.02 );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 uBaseColor;', 'uniform vec3 uDirLightPos;', 'uniform vec3 uDirLightColor;', 'uniform vec3 uAmbientLightColor;', 'varying vec3 vNormal;', 'varying vec3 vRefract;', 'void main() {', '\tfloat directionalLightWeighting = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);', '\tvec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;', '\tfloat intensity = smoothstep( - 0.5, 1.0, pow( length(lightWeighting), 20.0 ) );', '\tintensity += length(lightWeighting) * 0.2;', '\tfloat cameraWeighting = dot( normalize( vNormal ), vRefract );', '\tintensity += pow( 1.0 - length( cameraWeighting ), 6.0 );', '\tintensity = intensity * 0.2 + 0.3;', '\tif ( intensity < 0.50 ) {', '\t\tgl_FragColor = vec4( 2.0 * intensity * uBaseColor, 1.0 );', '\t} else {', '\t\tgl_FragColor = vec4( 1.0 - 2.0 * ( 1.0 - intensity ) * ( 1.0 - uBaseColor ), 1.0 );', '}', '}'].join('\\n')\n};\nconst ToonShader2 = {\n  uniforms: {\n    uDirLightPos: {\n      value: new Vector3()\n    },\n    uDirLightColor: {\n      value: new Color(0xeeeeee)\n    },\n    uAmbientLightColor: {\n      value: new Color(0x050505)\n    },\n    uBaseColor: {\n      value: new Color(0xeeeeee)\n    },\n    uLineColor1: {\n      value: new Color(0x808080)\n    },\n    uLineColor2: {\n      value: new Color(0x000000)\n    },\n    uLineColor3: {\n      value: new Color(0x000000)\n    },\n    uLineColor4: {\n      value: new Color(0x000000)\n    }\n  },\n  vertexShader: ['varying vec3 vNormal;', 'void main() {', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tvNormal = normalize( normalMatrix * normal );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 uBaseColor;', 'uniform vec3 uLineColor1;', 'uniform vec3 uLineColor2;', 'uniform vec3 uLineColor3;', 'uniform vec3 uLineColor4;', 'uniform vec3 uDirLightPos;', 'uniform vec3 uDirLightColor;', 'uniform vec3 uAmbientLightColor;', 'varying vec3 vNormal;', 'void main() {', '\tfloat camera = max( dot( normalize( vNormal ), vec3( 0.0, 0.0, 1.0 ) ), 0.4);', '\tfloat light = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);', '\tgl_FragColor = vec4( uBaseColor, 1.0 );', '\tif ( length(uAmbientLightColor + uDirLightColor * light) < 1.00 ) {', '\t\tgl_FragColor *= vec4( uLineColor1, 1.0 );', '\t}', '\tif ( length(uAmbientLightColor + uDirLightColor * camera) < 0.50 ) {', '\t\tgl_FragColor *= vec4( uLineColor2, 1.0 );', '\t}', '}'].join('\\n')\n};\nconst ToonShaderHatching = {\n  uniforms: {\n    uDirLightPos: {\n      value: new Vector3()\n    },\n    uDirLightColor: {\n      value: new Color(0xeeeeee)\n    },\n    uAmbientLightColor: {\n      value: new Color(0x050505)\n    },\n    uBaseColor: {\n      value: new Color(0xffffff)\n    },\n    uLineColor1: {\n      value: new Color(0x000000)\n    },\n    uLineColor2: {\n      value: new Color(0x000000)\n    },\n    uLineColor3: {\n      value: new Color(0x000000)\n    },\n    uLineColor4: {\n      value: new Color(0x000000)\n    }\n  },\n  vertexShader: ['varying vec3 vNormal;', 'void main() {', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tvNormal = normalize( normalMatrix * normal );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 uBaseColor;', 'uniform vec3 uLineColor1;', 'uniform vec3 uLineColor2;', 'uniform vec3 uLineColor3;', 'uniform vec3 uLineColor4;', 'uniform vec3 uDirLightPos;', 'uniform vec3 uDirLightColor;', 'uniform vec3 uAmbientLightColor;', 'varying vec3 vNormal;', 'void main() {', '\tfloat directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);', '\tvec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;', '\tgl_FragColor = vec4( uBaseColor, 1.0 );', '\tif ( length(lightWeighting) < 1.00 ) {', '\t\tif ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {', '\t\t\tgl_FragColor = vec4( uLineColor1, 1.0 );', '\t\t}', '\t}', '\tif ( length(lightWeighting) < 0.75 ) {', '\t\tif (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {', '\t\t\tgl_FragColor = vec4( uLineColor2, 1.0 );', '\t\t}', '\t}', '\tif ( length(lightWeighting) < 0.50 ) {', '\t\tif (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {', '\t\t\tgl_FragColor = vec4( uLineColor3, 1.0 );', '\t\t}', '\t}', '\tif ( length(lightWeighting) < 0.3465 ) {', '\t\tif (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {', '\t\t\tgl_FragColor = vec4( uLineColor4, 1.0 );', '\t}', '\t}', '}'].join('\\n')\n};\nconst ToonShaderDotted = {\n  uniforms: {\n    uDirLightPos: {\n      value: new Vector3()\n    },\n    uDirLightColor: {\n      value: new Color(0xeeeeee)\n    },\n    uAmbientLightColor: {\n      value: new Color(0x050505)\n    },\n    uBaseColor: {\n      value: new Color(0xffffff)\n    },\n    uLineColor1: {\n      value: new Color(0x000000)\n    }\n  },\n  vertexShader: ['varying vec3 vNormal;', 'void main() {', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tvNormal = normalize( normalMatrix * normal );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 uBaseColor;', 'uniform vec3 uLineColor1;', 'uniform vec3 uLineColor2;', 'uniform vec3 uLineColor3;', 'uniform vec3 uLineColor4;', 'uniform vec3 uDirLightPos;', 'uniform vec3 uDirLightColor;', 'uniform vec3 uAmbientLightColor;', 'varying vec3 vNormal;', 'void main() {', 'float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);', 'vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;', 'gl_FragColor = vec4( uBaseColor, 1.0 );', 'if ( length(lightWeighting) < 1.00 ) {', '\t\tif ( ( mod(gl_FragCoord.x, 4.001) + mod(gl_FragCoord.y, 4.0) ) > 6.00 ) {', '\t\t\tgl_FragColor = vec4( uLineColor1, 1.0 );', '\t\t}', '\t}', '\tif ( length(lightWeighting) < 0.50 ) {', '\t\tif ( ( mod(gl_FragCoord.x + 2.0, 4.001) + mod(gl_FragCoord.y + 2.0, 4.0) ) > 6.00 ) {', '\t\t\tgl_FragColor = vec4( uLineColor1, 1.0 );', '\t\t}', '\t}', '}'].join('\\n')\n};\n\nexport { ToonShader1, ToonShader2, ToonShaderDotted, ToonShaderHatching };\n", "import { Vector2 } from 'three';\n\n/**\n * Triangle blur shader\n * based on glfx.js triangle blur shader\n * https://github.com/evanw/glfx.js\n *\n * A basic blur filter, which convolves the image with a\n * pyramid filter. The pyramid filter is separable and is applied as two\n * perpendicular triangle filters.\n */\n\nconst TriangleBlurShader = {\n  uniforms: {\n    texture: {\n      value: null\n    },\n    delta: {\n      value: new Vector2(1, 1)\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#define ITERATIONS 10.0', 'uniform sampler2D texture;', 'uniform vec2 delta;', 'varying vec2 vUv;', 'void main() {', '\tvec4 color = vec4( 0.0 );', '\tfloat total = 0.0;', // randomize the lookup values to hide the fixed number of samples\n  '\tfloat offset = rand( vUv );', '\tfor ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {', '\t\tfloat percent = ( t + offset - 0.5 ) / ITERATIONS;', '\t\tfloat weight = 1.0 - abs( percent );', '\t\tcolor += texture2D( texture, vUv + delta * percent ) * weight;', '\t\ttotal += weight;', '\t}', '\tgl_FragColor = color / total;', '}'].join('\\n')\n};\n\nexport { TriangleBlurShader };\n", "/**\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\nconst VerticalBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    v: {\n      value: 1.0 / 512.0\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n    varying vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n  fragmentShader:\n  /* glsl */\n  `\n\n  uniform sampler2D tDiffuse;\n  uniform float v;\n\n  varying vec2 vUv;\n\n  void main() {\n\n    vec4 sum = vec4( 0.0 );\n\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n    gl_FragColor = sum;\n\n  }\n  `\n};\n\nexport { VerticalBlurShader };\n", "/**\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\nconst VerticalTiltShiftShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    v: {\n      value: 1.0 / 512.0\n    },\n    r: {\n      value: 0.35\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float v;', 'uniform float r;', 'varying vec2 vUv;', 'void main() {', '\tvec4 sum = vec4( 0.0 );', '\tfloat vv = v * abs( r - vUv.y );', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;', '\tgl_FragColor = sum;', '}'].join('\\n')\n};\n\nexport { VerticalTiltShiftShader };\n", "/**\n * Vignette shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\nconst VignetteShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    offset: {\n      value: 1.0\n    },\n    darkness: {\n      value: 1.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float offset;', 'uniform float darkness;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', // Eskil's vignette\n  '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tvec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );', '\tgl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );',\n  /*\n  // alternative version from glfx.js\n  // this one makes more \"dusty\" look (as opposed to \"burned\")\n  \"\tvec4 color = texture2D( tDiffuse, vUv );\",\n  \"\tfloat dist = distance( vUv, vec2( 0.5 ) );\",\n  \"\tcolor.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );\",\n  \"\tgl_FragColor = color;\",\n  */\n  '}'].join('\\n')\n};\n\nexport { VignetteShader };\n", "import { Vector3, Vector2 } from 'three';\n\n/**\n * Shaders to render 3D volumes using raycasting.\n * The applied techniques are based on similar implementations in the Visvis and Vispy projects.\n * This is not the only approach, therefore it's marked 1.\n */\n\nconst VolumeRenderShader1 = {\n  uniforms: {\n    u_size: {\n      value: new Vector3(1, 1, 1)\n    },\n    u_renderstyle: {\n      value: 0\n    },\n    u_renderthreshold: {\n      value: 0.5\n    },\n    u_clim: {\n      value: new Vector2(1, 1)\n    },\n    u_data: {\n      value: null\n    },\n    u_cmdata: {\n      value: null\n    }\n  },\n  vertexShader: ['\t\tvarying vec4 v_nearpos;', '\t\tvarying vec4 v_farpos;', '\t\tvarying vec3 v_position;', '\t\tvoid main() {', // Prepare transforms to map to \"camera view\". See also:\n  // https://threejs.org/docs/#api/renderers/webgl/WebGLProgram\n  '\t\t\t\tmat4 viewtransformf = modelViewMatrix;', '\t\t\t\tmat4 viewtransformi = inverse(modelViewMatrix);', // Project local vertex coordinate to camera position. Then do a step\n  // backward (in cam coords) to the near clipping plane, and project back. Do\n  // the same for the far clipping plane. This gives us all the information we\n  // need to calculate the ray and truncate it to the viewing cone.\n  '\t\t\t\tvec4 position4 = vec4(position, 1.0);', '\t\t\t\tvec4 pos_in_cam = viewtransformf * position4;', // Intersection of ray and near clipping plane (z = -1 in clip coords)\n  '\t\t\t\tpos_in_cam.z = -pos_in_cam.w;', '\t\t\t\tv_nearpos = viewtransformi * pos_in_cam;', // Intersection of ray and far clipping plane (z = +1 in clip coords)\n  '\t\t\t\tpos_in_cam.z = pos_in_cam.w;', '\t\t\t\tv_farpos = viewtransformi * pos_in_cam;', // Set varyings and output pos\n  '\t\t\t\tv_position = position;', '\t\t\t\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;', '\t\t}'].join('\\n'),\n  fragmentShader: ['\t\tprecision highp float;', '\t\tprecision mediump sampler3D;', '\t\tuniform vec3 u_size;', '\t\tuniform int u_renderstyle;', '\t\tuniform float u_renderthreshold;', '\t\tuniform vec2 u_clim;', '\t\tuniform sampler3D u_data;', '\t\tuniform sampler2D u_cmdata;', '\t\tvarying vec3 v_position;', '\t\tvarying vec4 v_nearpos;', '\t\tvarying vec4 v_farpos;', // The maximum distance through our rendering volume is sqrt(3).\n  '\t\tconst int MAX_STEPS = 887;\t// 887 for 512^3, 1774 for 1024^3', '\t\tconst int REFINEMENT_STEPS = 4;', '\t\tconst float relative_step_size = 1.0;', '\t\tconst vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);', '\t\tconst vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);', '\t\tconst vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);', '\t\tconst float shininess = 40.0;', '\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);', '\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);', '\t\tfloat sample1(vec3 texcoords);', '\t\tvec4 apply_colormap(float val);', '\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);', '\t\tvoid main() {', // Normalize clipping plane info\n  '\t\t\t\tvec3 farpos = v_farpos.xyz / v_farpos.w;', '\t\t\t\tvec3 nearpos = v_nearpos.xyz / v_nearpos.w;', // Calculate unit vector pointing in the view direction through this fragment.\n  '\t\t\t\tvec3 view_ray = normalize(nearpos.xyz - farpos.xyz);', // Compute the (negative) distance to the front surface or near clipping plane.\n  // v_position is the back face of the cuboid, so the initial distance calculated in the dot\n  // product below is the distance from near clip plane to the back of the cuboid\n  '\t\t\t\tfloat distance = dot(nearpos - v_position, view_ray);', '\t\t\t\tdistance = max(distance, min((-0.5 - v_position.x) / view_ray.x,', '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.x - 0.5 - v_position.x) / view_ray.x));', '\t\t\t\tdistance = max(distance, min((-0.5 - v_position.y) / view_ray.y,', '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.y - 0.5 - v_position.y) / view_ray.y));', '\t\t\t\tdistance = max(distance, min((-0.5 - v_position.z) / view_ray.z,', '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.z - 0.5 - v_position.z) / view_ray.z));', // Now we have the starting position on the front surface\n  '\t\t\t\tvec3 front = v_position + view_ray * distance;', // Decide how many steps to take\n  '\t\t\t\tint nsteps = int(-distance / relative_step_size + 0.5);', '\t\t\t\tif ( nsteps < 1 )', '\t\t\t\t\t\tdiscard;', // Get starting location and step vector in texture coordinates\n  '\t\t\t\tvec3 step = ((v_position - front) / u_size) / float(nsteps);', '\t\t\t\tvec3 start_loc = front / u_size;', // For testing: show the number of steps. This helps to establish\n  // whether the rays are correctly oriented\n  //'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);',\n  //'return;',\n  '\t\t\t\tif (u_renderstyle == 0)', '\t\t\t\t\t\tcast_mip(start_loc, step, nsteps, view_ray);', '\t\t\t\telse if (u_renderstyle == 1)', '\t\t\t\t\t\tcast_iso(start_loc, step, nsteps, view_ray);', '\t\t\t\tif (gl_FragColor.a < 0.05)', '\t\t\t\t\t\tdiscard;', '\t\t}', '\t\tfloat sample1(vec3 texcoords) {', '\t\t\t\t/* Sample float value from a 3D texture. Assumes intensity data. */', '\t\t\t\treturn texture(u_data, texcoords.xyz).r;', '\t\t}', '\t\tvec4 apply_colormap(float val) {', '\t\t\t\tval = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);', '\t\t\t\treturn texture2D(u_cmdata, vec2(val, 0.5));', '\t\t}', '\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {', '\t\t\t\tfloat max_val = -1e6;', '\t\t\t\tint max_i = 100;', '\t\t\t\tvec3 loc = start_loc;', // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n  // non-constant expression. So we use a hard-coded max, and an additional condition\n  // inside the loop.\n  '\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {', '\t\t\t\t\t\tif (iter >= nsteps)', '\t\t\t\t\t\t\t\tbreak;', // Sample from the 3D texture\n  '\t\t\t\t\t\tfloat val = sample1(loc);', // Apply MIP operation\n  '\t\t\t\t\t\tif (val > max_val) {', '\t\t\t\t\t\t\t\tmax_val = val;', '\t\t\t\t\t\t\t\tmax_i = iter;', '\t\t\t\t\t\t}', // Advance location deeper into the volume\n  '\t\t\t\t\t\tloc += step;', '\t\t\t\t}', // Refine location, gives crispier images\n  '\t\t\t\tvec3 iloc = start_loc + step * (float(max_i) - 0.5);', '\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);', '\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {', '\t\t\t\t\t\tmax_val = max(max_val, sample1(iloc));', '\t\t\t\t\t\tiloc += istep;', '\t\t\t\t}', // Resolve final color\n  '\t\t\t\tgl_FragColor = apply_colormap(max_val);', '\t\t}', '\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {', '\t\t\t\tgl_FragColor = vec4(0.0);\t// init transparent', '\t\t\t\tvec4 color3 = vec4(0.0);\t// final color', '\t\t\t\tvec3 dstep = 1.5 / u_size;\t// step to sample derivative', '\t\t\t\tvec3 loc = start_loc;', '\t\t\t\tfloat low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);', // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n  // non-constant expression. So we use a hard-coded max, and an additional condition\n  // inside the loop.\n  '\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {', '\t\t\t\t\t\tif (iter >= nsteps)', '\t\t\t\t\t\t\t\tbreak;', // Sample from the 3D texture\n  '\t\t\t\t\t\tfloat val = sample1(loc);', '\t\t\t\t\t\tif (val > low_threshold) {', // Take the last interval in smaller steps\n  '\t\t\t\t\t\t\t\tvec3 iloc = loc - 0.5 * step;', '\t\t\t\t\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);', '\t\t\t\t\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {', '\t\t\t\t\t\t\t\t\t\tval = sample1(iloc);', '\t\t\t\t\t\t\t\t\t\tif (val > u_renderthreshold) {', '\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = add_lighting(val, iloc, dstep, view_ray);', '\t\t\t\t\t\t\t\t\t\t\t\treturn;', '\t\t\t\t\t\t\t\t\t\t}', '\t\t\t\t\t\t\t\t\t\tiloc += istep;', '\t\t\t\t\t\t\t\t}', '\t\t\t\t\t\t}', // Advance location deeper into the volume\n  '\t\t\t\t\t\tloc += step;', '\t\t\t\t}', '\t\t}', '\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)', '\t\t{', // Calculate color by incorporating lighting\n  // View direction\n  '\t\t\t\tvec3 V = normalize(view_ray);', // calculate normal vector from gradient\n  '\t\t\t\tvec3 N;', '\t\t\t\tfloat val1, val2;', '\t\t\t\tval1 = sample1(loc + vec3(-step[0], 0.0, 0.0));', '\t\t\t\tval2 = sample1(loc + vec3(+step[0], 0.0, 0.0));', '\t\t\t\tN[0] = val1 - val2;', '\t\t\t\tval = max(max(val1, val2), val);', '\t\t\t\tval1 = sample1(loc + vec3(0.0, -step[1], 0.0));', '\t\t\t\tval2 = sample1(loc + vec3(0.0, +step[1], 0.0));', '\t\t\t\tN[1] = val1 - val2;', '\t\t\t\tval = max(max(val1, val2), val);', '\t\t\t\tval1 = sample1(loc + vec3(0.0, 0.0, -step[2]));', '\t\t\t\tval2 = sample1(loc + vec3(0.0, 0.0, +step[2]));', '\t\t\t\tN[2] = val1 - val2;', '\t\t\t\tval = max(max(val1, val2), val);', '\t\t\t\tfloat gm = length(N); // gradient magnitude', '\t\t\t\tN = normalize(N);', // Flip normal so it points towards viewer\n  '\t\t\t\tfloat Nselect = float(dot(N, V) > 0.0);', '\t\t\t\tN = (2.0 * Nselect - 1.0) * N;\t// ==\tNselect * N - (1.0-Nselect)*N;', // Init colors\n  '\t\t\t\tvec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);', '\t\t\t\tvec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);', '\t\t\t\tvec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);', // note: could allow multiple lights\n  '\t\t\t\tfor (int i=0; i<1; i++)', '\t\t\t\t{', // Get light direction (make sure to prevent zero devision)\n  '\t\t\t\t\t\tvec3 L = normalize(view_ray);\t//lightDirs[i];', '\t\t\t\t\t\tfloat lightEnabled = float( length(L) > 0.0 );', '\t\t\t\t\t\tL = normalize(L + (1.0 - lightEnabled));', // Calculate lighting properties\n  '\t\t\t\t\t\tfloat lambertTerm = clamp(dot(N, L), 0.0, 1.0);', '\t\t\t\t\t\tvec3 H = normalize(L+V); // Halfway vector', '\t\t\t\t\t\tfloat specularTerm = pow(max(dot(H, N), 0.0), shininess);', // Calculate mask\n  '\t\t\t\t\t\tfloat mask1 = lightEnabled;', // Calculate colors\n  '\t\t\t\t\t\tambient_color +=\tmask1 * ambient_color;\t// * gl_LightSource[i].ambient;', '\t\t\t\t\t\tdiffuse_color +=\tmask1 * lambertTerm;', '\t\t\t\t\t\tspecular_color += mask1 * specularTerm * specular_color;', '\t\t\t\t}', // Calculate final color by componing different components\n  '\t\t\t\tvec4 final_color;', '\t\t\t\tvec4 color = apply_colormap(val);', '\t\t\t\tfinal_color = color * (ambient_color + diffuse_color) + specular_color;', '\t\t\t\tfinal_color.a = color.a;', '\t\t\t\treturn final_color;', '\t\t}'].join('\\n')\n};\n\nexport { VolumeRenderShader1 };\n", "const WaterRefractionShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    time: {\n      value: 0\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDudv: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec2 vUv;', 'varying vec4 vUvRefraction;', 'void main() {', '\tvUv = uv;', '\tvUvRefraction = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec3 color;', 'uniform float time;', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDudv;', 'varying vec2 vUv;', 'varying vec4 vUvRefraction;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );', '}', 'void main() {', ' float waveStrength = 0.1;', ' float waveSpeed = 0.03;', // simple distortion (ripple) via dudv map (see https://www.youtube.com/watch?v=6B7IF6GOu7s)\n  '\tvec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;', '\tdistortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );', '\tvec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;', // new uv coords\n  ' vec4 uv = vec4( vUvRefraction );', ' uv.xy += distortion;', '\tvec4 base = texture2DProj( tDiffuse, uv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\n\nexport { WaterRefractionShader };\n", "import { Vector2, Group, Raycaster, Matrix4 } from 'three';\n\nconst _pointer = new Vector2();\n\nconst _event = {\n  type: '',\n  data: _pointer\n};\n\nclass InteractiveGroup extends Group {\n  constructor(renderer, camera) {\n    super();\n    const scope = this;\n    const raycaster = new Raycaster();\n    const tempMatrix = new Matrix4(); // Pointer Events\n\n    const element = renderer.domElement;\n\n    function onPointerEvent(event) {\n      event.stopPropagation();\n      _pointer.x = event.clientX / element.clientWidth * 2 - 1;\n      _pointer.y = -(event.clientY / element.clientHeight) * 2 + 1;\n      raycaster.setFromCamera(_pointer, camera);\n      const intersects = raycaster.intersectObjects(scope.children, false);\n\n      if (intersects.length > 0) {\n        const intersection = intersects[0];\n        const object = intersection.object;\n        const uv = intersection.uv;\n        _event.type = event.type;\n\n        _event.data.set(uv.x, 1 - uv.y);\n\n        object.dispatchEvent(_event);\n      }\n    }\n\n    element.addEventListener('pointerdown', onPointerEvent);\n    element.addEventListener('pointerup', onPointerEvent);\n    element.addEventListener('pointermove', onPointerEvent);\n    element.addEventListener('mousedown', onPointerEvent);\n    element.addEventListener('mouseup', onPointerEvent);\n    element.addEventListener('mousemove', onPointerEvent);\n    element.addEventListener('click', onPointerEvent); // WebXR Controller Events\n    // TODO: Dispatch pointerevents too\n\n    const events = {\n      move: 'mousemove',\n      select: 'click',\n      selectstart: 'mousedown',\n      selectend: 'mouseup'\n    };\n\n    function onXRControllerEvent(event) {\n      const controller = event.target;\n      tempMatrix.identity().extractRotation(controller.matrixWorld);\n      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);\n      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n      const intersections = raycaster.intersectObjects(scope.children, false);\n\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const object = intersection.object;\n        const uv = intersection.uv;\n        _event.type = events[event.type];\n\n        _event.data.set(uv.x, 1 - uv.y);\n\n        object.dispatchEvent(_event);\n      }\n    }\n\n    const controller1 = renderer.xr.getController(0);\n    controller1.addEventListener('move', onXRControllerEvent);\n    controller1.addEventListener('select', onXRControllerEvent);\n    controller1.addEventListener('selectstart', onXRControllerEvent);\n    controller1.addEventListener('selectend', onXRControllerEvent);\n    const controller2 = renderer.xr.getController(1);\n    controller2.addEventListener('move', onXRControllerEvent);\n    controller2.addEventListener('select', onXRControllerEvent);\n    controller2.addEventListener('selectstart', onXRControllerEvent);\n    controller2.addEventListener('selectend', onXRControllerEvent);\n  }\n\n}\n\nexport { InteractiveGroup };\n", "import { Vector2 } from 'three';\n\nconst SelectionHelper = (() => {\n  class SelectionHelper {\n    constructor(selectionBox, renderer, cssClassName) {\n      this.element = document.createElement('div');\n      this.element.classList.add(cssClassName);\n      this.element.style.pointerEvents = 'none';\n      this.renderer = renderer;\n      this.startPoint = new Vector2();\n      this.pointTopLeft = new Vector2();\n      this.pointBottomRight = new Vector2();\n      this.isDown = false;\n      this.renderer.domElement.addEventListener('pointerdown', event => {\n        this.isDown = true;\n        this.onSelectStart(event);\n      });\n      this.renderer.domElement.addEventListener('pointermove', event => {\n        if (this.isDown) {\n          this.onSelectMove(event);\n        }\n      });\n      this.renderer.domElement.addEventListener('pointerup', event => {\n        this.isDown = false;\n        this.onSelectOver(event);\n      });\n    }\n\n    onSelectStart(event) {\n      this.renderer.domElement.parentElement.appendChild(this.element);\n      this.element.style.left = `${event.clientX}px`;\n      this.element.style.top = `${event.clientY}px`;\n      this.element.style.width = '0px';\n      this.element.style.height = '0px';\n      this.startPoint.x = event.clientX;\n      this.startPoint.y = event.clientY;\n    }\n\n    onSelectMove(event) {\n      this.pointBottomRight.x = Math.max(this.startPoint.x, event.clientX);\n      this.pointBottomRight.y = Math.max(this.startPoint.y, event.clientY);\n      this.pointTopLeft.x = Math.min(this.startPoint.x, event.clientX);\n      this.pointTopLeft.y = Math.min(this.startPoint.y, event.clientY);\n      this.element.style.left = `${this.pointTopLeft.x}px`;\n      this.element.style.top = `${this.pointTopLeft.y}px`;\n      this.element.style.width = `${this.pointBottomRight.x - this.pointTopLeft.x}px`;\n      this.element.style.height = `${this.pointBottomRight.y - this.pointTopLeft.y}px`;\n    }\n\n    onSelectOver() {\n      this.element.parentElement.removeChild(this.element);\n    }\n\n  }\n\n  return SelectionHelper;\n})();\n\nexport { SelectionHelper };\n", "import { Frustum, Vector3 } from 'three';\n\n/**\n * This is a class to check whether objects are in a selection area in 3D space\n */\n\nconst SelectionBox = (() => {\n  const frustum = new Frustum();\n  const center = new Vector3();\n  const tmpPoint = new Vector3();\n  const vecNear = new Vector3();\n  const vecTopLeft = new Vector3();\n  const vecTopRight = new Vector3();\n  const vecDownRight = new Vector3();\n  const vecDownLeft = new Vector3();\n  const vecFarTopLeft = new Vector3();\n  const vecFarTopRight = new Vector3();\n  const vecFarDownRight = new Vector3();\n  const vecFarDownLeft = new Vector3();\n  const vectemp1 = new Vector3();\n  const vectemp2 = new Vector3();\n  const vectemp3 = new Vector3();\n\n  class SelectionBox {\n    constructor(camera, scene, deep) {\n      this.camera = camera;\n      this.scene = scene;\n      this.startPoint = new Vector3();\n      this.endPoint = new Vector3();\n      this.collection = [];\n      this.deep = deep || Number.MAX_VALUE;\n    }\n\n    select(startPoint, endPoint) {\n      this.startPoint = startPoint || this.startPoint;\n      this.endPoint = endPoint || this.endPoint;\n      this.collection = [];\n      this.updateFrustum(this.startPoint, this.endPoint);\n      this.searchChildInFrustum(frustum, this.scene);\n      return this.collection;\n    }\n\n    updateFrustum(startPoint, endPoint) {\n      startPoint = startPoint || this.startPoint;\n      endPoint = endPoint || this.endPoint; // Avoid invalid frustum\n\n      if (startPoint.x === endPoint.x) {\n        endPoint.x += Number.EPSILON;\n      }\n\n      if (startPoint.y === endPoint.y) {\n        endPoint.y += Number.EPSILON;\n      }\n\n      this.camera.updateProjectionMatrix();\n      this.camera.updateMatrixWorld();\n\n      if (this.camera.isPerspectiveCamera) {\n        tmpPoint.copy(startPoint);\n        tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n        tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n        endPoint.x = Math.max(startPoint.x, endPoint.x);\n        endPoint.y = Math.min(startPoint.y, endPoint.y);\n        vecNear.setFromMatrixPosition(this.camera.matrixWorld);\n        vecTopLeft.copy(tmpPoint);\n        vecTopRight.set(endPoint.x, tmpPoint.y, 0);\n        vecDownRight.copy(endPoint);\n        vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\n        vecTopLeft.unproject(this.camera);\n        vecTopRight.unproject(this.camera);\n        vecDownRight.unproject(this.camera);\n        vecDownLeft.unproject(this.camera);\n        vectemp1.copy(vecTopLeft).sub(vecNear);\n        vectemp2.copy(vecTopRight).sub(vecNear);\n        vectemp3.copy(vecDownRight).sub(vecNear);\n        vectemp1.normalize();\n        vectemp2.normalize();\n        vectemp3.normalize();\n        vectemp1.multiplyScalar(this.deep);\n        vectemp2.multiplyScalar(this.deep);\n        vectemp3.multiplyScalar(this.deep);\n        vectemp1.add(vecNear);\n        vectemp2.add(vecNear);\n        vectemp3.add(vecNear);\n        var planes = frustum.planes;\n        planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\n        planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\n        planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\n        planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\n        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n        planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\n        planes[5].normal.multiplyScalar(-1);\n      } else if (this.camera.isOrthographicCamera) {\n        const left = Math.min(startPoint.x, endPoint.x);\n        const top = Math.max(startPoint.y, endPoint.y);\n        const right = Math.max(startPoint.x, endPoint.x);\n        const down = Math.min(startPoint.y, endPoint.y);\n        vecTopLeft.set(left, top, -1);\n        vecTopRight.set(right, top, -1);\n        vecDownRight.set(right, down, -1);\n        vecDownLeft.set(left, down, -1);\n        vecFarTopLeft.set(left, top, 1);\n        vecFarTopRight.set(right, top, 1);\n        vecFarDownRight.set(right, down, 1);\n        vecFarDownLeft.set(left, down, 1);\n        vecTopLeft.unproject(this.camera);\n        vecTopRight.unproject(this.camera);\n        vecDownRight.unproject(this.camera);\n        vecDownLeft.unproject(this.camera);\n        vecFarTopLeft.unproject(this.camera);\n        vecFarTopRight.unproject(this.camera);\n        vecFarDownRight.unproject(this.camera);\n        vecFarDownLeft.unproject(this.camera);\n        var planes = frustum.planes;\n        planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\n        planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\n        planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\n        planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\n        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n        planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\n        planes[5].normal.multiplyScalar(-1);\n      } else {\n        console.error('THREE.SelectionBox: Unsupported camera type.');\n      }\n    }\n\n    searchChildInFrustum(frustum, object) {\n      if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.material !== undefined) {\n          if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();\n          center.copy(object.geometry.boundingSphere.center);\n          center.applyMatrix4(object.matrixWorld);\n\n          if (frustum.containsPoint(center)) {\n            this.collection.push(object);\n          }\n        }\n      }\n\n      if (object.children.length > 0) {\n        for (let x = 0; x < object.children.length; x++) {\n          this.searchChildInFrustum(frustum, object.children[x]);\n        }\n      }\n    }\n\n  }\n\n  return SelectionBox;\n})();\n\nexport { SelectionBox };\n", "import { Loader, LoaderUtils, FileLoader, TextureLoader, RepeatWrapping, ClampToEdgeWrapping, Texture, MeshPhongMaterial, MeshLambertMaterial, Color, sRGBEncoding, EquirectangularReflectionMapping, Matrix4, Group, Bone, PropertyBinding, Object3D, OrthographicCamera, PerspectiveCamera, PointLight, MathUtils, SpotLight, DirectionalLight, SkinnedMesh, Mesh, LineBasicMaterial, Line, Vector3, Skeleton, AmbientLight, BufferGeometry, Float32BufferAttribute, Uint16BufferAttribute, Matrix3, Vector4, AnimationClip, Quaternion, Euler, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack } from 'three';\nimport { unzlibSync } from 'fflate';\nimport { NURBSCurve } from '../curves/NURBSCurve.js';\n\n/**\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *\n * FBX format references:\n * \thttps://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * Binary format specification:\n *\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\nlet fbxTree;\nlet connections;\nlet sceneGraph;\n\nclass FBXLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(FBXBuffer, path) {\n    if (isFbxFormatBinary(FBXBuffer)) {\n      fbxTree = new BinaryParser().parse(FBXBuffer);\n    } else {\n      const FBXText = convertArrayBufferToString(FBXBuffer);\n\n      if (!isFbxFormatASCII(FBXText)) {\n        throw new Error('THREE.FBXLoader: Unknown format.');\n      }\n\n      if (getFbxVersion(FBXText) < 7000) {\n        throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));\n      }\n\n      fbxTree = new TextParser().parse(FBXText);\n    } // console.log( fbxTree );\n\n\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);\n  }\n\n} // Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\n\n\nclass FBXTreeParser {\n  constructor(textureLoader, manager) {\n    this.textureLoader = textureLoader;\n    this.manager = manager;\n  }\n\n  parse() {\n    connections = this.parseConnections();\n    const images = this.parseImages();\n    const textures = this.parseTextures(images);\n    const materials = this.parseMaterials(textures);\n    const deformers = this.parseDeformers();\n    const geometryMap = new GeometryParser().parse(deformers);\n    this.parseScene(deformers, geometryMap, materials);\n    return sceneGraph;\n  } // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n  // and details the connection type\n\n\n  parseConnections() {\n    const connectionMap = new Map();\n\n    if ('Connections' in fbxTree) {\n      const rawConnections = fbxTree.Connections.connections;\n      rawConnections.forEach(function (rawConnection) {\n        const fromID = rawConnection[0];\n        const toID = rawConnection[1];\n        const relationship = rawConnection[2];\n\n        if (!connectionMap.has(fromID)) {\n          connectionMap.set(fromID, {\n            parents: [],\n            children: []\n          });\n        }\n\n        const parentRelationship = {\n          ID: toID,\n          relationship: relationship\n        };\n        connectionMap.get(fromID).parents.push(parentRelationship);\n\n        if (!connectionMap.has(toID)) {\n          connectionMap.set(toID, {\n            parents: [],\n            children: []\n          });\n        }\n\n        const childRelationship = {\n          ID: fromID,\n          relationship: relationship\n        };\n        connectionMap.get(toID).children.push(childRelationship);\n      });\n    }\n\n    return connectionMap;\n  } // Parse FBXTree.Objects.Video for embedded image data\n  // These images are connected to textures in FBXTree.Objects.Textures\n  // via FBXTree.Connections.\n\n\n  parseImages() {\n    const images = {};\n    const blobs = {};\n\n    if ('Video' in fbxTree.Objects) {\n      const videoNodes = fbxTree.Objects.Video;\n\n      for (const nodeID in videoNodes) {\n        const videoNode = videoNodes[nodeID];\n        const id = parseInt(nodeID);\n        images[id] = videoNode.RelativeFilename || videoNode.Filename; // raw image data is in videoNode.Content\n\n        if ('Content' in videoNode) {\n          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;\n          const base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== '';\n\n          if (arrayBufferContent || base64Content) {\n            const image = this.parseImage(videoNodes[nodeID]);\n            blobs[videoNode.RelativeFilename || videoNode.Filename] = image;\n          }\n        }\n      }\n    }\n\n    for (const id in images) {\n      const filename = images[id];\n      if (blobs[filename] !== undefined) images[id] = blobs[filename];else images[id] = images[id].split('\\\\').pop();\n    }\n\n    return images;\n  } // Parse embedded image data in FBXTree.Video.Content\n\n\n  parseImage(videoNode) {\n    const content = videoNode.Content;\n    const fileName = videoNode.RelativeFilename || videoNode.Filename;\n    const extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();\n    let type;\n\n    switch (extension) {\n      case 'bmp':\n        type = 'image/bmp';\n        break;\n\n      case 'jpg':\n      case 'jpeg':\n        type = 'image/jpeg';\n        break;\n\n      case 'png':\n        type = 'image/png';\n        break;\n\n      case 'tif':\n        type = 'image/tiff';\n        break;\n\n      case 'tga':\n        if (this.manager.getHandler('.tga') === null) {\n          console.warn('FBXLoader: TGA loader not found, skipping ', fileName);\n        }\n\n        type = 'image/tga';\n        break;\n\n      default:\n        console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\n        return;\n    }\n\n    if (typeof content === 'string') {\n      // ASCII format\n      return 'data:' + type + ';base64,' + content;\n    } else {\n      // Binary Format\n      const array = new Uint8Array(content);\n      return window.URL.createObjectURL(new Blob([array], {\n        type: type\n      }));\n    }\n  } // Parse nodes in FBXTree.Objects.Texture\n  // These contain details such as UV scaling, cropping, rotation etc and are connected\n  // to images in FBXTree.Objects.Video\n\n\n  parseTextures(images) {\n    const textureMap = new Map();\n\n    if ('Texture' in fbxTree.Objects) {\n      const textureNodes = fbxTree.Objects.Texture;\n\n      for (const nodeID in textureNodes) {\n        const texture = this.parseTexture(textureNodes[nodeID], images);\n        textureMap.set(parseInt(nodeID), texture);\n      }\n    }\n\n    return textureMap;\n  } // Parse individual node in FBXTree.Objects.Texture\n\n\n  parseTexture(textureNode, images) {\n    const texture = this.loadTexture(textureNode, images);\n    texture.ID = textureNode.id;\n    texture.name = textureNode.attrName;\n    const wrapModeU = textureNode.WrapModeU;\n    const wrapModeV = textureNode.WrapModeV;\n    const valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n    const valueV = wrapModeV !== undefined ? wrapModeV.value : 0; // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n    // 0: repeat(default), 1: clamp\n\n    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;\n    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;\n\n    if ('Scaling' in textureNode) {\n      const values = textureNode.Scaling.value;\n      texture.repeat.x = values[0];\n      texture.repeat.y = values[1];\n    }\n\n    return texture;\n  } // load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n\n\n  loadTexture(textureNode, images) {\n    let fileName;\n    const currentPath = this.textureLoader.path;\n    const children = connections.get(textureNode.id).children;\n\n    if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\n      fileName = images[children[0].ID];\n\n      if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n        this.textureLoader.setPath(undefined);\n      }\n    }\n\n    let texture;\n    const extension = textureNode.FileName.slice(-3).toLowerCase();\n\n    if (extension === 'tga') {\n      const loader = this.manager.getHandler('.tga');\n\n      if (loader === null) {\n        console.warn('FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename);\n        texture = new Texture();\n      } else {\n        loader.setPath(this.textureLoader.path);\n        texture = loader.load(fileName);\n      }\n    } else if (extension === 'psd') {\n      console.warn('FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename);\n      texture = new Texture();\n    } else {\n      texture = this.textureLoader.load(fileName);\n    }\n\n    this.textureLoader.setPath(currentPath);\n    return texture;\n  } // Parse nodes in FBXTree.Objects.Material\n\n\n  parseMaterials(textureMap) {\n    const materialMap = new Map();\n\n    if ('Material' in fbxTree.Objects) {\n      const materialNodes = fbxTree.Objects.Material;\n\n      for (const nodeID in materialNodes) {\n        const material = this.parseMaterial(materialNodes[nodeID], textureMap);\n        if (material !== null) materialMap.set(parseInt(nodeID), material);\n      }\n    }\n\n    return materialMap;\n  } // Parse single node in FBXTree.Objects.Material\n  // Materials are connected to texture maps in FBXTree.Objects.Textures\n  // FBX format currently only supports Lambert and Phong shading models\n\n\n  parseMaterial(materialNode, textureMap) {\n    const ID = materialNode.id;\n    const name = materialNode.attrName;\n    let type = materialNode.ShadingModel; // Case where FBX wraps shading model in property object.\n\n    if (typeof type === 'object') {\n      type = type.value;\n    } // Ignore unused materials which don't have any connections.\n\n\n    if (!connections.has(ID)) return null;\n    const parameters = this.parseParameters(materialNode, textureMap, ID);\n    let material;\n\n    switch (type.toLowerCase()) {\n      case 'phong':\n        material = new MeshPhongMaterial();\n        break;\n\n      case 'lambert':\n        material = new MeshLambertMaterial();\n        break;\n\n      default:\n        console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\n        material = new MeshPhongMaterial();\n        break;\n    }\n\n    material.setValues(parameters);\n    material.name = name;\n    return material;\n  } // Parse FBX material and return parameters suitable for a three.js material\n  // Also parse the texture map and return any textures associated with the material\n\n\n  parseParameters(materialNode, textureMap, ID) {\n    const parameters = {};\n\n    if (materialNode.BumpFactor) {\n      parameters.bumpScale = materialNode.BumpFactor.value;\n    }\n\n    if (materialNode.Diffuse) {\n      parameters.color = new Color().fromArray(materialNode.Diffuse.value);\n    } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB')) {\n      // The blender exporter exports diffuse here instead of in materialNode.Diffuse\n      parameters.color = new Color().fromArray(materialNode.DiffuseColor.value);\n    }\n\n    if (materialNode.DisplacementFactor) {\n      parameters.displacementScale = materialNode.DisplacementFactor.value;\n    }\n\n    if (materialNode.Emissive) {\n      parameters.emissive = new Color().fromArray(materialNode.Emissive.value);\n    } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB')) {\n      // The blender exporter exports emissive color here instead of in materialNode.Emissive\n      parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value);\n    }\n\n    if (materialNode.EmissiveFactor) {\n      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);\n    }\n\n    if (materialNode.Opacity) {\n      parameters.opacity = parseFloat(materialNode.Opacity.value);\n    }\n\n    if (parameters.opacity < 1.0) {\n      parameters.transparent = true;\n    }\n\n    if (materialNode.ReflectionFactor) {\n      parameters.reflectivity = materialNode.ReflectionFactor.value;\n    }\n\n    if (materialNode.Shininess) {\n      parameters.shininess = materialNode.Shininess.value;\n    }\n\n    if (materialNode.Specular) {\n      parameters.specular = new Color().fromArray(materialNode.Specular.value);\n    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color') {\n      // The blender exporter exports specular color here instead of in materialNode.Specular\n      parameters.specular = new Color().fromArray(materialNode.SpecularColor.value);\n    }\n\n    const scope = this;\n    connections.get(ID).children.forEach(function (child) {\n      const type = child.relationship;\n\n      switch (type) {\n        case 'Bump':\n          parameters.bumpMap = scope.getTexture(textureMap, child.ID);\n          break;\n\n        case 'Maya|TEX_ao_map':\n          parameters.aoMap = scope.getTexture(textureMap, child.ID);\n          break;\n\n        case 'DiffuseColor':\n        case 'Maya|TEX_color_map':\n          parameters.map = scope.getTexture(textureMap, child.ID);\n\n          if (parameters.map !== undefined) {\n            parameters.map.encoding = sRGBEncoding;\n          }\n\n          break;\n\n        case 'DisplacementColor':\n          parameters.displacementMap = scope.getTexture(textureMap, child.ID);\n          break;\n\n        case 'EmissiveColor':\n          parameters.emissiveMap = scope.getTexture(textureMap, child.ID);\n\n          if (parameters.emissiveMap !== undefined) {\n            parameters.emissiveMap.encoding = sRGBEncoding;\n          }\n\n          break;\n\n        case 'NormalMap':\n        case 'Maya|TEX_normal_map':\n          parameters.normalMap = scope.getTexture(textureMap, child.ID);\n          break;\n\n        case 'ReflectionColor':\n          parameters.envMap = scope.getTexture(textureMap, child.ID);\n\n          if (parameters.envMap !== undefined) {\n            parameters.envMap.mapping = EquirectangularReflectionMapping;\n            parameters.envMap.encoding = sRGBEncoding;\n          }\n\n          break;\n\n        case 'SpecularColor':\n          parameters.specularMap = scope.getTexture(textureMap, child.ID);\n\n          if (parameters.specularMap !== undefined) {\n            parameters.specularMap.encoding = sRGBEncoding;\n          }\n\n          break;\n\n        case 'TransparentColor':\n        case 'TransparencyFactor':\n          parameters.alphaMap = scope.getTexture(textureMap, child.ID);\n          parameters.transparent = true;\n          break;\n\n        case 'AmbientColor':\n        case 'ShininessExponent': // AKA glossiness map\n\n        case 'SpecularFactor': // AKA specularLevel\n\n        case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\n        default:\n          console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);\n          break;\n      }\n    });\n    return parameters;\n  } // get a texture from the textureMap for use by a material.\n\n\n  getTexture(textureMap, id) {\n    // if the texture is a layered texture, just use the first layer and issue a warning\n    if ('LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {\n      console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.');\n      id = connections.get(id).children[0].ID;\n    }\n\n    return textureMap.get(id);\n  } // Parse nodes in FBXTree.Objects.Deformer\n  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\n\n  parseDeformers() {\n    const skeletons = {};\n    const morphTargets = {};\n\n    if ('Deformer' in fbxTree.Objects) {\n      const DeformerNodes = fbxTree.Objects.Deformer;\n\n      for (const nodeID in DeformerNodes) {\n        const deformerNode = DeformerNodes[nodeID];\n        const relationships = connections.get(parseInt(nodeID));\n\n        if (deformerNode.attrType === 'Skin') {\n          const skeleton = this.parseSkeleton(relationships, DeformerNodes);\n          skeleton.ID = nodeID;\n\n          if (relationships.parents.length > 1) {\n            console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.');\n          }\n\n          skeleton.geometryID = relationships.parents[0].ID;\n          skeletons[nodeID] = skeleton;\n        } else if (deformerNode.attrType === 'BlendShape') {\n          const morphTarget = {\n            id: nodeID\n          };\n          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);\n          morphTarget.id = nodeID;\n\n          if (relationships.parents.length > 1) {\n            console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.');\n          }\n\n          morphTargets[nodeID] = morphTarget;\n        }\n      }\n    }\n\n    return {\n      skeletons: skeletons,\n      morphTargets: morphTargets\n    };\n  } // Parse single nodes in FBXTree.Objects.Deformer\n  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n  // Each skin node represents a skeleton and each cluster node represents a bone\n\n\n  parseSkeleton(relationships, deformerNodes) {\n    const rawBones = [];\n    relationships.children.forEach(function (child) {\n      const boneNode = deformerNodes[child.ID];\n      if (boneNode.attrType !== 'Cluster') return;\n      const rawBone = {\n        ID: child.ID,\n        indices: [],\n        weights: [],\n        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a) // transform: new Matrix4().fromArray( boneNode.Transform.a ),\n        // linkMode: boneNode.Mode,\n\n      };\n\n      if ('Indexes' in boneNode) {\n        rawBone.indices = boneNode.Indexes.a;\n        rawBone.weights = boneNode.Weights.a;\n      }\n\n      rawBones.push(rawBone);\n    });\n    return {\n      rawBones: rawBones,\n      bones: []\n    };\n  } // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\n\n  parseMorphTargets(relationships, deformerNodes) {\n    const rawMorphTargets = [];\n\n    for (let i = 0; i < relationships.children.length; i++) {\n      const child = relationships.children[i];\n      const morphTargetNode = deformerNodes[child.ID];\n      const rawMorphTarget = {\n        name: morphTargetNode.attrName,\n        initialWeight: morphTargetNode.DeformPercent,\n        id: morphTargetNode.id,\n        fullWeights: morphTargetNode.FullWeights.a\n      };\n      if (morphTargetNode.attrType !== 'BlendShapeChannel') return;\n      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function (child) {\n        return child.relationship === undefined;\n      })[0].ID;\n      rawMorphTargets.push(rawMorphTarget);\n    }\n\n    return rawMorphTargets;\n  } // create the main Group() to be returned by the loader\n\n\n  parseScene(deformers, geometryMap, materialMap) {\n    sceneGraph = new Group();\n    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);\n    const modelNodes = fbxTree.Objects.Model;\n    const scope = this;\n    modelMap.forEach(function (model) {\n      const modelNode = modelNodes[model.ID];\n      scope.setLookAtProperties(model, modelNode);\n      const parentConnections = connections.get(model.ID).parents;\n      parentConnections.forEach(function (connection) {\n        const parent = modelMap.get(connection.ID);\n        if (parent !== undefined) parent.add(model);\n      });\n\n      if (model.parent === null) {\n        sceneGraph.add(model);\n      }\n    });\n    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);\n    this.createAmbientLight();\n    sceneGraph.traverse(function (node) {\n      if (node.userData.transformData) {\n        if (node.parent) {\n          node.userData.transformData.parentMatrix = node.parent.matrix;\n          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;\n        }\n\n        const transform = generateTransform(node.userData.transformData);\n        node.applyMatrix4(transform);\n        node.updateWorldMatrix();\n      }\n    });\n    const animations = new AnimationParser().parse(); // if all the models where already combined in a single group, just return that\n\n    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {\n      sceneGraph.children[0].animations = animations;\n      sceneGraph = sceneGraph.children[0];\n    }\n\n    sceneGraph.animations = animations;\n  } // parse nodes in FBXTree.Objects.Model\n\n\n  parseModels(skeletons, geometryMap, materialMap) {\n    const modelMap = new Map();\n    const modelNodes = fbxTree.Objects.Model;\n\n    for (const nodeID in modelNodes) {\n      const id = parseInt(nodeID);\n      const node = modelNodes[nodeID];\n      const relationships = connections.get(id);\n      let model = this.buildSkeleton(relationships, skeletons, id, node.attrName);\n\n      if (!model) {\n        switch (node.attrType) {\n          case 'Camera':\n            model = this.createCamera(relationships);\n            break;\n\n          case 'Light':\n            model = this.createLight(relationships);\n            break;\n\n          case 'Mesh':\n            model = this.createMesh(relationships, geometryMap, materialMap);\n            break;\n\n          case 'NurbsCurve':\n            model = this.createCurve(relationships, geometryMap);\n            break;\n\n          case 'LimbNode':\n          case 'Root':\n            model = new Bone();\n            break;\n\n          case 'Null':\n          default:\n            model = new Group();\n            break;\n        }\n\n        model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : '';\n        model.ID = id;\n      }\n\n      this.getTransformData(model, node);\n      modelMap.set(id, model);\n    }\n\n    return modelMap;\n  }\n\n  buildSkeleton(relationships, skeletons, id, name) {\n    let bone = null;\n    relationships.parents.forEach(function (parent) {\n      for (const ID in skeletons) {\n        const skeleton = skeletons[ID];\n        skeleton.rawBones.forEach(function (rawBone, i) {\n          if (rawBone.ID === parent.ID) {\n            const subBone = bone;\n            bone = new Bone();\n            bone.matrixWorld.copy(rawBone.transformLink); // set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : '';\n            bone.ID = id;\n            skeleton.bones[i] = bone; // In cases where a bone is shared between multiple meshes\n            // duplicate the bone here and and it as a child of the first bone\n\n            if (subBone !== null) {\n              bone.add(subBone);\n            }\n          }\n        });\n      }\n    });\n    return bone;\n  } // create a PerspectiveCamera or OrthographicCamera\n\n\n  createCamera(relationships) {\n    let model;\n    let cameraAttribute;\n    relationships.children.forEach(function (child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID];\n\n      if (attr !== undefined) {\n        cameraAttribute = attr;\n      }\n    });\n\n    if (cameraAttribute === undefined) {\n      model = new Object3D();\n    } else {\n      let type = 0;\n\n      if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n        type = 1;\n      }\n\n      let nearClippingPlane = 1;\n\n      if (cameraAttribute.NearPlane !== undefined) {\n        nearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n      }\n\n      let farClippingPlane = 1000;\n\n      if (cameraAttribute.FarPlane !== undefined) {\n        farClippingPlane = cameraAttribute.FarPlane.value / 1000;\n      }\n\n      let width = window.innerWidth;\n      let height = window.innerHeight;\n\n      if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n        width = cameraAttribute.AspectWidth.value;\n        height = cameraAttribute.AspectHeight.value;\n      }\n\n      const aspect = width / height;\n      let fov = 45;\n\n      if (cameraAttribute.FieldOfView !== undefined) {\n        fov = cameraAttribute.FieldOfView.value;\n      }\n\n      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n      switch (type) {\n        case 0:\n          // Perspective\n          model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);\n          if (focalLength !== null) model.setFocalLength(focalLength);\n          break;\n\n        case 1:\n          // Orthographic\n          model = new OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);\n          break;\n\n        default:\n          console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');\n          model = new Object3D();\n          break;\n      }\n    }\n\n    return model;\n  } // Create a DirectionalLight, PointLight or SpotLight\n\n\n  createLight(relationships) {\n    let model;\n    let lightAttribute;\n    relationships.children.forEach(function (child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID];\n\n      if (attr !== undefined) {\n        lightAttribute = attr;\n      }\n    });\n\n    if (lightAttribute === undefined) {\n      model = new Object3D();\n    } else {\n      let type; // LightType can be undefined for Point lights\n\n      if (lightAttribute.LightType === undefined) {\n        type = 0;\n      } else {\n        type = lightAttribute.LightType.value;\n      }\n\n      let color = 0xffffff;\n\n      if (lightAttribute.Color !== undefined) {\n        color = new Color().fromArray(lightAttribute.Color.value);\n      }\n\n      let intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100; // light disabled\n\n      if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n        intensity = 0;\n      }\n\n      let distance = 0;\n\n      if (lightAttribute.FarAttenuationEnd !== undefined) {\n        if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n          distance = 0;\n        } else {\n          distance = lightAttribute.FarAttenuationEnd.value;\n        }\n      } // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\n\n      const decay = 1;\n\n      switch (type) {\n        case 0:\n          // Point\n          model = new PointLight(color, intensity, distance, decay);\n          break;\n\n        case 1:\n          // Directional\n          model = new DirectionalLight(color, intensity);\n          break;\n\n        case 2:\n          // Spot\n          let angle = Math.PI / 3;\n\n          if (lightAttribute.InnerAngle !== undefined) {\n            angle = MathUtils.degToRad(lightAttribute.InnerAngle.value);\n          }\n\n          let penumbra = 0;\n\n          if (lightAttribute.OuterAngle !== undefined) {\n            // TODO: this is not correct - FBX calculates outer and inner angle in degrees\n            // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n            // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);\n            penumbra = Math.max(penumbra, 1);\n          }\n\n          model = new SpotLight(color, intensity, distance, angle, penumbra, decay);\n          break;\n\n        default:\n          console.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.');\n          model = new PointLight(color, intensity);\n          break;\n      }\n\n      if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n        model.castShadow = true;\n      }\n    }\n\n    return model;\n  }\n\n  createMesh(relationships, geometryMap, materialMap) {\n    let model;\n    let geometry = null;\n    let material = null;\n    const materials = []; // get geometry and materials(s) from connections\n\n    relationships.children.forEach(function (child) {\n      if (geometryMap.has(child.ID)) {\n        geometry = geometryMap.get(child.ID);\n      }\n\n      if (materialMap.has(child.ID)) {\n        materials.push(materialMap.get(child.ID));\n      }\n    });\n\n    if (materials.length > 1) {\n      material = materials;\n    } else if (materials.length > 0) {\n      material = materials[0];\n    } else {\n      material = new MeshPhongMaterial({\n        color: 0xcccccc\n      });\n      materials.push(material);\n    }\n\n    if ('color' in geometry.attributes) {\n      materials.forEach(function (material) {\n        material.vertexColors = true;\n      });\n    }\n\n    if (geometry.FBX_Deformer) {\n      model = new SkinnedMesh(geometry, material);\n      model.normalizeSkinWeights();\n    } else {\n      model = new Mesh(geometry, material);\n    }\n\n    return model;\n  }\n\n  createCurve(relationships, geometryMap) {\n    const geometry = relationships.children.reduce(function (geo, child) {\n      if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);\n      return geo;\n    }, null); // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\n    const material = new LineBasicMaterial({\n      color: 0x3300ff,\n      linewidth: 1\n    });\n    return new Line(geometry, material);\n  } // parse the model node for transform data\n\n\n  getTransformData(model, modelNode) {\n    const transformData = {};\n    if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\n    if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);else transformData.eulerOrder = 'ZYX';\n    if ('Lcl_Translation' in modelNode) transformData.translation = modelNode.Lcl_Translation.value;\n    if ('PreRotation' in modelNode) transformData.preRotation = modelNode.PreRotation.value;\n    if ('Lcl_Rotation' in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;\n    if ('PostRotation' in modelNode) transformData.postRotation = modelNode.PostRotation.value;\n    if ('Lcl_Scaling' in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;\n    if ('ScalingOffset' in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;\n    if ('ScalingPivot' in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;\n    if ('RotationOffset' in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;\n    if ('RotationPivot' in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;\n    model.userData.transformData = transformData;\n  }\n\n  setLookAtProperties(model, modelNode) {\n    if ('LookAtProperty' in modelNode) {\n      const children = connections.get(model.ID).children;\n      children.forEach(function (child) {\n        if (child.relationship === 'LookAtProperty') {\n          const lookAtTarget = fbxTree.Objects.Model[child.ID];\n\n          if ('Lcl_Translation' in lookAtTarget) {\n            const pos = lookAtTarget.Lcl_Translation.value; // DirectionalLight, SpotLight\n\n            if (model.target !== undefined) {\n              model.target.position.fromArray(pos);\n              sceneGraph.add(model.target);\n            } else {\n              // Cameras and other Object3Ds\n              model.lookAt(new Vector3().fromArray(pos));\n            }\n          }\n        }\n      });\n    }\n  }\n\n  bindSkeleton(skeletons, geometryMap, modelMap) {\n    const bindMatrices = this.parsePoseNodes();\n\n    for (const ID in skeletons) {\n      const skeleton = skeletons[ID];\n      const parents = connections.get(parseInt(skeleton.ID)).parents;\n      parents.forEach(function (parent) {\n        if (geometryMap.has(parent.ID)) {\n          const geoID = parent.ID;\n          const geoRelationships = connections.get(geoID);\n          geoRelationships.parents.forEach(function (geoConnParent) {\n            if (modelMap.has(geoConnParent.ID)) {\n              const model = modelMap.get(geoConnParent.ID);\n              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);\n            }\n          });\n        }\n      });\n    }\n  }\n\n  parsePoseNodes() {\n    const bindMatrices = {};\n\n    if ('Pose' in fbxTree.Objects) {\n      const BindPoseNode = fbxTree.Objects.Pose;\n\n      for (const nodeID in BindPoseNode) {\n        if (BindPoseNode[nodeID].attrType === 'BindPose' && BindPoseNode[nodeID].NbPoseNodes > 0) {\n          const poseNodes = BindPoseNode[nodeID].PoseNode;\n\n          if (Array.isArray(poseNodes)) {\n            poseNodes.forEach(function (poseNode) {\n              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);\n            });\n          } else {\n            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);\n          }\n        }\n      }\n    }\n\n    return bindMatrices;\n  } // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\n\n  createAmbientLight() {\n    if ('GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings) {\n      const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\n      const r = ambientColor[0];\n      const g = ambientColor[1];\n      const b = ambientColor[2];\n\n      if (r !== 0 || g !== 0 || b !== 0) {\n        const color = new Color(r, g, b);\n        sceneGraph.add(new AmbientLight(color, 1));\n      }\n    }\n  }\n\n} // parse Geometry data from FBXTree and return map of BufferGeometries\n\n\nclass GeometryParser {\n  // Parse nodes in FBXTree.Objects.Geometry\n  parse(deformers) {\n    const geometryMap = new Map();\n\n    if ('Geometry' in fbxTree.Objects) {\n      const geoNodes = fbxTree.Objects.Geometry;\n\n      for (const nodeID in geoNodes) {\n        const relationships = connections.get(parseInt(nodeID));\n        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);\n        geometryMap.set(parseInt(nodeID), geo);\n      }\n    }\n\n    return geometryMap;\n  } // Parse single node in FBXTree.Objects.Geometry\n\n\n  parseGeometry(relationships, geoNode, deformers) {\n    switch (geoNode.attrType) {\n      case 'Mesh':\n        return this.parseMeshGeometry(relationships, geoNode, deformers);\n\n      case 'NurbsCurve':\n        return this.parseNurbsGeometry(geoNode);\n    }\n  } // Parse single node mesh geometry in FBXTree.Objects.Geometry\n\n\n  parseMeshGeometry(relationships, geoNode, deformers) {\n    const skeletons = deformers.skeletons;\n    const morphTargets = [];\n    const modelNodes = relationships.parents.map(function (parent) {\n      return fbxTree.Objects.Model[parent.ID];\n    }); // don't create geometry if it is not associated with any models\n\n    if (modelNodes.length === 0) return;\n    const skeleton = relationships.children.reduce(function (skeleton, child) {\n      if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];\n      return skeleton;\n    }, null);\n    relationships.children.forEach(function (child) {\n      if (deformers.morphTargets[child.ID] !== undefined) {\n        morphTargets.push(deformers.morphTargets[child.ID]);\n      }\n    }); // Assume one model and get the preRotation from that\n    // if there is more than one model associated with the geometry this may cause problems\n\n    const modelNode = modelNodes[0];\n    const transformData = {};\n    if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);\n    if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\n    if ('GeometricTranslation' in modelNode) transformData.translation = modelNode.GeometricTranslation.value;\n    if ('GeometricRotation' in modelNode) transformData.rotation = modelNode.GeometricRotation.value;\n    if ('GeometricScaling' in modelNode) transformData.scale = modelNode.GeometricScaling.value;\n    const transform = generateTransform(transformData);\n    return this.genGeometry(geoNode, skeleton, morphTargets, transform);\n  } // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n\n\n  genGeometry(geoNode, skeleton, morphTargets, preTransform) {\n    const geo = new BufferGeometry();\n    if (geoNode.attrName) geo.name = geoNode.attrName;\n    const geoInfo = this.parseGeoNode(geoNode, skeleton);\n    const buffers = this.genBuffers(geoInfo);\n    const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);\n    positionAttribute.applyMatrix4(preTransform);\n    geo.setAttribute('position', positionAttribute);\n\n    if (buffers.colors.length > 0) {\n      geo.setAttribute('color', new Float32BufferAttribute(buffers.colors, 3));\n    }\n\n    if (skeleton) {\n      geo.setAttribute('skinIndex', new Uint16BufferAttribute(buffers.weightsIndices, 4));\n      geo.setAttribute('skinWeight', new Float32BufferAttribute(buffers.vertexWeights, 4)); // used later to bind the skeleton to the model\n\n      geo.FBX_Deformer = skeleton;\n    }\n\n    if (buffers.normal.length > 0) {\n      const normalMatrix = new Matrix3().getNormalMatrix(preTransform);\n      const normalAttribute = new Float32BufferAttribute(buffers.normal, 3);\n      normalAttribute.applyNormalMatrix(normalMatrix);\n      geo.setAttribute('normal', normalAttribute);\n    }\n\n    buffers.uvs.forEach(function (uvBuffer, i) {\n      // subsequent uv buffers are called 'uv1', 'uv2', ...\n      let name = 'uv' + (i + 1).toString(); // the first uv buffer is just called 'uv'\n\n      if (i === 0) {\n        name = 'uv';\n      }\n\n      geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2));\n    });\n\n    if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n      // Convert the material indices of each vertex into rendering groups on the geometry.\n      let prevMaterialIndex = buffers.materialIndex[0];\n      let startIndex = 0;\n      buffers.materialIndex.forEach(function (currentIndex, i) {\n        if (currentIndex !== prevMaterialIndex) {\n          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n          prevMaterialIndex = currentIndex;\n          startIndex = i;\n        }\n      }); // the loop above doesn't add the last group, do that here.\n\n      if (geo.groups.length > 0) {\n        const lastGroup = geo.groups[geo.groups.length - 1];\n        const lastIndex = lastGroup.start + lastGroup.count;\n\n        if (lastIndex !== buffers.materialIndex.length) {\n          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);\n        }\n      } // case where there are multiple materials but the whole geometry is only\n      // using one of them\n\n\n      if (geo.groups.length === 0) {\n        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);\n      }\n    }\n\n    this.addMorphTargets(geo, geoNode, morphTargets, preTransform);\n    return geo;\n  }\n\n  parseGeoNode(geoNode, skeleton) {\n    const geoInfo = {};\n    geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];\n    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];\n\n    if (geoNode.LayerElementColor) {\n      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);\n    }\n\n    if (geoNode.LayerElementMaterial) {\n      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);\n    }\n\n    if (geoNode.LayerElementNormal) {\n      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);\n    }\n\n    if (geoNode.LayerElementUV) {\n      geoInfo.uv = [];\n      let i = 0;\n\n      while (geoNode.LayerElementUV[i]) {\n        if (geoNode.LayerElementUV[i].UV) {\n          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));\n        }\n\n        i++;\n      }\n    }\n\n    geoInfo.weightTable = {};\n\n    if (skeleton !== null) {\n      geoInfo.skeleton = skeleton;\n      skeleton.rawBones.forEach(function (rawBone, i) {\n        // loop over the bone's vertex indices and weights\n        rawBone.indices.forEach(function (index, j) {\n          if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];\n          geoInfo.weightTable[index].push({\n            id: i,\n            weight: rawBone.weights[j]\n          });\n        });\n      });\n    }\n\n    return geoInfo;\n  }\n\n  genBuffers(geoInfo) {\n    const buffers = {\n      vertex: [],\n      normal: [],\n      colors: [],\n      uvs: [],\n      materialIndex: [],\n      vertexWeights: [],\n      weightsIndices: []\n    };\n    let polygonIndex = 0;\n    let faceLength = 0;\n    let displayedWeightsWarning = false; // these will hold data for a single face\n\n    let facePositionIndexes = [];\n    let faceNormals = [];\n    let faceColors = [];\n    let faceUVs = [];\n    let faceWeights = [];\n    let faceWeightIndices = [];\n    const scope = this;\n    geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\n      let materialIndex;\n      let endOfFace = false; // Face index and vertex index arrays are combined in a single array\n      // A cube with quad faces looks like this:\n      // PolygonVertexIndex: *24 {\n      //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n      //  }\n      // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n      // to find index of last vertex bit shift the index: ^ - 1\n\n      if (vertexIndex < 0) {\n        vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\n\n        endOfFace = true;\n      }\n\n      let weightIndices = [];\n      let weights = [];\n      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\n\n      if (geoInfo.color) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);\n        faceColors.push(data[0], data[1], data[2]);\n      }\n\n      if (geoInfo.skeleton) {\n        if (geoInfo.weightTable[vertexIndex] !== undefined) {\n          geoInfo.weightTable[vertexIndex].forEach(function (wt) {\n            weights.push(wt.weight);\n            weightIndices.push(wt.id);\n          });\n        }\n\n        if (weights.length > 4) {\n          if (!displayedWeightsWarning) {\n            console.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');\n            displayedWeightsWarning = true;\n          }\n\n          const wIndex = [0, 0, 0, 0];\n          const Weight = [0, 0, 0, 0];\n          weights.forEach(function (weight, weightIndex) {\n            let currentWeight = weight;\n            let currentIndex = weightIndices[weightIndex];\n            Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n              if (currentWeight > comparedWeight) {\n                comparedWeightArray[comparedWeightIndex] = currentWeight;\n                currentWeight = comparedWeight;\n                const tmp = wIndex[comparedWeightIndex];\n                wIndex[comparedWeightIndex] = currentIndex;\n                currentIndex = tmp;\n              }\n            });\n          });\n          weightIndices = wIndex;\n          weights = Weight;\n        } // if the weight array is shorter than 4 pad with 0s\n\n\n        while (weights.length < 4) {\n          weights.push(0);\n          weightIndices.push(0);\n        }\n\n        for (let i = 0; i < 4; ++i) {\n          faceWeights.push(weights[i]);\n          faceWeightIndices.push(weightIndices[i]);\n        }\n      }\n\n      if (geoInfo.normal) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);\n        faceNormals.push(data[0], data[1], data[2]);\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, i) {\n          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);\n\n          if (faceUVs[i] === undefined) {\n            faceUVs[i] = [];\n          }\n\n          faceUVs[i].push(data[0]);\n          faceUVs[i].push(data[1]);\n        });\n      }\n\n      faceLength++;\n\n      if (endOfFace) {\n        scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);\n        polygonIndex++;\n        faceLength = 0; // reset arrays for the next face\n\n        facePositionIndexes = [];\n        faceNormals = [];\n        faceColors = [];\n        faceUVs = [];\n        faceWeights = [];\n        faceWeightIndices = [];\n      }\n    });\n    return buffers;\n  } // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\n\n  genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {\n    for (let i = 2; i < faceLength; i++) {\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);\n\n      if (geoInfo.skeleton) {\n        buffers.vertexWeights.push(faceWeights[0]);\n        buffers.vertexWeights.push(faceWeights[1]);\n        buffers.vertexWeights.push(faceWeights[2]);\n        buffers.vertexWeights.push(faceWeights[3]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);\n        buffers.vertexWeights.push(faceWeights[i * 4]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 1]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 2]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 3]);\n        buffers.weightsIndices.push(faceWeightIndices[0]);\n        buffers.weightsIndices.push(faceWeightIndices[1]);\n        buffers.weightsIndices.push(faceWeightIndices[2]);\n        buffers.weightsIndices.push(faceWeightIndices[3]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);\n      }\n\n      if (geoInfo.color) {\n        buffers.colors.push(faceColors[0]);\n        buffers.colors.push(faceColors[1]);\n        buffers.colors.push(faceColors[2]);\n        buffers.colors.push(faceColors[(i - 1) * 3]);\n        buffers.colors.push(faceColors[(i - 1) * 3 + 1]);\n        buffers.colors.push(faceColors[(i - 1) * 3 + 2]);\n        buffers.colors.push(faceColors[i * 3]);\n        buffers.colors.push(faceColors[i * 3 + 1]);\n        buffers.colors.push(faceColors[i * 3 + 2]);\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        buffers.materialIndex.push(materialIndex);\n        buffers.materialIndex.push(materialIndex);\n        buffers.materialIndex.push(materialIndex);\n      }\n\n      if (geoInfo.normal) {\n        buffers.normal.push(faceNormals[0]);\n        buffers.normal.push(faceNormals[1]);\n        buffers.normal.push(faceNormals[2]);\n        buffers.normal.push(faceNormals[(i - 1) * 3]);\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);\n        buffers.normal.push(faceNormals[i * 3]);\n        buffers.normal.push(faceNormals[i * 3 + 1]);\n        buffers.normal.push(faceNormals[i * 3 + 2]);\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, j) {\n          if (buffers.uvs[j] === undefined) buffers.uvs[j] = [];\n          buffers.uvs[j].push(faceUVs[j][0]);\n          buffers.uvs[j].push(faceUVs[j][1]);\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);\n          buffers.uvs[j].push(faceUVs[j][i * 2]);\n          buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);\n        });\n      }\n    }\n  }\n\n  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {\n    if (morphTargets.length === 0) return;\n    parentGeo.morphTargetsRelative = true;\n    parentGeo.morphAttributes.position = []; // parentGeo.morphAttributes.normal = []; // not implemented\n\n    const scope = this;\n    morphTargets.forEach(function (morphTarget) {\n      morphTarget.rawTargets.forEach(function (rawTarget) {\n        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];\n\n        if (morphGeoNode !== undefined) {\n          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);\n        }\n      });\n    });\n  } // a morph geometry node is similar to a standard  node, and the node is also contained\n  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n  // and a special attribute Index defining which vertices of the original geometry are affected\n  // Normal and position attributes only have data for the vertices that are affected by the morph\n\n\n  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {\n    const vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];\n    const morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];\n    const indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];\n    const length = parentGeo.attributes.position.count * 3;\n    const morphPositions = new Float32Array(length);\n\n    for (let i = 0; i < indices.length; i++) {\n      const morphIndex = indices[i] * 3;\n      morphPositions[morphIndex] = morphPositionsSparse[i * 3];\n      morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];\n      morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];\n    } // TODO: add morph normal support\n\n\n    const morphGeoInfo = {\n      vertexIndices: vertexIndices,\n      vertexPositions: morphPositions\n    };\n    const morphBuffers = this.genBuffers(morphGeoInfo);\n    const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);\n    positionAttribute.name = name || morphGeoNode.attrName;\n    positionAttribute.applyMatrix4(preTransform);\n    parentGeo.morphAttributes.position.push(positionAttribute);\n  } // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\n\n  parseNormals(NormalNode) {\n    const mappingType = NormalNode.MappingInformationType;\n    const referenceType = NormalNode.ReferenceInformationType;\n    const buffer = NormalNode.Normals.a;\n    let indexBuffer = [];\n\n    if (referenceType === 'IndexToDirect') {\n      if ('NormalIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalIndex.a;\n      } else if ('NormalsIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalsIndex.a;\n      }\n    }\n\n    return {\n      dataSize: 3,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\n\n  parseUVs(UVNode) {\n    const mappingType = UVNode.MappingInformationType;\n    const referenceType = UVNode.ReferenceInformationType;\n    const buffer = UVNode.UV.a;\n    let indexBuffer = [];\n\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = UVNode.UVIndex.a;\n    }\n\n    return {\n      dataSize: 2,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\n\n  parseVertexColors(ColorNode) {\n    const mappingType = ColorNode.MappingInformationType;\n    const referenceType = ColorNode.ReferenceInformationType;\n    const buffer = ColorNode.Colors.a;\n    let indexBuffer = [];\n\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = ColorNode.ColorIndex.a;\n    }\n\n    return {\n      dataSize: 4,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\n\n  parseMaterialIndices(MaterialNode) {\n    const mappingType = MaterialNode.MappingInformationType;\n    const referenceType = MaterialNode.ReferenceInformationType;\n\n    if (mappingType === 'NoMappingInformation') {\n      return {\n        dataSize: 1,\n        buffer: [0],\n        indices: [0],\n        mappingType: 'AllSame',\n        referenceType: referenceType\n      };\n    }\n\n    const materialIndexBuffer = MaterialNode.Materials.a; // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n    // we expect.So we create an intermediate buffer that points to the index in the buffer,\n    // for conforming with the other functions we've written for other data.\n\n    const materialIndices = [];\n\n    for (let i = 0; i < materialIndexBuffer.length; ++i) {\n      materialIndices.push(i);\n    }\n\n    return {\n      dataSize: 1,\n      buffer: materialIndexBuffer,\n      indices: materialIndices,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\n\n  parseNurbsGeometry(geoNode) {\n    if (NURBSCurve === undefined) {\n      console.error('THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');\n      return new BufferGeometry();\n    }\n\n    const order = parseInt(geoNode.Order);\n\n    if (isNaN(order)) {\n      console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id);\n      return new BufferGeometry();\n    }\n\n    const degree = order - 1;\n    const knots = geoNode.KnotVector.a;\n    const controlPoints = [];\n    const pointsValues = geoNode.Points.a;\n\n    for (let i = 0, l = pointsValues.length; i < l; i += 4) {\n      controlPoints.push(new Vector4().fromArray(pointsValues, i));\n    }\n\n    let startKnot, endKnot;\n\n    if (geoNode.Form === 'Closed') {\n      controlPoints.push(controlPoints[0]);\n    } else if (geoNode.Form === 'Periodic') {\n      startKnot = degree;\n      endKnot = knots.length - 1 - startKnot;\n\n      for (let i = 0; i < degree; ++i) {\n        controlPoints.push(controlPoints[i]);\n      }\n    }\n\n    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\n    const points = curve.getPoints(controlPoints.length * 12);\n    return new BufferGeometry().setFromPoints(points);\n  }\n\n} // parse animation data from FBXTree\n\n\nclass AnimationParser {\n  // take raw animation clips and turn them into three.js animation clips\n  parse() {\n    const animationClips = [];\n    const rawClips = this.parseClips();\n\n    if (rawClips !== undefined) {\n      for (const key in rawClips) {\n        const rawClip = rawClips[key];\n        const clip = this.addClip(rawClip);\n        animationClips.push(clip);\n      }\n    }\n\n    return animationClips;\n  }\n\n  parseClips() {\n    // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n    // if this is undefined we can safely assume there are no animations\n    if (fbxTree.Objects.AnimationCurve === undefined) return undefined;\n    const curveNodesMap = this.parseAnimationCurveNodes();\n    this.parseAnimationCurves(curveNodesMap);\n    const layersMap = this.parseAnimationLayers(curveNodesMap);\n    const rawClips = this.parseAnimStacks(layersMap);\n    return rawClips;\n  } // parse nodes in FBXTree.Objects.AnimationCurveNode\n  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n  // and is referenced by an AnimationLayer\n\n\n  parseAnimationCurveNodes() {\n    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\n    const curveNodesMap = new Map();\n\n    for (const nodeID in rawCurveNodes) {\n      const rawCurveNode = rawCurveNodes[nodeID];\n\n      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {\n        const curveNode = {\n          id: rawCurveNode.id,\n          attr: rawCurveNode.attrName,\n          curves: {}\n        };\n        curveNodesMap.set(curveNode.id, curveNode);\n      }\n    }\n\n    return curveNodesMap;\n  } // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n  // axis ( e.g. times and values of x rotation)\n\n\n  parseAnimationCurves(curveNodesMap) {\n    const rawCurves = fbxTree.Objects.AnimationCurve; // TODO: Many values are identical up to roundoff error, but won't be optimised\n    // e.g. position times: [0, 0.4, 0. 8]\n    // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n    // clearly, this should be optimised to\n    // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n    // this shows up in nearly every FBX file, and generally time array is length > 100\n\n    for (const nodeID in rawCurves) {\n      const animationCurve = {\n        id: rawCurves[nodeID].id,\n        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n        values: rawCurves[nodeID].KeyValueFloat.a\n      };\n      const relationships = connections.get(animationCurve.id);\n\n      if (relationships !== undefined) {\n        const animationCurveID = relationships.parents[0].ID;\n        const animationCurveRelationship = relationships.parents[0].relationship;\n\n        if (animationCurveRelationship.match(/X/)) {\n          curveNodesMap.get(animationCurveID).curves['x'] = animationCurve;\n        } else if (animationCurveRelationship.match(/Y/)) {\n          curveNodesMap.get(animationCurveID).curves['y'] = animationCurve;\n        } else if (animationCurveRelationship.match(/Z/)) {\n          curveNodesMap.get(animationCurveID).curves['z'] = animationCurve;\n        } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {\n          curveNodesMap.get(animationCurveID).curves['morph'] = animationCurve;\n        }\n      }\n    }\n  } // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n  // to various AnimationCurveNodes and is referenced by an AnimationStack node\n  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\n\n  parseAnimationLayers(curveNodesMap) {\n    const rawLayers = fbxTree.Objects.AnimationLayer;\n    const layersMap = new Map();\n\n    for (const nodeID in rawLayers) {\n      const layerCurveNodes = [];\n      const connection = connections.get(parseInt(nodeID));\n\n      if (connection !== undefined) {\n        // all the animationCurveNodes used in the layer\n        const children = connection.children;\n        children.forEach(function (child, i) {\n          if (curveNodesMap.has(child.ID)) {\n            const curveNode = curveNodesMap.get(child.ID); // check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\n            if (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {\n              if (layerCurveNodes[i] === undefined) {\n                const modelID = connections.get(child.ID).parents.filter(function (parent) {\n                  return parent.relationship !== undefined;\n                })[0].ID;\n\n                if (modelID !== undefined) {\n                  const rawModel = fbxTree.Objects.Model[modelID.toString()];\n\n                  if (rawModel === undefined) {\n                    console.warn('THREE.FBXLoader: Encountered a unused curve.', child);\n                    return;\n                  }\n\n                  const node = {\n                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\n                    ID: rawModel.id,\n                    initialPosition: [0, 0, 0],\n                    initialRotation: [0, 0, 0],\n                    initialScale: [1, 1, 1]\n                  };\n                  sceneGraph.traverse(function (child) {\n                    if (child.ID === rawModel.id) {\n                      node.transform = child.matrix;\n                      if (child.userData.transformData) node.eulerOrder = child.userData.transformData.eulerOrder;\n                    }\n                  });\n                  if (!node.transform) node.transform = new Matrix4(); // if the animated model is pre rotated, we'll have to apply the pre rotations to every\n                  // animation value as well\n\n                  if ('PreRotation' in rawModel) node.preRotation = rawModel.PreRotation.value;\n                  if ('PostRotation' in rawModel) node.postRotation = rawModel.PostRotation.value;\n                  layerCurveNodes[i] = node;\n                }\n              }\n\n              if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode;\n            } else if (curveNode.curves.morph !== undefined) {\n              if (layerCurveNodes[i] === undefined) {\n                const deformerID = connections.get(child.ID).parents.filter(function (parent) {\n                  return parent.relationship !== undefined;\n                })[0].ID;\n                const morpherID = connections.get(deformerID).parents[0].ID;\n                const geoID = connections.get(morpherID).parents[0].ID; // assuming geometry is not used in more than one model\n\n                const modelID = connections.get(geoID).parents[0].ID;\n                const rawModel = fbxTree.Objects.Model[modelID];\n                const node = {\n                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\n                  morphName: fbxTree.Objects.Deformer[deformerID].attrName\n                };\n                layerCurveNodes[i] = node;\n              }\n\n              layerCurveNodes[i][curveNode.attr] = curveNode;\n            }\n          }\n        });\n        layersMap.set(parseInt(nodeID), layerCurveNodes);\n      }\n    }\n\n    return layersMap;\n  } // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n  // hierarchy. Each Stack node will be used to create a AnimationClip\n\n\n  parseAnimStacks(layersMap) {\n    const rawStacks = fbxTree.Objects.AnimationStack; // connect the stacks (clips) up to the layers\n\n    const rawClips = {};\n\n    for (const nodeID in rawStacks) {\n      const children = connections.get(parseInt(nodeID)).children;\n\n      if (children.length > 1) {\n        // it seems like stacks will always be associated with a single layer. But just in case there are files\n        // where there are multiple layers per stack, we'll display a warning\n        console.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.');\n      }\n\n      const layer = layersMap.get(children[0].ID);\n      rawClips[nodeID] = {\n        name: rawStacks[nodeID].attrName,\n        layer: layer\n      };\n    }\n\n    return rawClips;\n  }\n\n  addClip(rawClip) {\n    let tracks = [];\n    const scope = this;\n    rawClip.layer.forEach(function (rawTracks) {\n      tracks = tracks.concat(scope.generateTracks(rawTracks));\n    });\n    return new AnimationClip(rawClip.name, -1, tracks);\n  }\n\n  generateTracks(rawTracks) {\n    const tracks = [];\n    let initialPosition = new Vector3();\n    let initialRotation = new Quaternion();\n    let initialScale = new Vector3();\n    if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);\n    initialPosition = initialPosition.toArray();\n    initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();\n    initialScale = initialScale.toArray();\n\n    if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\n      const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position');\n      if (positionTrack !== undefined) tracks.push(positionTrack);\n    }\n\n    if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\n      const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);\n      if (rotationTrack !== undefined) tracks.push(rotationTrack);\n    }\n\n    if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\n      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale');\n      if (scaleTrack !== undefined) tracks.push(scaleTrack);\n    }\n\n    if (rawTracks.DeformPercent !== undefined) {\n      const morphTrack = this.generateMorphTrack(rawTracks);\n      if (morphTrack !== undefined) tracks.push(morphTrack);\n    }\n\n    return tracks;\n  }\n\n  generateVectorTrack(modelName, curves, initialValue, type) {\n    const times = this.getTimesForAllAxes(curves);\n    const values = this.getKeyframeTrackValues(times, curves, initialValue);\n    return new VectorKeyframeTrack(modelName + '.' + type, times, values);\n  }\n\n  generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {\n    if (curves.x !== undefined) {\n      this.interpolateRotations(curves.x);\n      curves.x.values = curves.x.values.map(MathUtils.degToRad);\n    }\n\n    if (curves.y !== undefined) {\n      this.interpolateRotations(curves.y);\n      curves.y.values = curves.y.values.map(MathUtils.degToRad);\n    }\n\n    if (curves.z !== undefined) {\n      this.interpolateRotations(curves.z);\n      curves.z.values = curves.z.values.map(MathUtils.degToRad);\n    }\n\n    const times = this.getTimesForAllAxes(curves);\n    const values = this.getKeyframeTrackValues(times, curves, initialValue);\n\n    if (preRotation !== undefined) {\n      preRotation = preRotation.map(MathUtils.degToRad);\n      preRotation.push(eulerOrder);\n      preRotation = new Euler().fromArray(preRotation);\n      preRotation = new Quaternion().setFromEuler(preRotation);\n    }\n\n    if (postRotation !== undefined) {\n      postRotation = postRotation.map(MathUtils.degToRad);\n      postRotation.push(eulerOrder);\n      postRotation = new Euler().fromArray(postRotation);\n      postRotation = new Quaternion().setFromEuler(postRotation).invert();\n    }\n\n    const quaternion = new Quaternion();\n    const euler = new Euler();\n    const quaternionValues = [];\n\n    for (let i = 0; i < values.length; i += 3) {\n      euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);\n      quaternion.setFromEuler(euler);\n      if (preRotation !== undefined) quaternion.premultiply(preRotation);\n      if (postRotation !== undefined) quaternion.multiply(postRotation);\n      quaternion.toArray(quaternionValues, i / 3 * 4);\n    }\n\n    return new QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues);\n  }\n\n  generateMorphTrack(rawTracks) {\n    const curves = rawTracks.DeformPercent.curves.morph;\n    const values = curves.values.map(function (val) {\n      return val / 100;\n    });\n    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];\n    return new NumberKeyframeTrack(rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values);\n  } // For all animated objects, times are defined separately for each axis\n  // Here we'll combine the times into one sorted array without duplicates\n\n\n  getTimesForAllAxes(curves) {\n    let times = []; // first join together the times for each axis, if defined\n\n    if (curves.x !== undefined) times = times.concat(curves.x.times);\n    if (curves.y !== undefined) times = times.concat(curves.y.times);\n    if (curves.z !== undefined) times = times.concat(curves.z.times); // then sort them\n\n    times = times.sort(function (a, b) {\n      return a - b;\n    }); // and remove duplicates\n\n    if (times.length > 1) {\n      let targetIndex = 1;\n      let lastValue = times[0];\n\n      for (let i = 1; i < times.length; i++) {\n        const currentValue = times[i];\n\n        if (currentValue !== lastValue) {\n          times[targetIndex] = currentValue;\n          lastValue = currentValue;\n          targetIndex++;\n        }\n      }\n\n      times = times.slice(0, targetIndex);\n    }\n\n    return times;\n  }\n\n  getKeyframeTrackValues(times, curves, initialValue) {\n    const prevValue = initialValue;\n    const values = [];\n    let xIndex = -1;\n    let yIndex = -1;\n    let zIndex = -1;\n    times.forEach(function (time) {\n      if (curves.x) xIndex = curves.x.times.indexOf(time);\n      if (curves.y) yIndex = curves.y.times.indexOf(time);\n      if (curves.z) zIndex = curves.z.times.indexOf(time); // if there is an x value defined for this frame, use that\n\n      if (xIndex !== -1) {\n        const xValue = curves.x.values[xIndex];\n        values.push(xValue);\n        prevValue[0] = xValue;\n      } else {\n        // otherwise use the x value from the previous frame\n        values.push(prevValue[0]);\n      }\n\n      if (yIndex !== -1) {\n        const yValue = curves.y.values[yIndex];\n        values.push(yValue);\n        prevValue[1] = yValue;\n      } else {\n        values.push(prevValue[1]);\n      }\n\n      if (zIndex !== -1) {\n        const zValue = curves.z.values[zIndex];\n        values.push(zValue);\n        prevValue[2] = zValue;\n      } else {\n        values.push(prevValue[2]);\n      }\n    });\n    return values;\n  } // Rotations are defined as Euler angles which can have values  of any size\n  // These will be converted to quaternions which don't support values greater than\n  // PI, so we'll interpolate large rotations\n\n\n  interpolateRotations(curve) {\n    for (let i = 1; i < curve.values.length; i++) {\n      const initialValue = curve.values[i - 1];\n      const valuesSpan = curve.values[i] - initialValue;\n      const absoluteSpan = Math.abs(valuesSpan);\n\n      if (absoluteSpan >= 180) {\n        const numSubIntervals = absoluteSpan / 180;\n        const step = valuesSpan / numSubIntervals;\n        let nextValue = initialValue + step;\n        const initialTime = curve.times[i - 1];\n        const timeSpan = curve.times[i] - initialTime;\n        const interval = timeSpan / numSubIntervals;\n        let nextTime = initialTime + interval;\n        const interpolatedTimes = [];\n        const interpolatedValues = [];\n\n        while (nextTime < curve.times[i]) {\n          interpolatedTimes.push(nextTime);\n          nextTime += interval;\n          interpolatedValues.push(nextValue);\n          nextValue += step;\n        }\n\n        curve.times = inject(curve.times, i, interpolatedTimes);\n        curve.values = inject(curve.values, i, interpolatedValues);\n      }\n    }\n  }\n\n} // parse an FBX file in ASCII format\n\n\nclass TextParser {\n  getPrevNode() {\n    return this.nodeStack[this.currentIndent - 2];\n  }\n\n  getCurrentNode() {\n    return this.nodeStack[this.currentIndent - 1];\n  }\n\n  getCurrentProp() {\n    return this.currentProp;\n  }\n\n  pushStack(node) {\n    this.nodeStack.push(node);\n    this.currentIndent += 1;\n  }\n\n  popStack() {\n    this.nodeStack.pop();\n    this.currentIndent -= 1;\n  }\n\n  setCurrentProp(val, name) {\n    this.currentProp = val;\n    this.currentPropName = name;\n  }\n\n  parse(text) {\n    this.currentIndent = 0;\n    this.allNodes = new FBXTree();\n    this.nodeStack = [];\n    this.currentProp = [];\n    this.currentPropName = '';\n    const scope = this;\n    const split = text.split(/[\\r\\n]+/);\n    split.forEach(function (line, i) {\n      const matchComment = line.match(/^[\\s\\t]*;/);\n      const matchEmpty = line.match(/^[\\s\\t]*$/);\n      if (matchComment || matchEmpty) return;\n      const matchBeginning = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '');\n      const matchProperty = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)');\n      const matchEnd = line.match('^\\\\t{' + (scope.currentIndent - 1) + '}}');\n\n      if (matchBeginning) {\n        scope.parseNodeBegin(line, matchBeginning);\n      } else if (matchProperty) {\n        scope.parseNodeProperty(line, matchProperty, split[++i]);\n      } else if (matchEnd) {\n        scope.popStack();\n      } else if (line.match(/^[^\\s\\t}]/)) {\n        // large arrays are split over multiple lines terminated with a ',' character\n        // if this is encountered the line needs to be joined to the previous line\n        scope.parseNodePropertyContinued(line);\n      }\n    });\n    return this.allNodes;\n  }\n\n  parseNodeBegin(line, property) {\n    const nodeName = property[1].trim().replace(/^\"/, '').replace(/\"$/, '');\n    const nodeAttrs = property[2].split(',').map(function (attr) {\n      return attr.trim().replace(/^\"/, '').replace(/\"$/, '');\n    });\n    const node = {\n      name: nodeName\n    };\n    const attrs = this.parseNodeAttr(nodeAttrs);\n    const currentNode = this.getCurrentNode(); // a top node\n\n    if (this.currentIndent === 0) {\n      this.allNodes.add(nodeName, node);\n    } else {\n      // a subnode\n      // if the subnode already exists, append it\n      if (nodeName in currentNode) {\n        // special case Pose needs PoseNodes as an array\n        if (nodeName === 'PoseNode') {\n          currentNode.PoseNode.push(node);\n        } else if (currentNode[nodeName].id !== undefined) {\n          currentNode[nodeName] = {};\n          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];\n        }\n\n        if (attrs.id !== '') currentNode[nodeName][attrs.id] = node;\n      } else if (typeof attrs.id === 'number') {\n        currentNode[nodeName] = {};\n        currentNode[nodeName][attrs.id] = node;\n      } else if (nodeName !== 'Properties70') {\n        if (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;\n      }\n    }\n\n    if (typeof attrs.id === 'number') node.id = attrs.id;\n    if (attrs.name !== '') node.attrName = attrs.name;\n    if (attrs.type !== '') node.attrType = attrs.type;\n    this.pushStack(node);\n  }\n\n  parseNodeAttr(attrs) {\n    let id = attrs[0];\n\n    if (attrs[0] !== '') {\n      id = parseInt(attrs[0]);\n\n      if (isNaN(id)) {\n        id = attrs[0];\n      }\n    }\n\n    let name = '',\n        type = '';\n\n    if (attrs.length > 1) {\n      name = attrs[1].replace(/^(\\w+)::/, '');\n      type = attrs[2];\n    }\n\n    return {\n      id: id,\n      name: name,\n      type: type\n    };\n  }\n\n  parseNodeProperty(line, property, contentLine) {\n    let propName = property[1].replace(/^\"/, '').replace(/\"$/, '').trim();\n    let propValue = property[2].replace(/^\"/, '').replace(/\"$/, '').trim(); // for special case: base64 image data follows \"Content: ,\" line\n    //\tContent: ,\n    //\t \"/9j/4RDaRXhpZgAATU0A...\"\n\n    if (propName === 'Content' && propValue === ',') {\n      propValue = contentLine.replace(/\"/g, '').replace(/,$/, '').trim();\n    }\n\n    const currentNode = this.getCurrentNode();\n    const parentName = currentNode.name;\n\n    if (parentName === 'Properties70') {\n      this.parseNodeSpecialProperty(line, propName, propValue);\n      return;\n    } // Connections\n\n\n    if (propName === 'C') {\n      const connProps = propValue.split(',').slice(1);\n      const from = parseInt(connProps[0]);\n      const to = parseInt(connProps[1]);\n      let rest = propValue.split(',').slice(3);\n      rest = rest.map(function (elem) {\n        return elem.trim().replace(/^\"/, '');\n      });\n      propName = 'connections';\n      propValue = [from, to];\n      append(propValue, rest);\n\n      if (currentNode[propName] === undefined) {\n        currentNode[propName] = [];\n      }\n    } // Node\n\n\n    if (propName === 'Node') currentNode.id = propValue; // connections\n\n    if (propName in currentNode && Array.isArray(currentNode[propName])) {\n      currentNode[propName].push(propValue);\n    } else {\n      if (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;\n    }\n\n    this.setCurrentProp(currentNode, propName); // convert string to array, unless it ends in ',' in which case more will be added to it\n\n    if (propName === 'a' && propValue.slice(-1) !== ',') {\n      currentNode.a = parseNumberArray(propValue);\n    }\n  }\n\n  parseNodePropertyContinued(line) {\n    const currentNode = this.getCurrentNode();\n    currentNode.a += line; // if the line doesn't end in ',' we have reached the end of the property value\n    // so convert the string to an array\n\n    if (line.slice(-1) !== ',') {\n      currentNode.a = parseNumberArray(currentNode.a);\n    }\n  } // parse \"Property70\"\n\n\n  parseNodeSpecialProperty(line, propName, propValue) {\n    // split this\n    // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n    // into array like below\n    // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n    const props = propValue.split('\",').map(function (prop) {\n      return prop.trim().replace(/^\\\"/, '').replace(/\\s/, '_');\n    });\n    const innerPropName = props[0];\n    const innerPropType1 = props[1];\n    const innerPropType2 = props[2];\n    const innerPropFlag = props[3];\n    let innerPropValue = props[4]; // cast values where needed, otherwise leave as strings\n\n    switch (innerPropType1) {\n      case 'int':\n      case 'enum':\n      case 'bool':\n      case 'ULongLong':\n      case 'double':\n      case 'Number':\n      case 'FieldOfView':\n        innerPropValue = parseFloat(innerPropValue);\n        break;\n\n      case 'Color':\n      case 'ColorRGB':\n      case 'Vector3D':\n      case 'Lcl_Translation':\n      case 'Lcl_Rotation':\n      case 'Lcl_Scaling':\n        innerPropValue = parseNumberArray(innerPropValue);\n        break;\n    } // CAUTION: these props must append to parent's parent\n\n\n    this.getPrevNode()[innerPropName] = {\n      type: innerPropType1,\n      type2: innerPropType2,\n      flag: innerPropFlag,\n      value: innerPropValue\n    };\n    this.setCurrentProp(this.getPrevNode(), innerPropName);\n  }\n\n} // Parse an FBX file in Binary format\n\n\nclass BinaryParser {\n  parse(buffer) {\n    const reader = new BinaryReader(buffer);\n    reader.skip(23); // skip magic 23 bytes\n\n    const version = reader.getUint32();\n\n    if (version < 6400) {\n      throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + version);\n    }\n\n    const allNodes = new FBXTree();\n\n    while (!this.endOfContent(reader)) {\n      const node = this.parseNode(reader, version);\n      if (node !== null) allNodes.add(node.name, node);\n    }\n\n    return allNodes;\n  } // Check if reader has reached the end of content.\n\n\n  endOfContent(reader) {\n    // footer size: 160bytes + 16-byte alignment padding\n    // - 16bytes: magic\n    // - padding til 16-byte alignment (at least 1byte?)\n    //\t(seems like some exporters embed fixed 15 or 16bytes?)\n    // - 4bytes: magic\n    // - 4bytes: version\n    // - 120bytes: zero\n    // - 16bytes: magic\n    if (reader.size() % 16 === 0) {\n      return (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();\n    } else {\n      return reader.getOffset() + 160 + 16 >= reader.size();\n    }\n  } // recursively parse nodes until the end of the file is reached\n\n\n  parseNode(reader, version) {\n    const node = {}; // The first three data sizes depends on version.\n\n    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\n    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();\n    version >= 7500 ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used\n\n    const nameLen = reader.getUint8();\n    const name = reader.getString(nameLen); // Regards this node as NULL-record if endOffset is zero\n\n    if (endOffset === 0) return null;\n    const propertyList = [];\n\n    for (let i = 0; i < numProperties; i++) {\n      propertyList.push(this.parseProperty(reader));\n    } // Regards the first three elements in propertyList as id, attrName, and attrType\n\n\n    const id = propertyList.length > 0 ? propertyList[0] : '';\n    const attrName = propertyList.length > 1 ? propertyList[1] : '';\n    const attrType = propertyList.length > 2 ? propertyList[2] : ''; // check if this node represents just a single property\n    // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\n    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;\n\n    while (endOffset > reader.getOffset()) {\n      const subNode = this.parseNode(reader, version);\n      if (subNode !== null) this.parseSubNode(name, node, subNode);\n    }\n\n    node.propertyList = propertyList; // raw property list used by parent\n\n    if (typeof id === 'number') node.id = id;\n    if (attrName !== '') node.attrName = attrName;\n    if (attrType !== '') node.attrType = attrType;\n    if (name !== '') node.name = name;\n    return node;\n  }\n\n  parseSubNode(name, node, subNode) {\n    // special case: child node is single property\n    if (subNode.singleProperty === true) {\n      const value = subNode.propertyList[0];\n\n      if (Array.isArray(value)) {\n        node[subNode.name] = subNode;\n        subNode.a = value;\n      } else {\n        node[subNode.name] = value;\n      }\n    } else if (name === 'Connections' && subNode.name === 'C') {\n      const array = [];\n      subNode.propertyList.forEach(function (property, i) {\n        // first Connection is FBX type (OO, OP, etc.). We'll discard these\n        if (i !== 0) array.push(property);\n      });\n\n      if (node.connections === undefined) {\n        node.connections = [];\n      }\n\n      node.connections.push(array);\n    } else if (subNode.name === 'Properties70') {\n      const keys = Object.keys(subNode);\n      keys.forEach(function (key) {\n        node[key] = subNode[key];\n      });\n    } else if (name === 'Properties70' && subNode.name === 'P') {\n      let innerPropName = subNode.propertyList[0];\n      let innerPropType1 = subNode.propertyList[1];\n      const innerPropType2 = subNode.propertyList[2];\n      const innerPropFlag = subNode.propertyList[3];\n      let innerPropValue;\n      if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');\n      if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');\n\n      if (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {\n        innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];\n      } else {\n        innerPropValue = subNode.propertyList[4];\n      } // this will be copied to parent, see above\n\n\n      node[innerPropName] = {\n        type: innerPropType1,\n        type2: innerPropType2,\n        flag: innerPropFlag,\n        value: innerPropValue\n      };\n    } else if (node[subNode.name] === undefined) {\n      if (typeof subNode.id === 'number') {\n        node[subNode.name] = {};\n        node[subNode.name][subNode.id] = subNode;\n      } else {\n        node[subNode.name] = subNode;\n      }\n    } else {\n      if (subNode.name === 'PoseNode') {\n        if (!Array.isArray(node[subNode.name])) {\n          node[subNode.name] = [node[subNode.name]];\n        }\n\n        node[subNode.name].push(subNode);\n      } else if (node[subNode.name][subNode.id] === undefined) {\n        node[subNode.name][subNode.id] = subNode;\n      }\n    }\n  }\n\n  parseProperty(reader) {\n    const type = reader.getString(1);\n    let length;\n\n    switch (type) {\n      case 'C':\n        return reader.getBoolean();\n\n      case 'D':\n        return reader.getFloat64();\n\n      case 'F':\n        return reader.getFloat32();\n\n      case 'I':\n        return reader.getInt32();\n\n      case 'L':\n        return reader.getInt64();\n\n      case 'R':\n        length = reader.getUint32();\n        return reader.getArrayBuffer(length);\n\n      case 'S':\n        length = reader.getUint32();\n        return reader.getString(length);\n\n      case 'Y':\n        return reader.getInt16();\n\n      case 'b':\n      case 'c':\n      case 'd':\n      case 'f':\n      case 'i':\n      case 'l':\n        const arrayLength = reader.getUint32();\n        const encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\n        const compressedLength = reader.getUint32();\n\n        if (encoding === 0) {\n          switch (type) {\n            case 'b':\n            case 'c':\n              return reader.getBooleanArray(arrayLength);\n\n            case 'd':\n              return reader.getFloat64Array(arrayLength);\n\n            case 'f':\n              return reader.getFloat32Array(arrayLength);\n\n            case 'i':\n              return reader.getInt32Array(arrayLength);\n\n            case 'l':\n              return reader.getInt64Array(arrayLength);\n          }\n        }\n\n        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef\n\n        const reader2 = new BinaryReader(data.buffer);\n\n        switch (type) {\n          case 'b':\n          case 'c':\n            return reader2.getBooleanArray(arrayLength);\n\n          case 'd':\n            return reader2.getFloat64Array(arrayLength);\n\n          case 'f':\n            return reader2.getFloat32Array(arrayLength);\n\n          case 'i':\n            return reader2.getInt32Array(arrayLength);\n\n          case 'l':\n            return reader2.getInt64Array(arrayLength);\n        }\n\n      default:\n        throw new Error('THREE.FBXLoader: Unknown property type ' + type);\n    }\n  }\n\n}\n\nclass BinaryReader {\n  constructor(buffer, littleEndian) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true;\n  }\n\n  getOffset() {\n    return this.offset;\n  }\n\n  size() {\n    return this.dv.buffer.byteLength;\n  }\n\n  skip(length) {\n    this.offset += length;\n  } // seems like true/false representation depends on exporter.\n  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n  // then sees LSB.\n\n\n  getBoolean() {\n    return (this.getUint8() & 1) === 1;\n  }\n\n  getBooleanArray(size) {\n    const a = [];\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getBoolean());\n    }\n\n    return a;\n  }\n\n  getUint8() {\n    const value = this.dv.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n\n  getInt16() {\n    const value = this.dv.getInt16(this.offset, this.littleEndian);\n    this.offset += 2;\n    return value;\n  }\n\n  getInt32() {\n    const value = this.dv.getInt32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n\n  getInt32Array(size) {\n    const a = [];\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt32());\n    }\n\n    return a;\n  }\n\n  getUint32() {\n    const value = this.dv.getUint32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  } // JavaScript doesn't support 64-bit integer so calculate this here\n  // 1 << 32 will return 1 so using multiply operation instead here.\n  // There's a possibility that this method returns wrong value if the value\n  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n  // TODO: safely handle 64-bit integer\n\n\n  getInt64() {\n    let low, high;\n\n    if (this.littleEndian) {\n      low = this.getUint32();\n      high = this.getUint32();\n    } else {\n      high = this.getUint32();\n      low = this.getUint32();\n    } // calculate negative value\n\n\n    if (high & 0x80000000) {\n      high = ~high & 0xffffffff;\n      low = ~low & 0xffffffff;\n      if (low === 0xffffffff) high = high + 1 & 0xffffffff;\n      low = low + 1 & 0xffffffff;\n      return -(high * 0x100000000 + low);\n    }\n\n    return high * 0x100000000 + low;\n  }\n\n  getInt64Array(size) {\n    const a = [];\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt64());\n    }\n\n    return a;\n  } // Note: see getInt64() comment\n\n\n  getUint64() {\n    let low, high;\n\n    if (this.littleEndian) {\n      low = this.getUint32();\n      high = this.getUint32();\n    } else {\n      high = this.getUint32();\n      low = this.getUint32();\n    }\n\n    return high * 0x100000000 + low;\n  }\n\n  getFloat32() {\n    const value = this.dv.getFloat32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n\n  getFloat32Array(size) {\n    const a = [];\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat32());\n    }\n\n    return a;\n  }\n\n  getFloat64() {\n    const value = this.dv.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n\n  getFloat64Array(size) {\n    const a = [];\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat64());\n    }\n\n    return a;\n  }\n\n  getArrayBuffer(size) {\n    const value = this.dv.buffer.slice(this.offset, this.offset + size);\n    this.offset += size;\n    return value;\n  }\n\n  getString(size) {\n    // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n    let a = [];\n\n    for (let i = 0; i < size; i++) {\n      a[i] = this.getUint8();\n    }\n\n    const nullByte = a.indexOf(0);\n    if (nullByte >= 0) a = a.slice(0, nullByte);\n    return LoaderUtils.decodeText(new Uint8Array(a));\n  }\n\n} // FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n// and BinaryParser( FBX Binary format)\n\n\nclass FBXTree {\n  add(key, val) {\n    this[key] = val;\n  }\n\n} // ************** UTILITY FUNCTIONS **************\n\n\nfunction isFbxFormatBinary(buffer) {\n  const CORRECT = 'Kaydara\\u0020FBX\\u0020Binary\\u0020\\u0020\\0';\n  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\n}\n\nfunction isFbxFormatASCII(text) {\n  const CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\'];\n  let cursor = 0;\n\n  function read(offset) {\n    const result = text[offset - 1];\n    text = text.slice(cursor + offset);\n    cursor++;\n    return result;\n  }\n\n  for (let i = 0; i < CORRECT.length; ++i) {\n    const num = read(1);\n\n    if (num === CORRECT[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getFbxVersion(text) {\n  const versionRegExp = /FBXVersion: (\\d+)/;\n  const match = text.match(versionRegExp);\n\n  if (match) {\n    const version = parseInt(match[1]);\n    return version;\n  }\n\n  throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.');\n} // Converts FBX ticks into real time seconds.\n\n\nfunction convertFBXTimeToSeconds(time) {\n  return time / 46186158000;\n}\n\nconst dataArray = []; // extracts the data from the correct position in the FBX array based on indexing type\n\nfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n  let index;\n\n  switch (infoObject.mappingType) {\n    case 'ByPolygonVertex':\n      index = polygonVertexIndex;\n      break;\n\n    case 'ByPolygon':\n      index = polygonIndex;\n      break;\n\n    case 'ByVertice':\n      index = vertexIndex;\n      break;\n\n    case 'AllSame':\n      index = infoObject.indices[0];\n      break;\n\n    default:\n      console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);\n  }\n\n  if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];\n  const from = index * infoObject.dataSize;\n  const to = from + infoObject.dataSize;\n  return slice(dataArray, infoObject.buffer, from, to);\n}\n\nconst tempEuler = new Euler();\nconst tempVec = new Vector3(); // generate transformation from FBX transform data\n// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\n\nfunction generateTransform(transformData) {\n  const lTranslationM = new Matrix4();\n  const lPreRotationM = new Matrix4();\n  const lRotationM = new Matrix4();\n  const lPostRotationM = new Matrix4();\n  const lScalingM = new Matrix4();\n  const lScalingPivotM = new Matrix4();\n  const lScalingOffsetM = new Matrix4();\n  const lRotationOffsetM = new Matrix4();\n  const lRotationPivotM = new Matrix4();\n  const lParentGX = new Matrix4();\n  const lParentLX = new Matrix4();\n  const lGlobalT = new Matrix4();\n  const inheritType = transformData.inheritType ? transformData.inheritType : 0;\n  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation));\n\n  if (transformData.preRotation) {\n    const array = transformData.preRotation.map(MathUtils.degToRad);\n    array.push(transformData.eulerOrder);\n    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\n  }\n\n  if (transformData.rotation) {\n    const array = transformData.rotation.map(MathUtils.degToRad);\n    array.push(transformData.eulerOrder);\n    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\n  }\n\n  if (transformData.postRotation) {\n    const array = transformData.postRotation.map(MathUtils.degToRad);\n    array.push(transformData.eulerOrder);\n    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\n    lPostRotationM.invert();\n  }\n\n  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale)); // Pivots and offsets\n\n  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));\n  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));\n  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));\n  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot)); // parent transform\n\n  if (transformData.parentMatrixWorld) {\n    lParentLX.copy(transformData.parentMatrix);\n    lParentGX.copy(transformData.parentMatrixWorld);\n  }\n\n  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM); // Global Rotation\n\n  const lParentGRM = new Matrix4();\n  lParentGRM.extractRotation(lParentGX); // Global Shear*Scaling\n\n  const lParentTM = new Matrix4();\n  lParentTM.copyPosition(lParentGX);\n  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);\n  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);\n  const lLSM = lScalingM;\n  const lGlobalRS = new Matrix4();\n\n  if (inheritType === 0) {\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);\n  } else if (inheritType === 1) {\n    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);\n  } else {\n    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX));\n    const lParentLSM_inv = lParentLSM.clone().invert();\n    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);\n  }\n\n  const lRotationPivotM_inv = lRotationPivotM.clone().invert();\n  const lScalingPivotM_inv = lScalingPivotM.clone().invert(); // Calculate the local transform matrix\n\n  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);\n  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);\n  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);\n  lGlobalT.copyPosition(lGlobalTranslation);\n  lTransform = lGlobalT.clone().multiply(lGlobalRS); // from global to local\n\n  lTransform.premultiply(lParentGX.invert());\n  return lTransform;\n} // Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n\n\nfunction getEulerOrder(order) {\n  order = order || 0;\n  const enums = ['ZYX', // -> XYZ extrinsic\n  'YZX', // -> XZY extrinsic\n  'XZY', // -> YZX extrinsic\n  'ZXY', // -> YXZ extrinsic\n  'YXZ', // -> ZXY extrinsic\n  'XYZ' // -> ZYX extrinsic\n  //'SphericXYZ', // not possible to support\n  ];\n\n  if (order === 6) {\n    console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');\n    return enums[0];\n  }\n\n  return enums[order];\n} // Parses comma separated list of numbers and returns them an array.\n// Used internally by the TextParser\n\n\nfunction parseNumberArray(value) {\n  const array = value.split(',').map(function (val) {\n    return parseFloat(val);\n  });\n  return array;\n}\n\nfunction convertArrayBufferToString(buffer, from, to) {\n  if (from === undefined) from = 0;\n  if (to === undefined) to = buffer.byteLength;\n  return LoaderUtils.decodeText(new Uint8Array(buffer, from, to));\n}\n\nfunction append(a, b) {\n  for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n    a[j] = b[i];\n  }\n}\n\nfunction slice(a, b, from, to) {\n  for (let i = from, j = 0; i < to; i++, j++) {\n    a[j] = b[i];\n  }\n\n  return a;\n} // inject array a2 into array a1 at index\n\n\nfunction inject(a1, index, a2) {\n  return a1.slice(0, index).concat(a2).concat(a1.slice(index));\n}\n\nexport { FBXLoader };\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Loader, FileLoader, ShapePath } from 'three';\n\nclass FontLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, response => {\n      if (typeof response !== 'string') throw new Error('unsupported data type');\n      const json = JSON.parse(response);\n      const font = this.parse(json);\n      if (onLoad) onLoad(font);\n    }, onProgress, onError);\n  }\n\n  parse(json) {\n    return new Font(json);\n  }\n\n}\nclass Font {\n  constructor(data) {\n    _defineProperty(this, \"data\", void 0);\n\n    this.data = data;\n  }\n\n  generateShapes(text, size = 100, _options) {\n    const shapes = [];\n    const options = {\n      letterSpacing: 0,\n      lineHeight: 1,\n      ..._options\n    };\n    const paths = createPaths(text, size, this.data, options);\n\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n    }\n\n    return shapes;\n  }\n\n}\n\n_defineProperty(Font, \"isFont\", void 0);\n\n_defineProperty(Font, \"type\", void 0);\n\nfunction createPaths(text, size, data, options) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0,\n      offsetY = 0;\n\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n\n    if (char === '\\n') {\n      offsetX = 0;\n      offsetY -= line_height * options.lineHeight;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing;\n        paths.push(ret.path);\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs['?'];\n\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.');\n    return;\n  }\n\n  const path = new ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\n\n    for (let i = 0, l = outline.length; i < l;) {\n      const action = outline[i++];\n\n      switch (action) {\n        case 'm':\n          // moveTo\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n\n        case 'l':\n          // lineTo\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n\n        case 'q':\n          // quadraticCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n\n        case 'b':\n          // bezierCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n\n  return {\n    offsetX: glyph.ha * scale,\n    path\n  };\n}\n\nexport { Font, FontLoader };\n", "import { Vector3, Quaternion, FileLoader, LoaderUtils, Matrix4, Bone, BufferGeometry, Float32BufferAttribute, Uint16BufferAttribute, MeshPhongMaterial, FrontSide, Vector2, SkinnedMesh, Mesh, Skeleton, AnimationClip, AnimationMixer, Loader, TextureLoader } from 'three';\n\nvar XLoader = function () {\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function');\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (let i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if ('value' in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  var XboneInf = function XboneInf() {\n    classCallCheck(this, XboneInf);\n    this.boneName = '';\n    this.BoneIndex = 0;\n    this.Indeces = [];\n    this.Weights = [];\n    this.initMatrix = null;\n    this.OffsetMatrix = null;\n  };\n\n  var XAnimationInfo = function XAnimationInfo() {\n    classCallCheck(this, XAnimationInfo);\n    this.animeName = '';\n    this.boneName = '';\n    this.targetBone = null;\n    this.keyType = 4;\n    this.frameStartLv = 0;\n    this.keyFrames = [];\n    this.InverseMx = null;\n  };\n\n  var XAnimationObj = function () {\n    function XAnimationObj(_flags) {\n      classCallCheck(this, XAnimationObj);\n      this.fps = 30;\n      this.name = 'xanimation';\n      this.length = 0;\n      this.hierarchy = [];\n      this.putFlags = _flags;\n\n      if (this.putFlags.putPos === undefined) {\n        this.putFlags.putPos = true;\n      }\n\n      if (this.putFlags.putRot === undefined) {\n        this.putFlags.putRot = true;\n      }\n\n      if (this.putFlags.putScl === undefined) {\n        this.putFlags.putScl = true;\n      }\n    }\n\n    createClass(XAnimationObj, [{\n      key: 'make',\n      value: function make(XAnimationInfoArray) {\n        for (let i = 0; i < XAnimationInfoArray.length; i++) {\n          this.hierarchy.push(this.makeBonekeys(XAnimationInfoArray[i]));\n        }\n\n        this.length = this.hierarchy[0].keys[this.hierarchy[0].keys.length - 1].time;\n      }\n    }, {\n      key: 'clone',\n      value: function clone() {\n        return Object.assign({}, this);\n      }\n    }, {\n      key: 'makeBonekeys',\n      value: function makeBonekeys(XAnimationInfo) {\n        var refObj = {};\n        refObj.name = XAnimationInfo.boneName;\n        refObj.parent = '';\n        refObj.keys = this.keyFrameRefactor(XAnimationInfo);\n\n        refObj.copy = function () {\n          return Object.assign({}, this);\n        };\n\n        return refObj;\n      }\n    }, {\n      key: 'keyFrameRefactor',\n      value: function keyFrameRefactor(XAnimationInfo) {\n        var keys = [];\n\n        for (let i = 0; i < XAnimationInfo.keyFrames.length; i++) {\n          var keyframe = {};\n          keyframe.time = XAnimationInfo.keyFrames[i].time * this.fps;\n\n          if (XAnimationInfo.keyFrames[i].pos && this.putFlags.putPos) {\n            keyframe.pos = XAnimationInfo.keyFrames[i].pos;\n          }\n\n          if (XAnimationInfo.keyFrames[i].rot && this.putFlags.putRot) {\n            keyframe.rot = XAnimationInfo.keyFrames[i].rot;\n          }\n\n          if (XAnimationInfo.keyFrames[i].scl && this.putFlags.putScl) {\n            keyframe.scl = XAnimationInfo.keyFrames[i].scl;\n          }\n\n          if (XAnimationInfo.keyFrames[i].matrix) {\n            keyframe.matrix = XAnimationInfo.keyFrames[i].matrix;\n\n            if (this.putFlags.putPos) {\n              keyframe.pos = new Vector3().setFromMatrixPosition(keyframe.matrix);\n            }\n\n            if (this.putFlags.putRot) {\n              keyframe.rot = new Quaternion().setFromRotationMatrix(keyframe.matrix);\n            }\n\n            if (this.putFlags.putScl) {\n              keyframe.scl = new Vector3().setFromMatrixScale(keyframe.matrix);\n            }\n          }\n\n          keys.push(keyframe);\n        }\n\n        return keys;\n      }\n    }]);\n    return XAnimationObj;\n  }();\n\n  var XKeyFrameInfo = function XKeyFrameInfo() {\n    classCallCheck(this, XKeyFrameInfo);\n    this.index = 0;\n    this.Frame = 0;\n    this.time = 0.0;\n    this.matrix = null;\n  };\n\n  var XLoader = function () {\n    function XLoader(manager) {\n      Loader.call(this, manager);\n      classCallCheck(this, XLoader);\n      this.debug = false;\n      this.texloader = new TextureLoader(this.manager);\n      this.url = '';\n      this._putMatLength = 0;\n      this._nowMat = null;\n      this._nowFrameName = '';\n      this.frameHierarchie = [];\n      this.Hierarchies = {};\n      this.HieStack = [];\n      this._currentObject = {};\n      this._currentFrame = {};\n      this._data = null;\n      this.onLoad = null;\n      this.IsUvYReverse = true;\n      this.Meshes = [];\n      this.animations = [];\n      this.animTicksPerSecond = 30;\n      this._currentGeo = null;\n      this._currentAnime = null;\n      this._currentAnimeFrames = null;\n    }\n\n    createClass(XLoader, [{\n      key: '_setArgOption',\n      value: function _setArgOption(_arg) {\n        var _start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n        if (!_arg) {\n          return;\n        }\n\n        for (let i = _start; i < _arg.length; i++) {\n          switch (i) {\n            case 0:\n              this.url = _arg[i];\n              break;\n\n            case 1:\n              this.options = _arg[i];\n              break;\n          }\n        }\n\n        if (this.options === undefined) {\n          this.options = {};\n        }\n      }\n    }, {\n      key: 'load',\n      value: function load(_arg, onLoad, onProgress, onError) {\n        var _this = this;\n\n        this._setArgOption(_arg);\n\n        var loader = new FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType('arraybuffer');\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(this.url, function (response) {\n          try {\n            _this.parse(response, onLoad);\n          } catch (e) {\n            if (onError) {\n              onError(e);\n            } else {\n              console.error(e);\n            }\n\n            _this.manager.itemError(_this.url);\n          }\n        }, onProgress, onError);\n      }\n    }, {\n      key: '_readLine',\n      value: function _readLine(line) {\n        var readed = 0;\n\n        while (true) {\n          var find = -1;\n          find = line.indexOf('//', readed);\n\n          if (find === -1) {\n            find = line.indexOf('#', readed);\n          }\n\n          if (find > -1 && find < 2) {\n            var foundNewLine = -1;\n            foundNewLine = line.indexOf('\\r\\n', readed);\n\n            if (foundNewLine > 0) {\n              readed = foundNewLine + 2;\n            } else {\n              foundNewLine = line.indexOf('\\r', readed);\n\n              if (foundNewLine > 0) {\n                readed = foundNewLine + 1;\n              } else {\n                readed = line.indexOf('\\n', readed) + 1;\n              }\n            }\n          } else {\n            break;\n          }\n        }\n\n        return line.substr(readed);\n      }\n    }, {\n      key: '_readLine',\n      value: function _readLine(line) {\n        var readed = 0;\n\n        while (true) {\n          var find = -1;\n          find = line.indexOf('//', readed);\n\n          if (find === -1) {\n            find = line.indexOf('#', readed);\n          }\n\n          if (find > -1 && find < 2) {\n            var foundNewLine = -1;\n            foundNewLine = line.indexOf('\\r\\n', readed);\n\n            if (foundNewLine > 0) {\n              readed = foundNewLine + 2;\n            } else {\n              foundNewLine = line.indexOf('\\r', readed);\n\n              if (foundNewLine > 0) {\n                readed = foundNewLine + 1;\n              } else {\n                readed = line.indexOf('\\n', readed) + 1;\n              }\n            }\n          } else {\n            break;\n          }\n        }\n\n        return line.substr(readed);\n      }\n    }, {\n      key: '_isBinary',\n      value: function _isBinary(binData) {\n        var reader = new DataView(binData);\n        var face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n        var n_faces = reader.getUint32(80, true);\n        var expect = 80 + 32 / 8 + n_faces * face_size;\n\n        if (expect === reader.byteLength) {\n          return true;\n        }\n\n        var fileLength = reader.byteLength;\n\n        for (let index = 0; index < fileLength; index++) {\n          if (reader.getUint8(index, false) > 127) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n    }, {\n      key: '_ensureBinary',\n      value: function _ensureBinary(buf) {\n        if (typeof buf === 'string') {\n          var array_buffer = new Uint8Array(buf.length);\n\n          for (let i = 0; i < buf.length; i++) {\n            array_buffer[i] = buf.charCodeAt(i) & 0xff;\n          }\n\n          return array_buffer.buffer || array_buffer;\n        } else {\n          return buf;\n        }\n      }\n    }, {\n      key: '_ensureString',\n      value: function _ensureString(buf) {\n        if (typeof buf !== 'string') {\n          return LoaderUtils.decodeText(new Uint8Array(buf));\n        } else {\n          return buf;\n        }\n      }\n    }, {\n      key: 'parse',\n      value: function _parse(data, onLoad) {\n        var binData = this._ensureBinary(data);\n\n        this._data = this._ensureString(data);\n        this.onLoad = onLoad;\n        return this._isBinary(binData) ? this._parseBinary(binData) : this._parseASCII();\n      }\n    }, {\n      key: '_parseBinary',\n      value: function _parseBinary(data) {\n        return this._parseASCII(LoaderUtils.decodeText(new Uint8Array(data)));\n      }\n    }, {\n      key: '_parseASCII',\n      value: function _parseASCII() {\n        var path;\n\n        if (this.resourcePath !== '') {\n          path = this.resourcePath;\n        } else if (this.path !== '') {\n          path = this.path;\n        } else {\n          path = LoaderUtils.extractUrlBase(this.url);\n        }\n\n        this.texloader.setPath(path).setCrossOrigin(this.crossOrigin);\n        var endRead = 16;\n        this.Hierarchies.children = [];\n\n        this._hierarchieParse(this.Hierarchies, endRead);\n\n        this._changeRoot();\n\n        this._currentObject = this.Hierarchies.children.shift();\n\n        this._mainloop();\n      }\n    }, {\n      key: '_hierarchieParse',\n      value: function _hierarchieParse(_parent, _end) {\n        var endRead = _end;\n\n        while (true) {\n          var find1 = this._data.indexOf('{', endRead) + 1;\n\n          var findEnd = this._data.indexOf('}', endRead);\n\n          var findNext = this._data.indexOf('{', find1) + 1;\n\n          if (find1 > 0 && findEnd > find1) {\n            var _currentObject = {};\n            _currentObject.children = [];\n\n            var nameData = this._readLine(this._data.substr(endRead, find1 - endRead - 1)).trim();\n\n            var word = nameData.split(/ /g);\n\n            if (word.length > 0) {\n              _currentObject.type = word[0];\n\n              if (word.length >= 2) {\n                _currentObject.name = word[1];\n              } else {\n                _currentObject.name = word[0] + this.Hierarchies.children.length;\n              }\n            } else {\n              _currentObject.name = nameData;\n              _currentObject.type = '';\n            }\n\n            if (_currentObject.type === 'Animation') {\n              _currentObject.data = this._data.substr(findNext, findEnd - findNext).trim();\n\n              var refs = this._hierarchieParse(_currentObject, findEnd + 1);\n\n              endRead = refs.end;\n              _currentObject.children = refs.parent.children;\n            } else {\n              var DataEnder = this._data.lastIndexOf(';', findNext > 0 ? Math.min(findNext, findEnd) : findEnd);\n\n              _currentObject.data = this._data.substr(find1, DataEnder - find1).trim();\n\n              if (findNext <= 0 || findEnd < findNext) {\n                endRead = findEnd + 1;\n              } else {\n                var nextStart = Math.max(DataEnder + 1, find1);\n\n                var _refs = this._hierarchieParse(_currentObject, nextStart);\n\n                endRead = _refs.end;\n                _currentObject.children = _refs.parent.children;\n              }\n            }\n\n            _currentObject.parent = _parent;\n\n            if (_currentObject.type != 'template') {\n              _parent.children.push(_currentObject);\n            }\n          } else {\n            endRead = find1 === -1 ? this._data.length : findEnd + 1;\n            break;\n          }\n        }\n\n        return {\n          parent: _parent,\n          end: endRead\n        };\n      }\n    }, {\n      key: '_mainloop',\n      value: function _mainloop() {\n        var _this2 = this;\n\n        this._mainProc();\n\n        if (this._currentObject.parent || this._currentObject.children.length > 0 || !this._currentObject.worked) {\n          setTimeout(function () {\n            _this2._mainloop();\n          }, 1);\n        } else {\n          setTimeout(function () {\n            _this2.onLoad({\n              models: _this2.Meshes,\n              animations: _this2.animations\n            });\n          }, 1);\n        }\n      }\n    }, {\n      key: '_mainProc',\n      value: function _mainProc() {\n        var breakFlag = false;\n\n        while (true) {\n          if (!this._currentObject.worked) {\n            switch (this._currentObject.type) {\n              case 'template':\n                break;\n\n              case 'AnimTicksPerSecond':\n                this.animTicksPerSecond = parseInt(this._currentObject.data);\n                break;\n\n              case 'Frame':\n                this._setFrame();\n\n                break;\n\n              case 'FrameTransformMatrix':\n                this._setFrameTransformMatrix();\n\n                break;\n\n              case 'Mesh':\n                this._changeRoot();\n\n                this._currentGeo = {};\n                this._currentGeo.name = this._currentObject.name.trim();\n                this._currentGeo.parentName = this._getParentName(this._currentObject).trim();\n                this._currentGeo.VertexSetedBoneCount = [];\n                this._currentGeo.GeometryData = {\n                  vertices: [],\n                  normals: [],\n                  uvs: [],\n                  skinIndices: [],\n                  skinWeights: [],\n                  indices: [],\n                  materialIndices: []\n                };\n                this._currentGeo.Materials = [];\n                this._currentGeo.normalVectors = [];\n                this._currentGeo.BoneInfs = [];\n                this._currentGeo.baseFrame = this._currentFrame;\n\n                this._makeBoneFrom_CurrentFrame();\n\n                this._readVertexDatas();\n\n                breakFlag = true;\n                break;\n\n              case 'MeshNormals':\n                this._readVertexDatas();\n\n                break;\n\n              case 'MeshTextureCoords':\n                this._setMeshTextureCoords();\n\n                break;\n\n              case 'VertexDuplicationIndices':\n                break;\n\n              case 'MeshMaterialList':\n                this._setMeshMaterialList();\n\n                break;\n\n              case 'Material':\n                this._setMaterial();\n\n                break;\n\n              case 'SkinWeights':\n                this._setSkinWeights();\n\n                break;\n\n              case 'AnimationSet':\n                this._changeRoot();\n\n                this._currentAnime = {};\n                this._currentAnime.name = this._currentObject.name.trim();\n                this._currentAnime.AnimeFrames = [];\n                break;\n\n              case 'Animation':\n                if (this._currentAnimeFrames) {\n                  this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);\n                }\n\n                this._currentAnimeFrames = new XAnimationInfo();\n                this._currentAnimeFrames.boneName = this._currentObject.data.trim();\n                break;\n\n              case 'AnimationKey':\n                this._readAnimationKey();\n\n                breakFlag = true;\n                break;\n            }\n\n            this._currentObject.worked = true;\n          }\n\n          if (this._currentObject.children.length > 0) {\n            this._currentObject = this._currentObject.children.shift();\n\n            if (this.debug) {\n              console.log('processing ' + this._currentObject.name);\n            }\n\n            if (breakFlag) break;\n          } else {\n            if (this._currentObject.worked) {\n              if (this._currentObject.parent && !this._currentObject.parent.parent) {\n                this._changeRoot();\n              }\n            }\n\n            if (this._currentObject.parent) {\n              this._currentObject = this._currentObject.parent;\n            } else {\n              breakFlag = true;\n            }\n\n            if (breakFlag) break;\n          }\n        }\n\n        return;\n      }\n    }, {\n      key: '_changeRoot',\n      value: function _changeRoot() {\n        if (this._currentGeo != null && this._currentGeo.name) {\n          this._makeOutputGeometry();\n        }\n\n        this._currentGeo = {};\n\n        if (this._currentAnime != null && this._currentAnime.name) {\n          if (this._currentAnimeFrames) {\n            this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);\n\n            this._currentAnimeFrames = null;\n          }\n\n          this._makeOutputAnimation();\n        }\n\n        this._currentAnime = {};\n      }\n    }, {\n      key: '_getParentName',\n      value: function _getParentName(_obj) {\n        if (_obj.parent) {\n          if (_obj.parent.name) {\n            return _obj.parent.name;\n          } else {\n            return this._getParentName(_obj.parent);\n          }\n        } else {\n          return '';\n        }\n      }\n    }, {\n      key: '_setFrame',\n      value: function _setFrame() {\n        this._nowFrameName = this._currentObject.name.trim();\n        this._currentFrame = {};\n        this._currentFrame.name = this._nowFrameName;\n        this._currentFrame.children = [];\n\n        if (this._currentObject.parent && this._currentObject.parent.name) {\n          this._currentFrame.parentName = this._currentObject.parent.name;\n        }\n\n        this.frameHierarchie.push(this._nowFrameName);\n        this.HieStack[this._nowFrameName] = this._currentFrame;\n      }\n    }, {\n      key: '_setFrameTransformMatrix',\n      value: function _setFrameTransformMatrix() {\n        this._currentFrame.FrameTransformMatrix = new Matrix4();\n\n        var data = this._currentObject.data.split(',');\n\n        this._ParseMatrixData(this._currentFrame.FrameTransformMatrix, data);\n\n        this._makeBoneFrom_CurrentFrame();\n      }\n    }, {\n      key: '_makeBoneFrom_CurrentFrame',\n      value: function _makeBoneFrom_CurrentFrame() {\n        if (!this._currentFrame.FrameTransformMatrix) {\n          return;\n        }\n\n        var b = new Bone();\n        b.name = this._currentFrame.name;\n        b.applyMatrix4(this._currentFrame.FrameTransformMatrix);\n        b.matrixWorld = b.matrix;\n        b.FrameTransformMatrix = this._currentFrame.FrameTransformMatrix;\n        this._currentFrame.putBone = b;\n\n        if (this._currentFrame.parentName) {\n          for (let frame in this.HieStack) {\n            if (this.HieStack[frame].name === this._currentFrame.parentName) {\n              this.HieStack[frame].putBone.add(this._currentFrame.putBone);\n            }\n          }\n        }\n      }\n    }, {\n      key: '_readVertexDatas',\n      value: function _readVertexDatas() {\n        var endRead = 0;\n        var mode = 0;\n        var mode_local = 0;\n        var maxLength = 0;\n\n        while (true) {\n          var changeMode = false;\n\n          if (mode_local === 0) {\n            var refO = this._readInt1(endRead);\n\n            endRead = refO.endRead;\n            mode_local = 1;\n            maxLength = this._currentObject.data.indexOf(';;', endRead) + 1;\n\n            if (maxLength <= 0) {\n              maxLength = this._currentObject.data.length;\n            }\n          } else {\n            var find = 0;\n\n            switch (mode) {\n              case 0:\n                find = this._currentObject.data.indexOf(',', endRead) + 1;\n                break;\n\n              case 1:\n                find = this._currentObject.data.indexOf(';,', endRead) + 1;\n                break;\n            }\n\n            if (find === 0 || find > maxLength) {\n              find = maxLength;\n              mode_local = 0;\n              changeMode = true;\n            }\n\n            switch (this._currentObject.type) {\n              case 'Mesh':\n                switch (mode) {\n                  case 0:\n                    this._readVertex1(this._currentObject.data.substr(endRead, find - endRead));\n\n                    break;\n\n                  case 1:\n                    this._readFace1(this._currentObject.data.substr(endRead, find - endRead));\n\n                    break;\n                }\n\n                break;\n\n              case 'MeshNormals':\n                switch (mode) {\n                  case 0:\n                    this._readNormalVector1(this._currentObject.data.substr(endRead, find - endRead));\n\n                    break;\n                }\n\n                break;\n            }\n\n            endRead = find + 1;\n\n            if (changeMode) {\n              mode++;\n            }\n          }\n\n          if (endRead >= this._currentObject.data.length) {\n            break;\n          }\n        }\n      }\n    }, {\n      key: '_readInt1',\n      value: function _readInt1(start) {\n        var find = this._currentObject.data.indexOf(';', start);\n\n        return {\n          refI: parseInt(this._currentObject.data.substr(start, find - start)),\n          endRead: find + 1\n        };\n      }\n    }, {\n      key: '_readVertex1',\n      value: function _readVertex1(line) {\n        var data = this._readLine(line.trim()).substr(0, line.length - 2).split(';');\n\n        this._currentGeo.GeometryData.vertices.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]));\n\n        this._currentGeo.GeometryData.skinIndices.push(0, 0, 0, 0);\n\n        this._currentGeo.GeometryData.skinWeights.push(1, 0, 0, 0);\n\n        this._currentGeo.VertexSetedBoneCount.push(0);\n      }\n    }, {\n      key: '_readFace1',\n      value: function _readFace1(line) {\n        var data = this._readLine(line.trim()).substr(2, line.length - 4).split(',');\n\n        this._currentGeo.GeometryData.indices.push(parseInt(data[0], 10), parseInt(data[1], 10), parseInt(data[2], 10));\n      }\n    }, {\n      key: '_readNormalVector1',\n      value: function _readNormalVector1(line) {\n        var data = this._readLine(line.trim()).substr(0, line.length - 2).split(';');\n\n        this._currentGeo.GeometryData.normals.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]));\n      }\n    }, {\n      key: '_buildGeometry',\n      value: function _buildGeometry() {\n        var bufferGeometry = new BufferGeometry();\n        var position = [];\n        var normals = [];\n        var uvs = [];\n        var skinIndices = [];\n        var skinWeights = []; //\n\n        var data = this._currentGeo.GeometryData;\n\n        for (let i = 0, l = data.indices.length; i < l; i++) {\n          var stride2 = data.indices[i] * 2;\n          var stride3 = data.indices[i] * 3;\n          var stride4 = data.indices[i] * 4;\n          position.push(data.vertices[stride3], data.vertices[stride3 + 1], data.vertices[stride3 + 2]);\n          normals.push(data.normals[stride3], data.normals[stride3 + 1], data.normals[stride3 + 2]);\n          skinIndices.push(data.skinIndices[stride4], data.skinIndices[stride4 + 1], data.skinIndices[stride4 + 2], data.skinIndices[stride4 + 3]);\n          skinWeights.push(data.skinWeights[stride4], data.skinWeights[stride4 + 1], data.skinWeights[stride4 + 2], data.skinWeights[stride4 + 3]);\n          uvs.push(data.uvs[stride2], data.uvs[stride2 + 1]);\n        } //\n\n\n        bufferGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n        bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n        bufferGeometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n        bufferGeometry.setAttribute('skinIndex', new Uint16BufferAttribute(skinIndices, 4));\n        bufferGeometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeights, 4));\n\n        this._computeGroups(bufferGeometry, data.materialIndices);\n\n        return bufferGeometry;\n      }\n    }, {\n      key: '_computeGroups',\n      value: function _computeGroups(bufferGeometry, materialIndices) {\n        var group;\n        var groups = [];\n        var materialIndex = undefined;\n\n        for (let i = 0; i < materialIndices.length; i++) {\n          var currentMaterialIndex = materialIndices[i];\n\n          if (currentMaterialIndex !== materialIndex) {\n            materialIndex = currentMaterialIndex;\n\n            if (group !== undefined) {\n              group.count = i * 3 - group.start;\n              groups.push(group);\n            }\n\n            group = {\n              start: i * 3,\n              materialIndex: materialIndex\n            };\n          }\n        }\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n\n        bufferGeometry.groups = groups;\n      }\n    }, {\n      key: '_setMeshTextureCoords',\n      value: function _setMeshTextureCoords() {\n        var endRead = 0;\n        var mode = 0;\n        var mode_local = 0;\n\n        while (true) {\n          switch (mode) {\n            case 0:\n              if (mode_local === 0) {\n                var refO = this._readInt1(0);\n\n                endRead = refO.endRead;\n                mode_local = 1;\n              } else {\n                var find = this._currentObject.data.indexOf(',', endRead) + 1;\n\n                if (find === 0) {\n                  find = this._currentObject.data.length;\n                  mode = 2;\n                  mode_local = 0;\n                }\n\n                var line = this._currentObject.data.substr(endRead, find - endRead);\n\n                var data = this._readLine(line.trim()).split(';');\n\n                if (this.IsUvYReverse) {\n                  this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), 1 - parseFloat(data[1]));\n                } else {\n                  this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), parseFloat(data[1]));\n                }\n\n                endRead = find + 1;\n              }\n\n              break;\n          }\n\n          if (endRead >= this._currentObject.data.length) {\n            break;\n          }\n        }\n      }\n    }, {\n      key: '_setMeshMaterialList',\n      value: function _setMeshMaterialList() {\n        var endRead = 0;\n        var mode = 0;\n        var mode_local = 0;\n\n        while (true) {\n          if (mode_local < 2) {\n            var refO = this._readInt1(endRead);\n\n            endRead = refO.endRead;\n            mode_local++;\n          } else {\n            var find = this._currentObject.data.indexOf(';', endRead);\n\n            if (find === -1) {\n              find = this._currentObject.data.length;\n              mode = 3;\n              mode_local = 0;\n            }\n\n            var line = this._currentObject.data.substr(endRead, find - endRead);\n\n            var data = this._readLine(line.trim()).split(',');\n\n            for (let i = 0; i < data.length; i++) {\n              this._currentGeo.GeometryData.materialIndices[i] = parseInt(data[i]);\n            }\n\n            endRead = this._currentObject.data.length;\n          }\n\n          if (endRead >= this._currentObject.data.length || mode >= 3) {\n            break;\n          }\n        }\n      }\n    }, {\n      key: '_setMaterial',\n      value: function _setMaterial() {\n        var _nowMat = new MeshPhongMaterial({\n          color: Math.random() * 0xffffff\n        });\n\n        _nowMat.side = FrontSide;\n        _nowMat.name = this._currentObject.name;\n        var endRead = 0;\n\n        var find = this._currentObject.data.indexOf(';;', endRead);\n\n        var line = this._currentObject.data.substr(endRead, find - endRead);\n\n        var data = this._readLine(line.trim()).split(';');\n\n        _nowMat.color.r = parseFloat(data[0]);\n        _nowMat.color.g = parseFloat(data[1]);\n        _nowMat.color.b = parseFloat(data[2]);\n        endRead = find + 2;\n        find = this._currentObject.data.indexOf(';', endRead);\n        line = this._currentObject.data.substr(endRead, find - endRead);\n        _nowMat.shininess = parseFloat(this._readLine(line));\n        endRead = find + 1;\n        find = this._currentObject.data.indexOf(';;', endRead);\n        line = this._currentObject.data.substr(endRead, find - endRead);\n\n        var data2 = this._readLine(line.trim()).split(';');\n\n        _nowMat.specular.r = parseFloat(data2[0]);\n        _nowMat.specular.g = parseFloat(data2[1]);\n        _nowMat.specular.b = parseFloat(data2[2]);\n        endRead = find + 2;\n        find = this._currentObject.data.indexOf(';;', endRead);\n\n        if (find === -1) {\n          find = this._currentObject.data.length;\n        }\n\n        line = this._currentObject.data.substr(endRead, find - endRead);\n\n        var data3 = this._readLine(line.trim()).split(';');\n\n        _nowMat.emissive.r = parseFloat(data3[0]);\n        _nowMat.emissive.g = parseFloat(data3[1]);\n        _nowMat.emissive.b = parseFloat(data3[2]);\n        var localObject = null;\n\n        while (true) {\n          if (this._currentObject.children.length > 0) {\n            localObject = this._currentObject.children.shift();\n\n            if (this.debug) {\n              console.log('processing ' + localObject.name);\n            }\n\n            var fileName = localObject.data.substr(1, localObject.data.length - 2);\n\n            switch (localObject.type) {\n              case 'TextureFilename':\n                _nowMat.map = this.texloader.load(fileName);\n                break;\n\n              case 'BumpMapFilename':\n                _nowMat.bumpMap = this.texloader.load(fileName);\n                _nowMat.bumpScale = 0.05;\n                break;\n\n              case 'NormalMapFilename':\n                _nowMat.normalMap = this.texloader.load(fileName);\n                _nowMat.normalScale = new Vector2(2, 2);\n                break;\n\n              case 'EmissiveMapFilename':\n                _nowMat.emissiveMap = this.texloader.load(fileName);\n                break;\n\n              case 'LightMapFilename':\n                _nowMat.lightMap = this.texloader.load(fileName);\n                break;\n            }\n          } else {\n            break;\n          }\n        }\n\n        this._currentGeo.Materials.push(_nowMat);\n      }\n    }, {\n      key: '_setSkinWeights',\n      value: function _setSkinWeights() {\n        var boneInf = new XboneInf();\n        var endRead = 0;\n\n        var find = this._currentObject.data.indexOf(';', endRead);\n\n        var line = this._currentObject.data.substr(endRead, find - endRead);\n\n        endRead = find + 1;\n        boneInf.boneName = line.substr(1, line.length - 2);\n        boneInf.BoneIndex = this._currentGeo.BoneInfs.length;\n        find = this._currentObject.data.indexOf(';', endRead);\n        endRead = find + 1;\n        find = this._currentObject.data.indexOf(';', endRead);\n        line = this._currentObject.data.substr(endRead, find - endRead);\n\n        var data = this._readLine(line.trim()).split(',');\n\n        for (let i = 0; i < data.length; i++) {\n          boneInf.Indeces.push(parseInt(data[i]));\n        }\n\n        endRead = find + 1;\n        find = this._currentObject.data.indexOf(';', endRead);\n        line = this._currentObject.data.substr(endRead, find - endRead);\n\n        var data2 = this._readLine(line.trim()).split(',');\n\n        for (let _i = 0; _i < data2.length; _i++) {\n          boneInf.Weights.push(parseFloat(data2[_i]));\n        }\n\n        endRead = find + 1;\n        find = this._currentObject.data.indexOf(';', endRead);\n\n        if (find <= 0) {\n          find = this._currentObject.data.length;\n        }\n\n        line = this._currentObject.data.substr(endRead, find - endRead);\n\n        var data3 = this._readLine(line.trim()).split(',');\n\n        boneInf.OffsetMatrix = new Matrix4();\n\n        this._ParseMatrixData(boneInf.OffsetMatrix, data3);\n\n        this._currentGeo.BoneInfs.push(boneInf);\n      }\n    }, {\n      key: '_makePutBoneList',\n      value: function _makePutBoneList(_RootName, _bones) {\n        var putting = false;\n\n        for (let frame in this.HieStack) {\n          if (this.HieStack[frame].name === _RootName || putting) {\n            putting = true;\n            var b = new Bone();\n            b.name = this.HieStack[frame].name;\n            b.applyMatrix4(this.HieStack[frame].FrameTransformMatrix);\n            b.matrixWorld = b.matrix;\n            b.FrameTransformMatrix = this.HieStack[frame].FrameTransformMatrix;\n            b.pos = new Vector3().setFromMatrixPosition(b.FrameTransformMatrix).toArray();\n            b.rotq = new Quaternion().setFromRotationMatrix(b.FrameTransformMatrix).toArray();\n            b.scl = new Vector3().setFromMatrixScale(b.FrameTransformMatrix).toArray();\n\n            if (this.HieStack[frame].parentName && this.HieStack[frame].parentName.length > 0) {\n              for (let i = 0; i < _bones.length; i++) {\n                if (this.HieStack[frame].parentName === _bones[i].name) {\n                  _bones[i].add(b);\n\n                  b.parent = i;\n                  break;\n                }\n              }\n            }\n\n            _bones.push(b);\n          }\n        }\n      }\n    }, {\n      key: '_makeOutputGeometry',\n      value: function _makeOutputGeometry() {\n        var mesh = null;\n\n        if (this._currentGeo.BoneInfs.length > 0) {\n          var putBones = [];\n\n          this._makePutBoneList(this._currentGeo.baseFrame.parentName, putBones);\n\n          for (let bi = 0; bi < this._currentGeo.BoneInfs.length; bi++) {\n            var boneIndex = 0;\n\n            for (let bb = 0; bb < putBones.length; bb++) {\n              if (putBones[bb].name === this._currentGeo.BoneInfs[bi].boneName) {\n                boneIndex = bb;\n                putBones[bb].OffsetMatrix = new Matrix4();\n                putBones[bb].OffsetMatrix.copy(this._currentGeo.BoneInfs[bi].OffsetMatrix);\n                break;\n              }\n            }\n\n            for (let vi = 0; vi < this._currentGeo.BoneInfs[bi].Indeces.length; vi++) {\n              var nowVertexID = this._currentGeo.BoneInfs[bi].Indeces[vi];\n              var nowVal = this._currentGeo.BoneInfs[bi].Weights[vi];\n              var stride = nowVertexID * 4;\n\n              switch (this._currentGeo.VertexSetedBoneCount[nowVertexID]) {\n                case 0:\n                  this._currentGeo.GeometryData.skinIndices[stride] = boneIndex;\n                  this._currentGeo.GeometryData.skinWeights[stride] = nowVal;\n                  break;\n\n                case 1:\n                  this._currentGeo.GeometryData.skinIndices[stride + 1] = boneIndex;\n                  this._currentGeo.GeometryData.skinWeights[stride + 1] = nowVal;\n                  break;\n\n                case 2:\n                  this._currentGeo.GeometryData.skinIndices[stride + 2] = boneIndex;\n                  this._currentGeo.GeometryData.skinWeights[stride + 2] = nowVal;\n                  break;\n\n                case 3:\n                  this._currentGeo.GeometryData.skinIndices[stride + 3] = boneIndex;\n                  this._currentGeo.GeometryData.skinWeights[stride + 3] = nowVal;\n                  break;\n              }\n\n              this._currentGeo.VertexSetedBoneCount[nowVertexID]++;\n\n              if (this._currentGeo.VertexSetedBoneCount[nowVertexID] > 4) {\n                console.log('warn! over 4 bone weight! :' + nowVertexID);\n              }\n            }\n          }\n\n          for (let sk = 0; sk < this._currentGeo.Materials.length; sk++) {\n            this._currentGeo.Materials[sk].skinning = true;\n          }\n\n          var offsetList = [];\n\n          for (let _bi = 0; _bi < putBones.length; _bi++) {\n            if (putBones[_bi].OffsetMatrix) {\n              offsetList.push(putBones[_bi].OffsetMatrix);\n            } else {\n              offsetList.push(new Matrix4());\n            }\n          }\n\n          var bufferGeometry = this._buildGeometry();\n\n          mesh = new SkinnedMesh(bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);\n\n          this._initSkeleton(mesh, putBones, offsetList);\n        } else {\n          var _bufferGeometry = this._buildGeometry();\n\n          mesh = new Mesh(_bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);\n        }\n\n        mesh.name = this._currentGeo.name;\n        var worldBaseMx = new Matrix4();\n        var currentMxFrame = this._currentGeo.baseFrame.putBone;\n\n        if (currentMxFrame && currentMxFrame.parent) {\n          while (true) {\n            currentMxFrame = currentMxFrame.parent;\n\n            if (currentMxFrame) {\n              worldBaseMx.multiply(currentMxFrame.FrameTransformMatrix);\n            } else {\n              break;\n            }\n          }\n\n          mesh.applyMatrix4(worldBaseMx);\n        }\n\n        this.Meshes.push(mesh);\n      }\n    }, {\n      key: '_initSkeleton',\n      value: function _initSkeleton(mesh, boneList, boneInverses) {\n        var bones = [],\n            bone,\n            gbone;\n        var i, il;\n\n        for (i = 0, il = boneList.length; i < il; i++) {\n          gbone = boneList[i];\n          bone = new Bone();\n          bones.push(bone);\n          bone.name = gbone.name;\n          bone.position.fromArray(gbone.pos);\n          bone.quaternion.fromArray(gbone.rotq);\n          if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl);\n        }\n\n        for (i = 0, il = boneList.length; i < il; i++) {\n          gbone = boneList[i];\n\n          if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {\n            bones[gbone.parent].add(bones[i]);\n          } else {\n            mesh.add(bones[i]);\n          }\n        }\n\n        mesh.updateMatrixWorld(true);\n        var skeleton = new Skeleton(bones, boneInverses);\n        mesh.bind(skeleton, mesh.matrixWorld);\n      }\n    }, {\n      key: '_readAnimationKey',\n      value: function _readAnimationKey() {\n        var endRead = 0;\n\n        var find = this._currentObject.data.indexOf(';', endRead);\n\n        var line = this._currentObject.data.substr(endRead, find - endRead);\n\n        endRead = find + 1;\n        var nowKeyType = parseInt(this._readLine(line));\n        find = this._currentObject.data.indexOf(';', endRead);\n        endRead = find + 1;\n        line = this._currentObject.data.substr(endRead);\n\n        var data = this._readLine(line.trim()).split(';;,');\n\n        for (let i = 0; i < data.length; i++) {\n          var data2 = data[i].split(';');\n          var keyInfo = new XKeyFrameInfo();\n          keyInfo.type = nowKeyType;\n          keyInfo.Frame = parseInt(data2[0]);\n          keyInfo.index = this._currentAnimeFrames.keyFrames.length;\n          keyInfo.time = keyInfo.Frame;\n\n          if (nowKeyType != 4) {\n            var frameFound = false;\n\n            for (let mm = 0; mm < this._currentAnimeFrames.keyFrames.length; mm++) {\n              if (this._currentAnimeFrames.keyFrames[mm].Frame === keyInfo.Frame) {\n                keyInfo = this._currentAnimeFrames.keyFrames[mm];\n                frameFound = true;\n                break;\n              }\n            }\n\n            var frameValue = data2[2].split(',');\n\n            switch (nowKeyType) {\n              case 0:\n                keyInfo.rot = new Quaternion(parseFloat(frameValue[1]), parseFloat(frameValue[2]), parseFloat(frameValue[3]), parseFloat(frameValue[0]) * -1);\n                break;\n\n              case 1:\n                keyInfo.scl = new Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));\n                break;\n\n              case 2:\n                keyInfo.pos = new Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));\n                break;\n            }\n\n            if (!frameFound) {\n              this._currentAnimeFrames.keyFrames.push(keyInfo);\n            }\n          } else {\n            keyInfo.matrix = new Matrix4();\n\n            this._ParseMatrixData(keyInfo.matrix, data2[2].split(','));\n\n            this._currentAnimeFrames.keyFrames.push(keyInfo);\n          }\n        }\n      }\n    }, {\n      key: '_makeOutputAnimation',\n      value: function _makeOutputAnimation() {\n        var animationObj = new XAnimationObj(this.options);\n        animationObj.fps = this.animTicksPerSecond;\n        animationObj.name = this._currentAnime.name;\n        animationObj.make(this._currentAnime.AnimeFrames);\n        this.animations.push(animationObj);\n      }\n    }, {\n      key: 'assignAnimation',\n      value: function assignAnimation(_model, _animation) {\n        var model = _model;\n        var animation = _animation;\n\n        if (!model) {\n          model = this.Meshes[0];\n        }\n\n        if (!animation) {\n          animation = this.animations[0];\n        }\n\n        if (!model || !animation) {\n          return null;\n        }\n\n        var put = {};\n        put.fps = animation.fps;\n        put.name = animation.name;\n        put.length = animation.length;\n        put.hierarchy = [];\n\n        for (let b = 0; b < model.skeleton.bones.length; b++) {\n          var findAnimation = false;\n\n          for (let i = 0; i < animation.hierarchy.length; i++) {\n            if (model.skeleton.bones[b].name === animation.hierarchy[i].name) {\n              findAnimation = true;\n              var c_key = animation.hierarchy[i].copy();\n              c_key.parent = -1;\n\n              if (model.skeleton.bones[b].parent && model.skeleton.bones[b].parent.type === 'Bone') {\n                for (let bb = 0; bb < put.hierarchy.length; bb++) {\n                  if (put.hierarchy[bb].name === model.skeleton.bones[b].parent.name) {\n                    c_key.parent = bb;\n                    c_key.parentName = model.skeleton.bones[b].parent.name;\n                  }\n                }\n              }\n\n              put.hierarchy.push(c_key);\n              break;\n            }\n          }\n\n          if (!findAnimation) {\n            var _c_key = animation.hierarchy[0].copy();\n\n            _c_key.name = model.skeleton.bones[b].name;\n            _c_key.parent = -1;\n\n            for (let k = 0; k < _c_key.keys.length; k++) {\n              if (_c_key.keys[k].pos) {\n                _c_key.keys[k].pos.set(0, 0, 0);\n              }\n\n              if (_c_key.keys[k].scl) {\n                _c_key.keys[k].scl.set(1, 1, 1);\n              }\n\n              if (_c_key.keys[k].rot) {\n                _c_key.keys[k].rot.set(0, 0, 0, 1);\n              }\n            }\n\n            put.hierarchy.push(_c_key);\n          }\n        }\n\n        if (!model.geometry.animations) {\n          model.geometry.animations = [];\n        }\n\n        model.geometry.animations.push(AnimationClip.parseAnimation(put, model.skeleton.bones));\n\n        if (!model.animationMixer) {\n          model.animationMixer = new AnimationMixer(model);\n        }\n\n        return put;\n      }\n    }, {\n      key: '_ParseMatrixData',\n      value: function _ParseMatrixData(targetMatrix, data) {\n        targetMatrix.set(parseFloat(data[0]), parseFloat(data[4]), parseFloat(data[8]), parseFloat(data[12]), parseFloat(data[1]), parseFloat(data[5]), parseFloat(data[9]), parseFloat(data[13]), parseFloat(data[2]), parseFloat(data[6]), parseFloat(data[10]), parseFloat(data[14]), parseFloat(data[3]), parseFloat(data[7]), parseFloat(data[11]), parseFloat(data[15]));\n      }\n    }]);\n    return XLoader;\n  }();\n\n  return XLoader;\n}();\n\nexport { XLoader };\n", "import mod from \"../lib/src/api.js\";\n\nexport default mod;\nexport const Alternation = mod.Alternation;\nexport const Alternative = mod.Alternative;\nexport const CstParser = mod.CstParser;\nexport const EMPTY_ALT = mod.EMPTY_ALT;\nexport const EOF = mod.EOF;\nexport const EarlyExitException = mod.EarlyExitException;\nexport const EmbeddedActionsParser = mod.EmbeddedActionsParser;\nexport const GAstVisitor = mod.GAstVisitor;\nexport const LLkLookaheadStrategy = mod.LLkLookaheadStrategy;\nexport const Lexer = mod.Lexer;\nexport const LexerDefinitionErrorType = mod.LexerDefinitionErrorType;\nexport const MismatchedTokenException = mod.MismatchedTokenException;\nexport const NoViableAltException = mod.NoViableAltException;\nexport const NonTerminal = mod.NonTerminal;\nexport const NotAllInputParsedException = mod.NotAllInputParsedException;\nexport const Option = mod.Option;\nexport const Parser = mod.Parser;\nexport const ParserDefinitionErrorType = mod.ParserDefinitionErrorType;\nexport const Repetition = mod.Repetition;\nexport const RepetitionMandatory = mod.RepetitionMandatory;\nexport const RepetitionMandatoryWithSeparator = mod.RepetitionMandatoryWithSeparator;\nexport const RepetitionWithSeparator = mod.RepetitionWithSeparator;\nexport const Rule = mod.Rule;\nexport const Terminal = mod.Terminal;\nexport const VERSION = mod.VERSION;\nexport const clearCache = mod.clearCache;\nexport const createSyntaxDiagramsCode = mod.createSyntaxDiagramsCode;\nexport const createToken = mod.createToken;\nexport const createTokenInstance = mod.createTokenInstance;\nexport const defaultLexerErrorProvider = mod.defaultLexerErrorProvider;\nexport const defaultParserErrorProvider = mod.defaultParserErrorProvider;\nexport const generateCstDts = mod.generateCstDts;\nexport const getLookaheadPaths = mod.getLookaheadPaths;\nexport const isRecognitionException = mod.isRecognitionException;\nexport const serializeGrammar = mod.serializeGrammar;\nexport const serializeProduction = mod.serializeProduction;\nexport const tokenLabel = mod.tokenLabel;\nexport const tokenMatcher = mod.tokenMatcher;\nexport const tokenName = mod.tokenName;\n", "/**\n * @author Deepkolos / https://github.com/deepkolos\n */\nclass WorkerPool {\n  constructor(pool = 4) {\n    this.pool = pool;\n    this.queue = [];\n    this.workers = [];\n    this.workersResolve = [];\n    this.workerStatus = 0;\n  }\n\n  _initWorker(workerId) {\n    if (!this.workers[workerId]) {\n      const worker = this.workerCreator();\n      worker.addEventListener('message', this._onMessage.bind(this, workerId));\n      this.workers[workerId] = worker;\n    }\n  }\n\n  _getIdleWorker() {\n    for (let i = 0; i < this.pool; i++) if (!(this.workerStatus & 1 << i)) return i;\n\n    return -1;\n  }\n\n  _onMessage(workerId, msg) {\n    const resolve = this.workersResolve[workerId];\n    resolve && resolve(msg);\n\n    if (this.queue.length) {\n      const {\n        resolve,\n        msg,\n        transfer\n      } = this.queue.shift();\n      this.workersResolve[workerId] = resolve;\n      this.workers[workerId].postMessage(msg, transfer);\n    } else {\n      this.workerStatus ^= 1 << workerId;\n    }\n  }\n\n  setWorkerCreator(workerCreator) {\n    this.workerCreator = workerCreator;\n  }\n\n  setWorkerLimit(pool) {\n    this.pool = pool;\n  }\n\n  postMessage(msg, transfer) {\n    return new Promise(resolve => {\n      const workerId = this._getIdleWorker();\n\n      if (workerId !== -1) {\n        this._initWorker(workerId);\n\n        this.workerStatus |= 1 << workerId;\n        this.workersResolve[workerId] = resolve;\n        this.workers[workerId].postMessage(msg, transfer);\n      } else {\n        this.queue.push({\n          resolve,\n          msg,\n          transfer\n        });\n      }\n    });\n  }\n\n  dispose() {\n    this.workers.forEach(worker => worker.terminate());\n    this.workersResolve.length = 0;\n    this.workers.length = 0;\n    this.queue.length = 0;\n    this.workerStatus = 0;\n  }\n\n}\n\nexport { WorkerPool };\n", "import { Loader, FileLoader, CompressedTexture, UnsignedByteType, LinearFilter, LinearMipmapLinearFilter, sRGBEncoding, LinearEncoding, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, FloatType, HalfFloatType, DataTexture, Data3DTexture, RGFormat, RedFormat } from 'three';\nimport { WorkerPool } from '../utils/WorkerPool.js';\nimport { KHR_DF_TRANSFER_SRGB, KHR_DF_FLAG_ALPHA_PREMULTIPLIED, read, VK_FORMAT_UNDEFINED, KHR_SUPERCOMPRESSION_NONE, KHR_SUPERCOMPRESSION_ZSTD, VK_FORMAT_R32G32B32A32_SFLOAT, VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SRGB, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R8G8_UNORM, VK_FORMAT_R8G8_SRGB, VK_FORMAT_R32_SFLOAT, VK_FORMAT_R16_SFLOAT, VK_FORMAT_R8_SRGB, VK_FORMAT_R8_UNORM } from 'ktx-parse';\nimport { ZSTDDecoder } from 'zstddec';\n\n/**\n * Loader for KTX 2.0 GPU Texture containers.\n *\n * KTX 2.0 is a container format for various GPU texture formats. The loader\n * supports Basis Universal GPU textures, which can be quickly transcoded to\n * a wide variety of GPU texture compression formats, as well as some\n * uncompressed DataTexture and Data3DTexture formats.\n *\n * References:\n * - KTX: http://github.khronos.org/KTX-Specification/\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\n */\n\nconst _taskCache = new WeakMap();\n\nlet _activeLoaders = 0;\n\nlet _zstd;\n\nclass KTX2Loader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.transcoderPath = '';\n    this.transcoderBinary = null;\n    this.transcoderPending = null;\n    this.workerPool = new WorkerPool();\n    this.workerSourceURL = '';\n    this.workerConfig = null;\n\n    if (typeof MSC_TRANSCODER !== 'undefined') {\n      console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' + ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\n    }\n  }\n\n  setTranscoderPath(path) {\n    this.transcoderPath = path;\n    return this;\n  }\n\n  setWorkerLimit(num) {\n    this.workerPool.setWorkerLimit(num);\n    return this;\n  }\n\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported: renderer.extensions.has('WEBGL_compressed_texture_pvrtc') || renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc')\n    };\n\n    if (renderer.capabilities.isWebGL2) {\n      // https://github.com/mrdoob/three.js/pull/22928\n      this.workerConfig.etc1Supported = false;\n    }\n\n    return this;\n  }\n\n  init() {\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      const jsLoader = new FileLoader(this.manager);\n      jsLoader.setPath(this.transcoderPath);\n      jsLoader.setWithCredentials(this.withCredentials);\n      const jsContent = jsLoader.loadAsync('basis_transcoder.js'); // Load transcoder WASM binary.\n\n      const binaryLoader = new FileLoader(this.manager);\n      binaryLoader.setPath(this.transcoderPath);\n      binaryLoader.setResponseType('arraybuffer');\n      binaryLoader.setWithCredentials(this.withCredentials);\n      const binaryContent = binaryLoader.loadAsync('basis_transcoder.wasm');\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n        const fn = KTX2Loader.BasisWorker.toString();\n        const body = ['/* constants */', 'let _EngineFormat = ' + JSON.stringify(KTX2Loader.EngineFormat), 'let _TranscoderFormat = ' + JSON.stringify(KTX2Loader.TranscoderFormat), 'let _BasisFormat = ' + JSON.stringify(KTX2Loader.BasisFormat), '/* basis_transcoder.js */', jsContent, '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n        this.transcoderBinary = binaryContent;\n        this.workerPool.setWorkerCreator(() => {\n          const worker = new Worker(this.workerSourceURL);\n          const transcoderBinary = this.transcoderBinary.slice(0);\n          worker.postMessage({\n            type: 'init',\n            config: this.workerConfig,\n            transcoderBinary\n          }, [transcoderBinary]);\n          return worker;\n        });\n      });\n\n      if (_activeLoaders > 0) {\n        // Each instance loads a transcoder and allocates workers, increasing network and memory cost.\n        console.warn('THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues.' + ' Use a single KTX2Loader instance, or call .dispose() on old instances.');\n      }\n\n      _activeLoaders++;\n    }\n\n    return this.transcoderPending;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (this.workerConfig === null) {\n      throw new Error('THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.');\n    }\n\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n      // again from this thread.\n      if (_taskCache.has(buffer)) {\n        const cachedTask = _taskCache.get(buffer);\n\n        return cachedTask.promise.then(onLoad).catch(onError);\n      }\n\n      this._createTexture(buffer).then(texture => onLoad ? onLoad(texture) : null).catch(onError);\n    }, onProgress, onError);\n  }\n\n  _createTextureFrom(transcodeResult) {\n    const {\n      mipmaps,\n      width,\n      height,\n      format,\n      type,\n      error,\n      dfdTransferFn,\n      dfdFlags\n    } = transcodeResult;\n    if (type === 'error') return Promise.reject(error);\n    const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n    texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n    texture.magFilter = LinearFilter;\n    texture.generateMipmaps = false;\n    texture.needsUpdate = true;\n    texture.encoding = dfdTransferFn === KHR_DF_TRANSFER_SRGB ? sRGBEncoding : LinearEncoding;\n    texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED);\n    return texture;\n  }\n  /**\n   * @param {ArrayBuffer} buffer\n   * @param {object?} config\n   * @return {Promise<CompressedTexture|DataTexture|Data3DTexture>}\n   */\n\n\n  _createTexture(buffer, config = {}) {\n    const container = read(new Uint8Array(buffer));\n\n    if (container.vkFormat !== VK_FORMAT_UNDEFINED) {\n      return createDataTexture(container);\n    } //\n\n\n    const taskConfig = config;\n    const texturePending = this.init().then(() => {\n      return this.workerPool.postMessage({\n        type: 'transcode',\n        buffer,\n        taskConfig: taskConfig\n      }, [buffer]);\n    }).then(e => this._createTextureFrom(e.data)); // Cache the task result.\n\n    _taskCache.set(buffer, {\n      promise: texturePending\n    });\n\n    return texturePending;\n  }\n\n  dispose() {\n    this.workerPool.dispose();\n    if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL);\n    _activeLoaders--;\n    return this;\n  }\n\n}\n/* CONSTANTS */\n\n\nKTX2Loader.BasisFormat = {\n  ETC1S: 0,\n  UASTC_4x4: 1\n};\nKTX2Loader.TranscoderFormat = {\n  ETC1: 0,\n  ETC2: 1,\n  BC1: 2,\n  BC3: 3,\n  BC4: 4,\n  BC5: 5,\n  BC7_M6_OPAQUE_ONLY: 6,\n  BC7_M5: 7,\n  PVRTC1_4_RGB: 8,\n  PVRTC1_4_RGBA: 9,\n  ASTC_4x4: 10,\n  ATC_RGB: 11,\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\n  RGBA32: 13,\n  RGB565: 14,\n  BGR565: 15,\n  RGBA4444: 16\n};\nKTX2Loader.EngineFormat = {\n  RGBAFormat: RGBAFormat,\n  RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format: RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format: RGB_ETC1_Format,\n  RGB_ETC2_Format: RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format\n};\n/* WEB WORKER */\n\nKTX2Loader.BasisWorker = function () {\n  let config;\n  let transcoderPending;\n  let BasisModule;\n  const EngineFormat = _EngineFormat; // eslint-disable-line no-undef\n\n  const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef\n\n  const BasisFormat = _BasisFormat; // eslint-disable-line no-undef\n\n  self.addEventListener('message', function (e) {\n    const message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        config = message.config;\n        init(message.transcoderBinary);\n        break;\n\n      case 'transcode':\n        transcoderPending.then(() => {\n          try {\n            const {\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format,\n              dfdTransferFn,\n              dfdFlags\n            } = transcode(message.buffer);\n            const buffers = [];\n\n            for (let i = 0; i < mipmaps.length; ++i) {\n              buffers.push(mipmaps[i].data.buffer);\n            }\n\n            self.postMessage({\n              type: 'transcode',\n              id: message.id,\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format,\n              dfdTransferFn,\n              dfdFlags\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          }\n        });\n        break;\n    }\n  });\n\n  function init(wasmBinary) {\n    transcoderPending = new Promise(resolve => {\n      BasisModule = {\n        wasmBinary,\n        onRuntimeInitialized: resolve\n      };\n      BASIS(BasisModule); // eslint-disable-line no-undef\n    }).then(() => {\n      BasisModule.initializeBasis();\n\n      if (BasisModule.KTX2File === undefined) {\n        console.warn('THREE.KTX2Loader: Please update Basis Universal transcoder.');\n      }\n    });\n  }\n\n  function transcode(buffer) {\n    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));\n\n    function cleanup() {\n      ktx2File.close();\n      ktx2File.delete();\n    }\n\n    if (!ktx2File.isValid()) {\n      cleanup();\n      throw new Error('THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file');\n    }\n\n    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n    const width = ktx2File.getWidth();\n    const height = ktx2File.getHeight();\n    const levels = ktx2File.getLevels();\n    const hasAlpha = ktx2File.getHasAlpha();\n    const dfdTransferFn = ktx2File.getDFDTransferFunc();\n    const dfdFlags = ktx2File.getDFDFlags();\n    const {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n\n    if (!width || !height || !levels) {\n      cleanup();\n      throw new Error('THREE.KTX2Loader:\tInvalid texture');\n    }\n\n    if (!ktx2File.startTranscoding()) {\n      cleanup();\n      throw new Error('THREE.KTX2Loader: .startTranscoding failed');\n    }\n\n    const mipmaps = [];\n\n    for (let mip = 0; mip < levels; mip++) {\n      const levelInfo = ktx2File.getImageLevelInfo(mip, 0, 0);\n      const mipWidth = levelInfo.origWidth;\n      const mipHeight = levelInfo.origHeight;\n      const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, 0, 0, transcoderFormat));\n      const status = ktx2File.transcodeImage(dst, mip, 0, 0, transcoderFormat, 0, -1, -1);\n\n      if (!status) {\n        cleanup();\n        throw new Error('THREE.KTX2Loader: .transcodeImage failed.');\n      }\n\n      mipmaps.push({\n        data: dst,\n        width: mipWidth,\n        height: mipHeight\n      });\n    }\n\n    cleanup();\n    return {\n      width,\n      height,\n      hasAlpha,\n      mipmaps,\n      format: engineFormat,\n      dfdTransferFn,\n      dfdFlags\n    };\n  } //\n  // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n  // device capabilities, and texture dimensions. The list below ranks the formats separately\n  // for ETC1S and UASTC.\n  //\n  // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n  // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n  // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n\n\n  const FORMAT_OPTIONS = [{\n    if: 'astcSupported',\n    basisFormat: [BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n    priorityETC1S: Infinity,\n    priorityUASTC: 1,\n    needsPowerOfTwo: false\n  }, {\n    if: 'bptcSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n    priorityETC1S: 3,\n    priorityUASTC: 2,\n    needsPowerOfTwo: false\n  }, {\n    if: 'dxtSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n    priorityETC1S: 4,\n    priorityUASTC: 5,\n    needsPowerOfTwo: false\n  }, {\n    if: 'etc2Supported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n    priorityETC1S: 1,\n    priorityUASTC: 3,\n    needsPowerOfTwo: false\n  }, {\n    if: 'etc1Supported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1],\n    engineFormat: [EngineFormat.RGB_ETC1_Format],\n    priorityETC1S: 2,\n    priorityUASTC: 4,\n    needsPowerOfTwo: false\n  }, {\n    if: 'pvrtcSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n    priorityETC1S: 5,\n    priorityUASTC: 6,\n    needsPowerOfTwo: true\n  }];\n  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityETC1S - b.priorityETC1S;\n  });\n  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityUASTC - b.priorityUASTC;\n  });\n\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n    let transcoderFormat;\n    let engineFormat;\n    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n\n    for (let i = 0; i < options.length; i++) {\n      const opt = options[i];\n      if (!config[opt.if]) continue;\n      if (!opt.basisFormat.includes(basisFormat)) continue;\n      if (hasAlpha && opt.transcoderFormat.length < 2) continue;\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n      return {\n        transcoderFormat,\n        engineFormat\n      };\n    }\n\n    console.warn('THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.');\n    transcoderFormat = TranscoderFormat.RGBA32;\n    engineFormat = EngineFormat.RGBAFormat;\n    return {\n      transcoderFormat,\n      engineFormat\n    };\n  }\n\n  function isPowerOfTwo(value) {\n    if (value <= 2) return true;\n    return (value & value - 1) === 0 && value !== 0;\n  }\n}; //\n// DataTexture and Data3DTexture parsing.\n\n\nconst FORMAT_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,\n  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,\n  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,\n  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,\n  [VK_FORMAT_R8G8_UNORM]: RGFormat,\n  [VK_FORMAT_R8G8_SRGB]: RGFormat,\n  [VK_FORMAT_R32_SFLOAT]: RedFormat,\n  [VK_FORMAT_R16_SFLOAT]: RedFormat,\n  [VK_FORMAT_R8_SRGB]: RedFormat,\n  [VK_FORMAT_R8_UNORM]: RedFormat\n};\nconst TYPE_MAP = {\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R32G32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,\n  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R32_SFLOAT]: FloatType,\n  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,\n  [VK_FORMAT_R8_SRGB]: UnsignedByteType,\n  [VK_FORMAT_R8_UNORM]: UnsignedByteType\n};\nconst ENCODING_MAP = {\n  [VK_FORMAT_R8G8B8A8_SRGB]: sRGBEncoding,\n  [VK_FORMAT_R8G8_SRGB]: sRGBEncoding,\n  [VK_FORMAT_R8_SRGB]: sRGBEncoding\n};\n\nasync function createDataTexture(container) {\n  const {\n    vkFormat,\n    pixelWidth,\n    pixelHeight,\n    pixelDepth\n  } = container;\n\n  if (FORMAT_MAP[vkFormat] === undefined) {\n    throw new Error('THREE.KTX2Loader: Unsupported vkFormat.');\n  } //\n\n\n  const level = container.levels[0];\n  let levelData;\n  let view;\n\n  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\n    levelData = level.levelData;\n  } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\n    if (!_zstd) {\n      _zstd = new Promise(async resolve => {\n        const zstd = new ZSTDDecoder();\n        await zstd.init();\n        resolve(zstd);\n      });\n    }\n\n    levelData = (await _zstd).decode(level.levelData, level.uncompressedByteLength);\n  } else {\n    throw new Error('THREE.KTX2Loader: Unsupported supercompressionScheme.');\n  }\n\n  if (TYPE_MAP[vkFormat] === FloatType) {\n    view = new Float32Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT);\n  } else if (TYPE_MAP[vkFormat] === HalfFloatType) {\n    view = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT);\n  } else {\n    view = levelData;\n  } //\n\n\n  const texture = pixelDepth === 0 ? new DataTexture(view, pixelWidth, pixelHeight) : new Data3DTexture(view, pixelWidth, pixelHeight, pixelDepth);\n  texture.type = TYPE_MAP[vkFormat];\n  texture.format = FORMAT_MAP[vkFormat];\n  texture.encoding = ENCODING_MAP[vkFormat] || LinearEncoding;\n  texture.needsUpdate = true; //\n\n  return Promise.resolve(texture);\n}\n\nexport { KTX2Loader };\n", "import { Loader, LoaderUtils, FileLoader, TextureLoader, Vector3, Quaternion, Matrix4, Skeleton, BufferGeometry, MeshLambertMaterial, BufferAttribute, Mesh, SkinnedMesh, Object3D, MeshPhongMaterial, Bone, Color } from 'three';\n\nvar AssimpLoader = function (manager) {\n  Loader.call(this, manager);\n};\n\nAssimpLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: AssimpLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function (buffer, path) {\n    var textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var Virtulous = {};\n\n    Virtulous.KeyFrame = function (time, matrix) {\n      this.time = time;\n      this.matrix = matrix.clone();\n      this.position = new Vector3();\n      this.quaternion = new Quaternion();\n      this.scale = new Vector3(1, 1, 1);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n\n      this.clone = function () {\n        var n = new Virtulous.KeyFrame(this.time, this.matrix);\n        return n;\n      };\n\n      this.lerp = function (nextKey, time) {\n        time -= this.time;\n        var dist = nextKey.time - this.time;\n        var l = time / dist;\n        var l2 = 1 - l;\n        var keypos = this.position;\n        var keyrot = this.quaternion; //      var keyscl =  key.parentspaceScl || key.scl;\n\n        var key2pos = nextKey.position;\n        var key2rot = nextKey.quaternion; //  var key2scl =  key2.parentspaceScl || key2.scl;\n\n        Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n        Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n        Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l; //     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n        //     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n        //     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n\n        Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\n        Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\n        return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\n      };\n    };\n\n    Virtulous.KeyFrame.tempAniPos = new Vector3();\n    Virtulous.KeyFrame.tempAniQuat = new Quaternion();\n    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);\n    Virtulous.KeyFrame.tempAniMatrix = new Matrix4();\n\n    Virtulous.KeyFrameTrack = function () {\n      this.keys = [];\n      this.target = null;\n      this.time = 0;\n      this.length = 0;\n      this._accelTable = {};\n      this.fps = 20;\n\n      this.addKey = function (key) {\n        this.keys.push(key);\n      };\n\n      this.init = function () {\n        this.sortKeys();\n        if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\n        if (!this.fps) return;\n\n        for (let j = 0; j < this.length * this.fps; j++) {\n          for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i].time == j) {\n              this._accelTable[j] = i;\n              break;\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n              this._accelTable[j] = i;\n              break;\n            }\n          }\n        }\n      };\n\n      this.parseFromThree = function (data) {\n        var fps = data.fps;\n        this.target = data.node;\n        var track = data.hierarchy[0].keys;\n\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\n        }\n\n        this.init();\n      };\n\n      this.parseFromCollada = function (data) {\n        var track = data.keys;\n        var fps = this.fps;\n\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\n        }\n\n        this.init();\n      };\n\n      this.sortKeys = function () {\n        this.keys.sort(this.keySortFunc);\n      };\n\n      this.keySortFunc = function (a, b) {\n        return a.time - b.time;\n      };\n\n      this.clone = function () {\n        var t = new Virtulous.KeyFrameTrack();\n        t.target = this.target;\n        t.time = this.time;\n        t.length = this.length;\n\n        for (let i = 0; i < this.keys.length; i++) {\n          t.addKey(this.keys[i].clone());\n        }\n\n        t.init();\n        return t;\n      };\n\n      this.reTarget = function (root, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        this.target = compareitor(root, this.target);\n      };\n\n      this.keySearchAccel = function (time) {\n        time *= this.fps;\n        time = Math.floor(time);\n        return this._accelTable[time] || 0;\n      };\n\n      this.setTime = function (time) {\n        time = Math.abs(time);\n        if (this.length) time = time % this.length + 0.05;\n        var key0 = null;\n        var key1 = null;\n\n        for (let i = this.keySearchAccel(time); i < this.keys.length; i++) {\n          if (this.keys[i].time == time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i];\n            break;\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i + 1];\n            break;\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n            key0 = this.keys[i];\n            key1 = this.keys[0].clone();\n            key1.time += this.length + 0.05;\n            break;\n          }\n        }\n\n        if (key0 && key1 && key0 !== key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.lerp(key1, time));\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n\n        if (key0 && key1 && key0 == key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.matrix);\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n      };\n    };\n\n    Virtulous.TrackTargetNodeNameCompare = function (root, target) {\n      function find(node, name) {\n        if (node.name == name) return node;\n\n        for (let i = 0; i < node.children.length; i++) {\n          var r = find(node.children[i], name);\n          if (r) return r;\n        }\n\n        return null;\n      }\n\n      return find(root, target.name);\n    };\n\n    Virtulous.Animation = function () {\n      this.tracks = [];\n      this.length = 0;\n\n      this.addTrack = function (track) {\n        this.tracks.push(track);\n        this.length = Math.max(track.length, this.length);\n      };\n\n      this.setTime = function (time) {\n        this.time = time;\n\n        for (let i = 0; i < this.tracks.length; i++) this.tracks[i].setTime(time);\n      };\n\n      this.clone = function (target, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        var n = new Virtulous.Animation();\n        n.target = target;\n\n        for (let i = 0; i < this.tracks.length; i++) {\n          var track = this.tracks[i].clone();\n          track.reTarget(target, compareitor);\n          n.addTrack(track);\n        }\n\n        return n;\n      };\n    };\n\n    var ASSBIN_CHUNK_AICAMERA = 0x1234;\n    var ASSBIN_CHUNK_AILIGHT = 0x1235;\n    var ASSBIN_CHUNK_AITEXTURE = 0x1236;\n    var ASSBIN_CHUNK_AIMESH = 0x1237;\n    var ASSBIN_CHUNK_AINODEANIM = 0x1238;\n    var ASSBIN_CHUNK_AISCENE = 0x1239;\n    var ASSBIN_CHUNK_AIBONE = 0x123a;\n    var ASSBIN_CHUNK_AIANIMATION = 0x123b;\n    var ASSBIN_CHUNK_AINODE = 0x123c;\n    var ASSBIN_CHUNK_AIMATERIAL = 0x123d;\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\n    var ASSBIN_MESH_HAS_POSITIONS = 0x1;\n    var ASSBIN_MESH_HAS_NORMALS = 0x2;\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\n    var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4; //var aiLightSource_UNDEFINED = 0x0;\n    //! A directional light source has a well-defined direction\n    //! but is infinitely far away. That's quite a good\n    //! approximation for sun light.\n\n    var aiLightSource_DIRECTIONAL = 0x1; //! A point light source has a well-defined position\n    //! in space but no direction - it emits light in all\n    //! directions. A normal bulb is a point light.\n    //var aiLightSource_POINT = 0x2;\n    //! A spot light source emits light in a specific\n    //! angle. It has a position and a direction it is pointing to.\n    //! A good example for a spot light is a light spot in\n    //! sport arenas.\n\n    var aiLightSource_SPOT = 0x3; //! The generic light level of the world, including the bounces\n    //! of all other lightsources.\n    //! Typically, there's at most one ambient light in a scene.\n    //! This light type doesn't have a valid position, direction, or\n    //! other properties, just a color.\n    //var aiLightSource_AMBIENT = 0x4;\n\n    /** Flat shading. Shading is done on per-face base,\n     *  diffuse only. Also known as 'faceted shading'.\n     */\n    //var aiShadingMode_Flat = 0x1;\n\n    /** Simple Gouraud shading.\n     */\n    //var aiShadingMode_Gouraud = 0x2;\n\n    /** Phong-Shading -\n     */\n    //var aiShadingMode_Phong = 0x3;\n\n    /** Phong-Blinn-Shading\n     */\n    //var aiShadingMode_Blinn = 0x4;\n\n    /** Toon-Shading per pixel\n     *\n     *  Also known as 'comic' shader.\n     */\n    //var aiShadingMode_Toon = 0x5;\n\n    /** OrenNayar-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  roughness of the material into account\n     */\n    //var aiShadingMode_OrenNayar = 0x6;\n\n    /** Minnaert-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  \"darkness\" of the material into account\n     */\n    //var aiShadingMode_Minnaert = 0x7;\n\n    /** CookTorrance-Shading per pixel\n     *\n     *  Special shader for metallic surfaces.\n     */\n    //var aiShadingMode_CookTorrance = 0x8;\n\n    /** No shading at all. Constant light influence of 1.0.\n     */\n    //var aiShadingMode_NoShading = 0x9;\n\n    /** Fresnel shading\n     */\n    //var aiShadingMode_Fresnel = 0xa;\n    //var aiTextureType_NONE = 0x0;\n\n    /** The texture is combined with the result of the diffuse\n     *  lighting equation.\n     */\n\n    var aiTextureType_DIFFUSE = 0x1;\n    /** The texture is combined with the result of the specular\n     *  lighting equation.\n     */\n    //var aiTextureType_SPECULAR = 0x2;\n\n    /** The texture is combined with the result of the ambient\n     *  lighting equation.\n     */\n    //var aiTextureType_AMBIENT = 0x3;\n\n    /** The texture is added to the result of the lighting\n     *  calculation. It isn't influenced by incoming light.\n     */\n    //var aiTextureType_EMISSIVE = 0x4;\n\n    /** The texture is a height map.\n     *\n     *  By convention, higher gray-scale values stand for\n     *  higher elevations from the base height.\n     */\n    //var aiTextureType_HEIGHT = 0x5;\n\n    /** The texture is a (tangent space) normal-map.\n     *\n     *  Again, there are several conventions for tangent-space\n     *  normal maps. Assimp does (intentionally) not\n     *  distinguish here.\n     */\n\n    var aiTextureType_NORMALS = 0x6;\n    /** The texture defines the glossiness of the material.\n     *\n     *  The glossiness is in fact the exponent of the specular\n     *  (phong) lighting equation. Usually there is a conversion\n     *  function defined to map the linear color values in the\n     *  texture to a suitable exponent. Have fun.\n     */\n    //var aiTextureType_SHININESS = 0x7;\n\n    /** The texture defines per-pixel opacity.\n     *\n     *  Usually 'white' means opaque and 'black' means\n     *  'transparency'. Or quite the opposite. Have fun.\n     */\n\n    var aiTextureType_OPACITY = 0x8;\n    /** Displacement texture\n     *\n     *  The exact purpose and format is application-dependent.\n     *  Higher color values stand for higher vertex displacements.\n     */\n    //var aiTextureType_DISPLACEMENT = 0x9;\n\n    /** Lightmap texture (aka Ambient Occlusion)\n     *\n     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n     *  covered by this material property. The texture contains a\n     *  scaling value for the final color value of a pixel. Its\n     *  intensity is not affected by incoming light.\n     */\n\n    var aiTextureType_LIGHTMAP = 0xa;\n    /** Reflection texture\n     *\n     * Contains the color of a perfect mirror reflection.\n     * Rarely used, almost never for real-time applications.\n     */\n    //var aiTextureType_REFLECTION = 0xB;\n\n    /** Unknown texture\n     *\n     *  A texture reference that does not match any of the definitions\n     *  above is considered to be 'unknown'. It is still imported,\n     *  but is excluded from any further postprocessing.\n     */\n    //var aiTextureType_UNKNOWN = 0xC;\n\n    var BONESPERVERT = 4;\n\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n    }\n\n    function ASSBIN_MESH_HAS_COLOR(n) {\n      return ASSBIN_MESH_HAS_COLOR_BASE << n;\n    }\n\n    function markBones(scene) {\n      for (let i in scene.mMeshes) {\n        var mesh = scene.mMeshes[i];\n\n        for (let k in mesh.mBones) {\n          var boneNode = scene.findNode(mesh.mBones[k].mName);\n          if (boneNode) boneNode.isBone = true;\n        }\n      }\n    }\n\n    function cloneTreeToBones(root, scene) {\n      var rootBone = new Bone();\n      rootBone.matrix.copy(root.matrix);\n      rootBone.matrixWorld.copy(root.matrixWorld);\n      rootBone.position.copy(root.position);\n      rootBone.quaternion.copy(root.quaternion);\n      rootBone.scale.copy(root.scale);\n      scene.nodeCount++;\n      rootBone.name = 'bone_' + root.name + scene.nodeCount.toString();\n      if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\n      scene.nodeToBoneMap[root.name].push(rootBone);\n\n      for (let i in root.children) {\n        var child = cloneTreeToBones(root.children[i], scene);\n        rootBone.add(child);\n      }\n\n      return rootBone;\n    }\n\n    function sortWeights(indexes, weights) {\n      var pairs = [];\n\n      for (let i = 0; i < indexes.length; i++) {\n        pairs.push({\n          i: indexes[i],\n          w: weights[i]\n        });\n      }\n\n      pairs.sort(function (a, b) {\n        return b.w - a.w;\n      });\n\n      while (pairs.length < 4) {\n        pairs.push({\n          i: 0,\n          w: 0\n        });\n      }\n\n      if (pairs.length > 4) pairs.length = 4;\n      var sum = 0;\n\n      for (let i = 0; i < 4; i++) {\n        sum += pairs[i].w * pairs[i].w;\n      }\n\n      sum = Math.sqrt(sum);\n\n      for (let i = 0; i < 4; i++) {\n        pairs[i].w = pairs[i].w / sum;\n        indexes[i] = pairs[i].i;\n        weights[i] = pairs[i].w;\n      }\n    }\n\n    function findMatchingBone(root, name) {\n      if (root.name.indexOf('bone_' + name) == 0) return root;\n\n      for (let i in root.children) {\n        var ret = findMatchingBone(root.children[i], name);\n        if (ret) return ret;\n      }\n\n      return undefined;\n    }\n\n    function aiMesh() {\n      this.mPrimitiveTypes = 0;\n      this.mNumVertices = 0;\n      this.mNumFaces = 0;\n      this.mNumBones = 0;\n      this.mMaterialIndex = 0;\n      this.mVertices = [];\n      this.mNormals = [];\n      this.mTangents = [];\n      this.mBitangents = [];\n      this.mColors = [[]];\n      this.mTextureCoords = [[]];\n      this.mFaces = [];\n      this.mBones = [];\n\n      this.hookupSkeletons = function (scene) {\n        if (this.mBones.length == 0) return;\n        var allBones = [];\n        var offsetMatrix = [];\n        var skeletonRoot = scene.findNode(this.mBones[0].mName);\n\n        while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n          skeletonRoot = skeletonRoot.mParent;\n        }\n\n        var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n        var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n        this.threeNode.add(threeSkeletonRootBone);\n\n        for (let i = 0; i < this.mBones.length; i++) {\n          var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n\n          if (bone) {\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          } else {\n            var skeletonRoot = scene.findNode(this.mBones[i].mName);\n            if (!skeletonRoot) return;\n            var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n            var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n            this.threeNode.add(threeSkeletonRootBone);\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          }\n        }\n\n        var skeleton = new Skeleton(allBones, offsetMatrix);\n        this.threeNode.bind(skeleton, new Matrix4());\n        this.threeNode.material.skinning = true;\n      };\n\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var geometry = new BufferGeometry();\n        var mat;\n        if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new MeshLambertMaterial();\n        geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));\n        geometry.setAttribute('position', new BufferAttribute(this.mVertexBuffer, 3));\n\n        if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\n          geometry.setAttribute('normal', new BufferAttribute(this.mNormalBuffer, 3));\n        }\n\n        if (this.mColorBuffer && this.mColorBuffer.length > 0) {\n          geometry.setAttribute('color', new BufferAttribute(this.mColorBuffer, 4));\n        }\n\n        if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\n          geometry.setAttribute('uv', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\n        }\n\n        if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\n          geometry.setAttribute('uv1', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\n        }\n\n        if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\n          geometry.setAttribute('tangents', new BufferAttribute(this.mTangentBuffer, 3));\n        }\n\n        if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\n          geometry.setAttribute('bitangents', new BufferAttribute(this.mBitangentBuffer, 3));\n        }\n\n        if (this.mBones.length > 0) {\n          var weights = [];\n          var bones = [];\n\n          for (let i = 0; i < this.mBones.length; i++) {\n            for (let j = 0; j < this.mBones[i].mWeights.length; j++) {\n              var weight = this.mBones[i].mWeights[j];\n\n              if (weight) {\n                if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\n                if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\n                weights[weight.mVertexId].push(weight.mWeight);\n                bones[weight.mVertexId].push(parseInt(i));\n              }\n            }\n          }\n\n          for (let i in bones) {\n            sortWeights(bones[i], weights[i]);\n          }\n\n          var _weights = [];\n          var _bones = [];\n\n          for (let i = 0; i < weights.length; i++) {\n            for (let j = 0; j < 4; j++) {\n              if (weights[i] && bones[i]) {\n                _weights.push(weights[i][j]);\n\n                _bones.push(bones[i][j]);\n              } else {\n                _weights.push(0);\n\n                _bones.push(0);\n              }\n            }\n          }\n\n          geometry.setAttribute('skinWeight', new BufferAttribute(new Float32Array(_weights), BONESPERVERT));\n          geometry.setAttribute('skinIndex', new BufferAttribute(new Float32Array(_bones), BONESPERVERT));\n        }\n\n        var mesh;\n        if (this.mBones.length == 0) mesh = new Mesh(geometry, mat);\n\n        if (this.mBones.length > 0) {\n          mesh = new SkinnedMesh(geometry, mat);\n          mesh.normalizeSkinWeights();\n        }\n\n        this.threeNode = mesh; //mesh.matrixAutoUpdate = false;\n\n        return mesh;\n      };\n    }\n\n    function aiFace() {\n      this.mNumIndices = 0;\n      this.mIndices = [];\n    }\n\n    function aiVector3D() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n\n      this.toTHREE = function () {\n        return new Vector3(this.x, this.y, this.z);\n      };\n    }\n\n    function aiColor3D() {\n      this.r = 0;\n      this.g = 0;\n      this.b = 0;\n      this.a = 0;\n\n      this.toTHREE = function () {\n        return new Color(this.r, this.g, this.b);\n      };\n    }\n\n    function aiQuaternion() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      this.w = 0;\n\n      this.toTHREE = function () {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n      };\n    }\n\n    function aiVertexWeight() {\n      this.mVertexId = 0;\n      this.mWeight = 0;\n    }\n\n    function aiString() {\n      this.data = [];\n\n      this.toString = function () {\n        var str = '';\n        this.data.forEach(function (i) {\n          str += String.fromCharCode(i);\n        });\n        return str.replace(/[^\\x20-\\x7E]+/g, '');\n      };\n    }\n\n    function aiVectorKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n\n    function aiQuatKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n\n    function aiNode() {\n      this.mName = '';\n      this.mTransformation = [];\n      this.mNumChildren = 0;\n      this.mNumMeshes = 0;\n      this.mMeshes = [];\n      this.mChildren = [];\n\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var o = new Object3D();\n        o.name = this.mName;\n        o.matrix = this.mTransformation.toTHREE();\n\n        for (let i = 0; i < this.mChildren.length; i++) {\n          o.add(this.mChildren[i].toTHREE(scene));\n        }\n\n        for (let i = 0; i < this.mMeshes.length; i++) {\n          o.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene));\n        }\n\n        this.threeNode = o; //o.matrixAutoUpdate = false;\n\n        o.matrix.decompose(o.position, o.quaternion, o.scale);\n        return o;\n      };\n    }\n\n    function aiBone() {\n      this.mName = '';\n      this.mNumWeights = 0;\n      this.mOffsetMatrix = 0;\n    }\n\n    function aiMaterialProperty() {\n      this.mKey = '';\n      this.mSemantic = 0;\n      this.mIndex = 0;\n      this.mData = [];\n      this.mDataLength = 0;\n      this.mType = 0;\n\n      this.dataAsColor = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        var g = reader.getFloat32(4, true);\n        var b = reader.getFloat32(8, true); //var a = reader.getFloat32(12, true);\n\n        return new Color(r, g, b);\n      };\n\n      this.dataAsFloat = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return r;\n      };\n\n      this.dataAsBool = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return !!r;\n      };\n\n      this.dataAsString = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        return s.toString();\n      };\n\n      this.dataAsMap = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        var path = s.toString();\n        path = path.replace(/\\\\/g, '/');\n\n        if (path.indexOf('/') != -1) {\n          path = path.substr(path.lastIndexOf('/') + 1);\n        }\n\n        return textureLoader.load(path);\n      };\n    }\n\n    var namePropMapping = {\n      '?mat.name': 'name',\n      '$mat.shadingm': 'shading',\n      '$mat.twosided': 'twoSided',\n      '$mat.wireframe': 'wireframe',\n      '$clr.ambient': 'ambient',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'specular',\n      '$clr.emissive': 'emissive',\n      '$clr.transparent': 'transparent',\n      '$clr.reflective': 'reflect',\n      '$mat.shininess': 'shininess',\n      '$mat.reflectivity': 'reflectivity',\n      '$mat.refracti': 'refraction',\n      '$tex.file': 'map'\n    };\n    var nameTypeMapping = {\n      '?mat.name': 'string',\n      '$mat.shadingm': 'bool',\n      '$mat.twosided': 'bool',\n      '$mat.wireframe': 'bool',\n      '$clr.ambient': 'color',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'color',\n      '$clr.emissive': 'color',\n      '$clr.transparent': 'color',\n      '$clr.reflective': 'color',\n      '$mat.shininess': 'float',\n      '$mat.reflectivity': 'float',\n      '$mat.refracti': 'float',\n      '$tex.file': 'map'\n    };\n\n    function aiMaterial() {\n      this.mNumAllocated = 0;\n      this.mNumProperties = 0;\n      this.mProperties = [];\n\n      this.toTHREE = function () {\n        var mat = new MeshPhongMaterial();\n\n        for (let i = 0; i < this.mProperties.length; i++) {\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'float') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'color') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'bool') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'string') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\n            var prop = this.mProperties[i];\n            if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\n          }\n        }\n\n        mat.ambient.r = 0.53;\n        mat.ambient.g = 0.53;\n        mat.ambient.b = 0.53;\n        mat.color.r = 1;\n        mat.color.g = 1;\n        mat.color.b = 1;\n        return mat;\n      };\n    }\n\n    function veclerp(v1, v2, l) {\n      var v = new Vector3();\n      var lm1 = 1 - l;\n      v.x = v1.x * l + v2.x * lm1;\n      v.y = v1.y * l + v2.y * lm1;\n      v.z = v1.z * l + v2.z * lm1;\n      return v;\n    }\n\n    function quatlerp(q1, q2, l) {\n      return q1.clone().slerp(q2, 1 - l);\n    }\n\n    function sampleTrack(keys, time, lne, lerp) {\n      if (keys.length == 1) return keys[0].mValue.toTHREE();\n      var dist = Infinity;\n      var key = null;\n      var nextKey = null;\n\n      for (let i = 0; i < keys.length; i++) {\n        var timeDist = Math.abs(keys[i].mTime - time);\n\n        if (timeDist < dist && keys[i].mTime <= time) {\n          dist = timeDist;\n          key = keys[i];\n          nextKey = keys[i + 1];\n        }\n      }\n\n      if (!key) {\n        return null;\n      } else if (nextKey) {\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      } else {\n        nextKey = keys[0].clone();\n        nextKey.mTime += lne;\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      }\n    }\n\n    function aiNodeAnim() {\n      this.mNodeName = '';\n      this.mNumPositionKeys = 0;\n      this.mNumRotationKeys = 0;\n      this.mNumScalingKeys = 0;\n      this.mPositionKeys = [];\n      this.mRotationKeys = [];\n      this.mScalingKeys = [];\n      this.mPreState = '';\n      this.mPostState = '';\n\n      this.init = function (tps) {\n        if (!tps) tps = 1;\n\n        function t(t) {\n          t.mTime /= tps;\n        }\n\n        this.mPositionKeys.forEach(t);\n        this.mRotationKeys.forEach(t);\n        this.mScalingKeys.forEach(t);\n      };\n\n      this.sortKeys = function () {\n        function comp(a, b) {\n          return a.mTime - b.mTime;\n        }\n\n        this.mPositionKeys.sort(comp);\n        this.mRotationKeys.sort(comp);\n        this.mScalingKeys.sort(comp);\n      };\n\n      this.getLength = function () {\n        return Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mRotationKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mScalingKeys.map(function (a) {\n          return a.mTime;\n        })));\n      };\n\n      this.toTHREE = function (o) {\n        this.sortKeys();\n        var length = this.getLength();\n        var track = new Virtulous.KeyFrameTrack();\n\n        for (let i = 0; i < length; i += 0.05) {\n          var matrix = new Matrix4();\n          var time = i;\n          var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\n          var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\n          var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\n          matrix.compose(pos, rotation, scale);\n          var key = new Virtulous.KeyFrame(time, matrix);\n          track.addKey(key);\n        }\n\n        track.target = o.findNode(this.mNodeName).toTHREE();\n        var tracks = [track];\n\n        if (o.nodeToBoneMap[this.mNodeName]) {\n          for (let i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++) {\n            var t2 = track.clone();\n            t2.target = o.nodeToBoneMap[this.mNodeName][i];\n            tracks.push(t2);\n          }\n        }\n\n        return tracks;\n      };\n    }\n\n    function aiAnimation() {\n      this.mName = '';\n      this.mDuration = 0;\n      this.mTicksPerSecond = 0;\n      this.mNumChannels = 0;\n      this.mChannels = [];\n\n      this.toTHREE = function (root) {\n        var animationHandle = new Virtulous.Animation();\n\n        for (let i in this.mChannels) {\n          this.mChannels[i].init(this.mTicksPerSecond);\n          var tracks = this.mChannels[i].toTHREE(root);\n\n          for (let j in tracks) {\n            tracks[j].init();\n            animationHandle.addTrack(tracks[j]);\n          }\n        }\n\n        animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\n          return e.length;\n        }));\n        return animationHandle;\n      };\n    }\n\n    function aiTexture() {\n      this.mWidth = 0;\n      this.mHeight = 0;\n      this.texAchFormatHint = [];\n      this.pcData = [];\n    }\n\n    function aiLight() {\n      this.mName = '';\n      this.mType = 0;\n      this.mAttenuationConstant = 0;\n      this.mAttenuationLinear = 0;\n      this.mAttenuationQuadratic = 0;\n      this.mAngleInnerCone = 0;\n      this.mAngleOuterCone = 0;\n      this.mColorDiffuse = null;\n      this.mColorSpecular = null;\n      this.mColorAmbient = null;\n    }\n\n    function aiCamera() {\n      this.mName = '';\n      this.mPosition = null;\n      this.mLookAt = null;\n      this.mUp = null;\n      this.mHorizontalFOV = 0;\n      this.mClipPlaneNear = 0;\n      this.mClipPlaneFar = 0;\n      this.mAspect = 0;\n    }\n\n    function aiScene() {\n      this.versionMajor = 0;\n      this.versionMinor = 0;\n      this.versionRevision = 0;\n      this.compileFlags = 0;\n      this.mFlags = 0;\n      this.mNumMeshes = 0;\n      this.mNumMaterials = 0;\n      this.mNumAnimations = 0;\n      this.mNumTextures = 0;\n      this.mNumLights = 0;\n      this.mNumCameras = 0;\n      this.mRootNode = null;\n      this.mMeshes = [];\n      this.mMaterials = [];\n      this.mAnimations = [];\n      this.mLights = [];\n      this.mCameras = [];\n      this.nodeToBoneMap = {};\n\n      this.findNode = function (name, root) {\n        if (!root) {\n          root = this.mRootNode;\n        }\n\n        if (root.mName == name) {\n          return root;\n        }\n\n        for (let i = 0; i < root.mChildren.length; i++) {\n          var ret = this.findNode(name, root.mChildren[i]);\n          if (ret) return ret;\n        }\n\n        return null;\n      };\n\n      this.toTHREE = function () {\n        this.nodeCount = 0;\n        markBones(this);\n        var o = this.mRootNode.toTHREE(this);\n\n        for (let i in this.mMeshes) this.mMeshes[i].hookupSkeletons(this);\n\n        if (this.mAnimations.length > 0) {\n          var a = this.mAnimations[0].toTHREE(this);\n        }\n\n        return {\n          object: o,\n          animation: a\n        };\n      };\n    }\n\n    function aiMatrix4() {\n      this.elements = [[], [], [], []];\n\n      this.toTHREE = function () {\n        var m = new Matrix4();\n\n        for (let i = 0; i < 4; ++i) {\n          for (let i2 = 0; i2 < 4; ++i2) {\n            m.elements[i * 4 + i2] = this.elements[i2][i];\n          }\n        }\n\n        return m;\n      };\n    }\n\n    var littleEndian = true;\n\n    function readFloat(dataview) {\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_double(dataview) {\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian);\n      dataview.readOffset += 8;\n      return val;\n    }\n\n    function Read_uint8_t(dataview) {\n      var val = dataview.getUint8(dataview.readOffset);\n      dataview.readOffset += 1;\n      return val;\n    }\n\n    function Read_uint16_t(dataview) {\n      var val = dataview.getUint16(dataview.readOffset, littleEndian);\n      dataview.readOffset += 2;\n      return val;\n    }\n\n    function Read_unsigned_int(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_uint32_t(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_aiVector3D(stream) {\n      var v = new aiVector3D();\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n\n    function Read_aiColor3D(stream) {\n      var c = new aiColor3D();\n      c.r = readFloat(stream);\n      c.g = readFloat(stream);\n      c.b = readFloat(stream);\n      return c;\n    }\n\n    function Read_aiQuaternion(stream) {\n      var v = new aiQuaternion();\n      v.w = readFloat(stream);\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n\n    function Read_aiString(stream) {\n      var s = new aiString();\n      var stringlengthbytes = Read_unsigned_int(stream);\n      stream.ReadBytes(s.data, 1, stringlengthbytes);\n      return s.toString();\n    }\n\n    function Read_aiVertexWeight(stream) {\n      var w = new aiVertexWeight();\n      w.mVertexId = Read_unsigned_int(stream);\n      w.mWeight = readFloat(stream);\n      return w;\n    }\n\n    function Read_aiMatrix4x4(stream) {\n      var m = new aiMatrix4();\n\n      for (let i = 0; i < 4; ++i) {\n        for (let i2 = 0; i2 < 4; ++i2) {\n          m.elements[i][i2] = readFloat(stream);\n        }\n      }\n\n      return m;\n    }\n\n    function Read_aiVectorKey(stream) {\n      var v = new aiVectorKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiVector3D(stream);\n      return v;\n    }\n\n    function Read_aiQuatKey(stream) {\n      var v = new aiQuatKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiQuaternion(stream);\n      return v;\n    }\n\n    function ReadArray_aiVertexWeight(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVertexWeight(stream);\n    }\n\n    function ReadArray_aiVectorKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVectorKey(stream);\n    }\n\n    function ReadArray_aiQuatKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiQuatKey(stream);\n    }\n\n    function ReadBounds(stream, T\n    /*p*/\n    , n) {\n      // not sure what to do here, the data isn't really useful.\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR); // eslint-disable-line no-undef\n    }\n\n    function ai_assert(bool) {\n      if (!bool) throw 'asset failed';\n    }\n\n    function ReadBinaryNode(stream, parent, depth) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      var node = new aiNode();\n      node.mParent = parent;\n      node.mDepth = depth;\n      node.mName = Read_aiString(stream);\n      node.mTransformation = Read_aiMatrix4x4(stream);\n      node.mNumChildren = Read_unsigned_int(stream);\n      node.mNumMeshes = Read_unsigned_int(stream);\n\n      if (node.mNumMeshes) {\n        node.mMeshes = [];\n\n        for (let i = 0; i < node.mNumMeshes; ++i) {\n          node.mMeshes[i] = Read_unsigned_int(stream);\n        }\n      }\n\n      if (node.mNumChildren) {\n        node.mChildren = [];\n\n        for (let i = 0; i < node.mNumChildren; ++i) {\n          var node2 = ReadBinaryNode(stream, node, depth++);\n          node.mChildren[i] = node2;\n        }\n      }\n\n      return node;\n    } // -----------------------------------------------------------------------------------\n\n\n    function ReadBinaryBone(stream, b) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      b.mName = Read_aiString(stream);\n      b.mNumWeights = Read_unsigned_int(stream);\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream); // for the moment we write dumb min/max values for the bones, too.\n      // maybe I'll add a better, hash-like solution later\n\n      if (shortened) {\n        ReadBounds(stream, b.mWeights, b.mNumWeights);\n      } else {\n        // else write as usual\n        b.mWeights = [];\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\n      }\n\n      return b;\n    }\n\n    function ReadBinaryMesh(stream, mesh) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream);\n      mesh.mNumVertices = Read_unsigned_int(stream);\n      mesh.mNumFaces = Read_unsigned_int(stream);\n      mesh.mNumBones = Read_unsigned_int(stream);\n      mesh.mMaterialIndex = Read_unsigned_int(stream);\n      mesh.mNumUVComponents = []; // first of all, write bits for all existent vertex components\n\n      var c = Read_unsigned_int(stream);\n\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mVertices = [];\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mNormals = [];\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTangents = [];\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          mesh.mBitangents = [];\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      for (let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mColors[n] = [];\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\n        }\n      }\n\n      mesh.mTexCoordsBuffers = [];\n\n      for (let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n))) break; // write number of UV components\n\n        mesh.mNumUVComponents[n] = Read_unsigned_int(stream);\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTextureCoords[n] = []; //note that assbin always writes 3d texcoords\n\n          mesh.mTexCoordsBuffers[n] = [];\n\n          for (let uv = 0; uv < mesh.mNumVertices; uv++) {\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\n            readFloat(stream);\n          }\n        }\n      } // write faces. There are no floating-point calculations involved\n      // in these, so we can write a simple hash over the face data\n      // to the dump file. We generate a single 32 Bit hash for 512 faces\n      // using Assimp's standard hashing function.\n\n\n      if (shortened) {\n        Read_unsigned_int(stream);\n      } else {\n        // else write as usual\n        // if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n        mesh.mFaces = [];\n        mesh.mIndexArray = [];\n\n        for (let i = 0; i < mesh.mNumFaces; ++i) {\n          var f = mesh.mFaces[i] = new aiFace(); // BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n\n          f.mNumIndices = Read_uint16_t(stream);\n          f.mIndices = [];\n\n          for (let a = 0; a < f.mNumIndices; ++a) {\n            if (mesh.mNumVertices < 1 << 16) {\n              f.mIndices[a] = Read_uint16_t(stream);\n            } else {\n              f.mIndices[a] = Read_unsigned_int(stream);\n            }\n          }\n\n          if (f.mNumIndices === 3) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n          } else if (f.mNumIndices === 4) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[3]);\n            mesh.mIndexArray.push(f.mIndices[0]);\n          } else {\n            throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\n          }\n        }\n      } // write bones\n\n\n      if (mesh.mNumBones) {\n        mesh.mBones = [];\n\n        for (let a = 0; a < mesh.mNumBones; ++a) {\n          mesh.mBones[a] = new aiBone();\n          ReadBinaryBone(stream, mesh.mBones[a]);\n        }\n      }\n    }\n\n    function ReadBinaryMaterialProperty(stream, prop) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      prop.mKey = Read_aiString(stream);\n      prop.mSemantic = Read_unsigned_int(stream);\n      prop.mIndex = Read_unsigned_int(stream);\n      prop.mDataLength = Read_unsigned_int(stream);\n      prop.mType = Read_unsigned_int(stream);\n      prop.mData = [];\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength);\n    } // -----------------------------------------------------------------------------------\n\n\n    function ReadBinaryMaterial(stream, mat) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\n\n      if (mat.mNumProperties) {\n        if (mat.mProperties) {\n          delete mat.mProperties;\n        }\n\n        mat.mProperties = [];\n\n        for (let i = 0; i < mat.mNumProperties; ++i) {\n          mat.mProperties[i] = new aiMaterialProperty();\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i]);\n        }\n      }\n    }\n\n    function ReadBinaryNodeAnim(stream, nd) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      nd.mNodeName = Read_aiString(stream);\n      nd.mNumPositionKeys = Read_unsigned_int(stream);\n      nd.mNumRotationKeys = Read_unsigned_int(stream);\n      nd.mNumScalingKeys = Read_unsigned_int(stream);\n      nd.mPreState = Read_unsigned_int(stream);\n      nd.mPostState = Read_unsigned_int(stream);\n\n      if (nd.mNumPositionKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        } else {\n          // else write as usual\n          nd.mPositionKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        }\n      }\n\n      if (nd.mNumRotationKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        } else {\n          // else write as usual\n          nd.mRotationKeys = [];\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        }\n      }\n\n      if (nd.mNumScalingKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        } else {\n          // else write as usual\n          nd.mScalingKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        }\n      }\n    }\n\n    function ReadBinaryAnim(stream, anim) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      anim.mName = Read_aiString(stream);\n      anim.mDuration = Read_double(stream);\n      anim.mTicksPerSecond = Read_double(stream);\n      anim.mNumChannels = Read_unsigned_int(stream);\n\n      if (anim.mNumChannels) {\n        anim.mChannels = [];\n\n        for (let a = 0; a < anim.mNumChannels; ++a) {\n          anim.mChannels[a] = new aiNodeAnim();\n          ReadBinaryNodeAnim(stream, anim.mChannels[a]);\n        }\n      }\n    }\n\n    function ReadBinaryTexture(stream, tex) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      tex.mWidth = Read_unsigned_int(stream);\n      tex.mHeight = Read_unsigned_int(stream);\n      stream.ReadBytes(tex.achFormatHint, 1, 4);\n\n      if (!shortened) {\n        if (!tex.mHeight) {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth);\n        } else {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\n        }\n      }\n    }\n\n    function ReadBinaryLight(stream, l) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      l.mName = Read_aiString(stream);\n      l.mType = Read_unsigned_int(stream);\n\n      if (l.mType != aiLightSource_DIRECTIONAL) {\n        l.mAttenuationConstant = readFloat(stream);\n        l.mAttenuationLinear = readFloat(stream);\n        l.mAttenuationQuadratic = readFloat(stream);\n      }\n\n      l.mColorDiffuse = Read_aiColor3D(stream);\n      l.mColorSpecular = Read_aiColor3D(stream);\n      l.mColorAmbient = Read_aiColor3D(stream);\n\n      if (l.mType == aiLightSource_SPOT) {\n        l.mAngleInnerCone = readFloat(stream);\n        l.mAngleOuterCone = readFloat(stream);\n      }\n    }\n\n    function ReadBinaryCamera(stream, cam) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      cam.mName = Read_aiString(stream);\n      cam.mPosition = Read_aiVector3D(stream);\n      cam.mLookAt = Read_aiVector3D(stream);\n      cam.mUp = Read_aiVector3D(stream);\n      cam.mHorizontalFOV = readFloat(stream);\n      cam.mClipPlaneNear = readFloat(stream);\n      cam.mClipPlaneFar = readFloat(stream);\n      cam.mAspect = readFloat(stream);\n    }\n\n    function ReadBinaryScene(stream, scene) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      scene.mFlags = Read_unsigned_int(stream);\n      scene.mNumMeshes = Read_unsigned_int(stream);\n      scene.mNumMaterials = Read_unsigned_int(stream);\n      scene.mNumAnimations = Read_unsigned_int(stream);\n      scene.mNumTextures = Read_unsigned_int(stream);\n      scene.mNumLights = Read_unsigned_int(stream);\n      scene.mNumCameras = Read_unsigned_int(stream); // Read node graph\n\n      scene.mRootNode = new aiNode();\n      scene.mRootNode = ReadBinaryNode(stream, null, 0); // Read all meshes\n\n      if (scene.mNumMeshes) {\n        scene.mMeshes = [];\n\n        for (let i = 0; i < scene.mNumMeshes; ++i) {\n          scene.mMeshes[i] = new aiMesh();\n          ReadBinaryMesh(stream, scene.mMeshes[i]);\n        }\n      } // Read materials\n\n\n      if (scene.mNumMaterials) {\n        scene.mMaterials = [];\n\n        for (let i = 0; i < scene.mNumMaterials; ++i) {\n          scene.mMaterials[i] = new aiMaterial();\n          ReadBinaryMaterial(stream, scene.mMaterials[i]);\n        }\n      } // Read all animations\n\n\n      if (scene.mNumAnimations) {\n        scene.mAnimations = [];\n\n        for (let i = 0; i < scene.mNumAnimations; ++i) {\n          scene.mAnimations[i] = new aiAnimation();\n          ReadBinaryAnim(stream, scene.mAnimations[i]);\n        }\n      } // Read all textures\n\n\n      if (scene.mNumTextures) {\n        scene.mTextures = [];\n\n        for (let i = 0; i < scene.mNumTextures; ++i) {\n          scene.mTextures[i] = new aiTexture();\n          ReadBinaryTexture(stream, scene.mTextures[i]);\n        }\n      } // Read lights\n\n\n      if (scene.mNumLights) {\n        scene.mLights = [];\n\n        for (let i = 0; i < scene.mNumLights; ++i) {\n          scene.mLights[i] = new aiLight();\n          ReadBinaryLight(stream, scene.mLights[i]);\n        }\n      } // Read cameras\n\n\n      if (scene.mNumCameras) {\n        scene.mCameras = [];\n\n        for (let i = 0; i < scene.mNumCameras; ++i) {\n          scene.mCameras[i] = new aiCamera();\n          ReadBinaryCamera(stream, scene.mCameras[i]);\n        }\n      }\n    }\n\n    var aiOrigin_CUR = 0;\n    var aiOrigin_BEG = 1;\n\n    function extendStream(stream) {\n      stream.readOffset = 0;\n\n      stream.Seek = function (off, ori) {\n        if (ori == aiOrigin_CUR) {\n          stream.readOffset += off;\n        }\n\n        if (ori == aiOrigin_BEG) {\n          stream.readOffset = off;\n        }\n      };\n\n      stream.ReadBytes = function (buff, size, n) {\n        var bytes = size * n;\n\n        for (let i = 0; i < bytes; i++) buff[i] = Read_uint8_t(this);\n      };\n\n      stream.subArray32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Float32Array(newbuff);\n      };\n\n      stream.subArrayUint16 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint16Array(newbuff);\n      };\n\n      stream.subArrayUint8 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint8Array(newbuff);\n      };\n\n      stream.subArrayUint32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint32Array(newbuff);\n      };\n    }\n\n    var shortened, compressed;\n\n    function InternReadFile(pFiledata) {\n      var pScene = new aiScene();\n      var stream = new DataView(pFiledata);\n      extendStream(stream);\n      stream.Seek(44, aiOrigin_CUR); // signature\n\n      /*unsigned int versionMajor =*/\n\n      pScene.versionMajor = Read_unsigned_int(stream);\n      /*unsigned int versionMinor =*/\n\n      pScene.versionMinor = Read_unsigned_int(stream);\n      /*unsigned int versionRevision =*/\n\n      pScene.versionRevision = Read_unsigned_int(stream);\n      /*unsigned int compileFlags =*/\n\n      pScene.compileFlags = Read_unsigned_int(stream);\n      shortened = Read_uint16_t(stream) > 0;\n      compressed = Read_uint16_t(stream) > 0;\n      if (shortened) throw 'Shortened binaries are not supported!';\n      stream.Seek(256, aiOrigin_CUR); // original filename\n\n      stream.Seek(128, aiOrigin_CUR); // options\n\n      stream.Seek(64, aiOrigin_CUR); // padding\n\n      if (compressed) {\n        var uncompressedSize = Read_uint32_t(stream);\n        var compressedSize = stream.FileSize() - stream.Tell();\n        var compressedData = [];\n        stream.Read(compressedData, 1, compressedSize);\n        var uncompressedData = [];\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize); // eslint-disable-line no-undef\n\n        var buff = new ArrayBuffer(uncompressedData);\n        ReadBinaryScene(buff, pScene);\n      } else {\n        ReadBinaryScene(stream, pScene);\n      }\n\n      return pScene.toTHREE();\n    }\n\n    return InternReadFile(buffer);\n  }\n});\n\nexport { AssimpLoader };\n", "import { Loader, FileLoader, CompressedTexture, UnsignedByteType, LinearFilter, LinearMipmapLinearFilter, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format } from 'three';\n\n/**\n * Loader for Basis Universal GPU Texture Codec.\n *\n * Basis Universal is a \"supercompressed\" GPU texture and texture video\n * compression system that outputs a highly compressed intermediate file format\n * (.basis) that can be quickly transcoded to a wide variety of GPU texture\n * compression formats.\n *\n * This loader parallelizes the transcoding process across a configurable number\n * of web workers, before transferring the transcoded compressed texture back\n * to the main thread.\n */\n\nconst _taskCache = new WeakMap();\n\nclass BasisTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.transcoderPath = '';\n    this.transcoderBinary = null;\n    this.transcoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = '';\n    this.workerConfig = null;\n  }\n\n  setTranscoderPath(path) {\n    this.transcoderPath = path;\n    return this;\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported: renderer.extensions.has('WEBGL_compressed_texture_pvrtc') || renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc')\n    };\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setWithCredentials(this.withCredentials);\n    const texture = new CompressedTexture();\n    loader.load(url, buffer => {\n      // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n      // again from this thread.\n      if (_taskCache.has(buffer)) {\n        const cachedTask = _taskCache.get(buffer);\n\n        return cachedTask.promise.then(onLoad).catch(onError);\n      }\n\n      this._createTexture([buffer]).then(function (_texture) {\n        texture.copy(_texture);\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }).catch(onError);\n    }, onProgress, onError);\n    return texture;\n  }\n  /** Low-level transcoding API, exposed for use by KTX2Loader. */\n\n\n  parseInternalAsync(options) {\n    const {\n      levels\n    } = options;\n    const buffers = new Set();\n\n    for (let i = 0; i < levels.length; i++) {\n      buffers.add(levels[i].data.buffer);\n    }\n\n    return this._createTexture(Array.from(buffers), { ...options,\n      lowLevel: true\n    });\n  }\n  /**\n   * @param {ArrayBuffer[]} buffers\n   * @param {object?} config\n   * @return {Promise<CompressedTexture>}\n   */\n\n\n  _createTexture(buffers, config = {}) {\n    let worker;\n    let taskID;\n    const taskConfig = config;\n    let taskCost = 0;\n\n    for (let i = 0; i < buffers.length; i++) {\n      taskCost += buffers[i].byteLength;\n    }\n\n    const texturePending = this._allocateWorker(taskCost).then(_worker => {\n      worker = _worker;\n      taskID = this.workerNextTaskID++;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: 'transcode',\n          id: taskID,\n          buffers: buffers,\n          taskConfig: taskConfig\n        }, buffers);\n      });\n    }).then(message => {\n      const {\n        mipmaps,\n        width,\n        height,\n        format\n      } = message;\n      const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n      texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n      texture.magFilter = LinearFilter;\n      texture.generateMipmaps = false;\n      texture.needsUpdate = true;\n      return texture;\n    }); // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n    texturePending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        worker._taskLoad -= taskCost;\n        delete worker._callbacks[taskID];\n      }\n    }); // Cache the task result.\n\n    _taskCache.set(buffers[0], {\n      promise: texturePending\n    });\n\n    return texturePending;\n  }\n\n  _initTranscoder() {\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      const jsLoader = new FileLoader(this.manager);\n      jsLoader.setPath(this.transcoderPath);\n      jsLoader.setWithCredentials(this.withCredentials);\n      const jsContent = new Promise((resolve, reject) => {\n        jsLoader.load('basis_transcoder.js', resolve, undefined, reject);\n      }); // Load transcoder WASM binary.\n\n      const binaryLoader = new FileLoader(this.manager);\n      binaryLoader.setPath(this.transcoderPath);\n      binaryLoader.setResponseType('arraybuffer');\n      binaryLoader.setWithCredentials(this.withCredentials);\n      const binaryContent = new Promise((resolve, reject) => {\n        binaryLoader.load('basis_transcoder.wasm', resolve, undefined, reject);\n      });\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n        const fn = BasisTextureLoader.BasisWorker.toString();\n        const body = ['/* constants */', 'let _EngineFormat = ' + JSON.stringify(BasisTextureLoader.EngineFormat), 'let _TranscoderFormat = ' + JSON.stringify(BasisTextureLoader.TranscoderFormat), 'let _BasisFormat = ' + JSON.stringify(BasisTextureLoader.BasisFormat), '/* basis_transcoder.js */', jsContent, '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n        this.transcoderBinary = binaryContent;\n      });\n    }\n\n    return this.transcoderPending;\n  }\n\n  _allocateWorker(taskCost) {\n    return this._initTranscoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          config: this.workerConfig,\n          transcoderBinary: this.transcoderBinary\n        });\n\n        worker.onmessage = function (e) {\n          const message = e.data;\n\n          switch (message.type) {\n            case 'transcode':\n              worker._callbacks[message.id].resolve(message);\n\n              break;\n\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n\n              break;\n\n            default:\n              console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n\n        this.workerPool.push(worker);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; i++) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n    return this;\n  }\n\n}\n/* CONSTANTS */\n\n\nBasisTextureLoader.BasisFormat = {\n  ETC1S: 0,\n  UASTC_4x4: 1\n};\nBasisTextureLoader.TranscoderFormat = {\n  ETC1: 0,\n  ETC2: 1,\n  BC1: 2,\n  BC3: 3,\n  BC4: 4,\n  BC5: 5,\n  BC7_M6_OPAQUE_ONLY: 6,\n  BC7_M5: 7,\n  PVRTC1_4_RGB: 8,\n  PVRTC1_4_RGBA: 9,\n  ASTC_4x4: 10,\n  ATC_RGB: 11,\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\n  RGBA32: 13,\n  RGB565: 14,\n  BGR565: 15,\n  RGBA4444: 16\n};\nBasisTextureLoader.EngineFormat = {\n  RGBAFormat: RGBAFormat,\n  RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format: RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format: RGB_ETC1_Format,\n  RGB_ETC2_Format: RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format\n};\n/* WEB WORKER */\n\nBasisTextureLoader.BasisWorker = function () {\n  let config;\n  let transcoderPending;\n  let BasisModule;\n  const EngineFormat = _EngineFormat; // eslint-disable-line no-undef\n\n  const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef\n\n  const BasisFormat = _BasisFormat; // eslint-disable-line no-undef\n\n  onmessage = function (e) {\n    const message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        config = message.config;\n        init(message.transcoderBinary);\n        break;\n\n      case 'transcode':\n        transcoderPending.then(() => {\n          try {\n            const {\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format\n            } = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]);\n            const buffers = [];\n\n            for (let i = 0; i < mipmaps.length; ++i) {\n              buffers.push(mipmaps[i].data.buffer);\n            }\n\n            self.postMessage({\n              type: 'transcode',\n              id: message.id,\n              width,\n              height,\n              hasAlpha,\n              mipmaps,\n              format\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          }\n        });\n        break;\n    }\n  };\n\n  function init(wasmBinary) {\n    transcoderPending = new Promise(resolve => {\n      BasisModule = {\n        wasmBinary,\n        onRuntimeInitialized: resolve\n      };\n      BASIS(BasisModule); // eslint-disable-line no-undef\n    }).then(() => {\n      BasisModule.initializeBasis();\n    });\n  }\n\n  function transcodeLowLevel(taskConfig) {\n    const {\n      basisFormat,\n      width,\n      height,\n      hasAlpha\n    } = taskConfig;\n    const {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n    assert(BasisModule.isFormatSupported(transcoderFormat), 'THREE.BasisTextureLoader: Unsupported format.');\n    const mipmaps = [];\n\n    if (basisFormat === BasisFormat.ETC1S) {\n      const transcoder = new BasisModule.LowLevelETC1SImageTranscoder();\n      const {\n        endpointCount,\n        endpointsData,\n        selectorCount,\n        selectorsData,\n        tablesData\n      } = taskConfig.globalData;\n\n      try {\n        let ok;\n        ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);\n        assert(ok, 'THREE.BasisTextureLoader: decodePalettes() failed.');\n        ok = transcoder.decodeTables(tablesData);\n        assert(ok, 'THREE.BasisTextureLoader: decodeTables() failed.');\n\n        for (let i = 0; i < taskConfig.levels.length; i++) {\n          const level = taskConfig.levels[i];\n          const imageDesc = taskConfig.globalData.imageDescs[i];\n          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n          const dst = new Uint8Array(dstByteLength);\n          ok = transcoder.transcodeImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength, imageDesc.alphaSliceByteOffset, imageDesc.alphaSliceByteLength, imageDesc.imageFlags, hasAlpha, false, 0, 0);\n          assert(ok, 'THREE.BasisTextureLoader: transcodeImage() failed for level ' + level.index + '.');\n          mipmaps.push({\n            data: dst,\n            width: level.width,\n            height: level.height\n          });\n        }\n      } finally {\n        transcoder.delete();\n      }\n    } else {\n      for (let i = 0; i < taskConfig.levels.length; i++) {\n        const level = taskConfig.levels[i];\n        const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n        const dst = new Uint8Array(dstByteLength);\n        const ok = BasisModule.transcodeUASTCImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, 0, level.data.byteLength, 0, hasAlpha, false, 0, 0, -1, -1);\n        assert(ok, 'THREE.BasisTextureLoader: transcodeUASTCImage() failed for level ' + level.index + '.');\n        mipmaps.push({\n          data: dst,\n          width: level.width,\n          height: level.height\n        });\n      }\n    }\n\n    return {\n      width,\n      height,\n      hasAlpha,\n      mipmaps,\n      format: engineFormat\n    };\n  }\n\n  function transcode(buffer) {\n    const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer));\n    const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n    const width = basisFile.getImageWidth(0, 0);\n    const height = basisFile.getImageHeight(0, 0);\n    const levels = basisFile.getNumLevels(0);\n    const hasAlpha = basisFile.getHasAlpha();\n\n    function cleanup() {\n      basisFile.close();\n      basisFile.delete();\n    }\n\n    const {\n      transcoderFormat,\n      engineFormat\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\n\n    if (!width || !height || !levels) {\n      cleanup();\n      throw new Error('THREE.BasisTextureLoader:\tInvalid texture');\n    }\n\n    if (!basisFile.startTranscoding()) {\n      cleanup();\n      throw new Error('THREE.BasisTextureLoader: .startTranscoding failed');\n    }\n\n    const mipmaps = [];\n\n    for (let mip = 0; mip < levels; mip++) {\n      const mipWidth = basisFile.getImageWidth(0, mip);\n      const mipHeight = basisFile.getImageHeight(0, mip);\n      const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));\n      const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);\n\n      if (!status) {\n        cleanup();\n        throw new Error('THREE.BasisTextureLoader: .transcodeImage failed.');\n      }\n\n      mipmaps.push({\n        data: dst,\n        width: mipWidth,\n        height: mipHeight\n      });\n    }\n\n    cleanup();\n    return {\n      width,\n      height,\n      hasAlpha,\n      mipmaps,\n      format: engineFormat\n    };\n  } //\n  // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n  // device capabilities, and texture dimensions. The list below ranks the formats separately\n  // for ETC1S and UASTC.\n  //\n  // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n  // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n  // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n\n\n  const FORMAT_OPTIONS = [{\n    if: 'astcSupported',\n    basisFormat: [BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n    priorityETC1S: Infinity,\n    priorityUASTC: 1,\n    needsPowerOfTwo: false\n  }, {\n    if: 'bptcSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n    priorityETC1S: 3,\n    priorityUASTC: 2,\n    needsPowerOfTwo: false\n  }, {\n    if: 'dxtSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n    priorityETC1S: 4,\n    priorityUASTC: 5,\n    needsPowerOfTwo: false\n  }, {\n    if: 'etc2Supported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n    priorityETC1S: 1,\n    priorityUASTC: 3,\n    needsPowerOfTwo: false\n  }, {\n    if: 'etc1Supported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n    engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\n    priorityETC1S: 2,\n    priorityUASTC: 4,\n    needsPowerOfTwo: false\n  }, {\n    if: 'pvrtcSupported',\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n    priorityETC1S: 5,\n    priorityUASTC: 6,\n    needsPowerOfTwo: true\n  }];\n  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityETC1S - b.priorityETC1S;\n  });\n  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityUASTC - b.priorityUASTC;\n  });\n\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n    let transcoderFormat;\n    let engineFormat;\n    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n\n    for (let i = 0; i < options.length; i++) {\n      const opt = options[i];\n      if (!config[opt.if]) continue;\n      if (!opt.basisFormat.includes(basisFormat)) continue;\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n      return {\n        transcoderFormat,\n        engineFormat\n      };\n    }\n\n    console.warn('THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.');\n    transcoderFormat = TranscoderFormat.RGBA32;\n    engineFormat = EngineFormat.RGBAFormat;\n    return {\n      transcoderFormat,\n      engineFormat\n    };\n  }\n\n  function assert(ok, message) {\n    if (!ok) throw new Error(message);\n  }\n\n  function getWidthInBlocks(transcoderFormat, width) {\n    return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));\n  }\n\n  function getHeightInBlocks(transcoderFormat, height) {\n    return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));\n  }\n\n  function getTranscodedImageByteLength(transcoderFormat, width, height) {\n    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n\n    if (BasisModule.formatIsUncompressed(transcoderFormat)) {\n      return width * height * blockByteLength;\n    }\n\n    if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\n      // GL requires extra padding for very small textures:\n      // https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt\n      const paddedWidth = width + 3 & ~3;\n      const paddedHeight = height + 3 & ~3;\n      return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;\n    }\n\n    return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;\n  }\n\n  function isPowerOfTwo(value) {\n    if (value <= 2) return true;\n    return (value & value - 1) === 0 && value !== 0;\n  }\n};\n\nexport { BasisTextureLoader };\n", "import { Vector3, Ray, Loader, FileLoader, MeshStandardMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Color, BufferGeometry, BufferAttribute, LineSegments, Mesh, Matrix4, Group } from 'three';\n\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\n\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\n\nconst _tempVec0 = new Vector3();\n\nconst _tempVec1 = new Vector3();\n\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\n        diffuse: {\n          value: new Color()\n        },\n        opacity: {\n          value: 1.0\n        }\n      }]),\n      vertexShader:\n      /* glsl */\n      `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `,\n      fragmentShader:\n      /* glsl */\n      `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <encodings_fragment>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `\n    });\n    Object.defineProperties(this, {\n      opacity: {\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function () {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    this.setValues(parameters);\n    this.isLDrawConditionalLineMaterial = true;\n  }\n\n}\n\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isConditionalLine = true;\n  }\n\n}\n\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i];\n    const vertices = face.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    const v2 = vertices[2];\n\n    _tempVec0.subVectors(v1, v0);\n\n    _tempVec1.subVectors(v2, v1);\n\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\n\nconst _ray = new Ray();\n\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n  // it allows edges to be smoothed as expected (see minifig arms).\n  // --\n  // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n  // point errors on vertices along quantization boundaries. Ie after matrix multiplication\n  // vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n  // get merged. This added epsilon attempts to push these error values to the same quantized\n  // value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n  const hashMultiplier = (1 + 1e-10) * 1e2;\n\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  } // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n  // onto the original line.\n\n\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    const scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n\n  const hardEdges = new Set();\n  const hardEdgeRays = new Map();\n  const halfEdgeList = {};\n  const normals = []; // Save the list of hard edges by hash\n\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const vertices = ls.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0)); // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n    // and requires more memory.\n\n    if (checkSubSegments) {\n      // add both ray directions to the map\n      const ray = toNormalizedRay(v0, v1, new Ray());\n      const rh1 = hashRay(ray);\n\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        const rh2 = hashRay(ray);\n        const info = {\n          ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info);\n        hardEdgeRays.set(rh2, info);\n      } // store both segments ends in min, max order in the distances array to check if a face edge is a\n      // subsegment later.\n\n\n      const info = hardEdgeRays.get(rh1);\n      let d0 = info.ray.direction.dot(v0);\n      let d1 = info.ray.direction.dot(v1);\n\n      if (d0 > d1) {\n        [d0, d1] = [d1, d0];\n      }\n\n      info.distances.push(d0, d1);\n    }\n  } // track the half edges associated with each triangle\n\n\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i];\n    const vertices = tri.vertices;\n    const vertCount = vertices.length;\n\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % vertCount;\n      const v0 = vertices[index];\n      const v1 = vertices[next];\n      const hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n      if (hardEdges.has(hash)) {\n        continue;\n      } // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\n\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray);\n        const rayHash = hashRay(_ray);\n\n        if (hardEdgeRays.has(rayHash)) {\n          const info = hardEdgeRays.get(rayHash);\n          const {\n            ray,\n            distances\n          } = info;\n          let d0 = ray.direction.dot(v0);\n          let d1 = ray.direction.dot(v1);\n\n          if (d0 > d1) {\n            [d0, d1] = [d1, d0];\n          } // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\n\n          let found = false;\n\n          for (let i = 0, l = distances.length; i < l; i += 2) {\n            if (d0 >= distances[i] && d1 <= distances[i + 1]) {\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            continue;\n          }\n        }\n      }\n\n      const info = {\n        index: index,\n        tri: tri\n      };\n      halfEdgeList[hash] = info;\n    }\n  } // Iterate until we've tried to connect all faces to share normals\n\n\n  while (true) {\n    // Stop if there are no more faces left\n    let halfEdge = null;\n\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n\n    if (halfEdge === null) {\n      break;\n    } // Exhaustively find all connected faces\n\n\n    const queue = [halfEdge];\n\n    while (queue.length > 0) {\n      // initialize all vertex normals in this triangle\n      const tri = queue.pop().tri;\n      const vertices = tri.vertices;\n      const vertNormals = tri.normals;\n      const faceNormal = tri.faceNormal; // Check if any edge is connected to another triangle edge\n\n      const vertCount = vertices.length;\n\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % vertCount;\n        const v0 = vertices[index];\n        const v1 = vertices[next]; // delete this triangle from the list so it won't be found again\n\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherInfo = halfEdgeList[reverseHash];\n\n        if (otherInfo) {\n          const otherTri = otherInfo.tri;\n          const otherIndex = otherInfo.index;\n          const otherNormals = otherTri.normals;\n          const otherVertCount = otherNormals.length;\n          const otherFaceNormal = otherTri.faceNormal; // NOTE: If the angle between faces is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          } // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n\n\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          } // share the first normal\n\n\n          const otherNext = (otherIndex + 1) % otherVertCount;\n\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm);\n            vertNormals[index].norm = otherNormals[otherNext].norm;\n          }\n\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];\n\n          if (sharedNormal1 === null) {\n            // it's possible to encounter an edge of a triangle that has already been traversed meaning\n            // both edges already have different normals defined and shared. To work around this we create\n            // a wrapper object so when those edges are merged the normals can be updated everywhere.\n            sharedNormal1 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal1.norm);\n          }\n\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          } // share the second normal\n\n\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm);\n            vertNormals[next].norm = otherNormals[otherIndex].norm;\n          }\n\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];\n\n          if (sharedNormal2 === null) {\n            sharedNormal2 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal2.norm);\n          }\n\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\n\nfunction isPartType(type) {\n  return type === 'Part' || type === 'Unofficial_Part';\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart';\n}\n\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return;\n      }\n\n      this.currentCharIndex++;\n    }\n  }\n\n  getToken() {\n    const pos0 = this.currentCharIndex++; // Seek space\n\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break;\n      }\n\n      this.currentCharIndex++;\n    }\n\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n  }\n\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n  }\n\n} // Fetches and parses an intermediate representation of LDraw parts files.\n\n\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader;\n    this._cache = {};\n  }\n\n  cloneResult(original) {\n    const result = {}; // vertices are transformed and normals computed before being converted to geometry\n    // so these pieces must be cloned.\n\n    result.faces = original.faces.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null\n      };\n    });\n    result.conditionalSegments = original.conditionalSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        controlPoints: face.controlPoints.map(v => v.clone())\n      };\n    });\n    result.lineSegments = original.lineSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone())\n      };\n    }); // none if this is subsequently modified\n\n    result.type = original.type;\n    result.category = original.category;\n    result.keywords = original.keywords;\n    result.subobjects = original.subobjects;\n    result.totalFaces = original.totalFaces;\n    result.startingConstructionStep = original.startingConstructionStep;\n    result.materials = original.materials;\n    result.group = null;\n    return result;\n  }\n\n  async fetchData(fileName) {\n    let triedLowerCase = false;\n    let locationState = FILE_LOCATION_AS_IS;\n\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName;\n\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf('/') + 1) + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            // Try absolute path\n            locationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            // Next attempt is lower case\n            fileName = fileName.toLowerCase();\n            subobjectURL = fileName;\n            triedLowerCase = true;\n            locationState = FILE_LOCATION_AS_IS;\n          }\n\n          break;\n      }\n\n      const loader = this.loader;\n      const fileLoader = new FileLoader(loader.manager);\n      fileLoader.setPath(loader.partsLibraryPath);\n      fileLoader.setRequestHeader(loader.requestHeader);\n      fileLoader.setWithCredentials(loader.withCredentials);\n\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL);\n        return text;\n      } catch {\n        continue;\n      }\n    }\n\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n  }\n\n  parse(text, fileName = null) {\n    const loader = this.loader; // final results\n\n    const faces = [];\n    const lineSegments = [];\n    const conditionalSegments = [];\n    const subobjects = [];\n    const materials = {};\n\n    const getLocalMaterial = colorCode => {\n      return materials[colorCode] || null;\n    };\n\n    let type = 'Model';\n    let category = null;\n    let keywords = null;\n    let totalFaces = 0; // split into lines\n\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n');\n    }\n\n    const lines = text.split('\\n');\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let startingConstructionStep = false; // Parse all line commands\n\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0) continue;\n\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.setData(currentEmbeddedFileName, currentEmbeddedText); // New embedded text file\n\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = '';\n        } else {\n          currentEmbeddedText += line + '\\n';\n        }\n\n        continue;\n      }\n\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue;\n      } // Parse the line type\n\n\n      const lineType = lp.getToken();\n      let material;\n      let colorCode;\n      let segment;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, c0, c1;\n\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken();\n\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken();\n                break;\n\n              case '!COLOUR':\n                material = loader.parseColorMetaDirective(lp);\n\n                if (material) {\n                  materials[material.userData.code] = material;\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                }\n\n                break;\n\n              case '!CATEGORY':\n                category = lp.getToken();\n                break;\n\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',');\n\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n\n                break;\n\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = '';\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n\n                break;\n\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY';\n                      bfcCCW = true;\n                      break;\n\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW';\n                      break;\n\n                    case 'INVERTNEXT':\n                      bfcInverted = true;\n                      break;\n\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP';\n                      break;\n\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n\n                break;\n\n              case 'STEP':\n                startingConstructionStep = true;\n                break;\n            }\n          }\n\n          break;\n        // Line type 1: Sub-object file\n\n        case '1':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n          if (loader.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = loader.fileMap[fileName];\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName;\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName;\n            }\n          }\n\n          subobjects.push({\n            material: material,\n            colorCode: colorCode,\n            matrix: matrix,\n            fileName: fileName,\n            inverted: bfcInverted,\n            startingConstructionStep: startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        // Line type 2: Line segment\n\n        case '2':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1]\n          };\n          lineSegments.push(segment);\n          break;\n        // Line type 5: Conditional Line segment\n\n        case '5':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          c0 = lp.getVector();\n          c1 = lp.getVector();\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1]\n          };\n          conditionalSegments.push(segment);\n          break;\n        // Line type 3: Triangle\n\n        case '3':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n          } else {\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null]\n          });\n          totalFaces++;\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n          }\n\n          break;\n        // Line type 4: Quadrilateral\n\n        case '4':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n            v3 = lp.getVector();\n          } else {\n            v3 = lp.getVector();\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          } // specifically place the triangle diagonal in the v0 and v1 slots so we can\n          // account for the doubling of vertices later when smoothing normals.\n\n\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null]\n          });\n          totalFaces += 2;\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n          }\n\n          break;\n\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.');\n      }\n    }\n\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText);\n    }\n\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null\n    };\n  } // returns an (optionally cloned) instance of the data\n\n\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase();\n    const result = this._cache[key];\n\n    if (result === null || result instanceof Promise) {\n      return null;\n    }\n\n    if (clone) {\n      return this.cloneResult(result);\n    } else {\n      return result;\n    }\n  } // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n\n\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase();\n\n    if (!(key in this._cache)) {\n      // replace the promise with a copy of the parsed data for immediate processing\n      this._cache[key] = this.fetchData(fileName).then(text => {\n        const info = this.parse(text, fileName);\n        this._cache[key] = info;\n        return info;\n      });\n    }\n\n    await this._cache[key];\n  } // sets the data in the cache from parsed data\n\n\n  setData(fileName, text) {\n    const key = fileName.toLowerCase();\n    this._cache[key] = this.parse(text, fileName);\n  }\n\n} // returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\n\n\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n\n  return materialHierarchy[colorCode] || null;\n} // Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\n\n\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  } // Convert the given file information into a mesh by processing subobjects.\n\n\n  async processIntoMesh(info) {\n    const loader = this.loader;\n    const parseCache = this.parseCache;\n    const faceMaterials = new Set(); // Processes the part subobject information to load child parts and merge geometry onto part\n    // piece object.\n\n    const processInfoSubobjects = async (info, subobject = null) => {\n      const subobjects = info.subobjects;\n      const promises = []; // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n      // group which lets instruction steps apply correctly.\n\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject = subobjects[i];\n        const promise = parseCache.ensureDataLoaded(subobject.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject.fileName, false);\n\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject.fileName).catch(error => {\n              console.warn(error);\n              return null;\n            });\n          }\n\n          return processInfoSubobjects(parseCache.getData(subobject.fileName), subobject);\n        });\n        promises.push(promise);\n      }\n\n      const group = new Group();\n      group.userData.category = info.category;\n      group.userData.keywords = info.keywords;\n      info.group = group;\n      const subobjectInfos = await Promise.all(promises);\n\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject = info.subobjects[i];\n        const subobjectInfo = subobjectInfos[i];\n\n        if (subobjectInfo === null) {\n          // the subobject failed to load\n          continue;\n        } // if the subobject was loaded as a separate group then apply the parent scopes materials\n\n\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo;\n          subobject.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n          subobjectGroup.userData.startingConstructionStep = subobject.startingConstructionStep;\n          subobjectGroup.name = subobject.fileName;\n          loader.applyMaterialsToMesh(subobjectGroup, subobject.colorCode, info.materials);\n          group.add(subobjectGroup);\n          continue;\n        } // add the subobject group if it has children in case it has both children and primitives\n\n\n        if (subobjectInfo.group.children.length) {\n          group.add(subobjectInfo.group);\n        } // transform the primitives into the local space of the parent piece and append them to\n        // to the parent primitives list.\n\n\n        const parentLineSegments = info.lineSegments;\n        const parentConditionalSegments = info.conditionalSegments;\n        const parentFaces = info.faces;\n        const lineSegments = subobjectInfo.lineSegments;\n        const conditionalSegments = subobjectInfo.conditionalSegments;\n        const faces = subobjectInfo.faces;\n        const matrix = subobject.matrix;\n        const inverted = subobject.inverted;\n        const matrixScaleInverted = matrix.determinant() < 0;\n        const colorCode = subobject.colorCode;\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i];\n          const vertices = ls.vertices;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info.materials, true);\n          parentLineSegments.push(ls);\n        }\n\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i];\n          const vertices = os.vertices;\n          const controlPoints = os.controlPoints;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          controlPoints[0].applyMatrix4(matrix);\n          controlPoints[1].applyMatrix4(matrix);\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info.materials, true);\n          parentConditionalSegments.push(os);\n        }\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const tri = faces[i];\n          const vertices = tri.vertices;\n\n          for (let i = 0, l = vertices.length; i < l; i++) {\n            vertices[i].applyMatrix4(matrix);\n          }\n\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info.materials, false);\n          faceMaterials.add(tri.colorCode); // If the scale of the object is negated then the triangle winding order\n          // needs to be flipped.\n\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse();\n          }\n\n          parentFaces.push(tri);\n        }\n\n        info.totalFaces += subobjectInfo.totalFaces;\n      } // Apply the parent subobjects pass through material code to this object. This is done several times due\n      // to material scoping.\n\n\n      if (subobject) {\n        loader.applyMaterialsToMesh(group, subobject.colorCode, info.materials);\n      }\n\n      return info;\n    }; // Track material use to see if we need to use the normal smooth slow path for hard edges.\n\n\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode);\n    }\n\n    await processInfoSubobjects(info);\n\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1;\n      generateFaceNormals(info.faces);\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n    } // Add the primitive objects and metadata.\n\n\n    const group = info.group;\n\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces));\n    }\n\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2));\n    }\n\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true));\n    }\n\n    return group;\n  }\n\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache;\n  }\n\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase();\n      const group = await this._cache[key];\n      return group.clone();\n    } else {\n      return null;\n    }\n  } // Loads and parses the model with the given file name. Returns a cached copy if available.\n\n\n  async loadModel(fileName) {\n    const parseCache = this.parseCache;\n    const key = fileName.toLowerCase();\n\n    if (this.hasCachedModel(fileName)) {\n      // Return cached model if available.\n      return this.getCachedModel(fileName);\n    } else {\n      // Otherwise parse a new model.\n      // Ensure the file data is loaded and pre parsed.\n      await parseCache.ensureDataLoaded(fileName);\n      const info = parseCache.getData(fileName);\n      const promise = this.processIntoMesh(info); // Now that the file has loaded it's possible that another part parse has been waiting in parallel\n      // so check the cache again to see if it's been added since the last async operation so we don't\n      // do unnecessary work.\n\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName);\n      } // Cache object if it's a part so it can be reused later.\n\n\n      if (isPartType(info.type)) {\n        this._cache[key] = promise;\n      } // return a copy\n\n\n      const group = await promise;\n      return group.clone();\n    }\n  } // parses the given model text into a renderable object. Returns cached copy if available.\n\n\n  async parseModel(text) {\n    const parseCache = this.parseCache;\n    const info = parseCache.parse(text);\n\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName);\n    }\n\n    return this.processIntoMesh(info);\n  }\n\n}\n\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n  // Sort the faces or line segments by color code to make later the mesh groups\n  elements.sort(sortByMaterial);\n\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n\n  const positions = new Float32Array(elementSize * totalElements * 3);\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  const materials = [];\n  const quadArray = new Array(6);\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n  let offset = 0;\n\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    let vertices = elem.vertices;\n\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j];\n      const index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    } // create the normals array if this is a set of faces\n\n\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0];\n        const v1 = vertices[1];\n        const v2 = vertices[2];\n\n        _tempVec0.subVectors(v1, v0);\n\n        _tempVec1.subVectors(v2, v1);\n\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n\n      let elemNormals = elem.normals;\n\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        // use face normal if a vertex normal is not provided\n        let n = elem.faceNormal;\n\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm;\n        }\n\n        const index = offset + j * 3;\n        normals[index + 0] = n.x;\n        normals[index + 1] = n.y;\n        normals[index + 2] = n.z;\n      }\n    }\n\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n\n      const material = elem.material;\n\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        // If a material has not been made available yet then keep the color code string in the material array\n        // to save the spot for the material once a parent scopes materials are being applied to the object.\n        materials.push(elem.colorCode);\n      }\n\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n\n    offset += 3 * vertices.length;\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n\n  bufferGeometry.setAttribute('position', new BufferAttribute(positions, 3));\n\n  if (normals !== null) {\n    bufferGeometry.setAttribute('normal', new BufferAttribute(normals, 3));\n  }\n\n  let object3d = null;\n\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const vertices = os.vertices;\n      const controlPoints = os.controlPoints;\n      const c0 = controlPoints[0];\n      const c1 = controlPoints[1];\n      const v0 = vertices[0];\n      const v1 = vertices[1];\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n  }\n\n  return object3d;\n} //\n\n\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager); // Array of THREE.Material\n\n    this.materials = [];\n    this.materialLibrary = {}; // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.partsCache = new LDrawPartsGeometryCache(this); // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = {}; // Initializes the materials library with default materials\n\n    this.setMaterials([]); // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true; // The path to load parts from the LDraw parts library from.\n\n    this.partsLibraryPath = '';\n  }\n\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path;\n    return this;\n  }\n\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    const text = await fileLoader.loadAsync(url);\n    const colorLineRegex = /^0 !COLOUR/;\n    const lines = text.split(/[\\n\\r]/g);\n    const materials = [];\n\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, '');\n        const material = this.parseColorMetaDirective(new LineParser(directive));\n        materials.push(material);\n      }\n    }\n\n    this.setMaterials(materials);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(url, text => {\n      this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n        this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);\n        this.computeConstructionSteps(group);\n        onLoad(group);\n      }).catch(onError);\n    }, onProgress, onError);\n  }\n\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n      this.computeConstructionSteps(group);\n      onLoad(group);\n    });\n  }\n\n  setMaterials(materials) {\n    this.materialLibrary = {};\n    this.materials = [];\n\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i]);\n    } // Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\n\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')));\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333')));\n    return this;\n  }\n\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n    const matLib = this.materialLibrary;\n\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n      matLib[material.userData.code] = material;\n    }\n\n    return this;\n  }\n\n  getMaterial(colorCode) {\n    if (colorCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB color)\n      const color = colorCode.substring(3);\n      return this.parseColorMetaDirective(new LineParser('Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + ''));\n    }\n\n    return this.materialLibrary[colorCode] || null;\n  } // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n\n\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    // find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n    const loader = this;\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n    group.traverse(c => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i]);\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material);\n        }\n      }\n    }); // Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n    // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n    // simply returned for the subsequent material application.\n\n    function getMaterial(c, colorCode) {\n      // if our parent is a passthrough color code and we don't have the current material color available then\n      // return early.\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode;\n      }\n\n      const forEdge = c.isLineSegments || c.isConditionalLine;\n      const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\n      if (isPassthrough) {\n        colorCode = parentColorCode;\n      }\n\n      let material = null;\n\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode];\n      } else if (finalMaterialPass) {\n        // see if we can get the final material from from the \"getMaterial\" function which will attempt to\n        // parse the \"direct\" colors\n        material = loader.getMaterial(colorCode);\n\n        if (material === null) {\n          // otherwise throw an error if this is final opportunity to set the material\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`);\n        }\n      } else {\n        return colorCode;\n      }\n\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial;\n\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial;\n        }\n      }\n\n      return material;\n    }\n  }\n\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE);\n  }\n\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n  }\n\n  parseColorMetaDirective(lineParser) {\n    // Parses a color definition and returns a THREE.Material\n    let code = null; // Triangle and line colors\n\n    let color = 0xff00ff;\n    let edgeColor = 0xff00ff; // Transparency\n\n    let alpha = 1;\n    let isTransparent = false; // Self-illumination:\n\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n\n    if (!name) {\n      throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.');\n    } // Parse tag tokens and their parameters\n\n\n    let token = null;\n\n    while (true) {\n      token = lineParser.getToken();\n\n      if (!token) {\n        break;\n      }\n\n      switch (token.toUpperCase()) {\n        case 'CODE':\n          code = lineParser.getToken();\n          break;\n\n        case 'VALUE':\n          color = lineParser.getToken();\n\n          if (color.startsWith('0x')) {\n            color = '#' + color.substring(2);\n          } else if (!color.startsWith('#')) {\n            throw new Error('LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.');\n          }\n\n          break;\n\n        case 'EDGE':\n          edgeColor = lineParser.getToken();\n\n          if (edgeColor.startsWith('0x')) {\n            edgeColor = '#' + edgeColor.substring(2);\n          } else if (!edgeColor.startsWith('#')) {\n            // Try to see if edge color is a color code\n            edgeMaterial = this.getMaterial(edgeColor);\n\n            if (!edgeMaterial) {\n              throw new Error('LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.');\n            } // Get the edge material for this triangle material\n\n\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n\n          break;\n\n        case 'ALPHA':\n          alpha = parseInt(lineParser.getToken());\n\n          if (isNaN(alpha)) {\n            throw new Error('LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.');\n          }\n\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n\n          break;\n\n        case 'LUMINANCE':\n          luminance = parseInt(lineParser.getToken());\n\n          if (isNaN(luminance)) {\n            throw new Error('LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.');\n          }\n\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n\n        case 'CHROME':\n          finishType = FINISH_TYPE_CHROME;\n          break;\n\n        case 'PEARLESCENT':\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n\n        case 'RUBBER':\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n\n        case 'MATTE_METALLIC':\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n\n        case 'METAL':\n          finishType = FINISH_TYPE_METAL;\n          break;\n\n        case 'MATERIAL':\n          // Not implemented\n          lineParser.setToEnd();\n          break;\n\n        default:\n          throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.');\n      }\n    }\n\n    let material = null;\n\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.3,\n          metalness: 0\n        });\n        break;\n\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by making the surface glossy\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.3,\n          metalness: 0.25\n        });\n        break;\n\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0,\n          metalness: 1\n        });\n        break;\n\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.9,\n          metalness: 0\n        });\n        break;\n\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.8,\n          metalness: 0.4\n        });\n        break;\n\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.2,\n          metalness: 0.85\n        });\n        break;\n    }\n\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + ' - Edge'; // This is the material used for conditional edges\n\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha\n      });\n    }\n\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    this.addMaterial(material);\n    return material;\n  }\n\n  computeConstructionSteps(model) {\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n    let stepNumber = 0;\n    model.traverse(c => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n\n}\n\nexport { LDrawLoader };\n", "function LWO3Parser(IFFParser) {\n  this.IFF = IFFParser;\n}\n\nLWO3Parser.prototype = {\n  constructor: LWO3Parser,\n  parseBlock: function () {\n    this.IFF.debugger.offset = this.IFF.reader.offset;\n    this.IFF.debugger.closeForms();\n    var blockID = this.IFF.reader.getIDTag();\n    var length = this.IFF.reader.getUint32(); // size of data in bytes\n\n    this.IFF.debugger.dataOffset = this.IFF.reader.offset;\n    this.IFF.debugger.length = length; // Data types may be found in either LWO2 OR LWO3 spec\n\n    switch (blockID) {\n      case 'FORM':\n        // form blocks may consist of sub -chunks or sub-forms\n        this.IFF.parseForm(length);\n        break;\n      // SKIPPED CHUNKS\n      // MISC skipped\n\n      case 'ICON': // Thumbnail Icon Image\n\n      case 'VMPA': // Vertex Map Parameter\n\n      case 'BBOX': // bounding box\n      // case 'VMMD':\n      // case 'VTYP':\n      // normal maps can be specified, normally on models imported from other applications. Currently ignored\n\n      case 'NORM': // ENVL FORM skipped\n\n      case 'PRE ':\n      case 'POST':\n      case 'KEY ':\n      case 'SPAN': // CLIP FORM skipped\n\n      case 'TIME':\n      case 'CLRS':\n      case 'CLRA':\n      case 'FILT':\n      case 'DITH':\n      case 'CONT':\n      case 'BRIT':\n      case 'SATR':\n      case 'HUE ':\n      case 'GAMM':\n      case 'NEGA':\n      case 'IFLT':\n      case 'PFLT': // Image Map Layer skipped\n\n      case 'PROJ':\n      case 'AXIS':\n      case 'AAST':\n      case 'PIXB':\n      case 'STCK': // Procedural Textures skipped\n\n      case 'VALU': // Gradient Textures skipped\n\n      case 'PNAM':\n      case 'INAM':\n      case 'GRST':\n      case 'GREN':\n      case 'GRPT':\n      case 'FKEY':\n      case 'IKEY': // Texture Mapping Form skipped\n\n      case 'CSYS': // Surface CHUNKs skipped\n\n      case 'OPAQ': // top level 'opacity' checkbox\n\n      case 'CMAP': // clip map\n      // Surface node CHUNKS skipped\n      // These mainly specify the node editor setup in LW\n\n      case 'NLOC':\n      case 'NZOM':\n      case 'NVER':\n      case 'NSRV':\n      case 'NCRD':\n      case 'NMOD':\n      case 'NSEL':\n      case 'NPRW':\n      case 'NPLA':\n      case 'VERS':\n      case 'ENUM':\n      case 'TAG ': // Car Material CHUNKS\n\n      case 'CGMD':\n      case 'CGTY':\n      case 'CGST':\n      case 'CGEN':\n      case 'CGTS':\n      case 'CGTE':\n      case 'OSMP':\n      case 'OMDE':\n      case 'OUTR':\n      case 'FLAG':\n      case 'TRNL':\n      case 'SHRP':\n      case 'RFOP':\n      case 'RSAN':\n      case 'TROP':\n      case 'RBLR':\n      case 'TBLR':\n      case 'CLRH':\n      case 'CLRF':\n      case 'ADTR':\n      case 'GLOW':\n      case 'LINE':\n      case 'ALPH':\n      case 'VCOL':\n      case 'ENAB':\n        this.IFF.debugger.skipped = true;\n        this.IFF.reader.skip(length);\n        break;\n      // Texture node chunks (not in spec)\n\n      case 'IPIX': // usePixelBlending\n\n      case 'IMIP': // useMipMaps\n\n      case 'IMOD': // imageBlendingMode\n\n      case 'AMOD': // unknown\n\n      case 'IINV': // imageInvertAlpha\n\n      case 'INCR': // imageInvertColor\n\n      case 'IAXS': // imageAxis ( for non-UV maps)\n\n      case 'IFOT': // imageFallofType\n\n      case 'ITIM': // timing for animated textures\n\n      case 'IWRL':\n      case 'IUTI':\n      case 'IINX':\n      case 'IINY':\n      case 'IINZ':\n      case 'IREF':\n        // possibly a VX for reused texture nodes\n        if (length === 4) this.IFF.currentNode[blockID] = this.IFF.reader.getInt32();else this.IFF.reader.skip(length);\n        break;\n\n      case 'OTAG':\n        this.IFF.parseObjectTag();\n        break;\n\n      case 'LAYR':\n        this.IFF.parseLayer(length);\n        break;\n\n      case 'PNTS':\n        this.IFF.parsePoints(length);\n        break;\n\n      case 'VMAP':\n        this.IFF.parseVertexMapping(length);\n        break;\n\n      case 'POLS':\n        this.IFF.parsePolygonList(length);\n        break;\n\n      case 'TAGS':\n        this.IFF.parseTagStrings(length);\n        break;\n\n      case 'PTAG':\n        this.IFF.parsePolygonTagMapping(length);\n        break;\n\n      case 'VMAD':\n        this.IFF.parseVertexMapping(length, true);\n        break;\n      // Misc CHUNKS\n\n      case 'DESC':\n        // Description Line\n        this.IFF.currentForm.description = this.IFF.reader.getString();\n        break;\n\n      case 'TEXT':\n      case 'CMNT':\n      case 'NCOM':\n        this.IFF.currentForm.comment = this.IFF.reader.getString();\n        break;\n      // Envelope Form\n\n      case 'NAME':\n        this.IFF.currentForm.channelName = this.IFF.reader.getString();\n        break;\n      // Image Map Layer\n\n      case 'WRAP':\n        this.IFF.currentForm.wrap = {\n          w: this.IFF.reader.getUint16(),\n          h: this.IFF.reader.getUint16()\n        };\n        break;\n\n      case 'IMAG':\n        var index = this.IFF.reader.getVariableLengthIndex();\n        this.IFF.currentForm.imageIndex = index;\n        break;\n      // Texture Mapping Form\n\n      case 'OREF':\n        this.IFF.currentForm.referenceObject = this.IFF.reader.getString();\n        break;\n\n      case 'ROID':\n        this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();\n        break;\n      // Surface Blocks\n\n      case 'SSHN':\n        this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();\n        break;\n\n      case 'AOVN':\n        this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();\n        break;\n      // Nodal Blocks\n\n      case 'NSTA':\n        this.IFF.currentForm.disabled = this.IFF.reader.getUint16();\n        break;\n\n      case 'NRNM':\n        this.IFF.currentForm.realName = this.IFF.reader.getString();\n        break;\n\n      case 'NNME':\n        this.IFF.currentForm.refName = this.IFF.reader.getString();\n        this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm;\n        break;\n      // Nodal Blocks : connections\n\n      case 'INME':\n        if (!this.IFF.currentForm.nodeName) this.IFF.currentForm.nodeName = [];\n        this.IFF.currentForm.nodeName.push(this.IFF.reader.getString());\n        break;\n\n      case 'IINN':\n        if (!this.IFF.currentForm.inputNodeName) this.IFF.currentForm.inputNodeName = [];\n        this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString());\n        break;\n\n      case 'IINM':\n        if (!this.IFF.currentForm.inputName) this.IFF.currentForm.inputName = [];\n        this.IFF.currentForm.inputName.push(this.IFF.reader.getString());\n        break;\n\n      case 'IONM':\n        if (!this.IFF.currentForm.inputOutputName) this.IFF.currentForm.inputOutputName = [];\n        this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString());\n        break;\n\n      case 'FNAM':\n        this.IFF.currentForm.fileName = this.IFF.reader.getString();\n        break;\n\n      case 'CHAN':\n        // NOTE: ENVL Forms may also have CHAN chunk, however ENVL is currently ignored\n        if (length === 4) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();else this.IFF.reader.skip(length);\n        break;\n      // LWO2 Spec chunks: these are needed since the SURF FORMs are often in LWO2 format\n\n      case 'SMAN':\n        var maxSmoothingAngle = this.IFF.reader.getFloat32();\n        this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true;\n        break;\n      // LWO2: Basic Surface Parameters\n\n      case 'COLR':\n        this.IFF.currentSurface.attributes.Color = {\n          value: this.IFF.reader.getFloat32Array(3)\n        };\n        this.IFF.reader.skip(2); // VX: envelope\n\n        break;\n\n      case 'LUMI':\n        this.IFF.currentSurface.attributes.Luminosity = {\n          value: this.IFF.reader.getFloat32()\n        };\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'SPEC':\n        this.IFF.currentSurface.attributes.Specular = {\n          value: this.IFF.reader.getFloat32()\n        };\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'DIFF':\n        this.IFF.currentSurface.attributes.Diffuse = {\n          value: this.IFF.reader.getFloat32()\n        };\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'REFL':\n        this.IFF.currentSurface.attributes.Reflection = {\n          value: this.IFF.reader.getFloat32()\n        };\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'GLOS':\n        this.IFF.currentSurface.attributes.Glossiness = {\n          value: this.IFF.reader.getFloat32()\n        };\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'TRAN':\n        this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'BUMP':\n        this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'SIDE':\n        this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();\n        break;\n\n      case 'RIMG':\n        this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();\n        break;\n\n      case 'RIND':\n        this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'TIMG':\n        this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();\n        break;\n\n      case 'IMAP':\n        this.IFF.currentSurface.attributes.imageMapIndex = this.IFF.reader.getUint32();\n        break;\n\n      case 'IUVI':\n        // uv channel name\n        this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length);\n        break;\n\n      case 'IUTL':\n        // widthWrappingMode: 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n        this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();\n        break;\n\n      case 'IVTL':\n        // heightWrappingMode\n        this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();\n        break;\n\n      default:\n        this.IFF.parseUnknownCHUNK(blockID, length);\n    }\n\n    if (blockID != 'FORM') {\n      this.IFF.debugger.node = 1;\n      this.IFF.debugger.nodeID = blockID;\n      this.IFF.debugger.log();\n    }\n\n    if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {\n      this.IFF.currentForm = this.IFF.parentForm;\n    }\n  }\n};\n\nexport { LWO3Parser };\n", "function LWO2Parser(IFFParser) {\n  this.IFF = IFFParser;\n}\n\nLWO2Parser.prototype = {\n  constructor: LWO2Parser,\n  parseBlock: function () {\n    this.IFF.debugger.offset = this.IFF.reader.offset;\n    this.IFF.debugger.closeForms();\n    var blockID = this.IFF.reader.getIDTag();\n    var length = this.IFF.reader.getUint32(); // size of data in bytes\n\n    if (length > this.IFF.reader.dv.byteLength - this.IFF.reader.offset) {\n      this.IFF.reader.offset -= 4;\n      length = this.IFF.reader.getUint16();\n    }\n\n    this.IFF.debugger.dataOffset = this.IFF.reader.offset;\n    this.IFF.debugger.length = length; // Data types may be found in either LWO2 OR LWO3 spec\n\n    switch (blockID) {\n      case 'FORM':\n        // form blocks may consist of sub -chunks or sub-forms\n        this.IFF.parseForm(length);\n        break;\n      // SKIPPED CHUNKS\n      // if break; is called directly, the position in the lwoTree is not created\n      // any sub chunks and forms are added to the parent form instead\n      // MISC skipped\n\n      case 'ICON': // Thumbnail Icon Image\n\n      case 'VMPA': // Vertex Map Parameter\n\n      case 'BBOX': // bounding box\n      // case 'VMMD':\n      // case 'VTYP':\n      // normal maps can be specified, normally on models imported from other applications. Currently ignored\n\n      case 'NORM': // ENVL FORM skipped\n\n      case 'PRE ':\n      case 'POST':\n      case 'KEY ':\n      case 'SPAN': // CLIP FORM skipped\n\n      case 'TIME':\n      case 'CLRS':\n      case 'CLRA':\n      case 'FILT':\n      case 'DITH':\n      case 'CONT':\n      case 'BRIT':\n      case 'SATR':\n      case 'HUE ':\n      case 'GAMM':\n      case 'NEGA':\n      case 'IFLT':\n      case 'PFLT': // Image Map Layer skipped\n\n      case 'PROJ':\n      case 'AXIS':\n      case 'AAST':\n      case 'PIXB':\n      case 'AUVO':\n      case 'STCK': // Procedural Textures skipped\n\n      case 'PROC':\n      case 'VALU':\n      case 'FUNC': // Gradient Textures skipped\n\n      case 'PNAM':\n      case 'INAM':\n      case 'GRST':\n      case 'GREN':\n      case 'GRPT':\n      case 'FKEY':\n      case 'IKEY': // Texture Mapping Form skipped\n\n      case 'CSYS': // Surface CHUNKs skipped\n\n      case 'OPAQ': // top level 'opacity' checkbox\n\n      case 'CMAP': // clip map\n      // Surface node CHUNKS skipped\n      // These mainly specify the node editor setup in LW\n\n      case 'NLOC':\n      case 'NZOM':\n      case 'NVER':\n      case 'NSRV':\n      case 'NVSK': // unknown\n\n      case 'NCRD':\n      case 'WRPW': // image wrap w ( for cylindrical and spherical projections)\n\n      case 'WRPH': // image wrap h\n\n      case 'NMOD':\n      case 'NPRW':\n      case 'NPLA':\n      case 'NODS':\n      case 'VERS':\n      case 'ENUM':\n      case 'TAG ':\n      case 'OPAC': // Car Material CHUNKS\n\n      case 'CGMD':\n      case 'CGTY':\n      case 'CGST':\n      case 'CGEN':\n      case 'CGTS':\n      case 'CGTE':\n      case 'OSMP':\n      case 'OMDE':\n      case 'OUTR':\n      case 'FLAG':\n      case 'TRNL':\n      case 'GLOW':\n      case 'GVAL': // glow intensity\n\n      case 'SHRP':\n      case 'RFOP':\n      case 'RSAN':\n      case 'TROP':\n      case 'RBLR':\n      case 'TBLR':\n      case 'CLRH':\n      case 'CLRF':\n      case 'ADTR':\n      case 'LINE':\n      case 'ALPH':\n      case 'VCOL':\n      case 'ENAB':\n        this.IFF.debugger.skipped = true;\n        this.IFF.reader.skip(length);\n        break;\n\n      case 'SURF':\n        this.IFF.parseSurfaceLwo2(length);\n        break;\n\n      case 'CLIP':\n        this.IFF.parseClipLwo2(length);\n        break;\n      // Texture node chunks (not in spec)\n\n      case 'IPIX': // usePixelBlending\n\n      case 'IMIP': // useMipMaps\n\n      case 'IMOD': // imageBlendingMode\n\n      case 'AMOD': // unknown\n\n      case 'IINV': // imageInvertAlpha\n\n      case 'INCR': // imageInvertColor\n\n      case 'IAXS': // imageAxis ( for non-UV maps)\n\n      case 'IFOT': // imageFallofType\n\n      case 'ITIM': // timing for animated textures\n\n      case 'IWRL':\n      case 'IUTI':\n      case 'IINX':\n      case 'IINY':\n      case 'IINZ':\n      case 'IREF':\n        // possibly a VX for reused texture nodes\n        if (length === 4) this.IFF.currentNode[blockID] = this.IFF.reader.getInt32();else this.IFF.reader.skip(length);\n        break;\n\n      case 'OTAG':\n        this.IFF.parseObjectTag();\n        break;\n\n      case 'LAYR':\n        this.IFF.parseLayer(length);\n        break;\n\n      case 'PNTS':\n        this.IFF.parsePoints(length);\n        break;\n\n      case 'VMAP':\n        this.IFF.parseVertexMapping(length);\n        break;\n\n      case 'AUVU':\n      case 'AUVN':\n        this.IFF.reader.skip(length - 1);\n        this.IFF.reader.getVariableLengthIndex(); // VX\n\n        break;\n\n      case 'POLS':\n        this.IFF.parsePolygonList(length);\n        break;\n\n      case 'TAGS':\n        this.IFF.parseTagStrings(length);\n        break;\n\n      case 'PTAG':\n        this.IFF.parsePolygonTagMapping(length);\n        break;\n\n      case 'VMAD':\n        this.IFF.parseVertexMapping(length, true);\n        break;\n      // Misc CHUNKS\n\n      case 'DESC':\n        // Description Line\n        this.IFF.currentForm.description = this.IFF.reader.getString();\n        break;\n\n      case 'TEXT':\n      case 'CMNT':\n      case 'NCOM':\n        this.IFF.currentForm.comment = this.IFF.reader.getString();\n        break;\n      // Envelope Form\n\n      case 'NAME':\n        this.IFF.currentForm.channelName = this.IFF.reader.getString();\n        break;\n      // Image Map Layer\n\n      case 'WRAP':\n        this.IFF.currentForm.wrap = {\n          w: this.IFF.reader.getUint16(),\n          h: this.IFF.reader.getUint16()\n        };\n        break;\n\n      case 'IMAG':\n        var index = this.IFF.reader.getVariableLengthIndex();\n        this.IFF.currentForm.imageIndex = index;\n        break;\n      // Texture Mapping Form\n\n      case 'OREF':\n        this.IFF.currentForm.referenceObject = this.IFF.reader.getString();\n        break;\n\n      case 'ROID':\n        this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();\n        break;\n      // Surface Blocks\n\n      case 'SSHN':\n        this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();\n        break;\n\n      case 'AOVN':\n        this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();\n        break;\n      // Nodal Blocks\n\n      case 'NSTA':\n        this.IFF.currentForm.disabled = this.IFF.reader.getUint16();\n        break;\n\n      case 'NRNM':\n        this.IFF.currentForm.realName = this.IFF.reader.getString();\n        break;\n\n      case 'NNME':\n        this.IFF.currentForm.refName = this.IFF.reader.getString();\n        this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm;\n        break;\n      // Nodal Blocks : connections\n\n      case 'INME':\n        if (!this.IFF.currentForm.nodeName) this.IFF.currentForm.nodeName = [];\n        this.IFF.currentForm.nodeName.push(this.IFF.reader.getString());\n        break;\n\n      case 'IINN':\n        if (!this.IFF.currentForm.inputNodeName) this.IFF.currentForm.inputNodeName = [];\n        this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString());\n        break;\n\n      case 'IINM':\n        if (!this.IFF.currentForm.inputName) this.IFF.currentForm.inputName = [];\n        this.IFF.currentForm.inputName.push(this.IFF.reader.getString());\n        break;\n\n      case 'IONM':\n        if (!this.IFF.currentForm.inputOutputName) this.IFF.currentForm.inputOutputName = [];\n        this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString());\n        break;\n\n      case 'FNAM':\n        this.IFF.currentForm.fileName = this.IFF.reader.getString();\n        break;\n\n      case 'CHAN':\n        // NOTE: ENVL Forms may also have CHAN chunk, however ENVL is currently ignored\n        if (length === 4) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();else this.IFF.reader.skip(length);\n        break;\n      // LWO2 Spec chunks: these are needed since the SURF FORMs are often in LWO2 format\n\n      case 'SMAN':\n        var maxSmoothingAngle = this.IFF.reader.getFloat32();\n        this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true;\n        break;\n      // LWO2: Basic Surface Parameters\n\n      case 'COLR':\n        this.IFF.currentSurface.attributes.Color = {\n          value: this.IFF.reader.getFloat32Array(3)\n        };\n        this.IFF.reader.skip(2); // VX: envelope\n\n        break;\n\n      case 'LUMI':\n        this.IFF.currentSurface.attributes.Luminosity = {\n          value: this.IFF.reader.getFloat32()\n        };\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'SPEC':\n        this.IFF.currentSurface.attributes.Specular = {\n          value: this.IFF.reader.getFloat32()\n        };\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'DIFF':\n        this.IFF.currentSurface.attributes.Diffuse = {\n          value: this.IFF.reader.getFloat32()\n        };\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'REFL':\n        this.IFF.currentSurface.attributes.Reflection = {\n          value: this.IFF.reader.getFloat32()\n        };\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'GLOS':\n        this.IFF.currentSurface.attributes.Glossiness = {\n          value: this.IFF.reader.getFloat32()\n        };\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'TRAN':\n        this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'BUMP':\n        this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'SIDE':\n        this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();\n        break;\n\n      case 'RIMG':\n        this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();\n        break;\n\n      case 'RIND':\n        this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'TIMG':\n        this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();\n        break;\n\n      case 'IMAP':\n        this.IFF.reader.skip(2);\n        break;\n\n      case 'TMAP':\n        this.IFF.debugger.skipped = true;\n        this.IFF.reader.skip(length); // needs implementing\n\n        break;\n\n      case 'IUVI':\n        // uv channel name\n        this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length);\n        break;\n\n      case 'IUTL':\n        // widthWrappingMode: 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n        this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();\n        break;\n\n      case 'IVTL':\n        // heightWrappingMode\n        this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();\n        break;\n      // LWO2 USE\n\n      case 'BLOK':\n        // skip\n        break;\n\n      default:\n        this.IFF.parseUnknownCHUNK(blockID, length);\n    }\n\n    if (blockID != 'FORM') {\n      this.IFF.debugger.node = 1;\n      this.IFF.debugger.nodeID = blockID;\n      this.IFF.debugger.log();\n    }\n\n    if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {\n      this.IFF.currentForm = this.IFF.parentForm;\n    }\n  }\n};\n\nexport { LWO2Parser };\n", "import { LoaderUtils } from 'three';\nimport { LWO2Parser } from './LWO2Parser.js';\nimport { LWO3Parser } from './LWO3Parser.js';\n\n/**\n * === IFFParser ===\n * - Parses data from the IFF buffer.\n * - LWO3 files are in IFF format and can contain the following data types, referred to by shorthand codes\n *\n * ATOMIC DATA TYPES\n *  ID Tag - 4x 7 bit uppercase ASCII chars: ID4\n *  signed integer, 1, 2, or 4 byte length: I1, I2, I4\n *  unsigned integer, 1, 2, or 4 byte length: U1, U2, U4\n *  float, 4 byte length: F4\n *  string, series of ASCII chars followed by null byte (If the length of the string including the null terminating byte is odd, an extra null is added so that the data that follows will begin on an even byte boundary): S0\n *\n * COMPOUND DATA TYPES\n *  Variable-length Index (index into an array or collection): U2 or U4 : VX\n *  Color (RGB): F4 + F4 + F4: COL12\n *  Coordinate (x, y, z): F4 + F4 + F4: VEC12\n *  Percentage F4 data type from 0->1 with 1 = 100%: FP4\n *  Angle in radian F4: ANG4\n *  Filename (string) S0: FNAM0\n *  XValue F4 + index (VX) + optional envelope( ENVL ): XVAL\n *  XValue vector VEC12 + index (VX) + optional envelope( ENVL ): XVAL3\n *\n *  The IFF file is arranged in chunks:\n *  CHUNK = ID4 + length (U4) + length X bytes of data + optional 0 pad byte\n *  optional 0 pad byte is there to ensure chunk ends on even boundary, not counted in size\n *\n * COMPOUND DATA TYPES\n * - Chunks are combined in Forms (collections of chunks)\n * - FORM = string 'FORM' (ID4) + length (U4) + type (ID4) + optional ( CHUNK | FORM )\n * - CHUNKS and FORMS are collectively referred to as blocks\n * - The entire file is contained in one top level FORM\n *\n **/\n\nfunction IFFParser() {\n  this.debugger = new Debugger(); // this.debugger.enable(); // un-comment to log IFF hierarchy.\n}\n\nIFFParser.prototype = {\n  constructor: IFFParser,\n  parse: function (buffer) {\n    this.reader = new DataViewReader(buffer);\n    this.tree = {\n      materials: {},\n      layers: [],\n      tags: [],\n      textures: []\n    }; // start out at the top level to add any data before first layer is encountered\n\n    this.currentLayer = this.tree;\n    this.currentForm = this.tree;\n    this.parseTopForm();\n    if (this.tree.format === undefined) return;\n\n    if (this.tree.format === 'LWO2') {\n      this.parser = new LWO2Parser(this);\n\n      while (!this.reader.endOfFile()) this.parser.parseBlock();\n    } else if (this.tree.format === 'LWO3') {\n      this.parser = new LWO3Parser(this);\n\n      while (!this.reader.endOfFile()) this.parser.parseBlock();\n    }\n\n    this.debugger.offset = this.reader.offset;\n    this.debugger.closeForms();\n    return this.tree;\n  },\n\n  parseTopForm() {\n    this.debugger.offset = this.reader.offset;\n    var topForm = this.reader.getIDTag();\n\n    if (topForm !== 'FORM') {\n      console.warn('LWOLoader: Top-level FORM missing.');\n      return;\n    }\n\n    var length = this.reader.getUint32();\n    this.debugger.dataOffset = this.reader.offset;\n    this.debugger.length = length;\n    var type = this.reader.getIDTag();\n\n    if (type === 'LWO2') {\n      this.tree.format = type;\n    } else if (type === 'LWO3') {\n      this.tree.format = type;\n    }\n\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n    return;\n  },\n\n  ///\n  // FORM PARSING METHODS\n  ///\n  // Forms are organisational and can contain any number of sub chunks and sub forms\n  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n  parseForm(length) {\n    var type = this.reader.getIDTag();\n\n    switch (type) {\n      // SKIPPED FORMS\n      // if skipForm( length ) is called, the entire form and any sub forms and chunks are skipped\n      case 'ISEQ': // Image sequence\n\n      case 'ANIM': // plug in animation\n\n      case 'STCC': // Color-cycling Still\n\n      case 'VPVL':\n      case 'VPRM':\n      case 'NROT':\n      case 'WRPW': // image wrap w ( for cylindrical and spherical projections)\n\n      case 'WRPH': // image wrap h\n\n      case 'FUNC':\n      case 'FALL':\n      case 'OPAC':\n      case 'GRAD': // gradient texture\n\n      case 'ENVS':\n      case 'VMOP':\n      case 'VMBG': // Car Material FORMS\n\n      case 'OMAX':\n      case 'STEX':\n      case 'CKBG':\n      case 'CKEY':\n      case 'VMLA':\n      case 'VMLB':\n        this.debugger.skipped = true;\n        this.skipForm(length); // not currently supported\n\n        break;\n      // if break; is called directly, the position in the lwoTree is not created\n      // any sub chunks and forms are added to the parent form instead\n\n      case 'META':\n      case 'NNDS':\n      case 'NODS':\n      case 'NDTA':\n      case 'ADAT':\n      case 'AOVS':\n      case 'BLOK': // used by texture nodes\n\n      case 'IBGC': // imageBackgroundColor\n\n      case 'IOPC': // imageOpacity\n\n      case 'IIMG': // hold reference to image path\n\n      case 'TXTR':\n        // this.setupForm( type, length );\n        this.debugger.length = 4;\n        this.debugger.skipped = true;\n        break;\n\n      case 'IFAL': // imageFallof\n\n      case 'ISCL': // imageScale\n\n      case 'IPOS': // imagePosition\n\n      case 'IROT': // imageRotation\n\n      case 'IBMP':\n      case 'IUTD':\n      case 'IVTD':\n        this.parseTextureNodeAttribute(type);\n        break;\n\n      case 'ENVL':\n        this.parseEnvelope(length);\n        break;\n      // CLIP FORM AND SUB FORMS\n\n      case 'CLIP':\n        if (this.tree.format === 'LWO2') {\n          this.parseForm(length);\n        } else {\n          this.parseClip(length);\n        }\n\n        break;\n\n      case 'STIL':\n        this.parseImage();\n        break;\n\n      case 'XREF':\n        // clone of another STIL\n        this.reader.skip(8); // unknown\n\n        this.currentForm.referenceTexture = {\n          index: this.reader.getUint32(),\n          refName: this.reader.getString() // internal unique ref\n\n        };\n        break;\n      // Not in spec, used by texture nodes\n\n      case 'IMST':\n        this.parseImageStateForm(length);\n        break;\n      // SURF FORM AND SUB FORMS\n\n      case 'SURF':\n        this.parseSurfaceForm(length);\n        break;\n\n      case 'VALU':\n        // Not in spec\n        this.parseValueForm(length);\n        break;\n\n      case 'NTAG':\n        this.parseSubNode(length);\n        break;\n\n      case 'ATTR': // BSDF Node Attributes\n\n      case 'SATR':\n        // Standard Node Attributes\n        this.setupForm('attributes', length);\n        break;\n\n      case 'NCON':\n        this.parseConnections(length);\n        break;\n\n      case 'SSHA':\n        this.parentForm = this.currentForm;\n        this.currentForm = this.currentSurface;\n        this.setupForm('surfaceShader', length);\n        break;\n\n      case 'SSHD':\n        this.setupForm('surfaceShaderData', length);\n        break;\n\n      case 'ENTR':\n        // Not in spec\n        this.parseEntryForm(length);\n        break;\n      // Image Map Layer\n\n      case 'IMAP':\n        this.parseImageMap(length);\n        break;\n\n      case 'TAMP':\n        this.parseXVAL('amplitude', length);\n        break;\n      //Texture Mapping Form\n\n      case 'TMAP':\n        this.setupForm('textureMap', length);\n        break;\n\n      case 'CNTR':\n        this.parseXVAL3('center', length);\n        break;\n\n      case 'SIZE':\n        this.parseXVAL3('scale', length);\n        break;\n\n      case 'ROTA':\n        this.parseXVAL3('rotation', length);\n        break;\n\n      default:\n        this.parseUnknownForm(type, length);\n    }\n\n    this.debugger.node = 0;\n    this.debugger.nodeID = type;\n    this.debugger.log();\n  },\n\n  setupForm(type, length) {\n    if (!this.currentForm) this.currentForm = this.currentNode;\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n\n    if (!this.currentForm[type]) {\n      this.currentForm[type] = {};\n      this.currentForm = this.currentForm[type];\n    } else {\n      // should never see this unless there's a bug in the reader\n      console.warn('LWOLoader: form already exists on parent: ', type, this.currentForm);\n      this.currentForm = this.currentForm[type];\n    }\n  },\n\n  skipForm(length) {\n    this.reader.skip(length - 4);\n  },\n\n  parseUnknownForm(type, length) {\n    console.warn('LWOLoader: unknown FORM encountered: ' + type, length);\n    printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);\n    this.reader.skip(length - 4);\n  },\n\n  parseSurfaceForm(length) {\n    this.reader.skip(8); // unknown Uint32 x2\n\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name: name,\n      inputName: name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  },\n\n  parseSurfaceLwo2(length) {\n    var name = this.reader.getString();\n    var surface = {\n      attributes: {},\n      // LWO2 style non-node attributes will go here\n      connections: {},\n      name: name,\n      nodes: {},\n      source: this.reader.getString()\n    };\n    this.tree.materials[name] = surface;\n    this.currentSurface = surface;\n    this.parentForm = this.tree.materials;\n    this.currentForm = surface;\n    this.currentFormEnd = this.reader.offset + length;\n  },\n\n  parseSubNode(length) {\n    // parse the NRNM CHUNK of the subnode FORM to get\n    // a meaningful name for the subNode\n    // some subnodes can be renamed, but Input and Surface cannot\n    this.reader.skip(8); // NRNM + length\n\n    var name = this.reader.getString();\n    var node = {\n      name: name\n    };\n    this.currentForm = node;\n    this.currentNode = node;\n    this.currentFormEnd = this.reader.offset + length;\n  },\n\n  // collect attributes from all nodes at the top level of a surface\n  parseConnections(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.currentForm = this.currentSurface.connections;\n  },\n\n  // surface node attribute data, e.g. specular, roughness etc\n  parseEntryForm(length) {\n    this.reader.skip(8); // NAME + length\n\n    var name = this.reader.getString();\n    this.currentForm = this.currentNode.attributes;\n    this.setupForm(name, length);\n  },\n\n  // parse values from material - doesn't match up to other LWO3 data types\n  // sub form of entry form\n  parseValueForm() {\n    this.reader.skip(8); // unknown + length\n\n    var valueType = this.reader.getString();\n\n    if (valueType === 'double') {\n      this.currentForm.value = this.reader.getUint64();\n    } else if (valueType === 'int') {\n      this.currentForm.value = this.reader.getUint32();\n    } else if (valueType === 'vparam') {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64();\n    } else if (valueType === 'vparam3') {\n      this.reader.skip(24);\n      this.currentForm.value = this.reader.getFloat64Array(3);\n    }\n  },\n\n  // holds various data about texture node image state\n  // Data other thanmipMapLevel unknown\n  parseImageStateForm() {\n    this.reader.skip(8); // unknown\n\n    this.currentForm.mipMapLevel = this.reader.getFloat32();\n  },\n\n  // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n  parseImageMap(length) {\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    if (!this.currentForm.maps) this.currentForm.maps = [];\n    var map = {};\n    this.currentForm.maps.push(map);\n    this.currentForm = map;\n    this.reader.skip(10); // unknown, could be an issue if it contains a VX\n  },\n\n  parseTextureNodeAttribute(type) {\n    this.reader.skip(28); // FORM + length + VPRM + unknown + Uint32 x2 + float32\n\n    this.reader.skip(20); // FORM + length + VPVL + float32 + Uint32\n\n    switch (type) {\n      case 'ISCL':\n        this.currentNode.scale = this.reader.getFloat32Array(3);\n        break;\n\n      case 'IPOS':\n        this.currentNode.position = this.reader.getFloat32Array(3);\n        break;\n\n      case 'IROT':\n        this.currentNode.rotation = this.reader.getFloat32Array(3);\n        break;\n\n      case 'IFAL':\n        this.currentNode.falloff = this.reader.getFloat32Array(3);\n        break;\n\n      case 'IBMP':\n        this.currentNode.amplitude = this.reader.getFloat32();\n        break;\n\n      case 'IUTD':\n        this.currentNode.uTiles = this.reader.getFloat32();\n        break;\n\n      case 'IVTD':\n        this.currentNode.vTiles = this.reader.getFloat32();\n        break;\n    }\n\n    this.reader.skip(2); // unknown\n  },\n\n  // ENVL forms are currently ignored\n  parseEnvelope(length) {\n    this.reader.skip(length - 4); // skipping  entirely for now\n  },\n\n  ///\n  // CHUNK PARSING METHODS\n  ///\n  // clips can either be defined inside a surface node, or at the top\n  // level and they have a different format in each case\n  parseClip(length) {\n    var tag = this.reader.getIDTag(); // inside surface node\n\n    if (tag === 'FORM') {\n      this.reader.skip(16);\n      this.currentNode.fileName = this.reader.getString();\n      return;\n    } // otherwise top level\n\n\n    this.reader.setOffset(this.reader.offset - 4);\n    this.currentFormEnd = this.reader.offset + length;\n    this.parentForm = this.currentForm;\n    this.reader.skip(8); // unknown\n\n    var texture = {\n      index: this.reader.getUint32()\n    };\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  },\n\n  parseClipLwo2(length) {\n    var texture = {\n      index: this.reader.getUint32(),\n      fileName: ''\n    }; // seach STIL block\n\n    while (true) {\n      var tag = this.reader.getIDTag();\n      var n_length = this.reader.getUint16();\n\n      if (tag === 'STIL') {\n        texture.fileName = this.reader.getString();\n        break;\n      }\n\n      if (n_length >= length) {\n        break;\n      }\n    }\n\n    this.tree.textures.push(texture);\n    this.currentForm = texture;\n  },\n\n  parseImage() {\n    this.reader.skip(8); // unknown\n\n    this.currentForm.fileName = this.reader.getString();\n  },\n\n  parseXVAL(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = this.reader.getFloat32();\n    this.reader.setOffset(endOffset); // set end offset directly to skip optional envelope\n  },\n\n  parseXVAL3(type, length) {\n    var endOffset = this.reader.offset + length - 4;\n    this.reader.skip(8);\n    this.currentForm[type] = {\n      x: this.reader.getFloat32(),\n      y: this.reader.getFloat32(),\n      z: this.reader.getFloat32()\n    };\n    this.reader.setOffset(endOffset);\n  },\n\n  // Tags associated with an object\n  // OTAG { type[ID4], tag-string[S0] }\n  parseObjectTag() {\n    if (!this.tree.objectTags) this.tree.objectTags = {};\n    this.tree.objectTags[this.reader.getIDTag()] = {\n      tagString: this.reader.getString()\n    };\n  },\n\n  // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n  parseLayer(length) {\n    var layer = {\n      number: this.reader.getUint16(),\n      flags: this.reader.getUint16(),\n      // If the least significant bit of flags is set, the layer is hidden.\n      pivot: this.reader.getFloat32Array(3),\n      // Note: this seems to be superflous, as the geometry is translated when pivot is present\n      name: this.reader.getString()\n    };\n    this.tree.layers.push(layer);\n    this.currentLayer = layer;\n    var parsedLength = 16 + stringOffset(this.currentLayer.name); // index ( 2 ) + flags( 2 ) + pivot( 12 ) + stringlength\n    // if we have not reached then end of the layer block, there must be a parent defined\n\n    this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1; // omitted or -1 for no parent\n  },\n\n  // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n  // Converting from left to right handed coordinate system:\n  // x -> -x and switch material FrontSide -> BackSide\n  parsePoints(length) {\n    this.currentPoints = [];\n\n    for (let i = 0; i < length / 4; i += 3) {\n      // z -> -z to match three.js right handed coords\n      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n  },\n\n  // parse VMAP or VMAD\n  // Associates a set of floating-point vectors with a set of points.\n  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n  // Similar to VMAP UVs, but associates with polygon vertices rather than points\n  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n  // if they exist. The vector values in the VMAD will then replace those in the\n  // corresponding VMAP, but only for calculations involving the specified polygons.\n  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n  parseVertexMapping(length, discontinuous) {\n    var finalOffset = this.reader.offset + length;\n    var channelName = this.reader.getString();\n\n    if (this.reader.offset === finalOffset) {\n      // then we are in a texture node and the VMAP chunk is just a reference to a UV channel name\n      this.currentForm.UVChannel = channelName;\n      return;\n    } // otherwise reset to initial length and parse normal VMAP CHUNK\n\n\n    this.reader.setOffset(this.reader.offset - stringOffset(channelName));\n    var type = this.reader.getIDTag();\n    this.reader.getUint16(); // dimension\n\n    var name = this.reader.getString();\n    var remainingLength = length - 6 - stringOffset(name);\n\n    switch (type) {\n      case 'TXUV':\n        this.parseUVMapping(name, finalOffset, discontinuous);\n        break;\n\n      case 'MORF':\n      case 'SPOT':\n        this.parseMorphTargets(name, finalOffset, type); // can't be discontinuous\n\n        break;\n      // unsupported VMAPs\n\n      case 'APSL':\n      case 'NORM':\n      case 'WGHT':\n      case 'MNVW':\n      case 'PICK':\n      case 'RGB ':\n      case 'RGBA':\n        this.reader.skip(remainingLength);\n        break;\n\n      default:\n        console.warn('LWOLoader: unknown vertex map type: ' + type);\n        this.reader.skip(remainingLength);\n    }\n  },\n\n  parseUVMapping(name, finalOffset, discontinuous) {\n    var uvIndices = [];\n    var polyIndices = [];\n    var uvs = [];\n\n    while (this.reader.offset < finalOffset) {\n      uvIndices.push(this.reader.getVariableLengthIndex());\n      if (discontinuous) polyIndices.push(this.reader.getVariableLengthIndex());\n      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());\n    }\n\n    if (discontinuous) {\n      if (!this.currentLayer.discontinuousUVs) this.currentLayer.discontinuousUVs = {};\n      this.currentLayer.discontinuousUVs[name] = {\n        uvIndices: uvIndices,\n        polyIndices: polyIndices,\n        uvs: uvs\n      };\n    } else {\n      if (!this.currentLayer.uvs) this.currentLayer.uvs = {};\n      this.currentLayer.uvs[name] = {\n        uvIndices: uvIndices,\n        uvs: uvs\n      };\n    }\n  },\n\n  parseMorphTargets(name, finalOffset, type) {\n    var indices = [];\n    var points = [];\n    type = type === 'MORF' ? 'relative' : 'absolute';\n\n    while (this.reader.offset < finalOffset) {\n      indices.push(this.reader.getVariableLengthIndex()); // z -> -z to match three.js right handed coords\n\n      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\n    }\n\n    if (!this.currentLayer.morphTargets) this.currentLayer.morphTargets = {};\n    this.currentLayer.morphTargets[name] = {\n      indices: indices,\n      points: points,\n      type: type\n    };\n  },\n\n  // A list of polygons for the current layer.\n  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n  parsePolygonList(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n    var indices = []; // hold a list of polygon sizes, to be split up later\n\n    var polygonDimensions = [];\n\n    while (this.reader.offset < finalOffset) {\n      var numverts = this.reader.getUint16(); //var flags = numverts & 64512; // 6 high order bits are flags - ignoring for now\n\n      numverts = numverts & 1023; // remaining ten low order bits are vertex num\n\n      polygonDimensions.push(numverts);\n\n      for (let j = 0; j < numverts; j++) indices.push(this.reader.getVariableLengthIndex());\n    }\n\n    var geometryData = {\n      type: type,\n      vertexIndices: indices,\n      polygonDimensions: polygonDimensions,\n      points: this.currentPoints\n    }; // Note: assuming that all polys will be lines or points if the first is\n\n    if (polygonDimensions[0] === 1) geometryData.type = 'points';else if (polygonDimensions[0] === 2) geometryData.type = 'lines';\n    this.currentLayer.geometry = geometryData;\n  },\n\n  // Lists the tag strings that can be associated with polygons by the PTAG chunk.\n  // TAGS { tag-string[S0] * }\n  parseTagStrings(length) {\n    this.tree.tags = this.reader.getStringArray(length);\n  },\n\n  // Associates tags of a given type with polygons in the most recent POLS chunk.\n  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n  parsePolygonTagMapping(length) {\n    var finalOffset = this.reader.offset + length;\n    var type = this.reader.getIDTag();\n\n    if (type === 'SURF') {\n      this.parseMaterialIndices(finalOffset);\n    } else {\n      //PART, SMGP, COLR not supported\n      this.reader.skip(length - 4);\n    }\n  },\n\n  parseMaterialIndices(finalOffset) {\n    // array holds polygon index followed by material index\n    this.currentLayer.geometry.materialIndices = [];\n\n    while (this.reader.offset < finalOffset) {\n      var polygonIndex = this.reader.getVariableLengthIndex();\n      var materialIndex = this.reader.getUint16();\n      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);\n    }\n  },\n\n  parseUnknownCHUNK(blockID, length) {\n    console.warn('LWOLoader: unknown chunk type: ' + blockID + ' length: ' + length); // print the chunk plus some bytes padding either side\n    // printBuffer( this.reader.dv.buffer, this.reader.offset - 20, length + 40 );\n\n    var data = this.reader.getString(length);\n    this.currentForm[blockID] = data;\n  }\n\n};\n\nfunction DataViewReader(buffer) {\n  this.dv = new DataView(buffer);\n  this.offset = 0;\n}\n\nDataViewReader.prototype = {\n  constructor: DataViewReader,\n  size: function () {\n    return this.dv.buffer.byteLength;\n  },\n\n  setOffset(offset) {\n    if (offset > 0 && offset < this.dv.buffer.byteLength) {\n      this.offset = offset;\n    } else {\n      console.error('LWOLoader: invalid buffer offset');\n    }\n  },\n\n  endOfFile: function () {\n    if (this.offset >= this.size()) return true;\n    return false;\n  },\n  skip: function (length) {\n    this.offset += length;\n  },\n  getUint8: function () {\n    var value = this.dv.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  },\n  getUint16: function () {\n    var value = this.dv.getUint16(this.offset);\n    this.offset += 2;\n    return value;\n  },\n  getInt32: function () {\n    var value = this.dv.getInt32(this.offset, false);\n    this.offset += 4;\n    return value;\n  },\n  getUint32: function () {\n    var value = this.dv.getUint32(this.offset, false);\n    this.offset += 4;\n    return value;\n  },\n  getUint64: function () {\n    var low, high;\n    high = this.getUint32();\n    low = this.getUint32();\n    return high * 0x100000000 + low;\n  },\n  getFloat32: function () {\n    var value = this.dv.getFloat32(this.offset, false);\n    this.offset += 4;\n    return value;\n  },\n  getFloat32Array: function (size) {\n    var a = [];\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat32());\n    }\n\n    return a;\n  },\n  getFloat64: function () {\n    var value = this.dv.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  },\n  getFloat64Array: function (size) {\n    var a = [];\n\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat64());\n    }\n\n    return a;\n  },\n\n  // get variable-length index data type\n  // VX ::= index[U2] | (index + 0xFF000000)[U4]\n  // If the index value is less than 65,280 (0xFF00),then VX === U2\n  // otherwise VX === U4 with bits 24-31 set\n  // When reading an index, if the first byte encountered is 255 (0xFF), then\n  // the four-byte form is being used and the first byte should be discarded or masked out.\n  getVariableLengthIndex() {\n    var firstByte = this.getUint8();\n\n    if (firstByte === 255) {\n      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n    }\n\n    return firstByte * 256 + this.getUint8();\n  },\n\n  // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n  getIDTag() {\n    return this.getString(4);\n  },\n\n  getString: function (size) {\n    if (size === 0) return; // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n\n    var a = [];\n\n    if (size) {\n      for (let i = 0; i < size; i++) {\n        a[i] = this.getUint8();\n      }\n    } else {\n      var currentChar;\n      var len = 0;\n\n      while (currentChar !== 0) {\n        currentChar = this.getUint8();\n        if (currentChar !== 0) a.push(currentChar);\n        len++;\n      }\n\n      if (!isEven(len + 1)) this.getUint8(); // if string with terminating nullbyte is uneven, extra nullbyte is added\n    }\n\n    return LoaderUtils.decodeText(new Uint8Array(a));\n  },\n  getStringArray: function (size) {\n    var a = this.getString(size);\n    a = a.split('\\0');\n    return a.filter(Boolean); // return array with any empty strings removed\n  }\n}; // ************** DEBUGGER  **************\n\nfunction Debugger() {\n  this.active = false;\n  this.depth = 0;\n  this.formList = [];\n}\n\nDebugger.prototype = {\n  constructor: Debugger,\n  enable: function () {\n    this.active = true;\n  },\n  log: function () {\n    if (!this.active) return;\n    var nodeType;\n\n    switch (this.node) {\n      case 0:\n        nodeType = 'FORM';\n        break;\n\n      case 1:\n        nodeType = 'CHK';\n        break;\n\n      case 2:\n        nodeType = 'S-CHK';\n        break;\n    }\n\n    console.log('| '.repeat(this.depth) + nodeType, this.nodeID, `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`, this.node == 0 ? ' {' : '', this.skipped ? 'SKIPPED' : '', this.node == 0 && this.skipped ? '}' : '');\n\n    if (this.node == 0 && !this.skipped) {\n      this.depth += 1;\n      this.formList.push(this.dataOffset + this.length);\n    }\n\n    this.skipped = false;\n  },\n  closeForms: function () {\n    if (!this.active) return;\n\n    for (let i = this.formList.length - 1; i >= 0; i--) {\n      if (this.offset >= this.formList[i]) {\n        this.depth -= 1;\n        console.log('| '.repeat(this.depth) + '}');\n        this.formList.splice(-1, 1);\n      }\n    }\n  }\n}; // ************** UTILITY FUNCTIONS **************\n\nfunction isEven(num) {\n  return num % 2;\n} // calculate the length of the string in the buffer\n// this will be string.length + nullbyte + optional padbyte to make the length even\n\n\nfunction stringOffset(string) {\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);\n} // for testing purposes, dump buffer to console\n// printBuffer( this.reader.dv.buffer, this.reader.offset, length );\n\n\nfunction printBuffer(buffer, from, to) {\n  console.log(LoaderUtils.decodeText(new Uint8Array(buffer, from, to)));\n}\n\nexport { IFFParser };\n", "import { Vector3, Loader, FileLoader, Group, BufferGeometry, Float32BufferAttribute, LineBasicMaterial, Material, PointsMaterial, MeshPhongMaterial, LineSegments, Points, Mesh } from 'three';\n\nconst _object_pattern = /^[og]\\s*(.+)?/; // mtllib file_reference\n\nconst _material_library_pattern = /^mtllib /; // usemtl material_name\n\nconst _material_use_pattern = /^usemtl /; // usemap map_name\n\nconst _map_use_pattern = /^usemap /;\n\nconst _vA = new Vector3();\n\nconst _vB = new Vector3();\n\nconst _vC = new Vector3();\n\nconst _ab = new Vector3();\n\nconst _cb = new Vector3();\n\nfunction ParserState() {\n  const state = {\n    objects: [],\n    object: {},\n    vertices: [],\n    normals: [],\n    colors: [],\n    uvs: [],\n    materials: {},\n    materialLibraries: [],\n    startObject: function (name, fromDeclaration) {\n      // If the current object (initial from reset) is not from a g/o declaration in the parsed\n      // file. We need to use it for the first parsed g/o to keep things in sync.\n      if (this.object && this.object.fromDeclaration === false) {\n        this.object.name = name;\n        this.object.fromDeclaration = fromDeclaration !== false;\n        return;\n      }\n\n      const previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\n\n      if (this.object && typeof this.object._finalize === 'function') {\n        this.object._finalize(true);\n      }\n\n      this.object = {\n        name: name || '',\n        fromDeclaration: fromDeclaration !== false,\n        geometry: {\n          vertices: [],\n          normals: [],\n          colors: [],\n          uvs: [],\n          hasUVIndices: false\n        },\n        materials: [],\n        smooth: true,\n        startMaterial: function (name, libraries) {\n          const previous = this._finalize(false); // New usemtl declaration overwrites an inherited material, except if faces were declared\n          // after the material, then it must be preserved for proper MultiMaterial continuation.\n\n\n          if (previous && (previous.inherited || previous.groupCount <= 0)) {\n            this.materials.splice(previous.index, 1);\n          }\n\n          const material = {\n            index: this.materials.length,\n            name: name || '',\n            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n            smooth: previous !== undefined ? previous.smooth : this.smooth,\n            groupStart: previous !== undefined ? previous.groupEnd : 0,\n            groupEnd: -1,\n            groupCount: -1,\n            inherited: false,\n            clone: function (index) {\n              const cloned = {\n                index: typeof index === 'number' ? index : this.index,\n                name: this.name,\n                mtllib: this.mtllib,\n                smooth: this.smooth,\n                groupStart: 0,\n                groupEnd: -1,\n                groupCount: -1,\n                inherited: false\n              };\n              cloned.clone = this.clone.bind(cloned);\n              return cloned;\n            }\n          };\n          this.materials.push(material);\n          return material;\n        },\n        currentMaterial: function () {\n          if (this.materials.length > 0) {\n            return this.materials[this.materials.length - 1];\n          }\n\n          return undefined;\n        },\n        _finalize: function (end) {\n          const lastMultiMaterial = this.currentMaterial();\n\n          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n            lastMultiMaterial.inherited = false;\n          } // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\n\n          if (end && this.materials.length > 1) {\n            for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n              if (this.materials[mi].groupCount <= 0) {\n                this.materials.splice(mi, 1);\n              }\n            }\n          } // Guarantee at least one empty material, this makes the creation later more straight forward.\n\n\n          if (end && this.materials.length === 0) {\n            this.materials.push({\n              name: '',\n              smooth: this.smooth\n            });\n          }\n\n          return lastMultiMaterial;\n        }\n      }; // Inherit previous objects material.\n      // Spec tells us that a declared material must be set to all objects until a new material is declared.\n      // If a usemtl declaration is encountered while this new object is being parsed, it will\n      // overwrite the inherited material. Exception being that there was already face declarations\n      // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n        const declared = previousMaterial.clone(0);\n        declared.inherited = true;\n        this.object.materials.push(declared);\n      }\n\n      this.objects.push(this.object);\n    },\n    finalize: function () {\n      if (this.object && typeof this.object._finalize === 'function') {\n        this.object._finalize(true);\n      }\n    },\n    parseVertexIndex: function (value, len) {\n      const index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    },\n    parseNormalIndex: function (value, len) {\n      const index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    },\n    parseUVIndex: function (value, len) {\n      const index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 2) * 2;\n    },\n    addVertex: function (a, b, c) {\n      const src = this.vertices;\n      const dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addVertexPoint: function (a) {\n      const src = this.vertices;\n      const dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    },\n    addVertexLine: function (a) {\n      const src = this.vertices;\n      const dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    },\n    addNormal: function (a, b, c) {\n      const src = this.normals;\n      const dst = this.object.geometry.normals;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addFaceNormal: function (a, b, c) {\n      const src = this.vertices;\n      const dst = this.object.geometry.normals;\n\n      _vA.fromArray(src, a);\n\n      _vB.fromArray(src, b);\n\n      _vC.fromArray(src, c);\n\n      _cb.subVectors(_vC, _vB);\n\n      _ab.subVectors(_vA, _vB);\n\n      _cb.cross(_ab);\n\n      _cb.normalize();\n\n      dst.push(_cb.x, _cb.y, _cb.z);\n      dst.push(_cb.x, _cb.y, _cb.z);\n      dst.push(_cb.x, _cb.y, _cb.z);\n    },\n    addColor: function (a, b, c) {\n      const src = this.colors;\n      const dst = this.object.geometry.colors;\n      if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addUV: function (a, b, c) {\n      const src = this.uvs;\n      const dst = this.object.geometry.uvs;\n      dst.push(src[a + 0], src[a + 1]);\n      dst.push(src[b + 0], src[b + 1]);\n      dst.push(src[c + 0], src[c + 1]);\n    },\n    addDefaultUV: function () {\n      const dst = this.object.geometry.uvs;\n      dst.push(0, 0);\n      dst.push(0, 0);\n      dst.push(0, 0);\n    },\n    addUVLine: function (a) {\n      const src = this.uvs;\n      const dst = this.object.geometry.uvs;\n      dst.push(src[a + 0], src[a + 1]);\n    },\n    addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\n      const vLen = this.vertices.length;\n      let ia = this.parseVertexIndex(a, vLen);\n      let ib = this.parseVertexIndex(b, vLen);\n      let ic = this.parseVertexIndex(c, vLen);\n      this.addVertex(ia, ib, ic);\n      this.addColor(ia, ib, ic); // normals\n\n      if (na !== undefined && na !== '') {\n        const nLen = this.normals.length;\n        ia = this.parseNormalIndex(na, nLen);\n        ib = this.parseNormalIndex(nb, nLen);\n        ic = this.parseNormalIndex(nc, nLen);\n        this.addNormal(ia, ib, ic);\n      } else {\n        this.addFaceNormal(ia, ib, ic);\n      } // uvs\n\n\n      if (ua !== undefined && ua !== '') {\n        const uvLen = this.uvs.length;\n        ia = this.parseUVIndex(ua, uvLen);\n        ib = this.parseUVIndex(ub, uvLen);\n        ic = this.parseUVIndex(uc, uvLen);\n        this.addUV(ia, ib, ic);\n        this.object.geometry.hasUVIndices = true;\n      } else {\n        // add placeholder values (for inconsistent face definitions)\n        this.addDefaultUV();\n      }\n    },\n    addPointGeometry: function (vertices) {\n      this.object.geometry.type = 'Points';\n      const vLen = this.vertices.length;\n\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        const index = this.parseVertexIndex(vertices[vi], vLen);\n        this.addVertexPoint(index);\n        this.addColor(index);\n      }\n    },\n    addLineGeometry: function (vertices, uvs) {\n      this.object.geometry.type = 'Line';\n      const vLen = this.vertices.length;\n      const uvLen = this.uvs.length;\n\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n      }\n\n      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {\n        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n      }\n    }\n  };\n  state.startObject('', false);\n  return state;\n} //\n\n\nclass OBJLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.materials = null;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  setMaterials(materials) {\n    this.materials = materials;\n    return this;\n  }\n\n  parse(text) {\n    const state = new ParserState();\n\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n');\n    }\n\n    if (text.indexOf('\\\\\\n') !== -1) {\n      // join lines separated by a line continuation character (\\)\n      text = text.replace(/\\\\\\n/g, '');\n    }\n\n    const lines = text.split('\\n');\n    let line = '',\n        lineFirstChar = '';\n    let lineLength = 0;\n    let result = []; // Faster to just trim left side of the line. Use if available.\n\n    const trimLeft = typeof ''.trimLeft === 'function';\n\n    for (let i = 0, l = lines.length; i < l; i++) {\n      line = lines[i];\n      line = trimLeft ? line.trimLeft() : line.trim();\n      lineLength = line.length;\n      if (lineLength === 0) continue;\n      lineFirstChar = line.charAt(0); // @todo invoke passed in handler if any\n\n      if (lineFirstChar === '#') continue;\n\n      if (lineFirstChar === 'v') {\n        const data = line.split(/\\s+/);\n\n        switch (data[0]) {\n          case 'v':\n            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n\n            if (data.length >= 7) {\n              state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n            } else {\n              // if no colors are defined, add placeholders so color and vertex indices match\n              state.colors.push(undefined, undefined, undefined);\n            }\n\n            break;\n\n          case 'vn':\n            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n            break;\n\n          case 'vt':\n            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n            break;\n        }\n      } else if (lineFirstChar === 'f') {\n        const lineData = line.substr(1).trim();\n        const vertexData = lineData.split(/\\s+/);\n        const faceVertices = []; // Parse the face vertex data into an easy to work with format\n\n        for (let j = 0, jl = vertexData.length; j < jl; j++) {\n          const vertex = vertexData[j];\n\n          if (vertex.length > 0) {\n            const vertexParts = vertex.split('/');\n            faceVertices.push(vertexParts);\n          }\n        } // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\n        const v1 = faceVertices[0];\n\n        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n          const v2 = faceVertices[j];\n          const v3 = faceVertices[j + 1];\n          state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n        }\n      } else if (lineFirstChar === 'l') {\n        const lineParts = line.substring(1).trim().split(' ');\n        let lineVertices = [];\n        const lineUVs = [];\n\n        if (line.indexOf('/') === -1) {\n          lineVertices = lineParts;\n        } else {\n          for (let li = 0, llen = lineParts.length; li < llen; li++) {\n            const parts = lineParts[li].split('/');\n            if (parts[0] !== '') lineVertices.push(parts[0]);\n            if (parts[1] !== '') lineUVs.push(parts[1]);\n          }\n        }\n\n        state.addLineGeometry(lineVertices, lineUVs);\n      } else if (lineFirstChar === 'p') {\n        const lineData = line.substr(1).trim();\n        const pointData = lineData.split(' ');\n        state.addPointGeometry(pointData);\n      } else if ((result = _object_pattern.exec(line)) !== null) {\n        // o object_name\n        // or\n        // g group_name\n        // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n        // let name = result[ 0 ].substr( 1 ).trim();\n        const name = (' ' + result[0].substr(1).trim()).substr(1);\n        state.startObject(name);\n      } else if (_material_use_pattern.test(line)) {\n        // material\n        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n      } else if (_material_library_pattern.test(line)) {\n        // mtl file\n        state.materialLibraries.push(line.substring(7).trim());\n      } else if (_map_use_pattern.test(line)) {\n        // the line is parsed but ignored since the loader assumes textures are defined MTL files\n        // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n        console.warn('THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.');\n      } else if (lineFirstChar === 's') {\n        result = line.split(' '); // smooth shading\n        // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n        // but does not define a usemtl for each face set.\n        // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n        // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n        // where explicit usemtl defines geometry groups.\n        // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n        /*\n         * http://paulbourke.net/dataformats/obj/\n         * or\n         * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n         *\n         * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n         * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n         * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n         * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n         * than 0.\"\n         */\n\n        if (result.length > 1) {\n          const value = result[1].trim().toLowerCase();\n          state.object.smooth = value !== '0' && value !== 'off';\n        } else {\n          // ZBrush can produce \"s\" lines #11707\n          state.object.smooth = true;\n        }\n\n        const material = state.object.currentMaterial();\n        if (material) material.smooth = state.object.smooth;\n      } else {\n        // Handle null terminated files without exception\n        if (line === '\\0') continue;\n        console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\n      }\n    }\n\n    state.finalize();\n    const container = new Group();\n    container.materialLibraries = [].concat(state.materialLibraries);\n    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);\n\n    if (hasPrimitives === true) {\n      for (let i = 0, l = state.objects.length; i < l; i++) {\n        const object = state.objects[i];\n        const geometry = object.geometry;\n        const materials = object.materials;\n        const isLine = geometry.type === 'Line';\n        const isPoints = geometry.type === 'Points';\n        let hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces\n\n        if (geometry.vertices.length === 0) continue;\n        const buffergeometry = new BufferGeometry();\n        buffergeometry.setAttribute('position', new Float32BufferAttribute(geometry.vertices, 3));\n\n        if (geometry.normals.length > 0) {\n          buffergeometry.setAttribute('normal', new Float32BufferAttribute(geometry.normals, 3));\n        }\n\n        if (geometry.colors.length > 0) {\n          hasVertexColors = true;\n          buffergeometry.setAttribute('color', new Float32BufferAttribute(geometry.colors, 3));\n        }\n\n        if (geometry.hasUVIndices === true) {\n          buffergeometry.setAttribute('uv', new Float32BufferAttribute(geometry.uvs, 2));\n        } // Create materials\n\n\n        const createdMaterials = [];\n\n        for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n          const sourceMaterial = materials[mi];\n          const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\n          let material = state.materials[materialHash];\n\n          if (this.materials !== null) {\n            material = this.materials.create(sourceMaterial.name); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\n            if (isLine && material && !(material instanceof LineBasicMaterial)) {\n              const materialLine = new LineBasicMaterial();\n              Material.prototype.copy.call(materialLine, material);\n              materialLine.color.copy(material.color);\n              material = materialLine;\n            } else if (isPoints && material && !(material instanceof PointsMaterial)) {\n              const materialPoints = new PointsMaterial({\n                size: 10,\n                sizeAttenuation: false\n              });\n              Material.prototype.copy.call(materialPoints, material);\n              materialPoints.color.copy(material.color);\n              materialPoints.map = material.map;\n              material = materialPoints;\n            }\n          }\n\n          if (material === undefined) {\n            if (isLine) {\n              material = new LineBasicMaterial();\n            } else if (isPoints) {\n              material = new PointsMaterial({\n                size: 1,\n                sizeAttenuation: false\n              });\n            } else {\n              material = new MeshPhongMaterial();\n            }\n\n            material.name = sourceMaterial.name;\n            material.flatShading = sourceMaterial.smooth ? false : true;\n            material.vertexColors = hasVertexColors;\n            state.materials[materialHash] = material;\n          }\n\n          createdMaterials.push(material);\n        } // Create mesh\n\n\n        let mesh;\n\n        if (createdMaterials.length > 1) {\n          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n            const sourceMaterial = materials[mi];\n            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n          }\n\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials);\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials);\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials);\n          }\n        } else {\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials[0]);\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials[0]);\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials[0]);\n          }\n        }\n\n        mesh.name = object.name;\n        container.add(mesh);\n      }\n    } else {\n      // if there is only the default parser state object with no geometry data, interpret data as point cloud\n      if (state.vertices.length > 0) {\n        const material = new PointsMaterial({\n          size: 1,\n          sizeAttenuation: false\n        });\n        const buffergeometry = new BufferGeometry();\n        buffergeometry.setAttribute('position', new Float32BufferAttribute(state.vertices, 3));\n\n        if (state.colors.length > 0 && state.colors[0] !== undefined) {\n          buffergeometry.setAttribute('color', new Float32BufferAttribute(state.colors, 3));\n          material.vertexColors = true;\n        }\n\n        const points = new Points(buffergeometry, material);\n        container.add(points);\n      }\n    }\n\n    return container;\n  }\n\n}\n\nexport { OBJLoader };\n", "import { CompressedTextureLoader } from 'three';\n\n/**\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n *\n * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts\n */\n\nclass KTXLoader extends CompressedTextureLoader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  parse(buffer, loadMipmaps) {\n    const ktx = new KhronosTextureContainer(buffer, 1);\n    return {\n      mipmaps: ktx.mipmaps(loadMipmaps),\n      width: ktx.pixelWidth,\n      height: ktx.pixelHeight,\n      format: ktx.glInternalFormat,\n      isCubemap: ktx.numberOfFaces === 6,\n      mipmapCount: ktx.numberOfMipmapLevels\n    };\n  }\n\n}\n\nconst HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\n// load types\n\nconst COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\n//const COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\n//const TEX_2D = 2; // uses a gl.texImage2D()\n//const TEX_3D = 3; // uses a gl.texImage3D()\n\nclass KhronosTextureContainer {\n  /**\n   * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file\n   * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or\n   * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented\n   * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented\n   */\n  constructor(arrayBuffer, facesExpected\n  /*, threeDExpected, textureArrayExpected */\n  ) {\n    this.arrayBuffer = arrayBuffer; // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:\n    // '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\\r', '\\n', '\\x1A', '\\n'\n    // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n\n    const identifier = new Uint8Array(this.arrayBuffer, 0, 12);\n\n    if (identifier[0] !== 0xab || identifier[1] !== 0x4b || identifier[2] !== 0x54 || identifier[3] !== 0x58 || identifier[4] !== 0x20 || identifier[5] !== 0x31 || identifier[6] !== 0x31 || identifier[7] !== 0xbb || identifier[8] !== 0x0d || identifier[9] !== 0x0a || identifier[10] !== 0x1a || identifier[11] !== 0x0a) {\n      console.error('texture missing KTX identifier');\n      return;\n    } // load the reset of the header in native 32 bit uint\n\n\n    const dataSize = Uint32Array.BYTES_PER_ELEMENT;\n    const headerDataView = new DataView(this.arrayBuffer, 12, 13 * dataSize);\n    const endianness = headerDataView.getUint32(0, true);\n    const littleEndian = endianness === 0x04030201;\n    this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures\n\n    this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures\n\n    this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures\n\n    this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n\n    this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n\n    this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n\n    this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n\n    this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n\n    this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays\n\n    this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6\n\n    this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures\n\n    this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data\n    // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n\n    if (this.glType !== 0) {\n      console.warn('only compressed formats currently supported');\n      return;\n    } else {\n      // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n      this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);\n    }\n\n    if (this.pixelHeight === 0 || this.pixelDepth !== 0) {\n      console.warn('only 2D textures currently supported');\n      return;\n    }\n\n    if (this.numberOfArrayElements !== 0) {\n      console.warn('texture arrays not currently supported');\n      return;\n    }\n\n    if (this.numberOfFaces !== facesExpected) {\n      console.warn('number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces);\n      return;\n    } // we now have a completely validated file, so could use existence of loadType as success\n    // would need to make this more elaborate & adjust checks above to support more than one load type\n\n\n    this.loadType = COMPRESSED_2D;\n  }\n\n  mipmaps(loadMipmaps) {\n    const mipmaps = []; // initialize width & height for level 1\n\n    let dataOffset = HEADER_LEN + this.bytesOfKeyValueData;\n    let width = this.pixelWidth;\n    let height = this.pixelHeight;\n    const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\n\n    for (let level = 0; level < mipmapCount; level++) {\n      const imageSize = new Int32Array(this.arrayBuffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\n\n      dataOffset += 4; // size of the image + 4 for the imageSize field\n\n      for (let face = 0; face < this.numberOfFaces; face++) {\n        const byteArray = new Uint8Array(this.arrayBuffer, dataOffset, imageSize);\n        mipmaps.push({\n          data: byteArray,\n          width: width,\n          height: height\n        });\n        dataOffset += imageSize;\n        dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image\n      }\n\n      width = Math.max(1.0, width * 0.5);\n      height = Math.max(1.0, height * 0.5);\n    }\n\n    return mipmaps;\n  }\n\n}\n\nexport { KTXLoader };\n", "import { DataTextureLoader, HalfFloatType, CubeTexture, RGBAFormat, LinearFilter, DataUtils } from 'three';\n\nclass RGBMLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n    this.maxRange = 7; // more information about this property at https://iwasbeingirony.blogspot.com/2010/06/difference-between-rgbm-and-rgbd.html\n  }\n\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n\n  setMaxRange(value) {\n    this.maxRange = value;\n    return this;\n  }\n\n  loadCubemap(urls, onLoad, onProgress, onError) {\n    const texture = new CubeTexture();\n    let loaded = 0;\n    const scope = this;\n\n    function loadTexture(i) {\n      scope.load(urls[i], function (image) {\n        texture.images[i] = image;\n        loaded++;\n\n        if (loaded === 6) {\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }\n      }, undefined, onError);\n    }\n\n    for (let i = 0; i < urls.length; ++i) {\n      loadTexture(i);\n    }\n\n    texture.type = this.type;\n    texture.format = RGBAFormat;\n    texture.minFilter = LinearFilter;\n    texture.generateMipmaps = false;\n    return texture;\n  }\n\n  parse(buffer) {\n    const img = UPNG.decode(buffer);\n    const rgba = UPNG.toRGBA8(img)[0];\n    const data = new Uint8Array(rgba);\n    const size = img.width * img.height * 4;\n    const output = this.type === HalfFloatType ? new Uint16Array(size) : new Float32Array(size); // decode RGBM\n\n    for (let i = 0; i < data.length; i += 4) {\n      const r = data[i + 0] / 255;\n      const g = data[i + 1] / 255;\n      const b = data[i + 2] / 255;\n      const a = data[i + 3] / 255;\n\n      if (this.type === HalfFloatType) {\n        output[i + 0] = DataUtils.toHalfFloat(Math.min(r * a * this.maxRange, 65504));\n        output[i + 1] = DataUtils.toHalfFloat(Math.min(g * a * this.maxRange, 65504));\n        output[i + 2] = DataUtils.toHalfFloat(Math.min(b * a * this.maxRange, 65504));\n        output[i + 3] = DataUtils.toHalfFloat(1);\n      } else {\n        output[i + 0] = r * a * this.maxRange;\n        output[i + 1] = g * a * this.maxRange;\n        output[i + 2] = b * a * this.maxRange;\n        output[i + 3] = 1;\n      }\n    }\n\n    return {\n      width: img.width,\n      height: img.height,\n      data: output,\n      format: RGBAFormat,\n      type: this.type,\n      flipY: true\n    };\n  }\n\n} // from https://github.com/photopea/UPNG.js (MIT License)\n\n\nvar UPNG = {};\n\nUPNG.toRGBA8 = function (out) {\n  var w = out.width,\n      h = out.height;\n  if (out.tabs.acTL == null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];\n  var frms = [];\n  if (out.frames[0].data == null) out.frames[0].data = out.data;\n  var len = w * h * 4,\n      img = new Uint8Array(len),\n      empty = new Uint8Array(len),\n      prev = new Uint8Array(len);\n\n  for (var i = 0; i < out.frames.length; i++) {\n    var frm = out.frames[i];\n    var fx = frm.rect.x,\n        fy = frm.rect.y,\n        fw = frm.rect.width,\n        fh = frm.rect.height;\n    var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);\n    if (i != 0) for (var j = 0; j < len; j++) prev[j] = img[j];\n    if (frm.blend == 0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);else if (frm.blend == 1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\n    frms.push(img.buffer.slice(0));\n    if (frm.dispose == 1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);else if (frm.dispose == 2) for (var j = 0; j < len; j++) img[j] = prev[j];\n  }\n\n  return frms;\n};\n\nUPNG.toRGBA8.decodeImage = function (data, w, h, out) {\n  var area = w * h,\n      bpp = UPNG.decode._getBPP(out);\n\n  var bpl = Math.ceil(w * bpp / 8); // bytes per line\n\n  var bf = new Uint8Array(area * 4),\n      bf32 = new Uint32Array(bf.buffer);\n  var ctype = out.ctype,\n      depth = out.depth;\n  var rs = UPNG._bin.readUshort;\n\n  if (ctype == 6) {\n    // RGB + alpha\n    var qarea = area << 2;\n\n    if (depth == 8) {\n      for (var i = 0; i < qarea; i += 4) {\n        bf[i] = data[i];\n        bf[i + 1] = data[i + 1];\n        bf[i + 2] = data[i + 2];\n        bf[i + 3] = data[i + 3];\n      }\n    }\n\n    if (depth == 16) {\n      for (var i = 0; i < qarea; i++) {\n        bf[i] = data[i << 1];\n      }\n    }\n  } else if (ctype == 2) {\n    // RGB\n    var ts = out.tabs['tRNS'];\n\n    if (ts == null) {\n      if (depth == 8) {\n        for (var i = 0; i < area; i++) {\n          var ti = i * 3;\n          bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];\n        }\n      }\n\n      if (depth == 16) {\n        for (var i = 0; i < area; i++) {\n          var ti = i * 6;\n          bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];\n        }\n      }\n    } else {\n      var tr = ts[0],\n          tg = ts[1],\n          tb = ts[2];\n\n      if (depth == 8) {\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2,\n              ti = i * 3;\n          bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];\n          if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb) bf[qi + 3] = 0;\n        }\n      }\n\n      if (depth == 16) {\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2,\n              ti = i * 6;\n          bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];\n          if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb) bf[qi + 3] = 0;\n        }\n      }\n    }\n  } else if (ctype == 3) {\n    // palette\n    var p = out.tabs['PLTE'],\n        ap = out.tabs['tRNS'],\n        tl = ap ? ap.length : 0; //console.log(p, ap);\n\n    if (depth == 1) {\n      for (var y = 0; y < h; y++) {\n        var s0 = y * bpl,\n            t0 = y * w;\n\n        for (var i = 0; i < w; i++) {\n          var qi = t0 + i << 2,\n              j = data[s0 + (i >> 3)] >> 7 - ((i & 7) << 0) & 1,\n              cj = 3 * j;\n          bf[qi] = p[cj];\n          bf[qi + 1] = p[cj + 1];\n          bf[qi + 2] = p[cj + 2];\n          bf[qi + 3] = j < tl ? ap[j] : 255;\n        }\n      }\n    }\n\n    if (depth == 2) {\n      for (var y = 0; y < h; y++) {\n        var s0 = y * bpl,\n            t0 = y * w;\n\n        for (var i = 0; i < w; i++) {\n          var qi = t0 + i << 2,\n              j = data[s0 + (i >> 2)] >> 6 - ((i & 3) << 1) & 3,\n              cj = 3 * j;\n          bf[qi] = p[cj];\n          bf[qi + 1] = p[cj + 1];\n          bf[qi + 2] = p[cj + 2];\n          bf[qi + 3] = j < tl ? ap[j] : 255;\n        }\n      }\n    }\n\n    if (depth == 4) {\n      for (var y = 0; y < h; y++) {\n        var s0 = y * bpl,\n            t0 = y * w;\n\n        for (var i = 0; i < w; i++) {\n          var qi = t0 + i << 2,\n              j = data[s0 + (i >> 1)] >> 4 - ((i & 1) << 2) & 15,\n              cj = 3 * j;\n          bf[qi] = p[cj];\n          bf[qi + 1] = p[cj + 1];\n          bf[qi + 2] = p[cj + 2];\n          bf[qi + 3] = j < tl ? ap[j] : 255;\n        }\n      }\n    }\n\n    if (depth == 8) {\n      for (var i = 0; i < area; i++) {\n        var qi = i << 2,\n            j = data[i],\n            cj = 3 * j;\n        bf[qi] = p[cj];\n        bf[qi + 1] = p[cj + 1];\n        bf[qi + 2] = p[cj + 2];\n        bf[qi + 3] = j < tl ? ap[j] : 255;\n      }\n    }\n  } else if (ctype == 4) {\n    // gray + alpha\n    if (depth == 8) {\n      for (var i = 0; i < area; i++) {\n        var qi = i << 2,\n            di = i << 1,\n            gr = data[di];\n        bf[qi] = gr;\n        bf[qi + 1] = gr;\n        bf[qi + 2] = gr;\n        bf[qi + 3] = data[di + 1];\n      }\n    }\n\n    if (depth == 16) {\n      for (var i = 0; i < area; i++) {\n        var qi = i << 2,\n            di = i << 2,\n            gr = data[di];\n        bf[qi] = gr;\n        bf[qi + 1] = gr;\n        bf[qi + 2] = gr;\n        bf[qi + 3] = data[di + 2];\n      }\n    }\n  } else if (ctype == 0) {\n    // gray\n    var tr = out.tabs['tRNS'] ? out.tabs['tRNS'] : -1;\n\n    for (var y = 0; y < h; y++) {\n      var off = y * bpl,\n          to = y * w;\n\n      if (depth == 1) {\n        for (var x = 0; x < w; x++) {\n          var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1),\n              al = gr == tr * 255 ? 0 : 255;\n          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n        }\n      } else if (depth == 2) {\n        for (var x = 0; x < w; x++) {\n          var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3),\n              al = gr == tr * 85 ? 0 : 255;\n          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n        }\n      } else if (depth == 4) {\n        for (var x = 0; x < w; x++) {\n          var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15),\n              al = gr == tr * 17 ? 0 : 255;\n          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n        }\n      } else if (depth == 8) {\n        for (var x = 0; x < w; x++) {\n          var gr = data[off + x],\n              al = gr == tr ? 0 : 255;\n          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n        }\n      } else if (depth == 16) {\n        for (var x = 0; x < w; x++) {\n          var gr = data[off + (x << 1)],\n              al = rs(data, off + (x << 1)) == tr ? 0 : 255;\n          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n        }\n      }\n    }\n  } //console.log(Date.now()-time);\n\n\n  return bf;\n};\n\nUPNG.decode = function (buff) {\n  var data = new Uint8Array(buff),\n      offset = 8,\n      bin = UPNG._bin,\n      rUs = bin.readUshort,\n      rUi = bin.readUint;\n  var out = {\n    tabs: {},\n    frames: []\n  };\n  var dd = new Uint8Array(data.length),\n      doff = 0; // put all IDAT data into it\n\n  var fd,\n      foff = 0; // frames\n\n  var text, keyw, bfr;\n  var mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n\n  for (var i = 0; i < 8; i++) if (data[i] != mgck[i]) throw new Error('The input is not a PNG file!');\n\n  while (offset < data.length) {\n    var len = bin.readUint(data, offset);\n    offset += 4;\n    var type = bin.readASCII(data, offset, 4);\n    offset += 4; //console.log(type,len);\n\n    if (type == 'IHDR') {\n      UPNG.decode._IHDR(data, offset, out);\n    } else if (type == 'CgBI') {\n      out.tabs[type] = data.slice(offset, offset + 4);\n    } else if (type == 'IDAT') {\n      for (var i = 0; i < len; i++) dd[doff + i] = data[offset + i];\n\n      doff += len;\n    } else if (type == 'acTL') {\n      out.tabs[type] = {\n        num_frames: rUi(data, offset),\n        num_plays: rUi(data, offset + 4)\n      };\n      fd = new Uint8Array(data.length);\n    } else if (type == 'fcTL') {\n      if (foff != 0) {\n        var fr = out.frames[out.frames.length - 1];\n        fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\n        foff = 0;\n      }\n\n      var rct = {\n        x: rUi(data, offset + 12),\n        y: rUi(data, offset + 16),\n        width: rUi(data, offset + 4),\n        height: rUi(data, offset + 8)\n      };\n      var del = rUs(data, offset + 22);\n      del = rUs(data, offset + 20) / (del == 0 ? 100 : del);\n      var frm = {\n        rect: rct,\n        delay: Math.round(del * 1000),\n        dispose: data[offset + 24],\n        blend: data[offset + 25]\n      }; //console.log(frm);\n\n      out.frames.push(frm);\n    } else if (type == 'fdAT') {\n      for (var i = 0; i < len - 4; i++) fd[foff + i] = data[offset + i + 4];\n\n      foff += len - 4;\n    } else if (type == 'pHYs') {\n      out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];\n    } else if (type == 'cHRM') {\n      out.tabs[type] = [];\n\n      for (var i = 0; i < 8; i++) out.tabs[type].push(bin.readUint(data, offset + i * 4));\n    } else if (type == 'tEXt' || type == 'zTXt') {\n      if (out.tabs[type] == null) out.tabs[type] = {};\n      var nz = bin.nextZero(data, offset);\n      keyw = bin.readASCII(data, offset, nz - offset);\n      var tl = offset + len - nz - 1;\n\n      if (type == 'tEXt') {\n        text = bin.readASCII(data, nz + 1, tl);\n      } else {\n        bfr = UPNG.decode._inflate(data.slice(nz + 2, nz + 2 + tl));\n        text = bin.readUTF8(bfr, 0, bfr.length);\n      }\n\n      out.tabs[type][keyw] = text;\n    } else if (type == 'iTXt') {\n      if (out.tabs[type] == null) out.tabs[type] = {};\n      var nz = 0,\n          off = offset;\n      nz = bin.nextZero(data, off);\n      keyw = bin.readASCII(data, off, nz - off);\n      off = nz + 1;\n      var cflag = data[off];\n      off += 2;\n      nz = bin.nextZero(data, off);\n      bin.readASCII(data, off, nz - off);\n      off = nz + 1;\n      nz = bin.nextZero(data, off);\n      bin.readUTF8(data, off, nz - off);\n      off = nz + 1;\n      var tl = len - (off - offset);\n\n      if (cflag == 0) {\n        text = bin.readUTF8(data, off, tl);\n      } else {\n        bfr = UPNG.decode._inflate(data.slice(off, off + tl));\n        text = bin.readUTF8(bfr, 0, bfr.length);\n      }\n\n      out.tabs[type][keyw] = text;\n    } else if (type == 'PLTE') {\n      out.tabs[type] = bin.readBytes(data, offset, len);\n    } else if (type == 'hIST') {\n      var pl = out.tabs['PLTE'].length / 3;\n      out.tabs[type] = [];\n\n      for (var i = 0; i < pl; i++) out.tabs[type].push(rUs(data, offset + i * 2));\n    } else if (type == 'tRNS') {\n      if (out.ctype == 3) out.tabs[type] = bin.readBytes(data, offset, len);else if (out.ctype == 0) out.tabs[type] = rUs(data, offset);else if (out.ctype == 2) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)]; //else console.log(\"tRNS for unsupported color type\",out.ctype, len);\n    } else if (type == 'gAMA') {\n      out.tabs[type] = bin.readUint(data, offset) / 100000;\n    } else if (type == 'sRGB') {\n      out.tabs[type] = data[offset];\n    } else if (type == 'bKGD') {\n      if (out.ctype == 0 || out.ctype == 4) {\n        out.tabs[type] = [rUs(data, offset)];\n      } else if (out.ctype == 2 || out.ctype == 6) {\n        out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];\n      } else if (out.ctype == 3) {\n        out.tabs[type] = data[offset];\n      }\n    } else if (type == 'IEND') {\n      break;\n    } //else {  console.log(\"unknown chunk type\", type, len);  out.tabs[type]=data.slice(offset,offset+len);  }\n\n\n    offset += len;\n    bin.readUint(data, offset);\n    offset += 4;\n  }\n\n  if (foff != 0) {\n    var fr = out.frames[out.frames.length - 1];\n    fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\n  }\n\n  out.data = UPNG.decode._decompress(out, dd, out.width, out.height);\n  delete out.compress;\n  delete out.interlace;\n  delete out.filter;\n  return out;\n};\n\nUPNG.decode._decompress = function (out, dd, w, h) {\n  var bpp = UPNG.decode._getBPP(out),\n      bpl = Math.ceil(w * bpp / 8),\n      buff = new Uint8Array((bpl + 1 + out.interlace) * h);\n\n  if (out.tabs['CgBI']) dd = UPNG.inflateRaw(dd, buff);else dd = UPNG.decode._inflate(dd, buff);\n  if (out.interlace == 0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);else if (out.interlace == 1) dd = UPNG.decode._readInterlace(dd, out);\n  return dd;\n};\n\nUPNG.decode._inflate = function (data, buff) {\n  var out = UPNG['inflateRaw'](new Uint8Array(data.buffer, 2, data.length - 6), buff);\n  return out;\n};\n\nUPNG.inflateRaw = function () {\n  var H = {};\n  H.H = {};\n\n  H.H.N = function (N, W) {\n    var R = Uint8Array,\n        i = 0,\n        m = 0,\n        J = 0,\n        h = 0,\n        Q = 0,\n        X = 0,\n        u = 0,\n        w = 0,\n        d = 0,\n        v,\n        C;\n    if (N[0] == 3 && N[1] == 0) return W ? W : new R(0);\n    var V = H.H,\n        n = V.b,\n        A = V.e,\n        l = V.R,\n        M = V.n,\n        I = V.A,\n        e = V.Z,\n        b = V.m,\n        Z = W == null;\n    if (Z) W = new R(N.length >>> 2 << 5);\n\n    while (i == 0) {\n      i = n(N, d, 1);\n      m = n(N, d + 1, 2);\n      d += 3;\n\n      if (m == 0) {\n        if ((d & 7) != 0) d += 8 - (d & 7);\n        var D = (d >>> 3) + 4,\n            q = N[D - 4] | N[D - 3] << 8;\n        if (Z) W = H.H.W(W, w + q);\n        W.set(new R(N.buffer, N.byteOffset + D, q), w);\n        d = D + q << 3;\n        w += q;\n        continue;\n      }\n\n      if (Z) W = H.H.W(W, w + (1 << 17));\n\n      if (m == 1) {\n        v = b.J;\n        C = b.h;\n        X = (1 << 9) - 1;\n        u = (1 << 5) - 1;\n      }\n\n      if (m == 2) {\n        J = A(N, d, 5) + 257;\n        h = A(N, d + 5, 5) + 1;\n        Q = A(N, d + 10, 4) + 4;\n        d += 14;\n        var j = 1;\n\n        for (var c = 0; c < 38; c += 2) {\n          b.Q[c] = 0;\n          b.Q[c + 1] = 0;\n        }\n\n        for (var c = 0; c < Q; c++) {\n          var K = A(N, d + c * 3, 3);\n          b.Q[(b.X[c] << 1) + 1] = K;\n          if (K > j) j = K;\n        }\n\n        d += 3 * Q;\n        M(b.Q, j);\n        I(b.Q, j, b.u);\n        v = b.w;\n        C = b.d;\n        d = l(b.u, (1 << j) - 1, J + h, N, d, b.v);\n        var r = V.V(b.v, 0, J, b.C);\n        X = (1 << r) - 1;\n        var S = V.V(b.v, J, h, b.D);\n        u = (1 << S) - 1;\n        M(b.C, r);\n        I(b.C, r, v);\n        M(b.D, S);\n        I(b.D, S, C);\n      }\n\n      while (!0) {\n        var T = v[e(N, d) & X];\n        d += T & 15;\n        var p = T >>> 4;\n\n        if (p >>> 8 == 0) {\n          W[w++] = p;\n        } else if (p == 256) {\n          break;\n        } else {\n          var z = w + p - 254;\n\n          if (p > 264) {\n            var _ = b.q[p - 257];\n            z = w + (_ >>> 3) + A(N, d, _ & 7);\n            d += _ & 7;\n          }\n\n          var $ = C[e(N, d) & u];\n          d += $ & 15;\n          var s = $ >>> 4,\n              Y = b.c[s],\n              a = (Y >>> 4) + n(N, d, Y & 15);\n          d += Y & 15;\n\n          while (w < z) {\n            W[w] = W[w++ - a];\n            W[w] = W[w++ - a];\n            W[w] = W[w++ - a];\n            W[w] = W[w++ - a];\n          }\n\n          w = z;\n        }\n      }\n    }\n\n    return W.length == w ? W : W.slice(0, w);\n  };\n\n  H.H.W = function (N, W) {\n    var R = N.length;\n    if (W <= R) return N;\n    var V = new Uint8Array(R << 1);\n    V.set(N, 0);\n    return V;\n  };\n\n  H.H.R = function (N, W, R, V, n, A) {\n    var l = H.H.e,\n        M = H.H.Z,\n        I = 0;\n\n    while (I < R) {\n      var e = N[M(V, n) & W];\n      n += e & 15;\n      var b = e >>> 4;\n\n      if (b <= 15) {\n        A[I] = b;\n        I++;\n      } else {\n        var Z = 0,\n            m = 0;\n\n        if (b == 16) {\n          m = 3 + l(V, n, 2);\n          n += 2;\n          Z = A[I - 1];\n        } else if (b == 17) {\n          m = 3 + l(V, n, 3);\n          n += 3;\n        } else if (b == 18) {\n          m = 11 + l(V, n, 7);\n          n += 7;\n        }\n\n        var J = I + m;\n\n        while (I < J) {\n          A[I] = Z;\n          I++;\n        }\n      }\n    }\n\n    return n;\n  };\n\n  H.H.V = function (N, W, R, V) {\n    var n = 0,\n        A = 0,\n        l = V.length >>> 1;\n\n    while (A < R) {\n      var M = N[A + W];\n      V[A << 1] = 0;\n      V[(A << 1) + 1] = M;\n      if (M > n) n = M;\n      A++;\n    }\n\n    while (A < l) {\n      V[A << 1] = 0;\n      V[(A << 1) + 1] = 0;\n      A++;\n    }\n\n    return n;\n  };\n\n  H.H.n = function (N, W) {\n    var R = H.H.m,\n        V = N.length,\n        n,\n        A,\n        l,\n        M,\n        I,\n        e = R.j;\n\n    for (var M = 0; M <= W; M++) e[M] = 0;\n\n    for (M = 1; M < V; M += 2) e[N[M]]++;\n\n    var b = R.K;\n    n = 0;\n    e[0] = 0;\n\n    for (A = 1; A <= W; A++) {\n      n = n + e[A - 1] << 1;\n      b[A] = n;\n    }\n\n    for (l = 0; l < V; l += 2) {\n      I = N[l + 1];\n\n      if (I != 0) {\n        N[l] = b[I];\n        b[I]++;\n      }\n    }\n  };\n\n  H.H.A = function (N, W, R) {\n    var V = N.length,\n        n = H.H.m,\n        A = n.r;\n\n    for (var l = 0; l < V; l += 2) {\n      if (N[l + 1] != 0) {\n        var M = l >> 1,\n            I = N[l + 1],\n            e = M << 4 | I,\n            b = W - I,\n            Z = N[l] << b,\n            m = Z + (1 << b);\n\n        while (Z != m) {\n          var J = A[Z] >>> 15 - W;\n          R[J] = e;\n          Z++;\n        }\n      }\n    }\n  };\n\n  H.H.l = function (N, W) {\n    var R = H.H.m.r,\n        V = 15 - W;\n\n    for (var n = 0; n < N.length; n += 2) {\n      var A = N[n] << W - N[n + 1];\n      N[n] = R[A] >>> V;\n    }\n  };\n\n  H.H.M = function (N, W, R) {\n    R = R << (W & 7);\n    var V = W >>> 3;\n    N[V] |= R;\n    N[V + 1] |= R >>> 8;\n  };\n\n  H.H.I = function (N, W, R) {\n    R = R << (W & 7);\n    var V = W >>> 3;\n    N[V] |= R;\n    N[V + 1] |= R >>> 8;\n    N[V + 2] |= R >>> 16;\n  };\n\n  H.H.e = function (N, W, R) {\n    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1;\n  };\n\n  H.H.b = function (N, W, R) {\n    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1;\n  };\n\n  H.H.Z = function (N, W) {\n    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);\n  };\n\n  H.H.i = function (N, W) {\n    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);\n  };\n\n  H.H.m = function () {\n    var N = Uint16Array,\n        W = Uint32Array;\n    return {\n      K: new N(16),\n      j: new N(16),\n      X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n      S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\n      T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n      q: new N(32),\n      p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\n      z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n      c: new W(32),\n      J: new N(512),\n      _: [],\n      h: new N(32),\n      $: [],\n      w: new N(32768),\n      C: [],\n      v: [],\n      d: new N(32768),\n      D: [],\n      u: new N(512),\n      Q: [],\n      r: new N(1 << 15),\n      s: new W(286),\n      Y: new W(30),\n      a: new W(19),\n      t: new W(15e3),\n      k: new N(1 << 16),\n      g: new N(1 << 15)\n    };\n  }();\n\n  (function () {\n    var N = H.H.m,\n        W = 1 << 15;\n\n    for (var R = 0; R < W; R++) {\n      var V = R;\n      V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;\n      V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;\n      V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;\n      V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;\n      N.r[R] = (V >>> 16 | V << 16) >>> 17;\n    }\n\n    function n(A, l, M) {\n      while (l-- != 0) A.push(0, M);\n    }\n\n    for (var R = 0; R < 32; R++) {\n      N.q[R] = N.S[R] << 3 | N.T[R];\n      N.c[R] = N.p[R] << 4 | N.z[R];\n    }\n\n    n(N._, 144, 8);\n    n(N._, 255 - 143, 9);\n    n(N._, 279 - 255, 7);\n    n(N._, 287 - 279, 8);\n    H.H.n(N._, 9);\n    H.H.A(N._, 9, N.J);\n    H.H.l(N._, 9);\n    n(N.$, 32, 5);\n    H.H.n(N.$, 5);\n    H.H.A(N.$, 5, N.h);\n    H.H.l(N.$, 5);\n    n(N.Q, 19, 0);\n    n(N.C, 286, 0);\n    n(N.D, 30, 0);\n    n(N.v, 320, 0);\n  })();\n\n  return H.H.N;\n}();\n\nUPNG.decode._readInterlace = function (data, out) {\n  var w = out.width,\n      h = out.height;\n\n  var bpp = UPNG.decode._getBPP(out),\n      cbpp = bpp >> 3,\n      bpl = Math.ceil(w * bpp / 8);\n\n  var img = new Uint8Array(h * bpl);\n  var di = 0;\n  var starting_row = [0, 0, 4, 0, 2, 0, 1];\n  var starting_col = [0, 4, 0, 2, 0, 1, 0];\n  var row_increment = [8, 8, 8, 4, 4, 2, 2];\n  var col_increment = [8, 8, 4, 4, 2, 2, 1];\n  var pass = 0;\n\n  while (pass < 7) {\n    var ri = row_increment[pass],\n        ci = col_increment[pass];\n    var sw = 0,\n        sh = 0;\n    var cr = starting_row[pass];\n\n    while (cr < h) {\n      cr += ri;\n      sh++;\n    }\n\n    var cc = starting_col[pass];\n\n    while (cc < w) {\n      cc += ci;\n      sw++;\n    }\n\n    var bpll = Math.ceil(sw * bpp / 8);\n\n    UPNG.decode._filterZero(data, out, di, sw, sh);\n\n    var y = 0,\n        row = starting_row[pass];\n    var val;\n\n    while (row < h) {\n      var col = starting_col[pass];\n      var cdi = di + y * bpll << 3;\n\n      while (col < w) {\n        if (bpp == 1) {\n          val = data[cdi >> 3];\n          val = val >> 7 - (cdi & 7) & 1;\n          img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);\n        }\n\n        if (bpp == 2) {\n          val = data[cdi >> 3];\n          val = val >> 6 - (cdi & 7) & 3;\n          img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);\n        }\n\n        if (bpp == 4) {\n          val = data[cdi >> 3];\n          val = val >> 4 - (cdi & 7) & 15;\n          img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);\n        }\n\n        if (bpp >= 8) {\n          var ii = row * bpl + col * cbpp;\n\n          for (var j = 0; j < cbpp; j++) img[ii + j] = data[(cdi >> 3) + j];\n        }\n\n        cdi += bpp;\n        col += ci;\n      }\n\n      y++;\n      row += ri;\n    }\n\n    if (sw * sh != 0) di += sh * (1 + bpll);\n    pass = pass + 1;\n  }\n\n  return img;\n};\n\nUPNG.decode._getBPP = function (out) {\n  var noc = [1, null, 3, 1, 2, null, 4][out.ctype];\n  return noc * out.depth;\n};\n\nUPNG.decode._filterZero = function (data, out, off, w, h) {\n  var bpp = UPNG.decode._getBPP(out),\n      bpl = Math.ceil(w * bpp / 8),\n      paeth = UPNG.decode._paeth;\n\n  bpp = Math.ceil(bpp / 8);\n  var i,\n      di,\n      type = data[off],\n      x = 0;\n  if (type > 1) data[off] = [0, 0, 1][type - 2];\n  if (type == 3) for (x = bpp; x < bpl; x++) data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;\n\n  for (var y = 0; y < h; y++) {\n    i = off + y * bpl;\n    di = i + y + 1;\n    type = data[di - 1];\n    x = 0;\n\n    if (type == 0) {\n      for (; x < bpl; x++) data[i + x] = data[di + x];\n    } else if (type == 1) {\n      for (; x < bpp; x++) data[i + x] = data[di + x];\n\n      for (; x < bpl; x++) data[i + x] = data[di + x] + data[i + x - bpp];\n    } else if (type == 2) {\n      for (; x < bpl; x++) data[i + x] = data[di + x] + data[i + x - bpl];\n    } else if (type == 3) {\n      for (; x < bpp; x++) data[i + x] = data[di + x] + (data[i + x - bpl] >>> 1);\n\n      for (; x < bpl; x++) data[i + x] = data[di + x] + (data[i + x - bpl] + data[i + x - bpp] >>> 1);\n    } else {\n      for (; x < bpp; x++) data[i + x] = data[di + x] + paeth(0, data[i + x - bpl], 0);\n\n      for (; x < bpl; x++) {\n        data[i + x] = data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]);\n      }\n    }\n  }\n\n  return data;\n};\n\nUPNG.decode._paeth = function (a, b, c) {\n  var p = a + b - c,\n      pa = p - a,\n      pb = p - b,\n      pc = p - c;\n  if (pa * pa <= pb * pb && pa * pa <= pc * pc) return a;else if (pb * pb <= pc * pc) return b;\n  return c;\n};\n\nUPNG.decode._IHDR = function (data, offset, out) {\n  var bin = UPNG._bin;\n  out.width = bin.readUint(data, offset);\n  offset += 4;\n  out.height = bin.readUint(data, offset);\n  offset += 4;\n  out.depth = data[offset];\n  offset++;\n  out.ctype = data[offset];\n  offset++;\n  out.compress = data[offset];\n  offset++;\n  out.filter = data[offset];\n  offset++;\n  out.interlace = data[offset];\n  offset++;\n};\n\nUPNG._bin = {\n  nextZero: function (data, p) {\n    while (data[p] != 0) p++;\n\n    return p;\n  },\n  readUshort: function (buff, p) {\n    return buff[p] << 8 | buff[p + 1];\n  },\n  writeUshort: function (buff, p, n) {\n    buff[p] = n >> 8 & 255;\n    buff[p + 1] = n & 255;\n  },\n  readUint: function (buff, p) {\n    return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);\n  },\n  writeUint: function (buff, p, n) {\n    buff[p] = n >> 24 & 255;\n    buff[p + 1] = n >> 16 & 255;\n    buff[p + 2] = n >> 8 & 255;\n    buff[p + 3] = n & 255;\n  },\n  readASCII: function (buff, p, l) {\n    var s = '';\n\n    for (var i = 0; i < l; i++) s += String.fromCharCode(buff[p + i]);\n\n    return s;\n  },\n  writeASCII: function (data, p, s) {\n    for (var i = 0; i < s.length; i++) data[p + i] = s.charCodeAt(i);\n  },\n  readBytes: function (buff, p, l) {\n    var arr = [];\n\n    for (var i = 0; i < l; i++) arr.push(buff[p + i]);\n\n    return arr;\n  },\n  pad: function (n) {\n    return n.length < 2 ? '0' + n : n;\n  },\n  readUTF8: function (buff, p, l) {\n    var s = '',\n        ns;\n\n    for (var i = 0; i < l; i++) s += '%' + UPNG._bin.pad(buff[p + i].toString(16));\n\n    try {\n      ns = decodeURIComponent(s);\n    } catch (e) {\n      return UPNG._bin.readASCII(buff, p, l);\n    }\n\n    return ns;\n  }\n};\n\nUPNG._copyTile = function (sb, sw, sh, tb, tw, th, xoff, yoff, mode) {\n  var w = Math.min(sw, tw),\n      h = Math.min(sh, th);\n  var si = 0,\n      ti = 0;\n\n  for (var y = 0; y < h; y++) {\n    for (var x = 0; x < w; x++) {\n      if (xoff >= 0 && yoff >= 0) {\n        si = y * sw + x << 2;\n        ti = (yoff + y) * tw + xoff + x << 2;\n      } else {\n        si = (-yoff + y) * sw - xoff + x << 2;\n        ti = y * tw + x << 2;\n      }\n\n      if (mode == 0) {\n        tb[ti] = sb[si];\n        tb[ti + 1] = sb[si + 1];\n        tb[ti + 2] = sb[si + 2];\n        tb[ti + 3] = sb[si + 3];\n      } else if (mode == 1) {\n        var fa = sb[si + 3] * (1 / 255),\n            fr = sb[si] * fa,\n            fg = sb[si + 1] * fa,\n            fb = sb[si + 2] * fa;\n        var ba = tb[ti + 3] * (1 / 255),\n            br = tb[ti] * ba,\n            bg = tb[ti + 1] * ba,\n            bb = tb[ti + 2] * ba;\n        var ifa = 1 - fa,\n            oa = fa + ba * ifa,\n            ioa = oa == 0 ? 0 : 1 / oa;\n        tb[ti + 3] = 255 * oa;\n        tb[ti + 0] = (fr + br * ifa) * ioa;\n        tb[ti + 1] = (fg + bg * ifa) * ioa;\n        tb[ti + 2] = (fb + bb * ifa) * ioa;\n      } else if (mode == 2) {\n        // copy only differences, otherwise zero\n        var fa = sb[si + 3],\n            fr = sb[si],\n            fg = sb[si + 1],\n            fb = sb[si + 2];\n        var ba = tb[ti + 3],\n            br = tb[ti],\n            bg = tb[ti + 1],\n            bb = tb[ti + 2];\n\n        if (fa == ba && fr == br && fg == bg && fb == bb) {\n          tb[ti] = 0;\n          tb[ti + 1] = 0;\n          tb[ti + 2] = 0;\n          tb[ti + 3] = 0;\n        } else {\n          tb[ti] = fr;\n          tb[ti + 1] = fg;\n          tb[ti + 2] = fb;\n          tb[ti + 3] = fa;\n        }\n      } else if (mode == 3) {\n        // check if can be blended\n        var fa = sb[si + 3],\n            fr = sb[si],\n            fg = sb[si + 1],\n            fb = sb[si + 2];\n        var ba = tb[ti + 3],\n            br = tb[ti],\n            bg = tb[ti + 1],\n            bb = tb[ti + 2];\n        if (fa == ba && fr == br && fg == bg && fb == bb) continue; //if(fa!=255 && ba!=0) return false;\n\n        if (fa < 220 && ba > 20) return false;\n      }\n    }\n  }\n\n  return true;\n};\n\nexport { RGBMLoader };\n", "import { Box3, Vector3, InstancedBufferGeometry, Float32BufferAttribute, InstancedInterleavedBuffer, InterleavedBufferAttribute, WireframeGeometry, Sphere } from 'three';\n\nconst _box = new Box3();\n\nconst _vector = new Vector3();\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.isLineSegmentsGeometry = true;\n    this.type = 'LineSegmentsGeometry';\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this.setAttribute('position', new Float32BufferAttribute(positions, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  }\n\n  setPositions(array) {\n    let lineSegments;\n\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this.setAttribute('instanceStart', new InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this.setAttribute('instanceEnd', new InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n\n  setColors(array) {\n    let colors;\n\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this.setAttribute('instanceColorStart', new InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this.setAttribute('instanceColorEnd', new InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  }\n\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n    this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    // set colors, maybe\n\n    return this;\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start);\n\n      _box.setFromBufferAttribute(end);\n\n      this.boundingBox.union(_box);\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n\n        _vector.fromBufferAttribute(end, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n      }\n    }\n  }\n\n  toJSON() {// todo\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n}\n\nexport { LineSegmentsGeometry };\n", "import { UniformsLib, Vector2, ShaderLib, UniformsUtils, ShaderMaterial } from 'three';\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\nUniformsLib.line = {\n  worldUnits: {\n    value: 1\n  },\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashOffset: {\n    value: 0\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  gapSize: {\n    value: 1\n  } // todo FIX - maybe change to totalSize\n\n};\nShaderLib['line'] = {\n  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, UniformsLib.line]),\n  vertexShader:\n  /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      type: 'LineMaterial',\n      uniforms: UniformsUtils.clone(ShaderLib['line'].uniforms),\n      vertexShader: ShaderLib['line'].vertexShader,\n      fragmentShader: ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    this.isLineMaterial = true;\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      worldUnits: {\n        enumerable: true,\n        get: function () {\n          return 'WORLD_UNITS' in this.defines;\n        },\n        set: function (value) {\n          if (value === true) {\n            this.defines.WORLD_UNITS = '';\n          } else {\n            delete this.defines.WORLD_UNITS;\n          }\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n\n        set(value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value === true) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('USE_ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value === true) {\n            this.defines.USE_ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.USE_ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nexport { LineMaterial };\n", "import { Vector3, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute } from 'three';\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\nimport { LineMaterial } from './LineMaterial.js';\n\nconst _start = new Vector3();\n\nconst _end = new Vector3();\n\nclass Wireframe extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.isWireframe = true;\n    this.type = 'Wireframe';\n  } // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n\n      _end.fromBufferAttribute(instanceEnd, i);\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n}\n\nexport { Wireframe };\n", "import { Vector3, Vector4, Matrix4, Line3, Box3, Sphere, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute, MathUtils } from 'three';\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\nimport { LineMaterial } from './LineMaterial.js';\n\nconst _start = new Vector3();\n\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\n\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\n\nconst _ssOrigin3 = new Vector3();\n\nconst _mvMatrix = new Matrix4();\n\nconst _line = new Line3();\n\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\n\nconst _sphere = new Sphere();\n\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _instanceStart, _instanceEnd, _lineWidth; // Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\n\n\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix);\n\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\n\nfunction raycastWorldUnits(lineSegments, intersects) {\n  for (let i = 0, l = _instanceStart.count; i < l; i++) {\n    _line.start.fromBufferAttribute(_instanceStart, i);\n\n    _line.end.fromBufferAttribute(_instanceEnd, i);\n\n    const pointOnLine = new Vector3();\n    const point = new Vector3();\n\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\n\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix;\n  const material = lineSegments.material;\n  const resolution = material.resolution;\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const near = -camera.near; //\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n\n  _ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\n\n\n  _ssOrigin.w = 1;\n\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n\n  _ssOrigin.applyMatrix4(projectionMatrix);\n\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\n\n\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n\n  _ssOrigin3.copy(_ssOrigin);\n\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n\n  for (let i = 0, l = instanceStart.count; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n\n    _end4.fromBufferAttribute(instanceEnd, i);\n\n    _start4.w = 1;\n    _end4.w = 1; // camera space\n\n    _start4.applyMatrix4(_mvMatrix);\n\n    _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\n\n\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\n\n    if (isBehindCameraNear) {\n      continue;\n    } // trim the segment if it extends behind camera near\n\n\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z;\n      const t = (_start4.z - near) / deltaDist;\n\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z;\n      const t = (_end4.z - near) / deltaDist;\n\n      _end4.lerp(_start4, t);\n    } // clip space\n\n\n    _start4.applyMatrix4(projectionMatrix);\n\n    _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\n\n\n    _start4.multiplyScalar(1 / _start4.w);\n\n    _end4.multiplyScalar(1 / _end4.w); // screen space\n\n\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2; // create 2d segment\n\n    _line.start.copy(_start4);\n\n    _line.start.z = 0;\n\n    _line.end.copy(_end4);\n\n    _line.end.z = 0; // get closest point on ray to segment\n\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n\n    _line.at(param, _closestPoint); // check if the intersection point is within clip space\n\n\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\n\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n\n      _line.end.fromBufferAttribute(instanceEnd, i);\n\n      _line.start.applyMatrix4(matrixWorld);\n\n      _line.end.applyMatrix4(matrixWorld);\n\n      const pointOnLine = new Vector3();\n      const point = new Vector3();\n\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv2: null\n      });\n    }\n  }\n}\n\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  })) {\n    super(geometry, material);\n    this.isLineSegments2 = true;\n    this.type = 'LineSegments2';\n  } // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n\n      _end.fromBufferAttribute(instanceEnd, i);\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits;\n    const camera = raycaster.camera;\n\n    if (camera === null && !worldUnits) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    _ray = raycaster.ray;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    _lineWidth = material.linewidth + threshold;\n    _instanceStart = geometry.attributes.instanceStart;\n    _instanceEnd = geometry.attributes.instanceEnd; // check if we intersect the sphere bounds\n\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld); // increase the sphere bounds by the worst case line screen space width\n\n\n    let sphereMargin;\n\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n    }\n\n    _sphere.radius += sphereMargin;\n\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return;\n    } // check if we intersect the box bounds\n\n\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld); // increase the box bounds by the worst case line width\n\n\n    let boxMargin;\n\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n    }\n\n    _box.expandByScalar(boxMargin);\n\n    if (_ray.intersectsBox(_box) === false) {\n      return;\n    }\n\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects);\n    } else {\n      raycastScreenSpace(this, camera, intersects);\n    }\n  }\n\n}\n\nexport { LineSegments2 };\n", "import { Vector3, LineSegments, BufferGeometry, Float32BufferAttribute, LineBasicMaterial } from 'three';\n\nconst _v1 = new Vector3();\n\nconst _v2 = new Vector3();\n\nclass VertexTangentsHelper extends LineSegments {\n  constructor(object, size, hex) {\n    const color = hex !== undefined ? hex : 0x00ffff; //\n\n    const objGeometry = object.geometry;\n\n    if (!(objGeometry && objGeometry.isBufferGeometry)) {\n      console.error('THREE.VertexTangentsHelper: geometry not an instance of THREE.BufferGeometry.', objGeometry);\n      return;\n    }\n\n    const nTangents = objGeometry.attributes.tangent.count; //\n\n    const geometry = new BufferGeometry();\n    const positions = new Float32BufferAttribute(nTangents * 2 * 3, 3);\n    geometry.setAttribute('position', positions);\n    super(geometry, new LineBasicMaterial({\n      color,\n      toneMapped: false\n    }));\n    this.type = 'VertexTangentsHelper';\n    this.object = object;\n    this.size = size !== undefined ? size : 1; //\n\n    this.matrixAutoUpdate = false;\n    this.update();\n  }\n\n  update() {\n    this.object.updateMatrixWorld(true);\n    const matrixWorld = this.object.matrixWorld;\n    const position = this.geometry.attributes.position; //\n\n    const objGeometry = this.object.geometry;\n    const objPos = objGeometry.attributes.position;\n    const objTan = objGeometry.attributes.tangent;\n    let idx = 0; // for simplicity, ignore index and drawcalls, and render every tangent\n\n    for (let j = 0, jl = objPos.count; j < jl; j++) {\n      _v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);\n\n      _v2.set(objTan.getX(j), objTan.getY(j), objTan.getZ(j));\n\n      _v2.transformDirection(matrixWorld).multiplyScalar(this.size).add(_v1);\n\n      position.setXYZ(idx, _v1.x, _v1.y, _v1.z);\n      idx = idx + 1;\n      position.setXYZ(idx, _v2.x, _v2.y, _v2.z);\n      idx = idx + 1;\n    }\n\n    position.needsUpdate = true;\n  }\n\n}\n\nexport { VertexTangentsHelper };\n", "import { Vector3, Matrix3, LineSegments, BufferGeometry, LineBasicMaterial, Float32BufferAttribute } from 'three';\n\nconst _v1 = new Vector3();\n\nconst _v2 = new Vector3();\n\nconst _normalMatrix = new Matrix3();\n\nclass VertexNormalsHelper extends LineSegments {\n  constructor(object, size, hex) {\n    const geometry = new BufferGeometry();\n    const color = hex !== undefined ? hex : 0xff0000;\n    super(geometry, new LineBasicMaterial({\n      color,\n      toneMapped: false\n    }));\n    this.object = object;\n    this.size = size !== undefined ? size : 0.1;\n    let nNormals = 0;\n    const objGeometry = this.object.geometry;\n\n    if (objGeometry && objGeometry.isGeometry) {\n      console.error('THREE.VertexNormalsHelper no longer supports Geometry. Use BufferGeometry instead.');\n      return;\n    } else if (objGeometry && objGeometry.isBufferGeometry) {\n      nNormals = objGeometry.attributes.normal.count;\n    } //\n\n\n    const positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);\n    geometry.setAttribute('position', positions);\n    this.type = 'VertexNormalsHelper'; //\n\n    this.matrixAutoUpdate = false;\n    this.update();\n  }\n\n  update() {\n    this.object.updateMatrixWorld(true);\n\n    _normalMatrix.getNormalMatrix(this.object.matrixWorld);\n\n    const matrixWorld = this.object.matrixWorld;\n    const position = this.geometry.attributes.position; //\n\n    const objGeometry = this.object.geometry;\n\n    if (objGeometry && objGeometry.isGeometry) {\n      console.error('THREE.VertexNormalsHelper no longer supports Geometry. Use BufferGeometry instead.');\n      return;\n    } else if (objGeometry && objGeometry.isBufferGeometry) {\n      const objPos = objGeometry.attributes.position;\n      const objNorm = objGeometry.attributes.normal;\n      let idx = 0; // for simplicity, ignore index and drawcalls, and render every normal\n\n      for (let j = 0, jl = objPos.count; j < jl; j++) {\n        _v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);\n\n        _v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));\n\n        _v2.applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1);\n\n        position.setXYZ(idx, _v1.x, _v1.y, _v1.z);\n        idx = idx + 1;\n        position.setXYZ(idx, _v2.x, _v2.y, _v2.z);\n        idx = idx + 1;\n      }\n    }\n\n    position.needsUpdate = true;\n  }\n\n}\n\nexport { VertexNormalsHelper };\n", "import { Matrix4, Object3D, Vector3, EventDispatcher, MathUtils, Matrix3, Color, Box3, Sphere, BufferGeometry, BufferAttribute, Float32BufferAttribute, Vector2 } from 'three';\n\nconst _m1 = new Matrix4();\n\nconst _obj = new Object3D();\n\nconst _offset = new Vector3();\n\nclass Geometry extends EventDispatcher {\n  constructor() {\n    super();\n    this.isGeometry = true;\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.type = 'Geometry';\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : undefined;\n    const attributes = geometry.attributes;\n\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n      return this;\n    }\n\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== undefined) this.faceVertexUvs[1] = [];\n\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n\n      if (color !== undefined) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n\n      if (uv !== undefined) {\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n      }\n\n      if (uv2 !== undefined) {\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n      }\n    }\n\n    const groups = geometry.groups;\n\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== undefined) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== undefined) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n\n    this.computeFaceNormals();\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    return this;\n  }\n\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1.0 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n\n  computeFaceNormals() {\n    const cb = new Vector3(),\n          ab = new Vector3();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length);\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n      const cb = new Vector3(),\n            ab = new Vector3();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeMorphNormals() {\n    // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    } // use temp geometry to compute face and vertex normals for each morph\n\n\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n\n      const morphNormals = this.morphNormals[i]; // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals\n\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals(); // store morph normals\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    } // restore original normals\n\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n      return;\n    }\n\n    let normalMatrix;\n    const vertexOffset = this.vertices.length,\n          vertices1 = this.vertices,\n          vertices2 = geometry.vertices,\n          faces1 = this.faces,\n          faces2 = geometry.faces,\n          colors1 = this.colors,\n          colors2 = geometry.colors;\n\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    } // vertices\n\n\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    } // colors\n\n\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    } // faces\n\n\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals,\n            faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n\n        faceCopy.vertexNormals.push(normal);\n      }\n\n      faceCopy.color.copy(face.color);\n\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    } // uvs\n\n\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];\n\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n      return;\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n\n\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n    const unique = [],\n          changes = [];\n    const precision = Math.pow(10, precisionPoints);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]];\n      }\n    } // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n\n\n    const faceIndicesToRemove = [];\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    } // Use unique set of vertices\n\n\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n\n  setFromPoints(points) {\n    this.vertices = [];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n\n    return this;\n  }\n\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length; // tag faces\n\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    } // sort faces\n\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n\n    faces.sort(materialIndexSort); // sort uvs\n\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON'\n      }\n    }; // standard Geometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n\n      for (let key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    const vertices = [];\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false; // deprecated\n\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0); // isQuad\n\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash];\n      }\n\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash];\n      }\n\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash];\n      }\n\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n    data.data.faces = faces;\n    return data;\n  }\n\n  clone() {\n    /*\n    // Handle primitives\n    const parameters = this.parameters;\n    if ( parameters !== undefined ) {\n    const values = [];\n    for ( const key in parameters ) {\n    values.push( parameters[ key ] );\n    }\n    const geometry = Object.create( this.constructor.prototype );\n    this.constructor.apply( geometry, values );\n    return geometry;\n    }\n    return new this.constructor().copy( this );\n    */\n    return new Geometry().copy(this);\n  }\n\n  copy(source) {\n    // reset\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // name\n\n    this.name = source.name; // vertices\n\n    const vertices = source.vertices;\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    } // colors\n\n\n    const colors = source.colors;\n\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    } // faces\n\n\n    const faces = source.faces;\n\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    } // face vertex uvs\n\n\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = [];\n      }\n\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    } // morph targets\n\n\n    const morphTargets = source.morphTargets;\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name; // vertices\n\n      if (morphTargets[i].vertices !== undefined) {\n        morphTarget.vertices = [];\n\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      } // normals\n\n\n      if (morphTargets[i].normals !== undefined) {\n        morphTarget.normals = [];\n\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n\n      this.morphTargets.push(morphTarget);\n    } // morph normals\n\n\n    const morphNormals = source.morphNormals;\n\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {}; // vertex normals\n\n      if (morphNormals[i].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      } // face normals\n\n\n      if (morphNormals[i].faceNormals !== undefined) {\n        morphNormal.faceNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n\n      this.morphNormals.push(morphNormal);\n    } // skin weights\n\n\n    const skinWeights = source.skinWeights;\n\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    } // skin indices\n\n\n    const skinIndices = source.skinIndices;\n\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    } // line distances\n\n\n    const lineDistances = source.lineDistances;\n\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    } // bounding box\n\n\n    const boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    const boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // update flags\n\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    } // groups\n\n\n    buffergeometry.groups = geometry.groups; // morphs\n\n    for (let name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n\n      buffergeometry.morphAttributes[name] = array;\n    } // skinning\n\n\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n    } //\n\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return buffergeometry;\n  }\n\n  computeTangents() {\n    console.error('THREE.Geometry: .computeTangents() has been removed.');\n  }\n\n  computeLineDistances() {\n    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n}\n\nGeometry.createBufferGeometryFromObject = object => {\n  let buffergeometry = new BufferGeometry();\n  const geometry = object.geometry;\n\n  if (object.isPoints || object.isLine) {\n    const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n    const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n    buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n    buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\n\n    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n      const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n      buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n    }\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n  } else if (object.isMesh) {\n    buffergeometry = geometry.toBufferGeometry();\n  }\n\n  return buffergeometry;\n};\n\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = []; // this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = undefined;\n    const faces = geometry.faces;\n\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i]; // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n\n    if (group !== undefined) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n\n    this.groups = groups;\n  }\n\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\n\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.position = morphTargetsPosition;\n    }\n\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.normal = morphTargetsNormal;\n    } // skins\n\n\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length; //\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n    }\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n\n      const vertexColors = face.vertexColors;\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      } // morphs\n\n\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      } // skins\n\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return this;\n  }\n\n}\n\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n\n    return this;\n  }\n\n}\n\nexport { Face3, Geometry };\n", "import { ShaderMaterial, Material } from 'three';\nimport { getNodesKeys } from '../core/NodeUtils.js';\n\nclass NodeMaterial extends ShaderMaterial {\n  constructor() {\n    super();\n    this.type = this.constructor.name;\n    this.lights = true;\n  }\n\n  setDefaultValues(values) {\n    // This approach is to reuse the native refreshUniforms*\n    // and turn available the use of features like transmission and environment in core\n    let value;\n\n    for (const property in values) {\n      value = values[property];\n\n      if (this[property] === undefined) {\n        if (value && typeof value.clone === 'function') {\n          this[property] = value.clone();\n        } else {\n          this[property] = value;\n        }\n      }\n    }\n\n    Object.assign(this.defines, values.defines);\n  }\n\n  toJSON(meta) {\n    const isRoot = meta === undefined || typeof meta === 'string';\n\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    }\n\n    const data = Material.prototype.toJSON.call(this, meta);\n    const nodeKeys = getNodesKeys(this);\n    data.inputNodes = {};\n\n    for (const name of nodeKeys) {\n      data.inputNodes[name] = this[name].toJSON(meta).uuid;\n    } // TODO: Copied from Object3D.toJSON\n\n\n    function extractFromCache(cache) {\n      const values = [];\n\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n\n    return data;\n  }\n\n}\n\nNodeMaterial.prototype.isNodeMaterial = true;\n\nexport default NodeMaterial;\n", "import NodeMaterial from './NodeMaterial.js';\nimport { LineBasicMaterial } from 'three';\n\nconst defaultValues = new LineBasicMaterial();\n\nclass LineBasicNodeMaterial extends NodeMaterial {\n  constructor(parameters) {\n    super();\n    this.colorNode = null;\n    this.opacityNode = null;\n    this.alphaTestNode = null;\n    this.lightNode = null;\n    this.positionNode = null;\n    this.setDefaultValues(defaultValues);\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    this.colorNode = source.colorNode;\n    this.opacityNode = source.opacityNode;\n    this.alphaTestNode = source.alphaTestNode;\n    this.lightNode = source.lightNode;\n    this.positionNode = source.positionNode;\n    return super.copy(source);\n  }\n\n}\n\nLineBasicNodeMaterial.prototype.isLineBasicNodeMaterial = true;\n\nexport default LineBasicNodeMaterial;\n", "import NodeMaterial from './NodeMaterial.js';\nimport { MeshBasicMaterial } from 'three';\n\nconst defaultValues = new MeshBasicMaterial();\n\nclass MeshBasicNodeMaterial extends NodeMaterial {\n  constructor(parameters) {\n    super();\n    this.lights = true;\n    this.colorNode = null;\n    this.opacityNode = null;\n    this.alphaTestNode = null;\n    this.lightNode = null;\n    this.positionNode = null;\n    this.setDefaultValues(defaultValues);\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    this.colorNode = source.colorNode;\n    this.opacityNode = source.opacityNode;\n    this.alphaTestNode = source.alphaTestNode;\n    this.lightNode = source.lightNode;\n    this.positionNode = source.positionNode;\n    return super.copy(source);\n  }\n\n}\n\nMeshBasicNodeMaterial.prototype.isMeshBasicNodeMaterial = true;\n\nexport default MeshBasicNodeMaterial;\n", "import NodeMaterial from './NodeMaterial.js';\nimport { MeshStandardMaterial } from 'three';\n\nconst defaultValues = new MeshStandardMaterial();\nclass MeshStandardNodeMaterial extends NodeMaterial {\n  constructor(parameters) {\n    super();\n    this.colorNode = null;\n    this.opacityNode = null;\n    this.alphaTestNode = null;\n    this.normalNode = null;\n    this.emissiveNode = null;\n    this.metalnessNode = null;\n    this.roughnessNode = null;\n    this.clearcoatNode = null;\n    this.clearcoatRoughnessNode = null;\n    this.envNode = null;\n    this.lightNode = null;\n    this.positionNode = null;\n    this.setDefaultValues(defaultValues);\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    this.colorNode = source.colorNode;\n    this.opacityNode = source.opacityNode;\n    this.alphaTestNode = source.alphaTestNode;\n    this.normalNode = source.normalNode;\n    this.emissiveNode = source.emissiveNode;\n    this.metalnessNode = source.metalnessNode;\n    this.roughnessNode = source.roughnessNode;\n    this.clearcoatNode = source.clearcoatNode;\n    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;\n    this.envNode = source.envNode;\n    this.lightNode = source.lightNode;\n    this.positionNode = source.positionNode;\n    return super.copy(source);\n  }\n\n}\nMeshStandardNodeMaterial.prototype.isMeshStandardNodeMaterial = true;\n\nexport default MeshStandardNodeMaterial;\n", "import NodeMaterial from './NodeMaterial.js';\nimport { PointsMaterial } from 'three';\n\nconst defaultValues = new PointsMaterial();\n\nclass PointsNodeMaterial extends NodeMaterial {\n  constructor(parameters) {\n    super();\n    this.transparent = true;\n    this.colorNode = null;\n    this.opacityNode = null;\n    this.alphaTestNode = null;\n    this.lightNode = null;\n    this.sizeNode = null;\n    this.positionNode = null;\n    this.setDefaultValues(defaultValues);\n    this.setValues(parameters);\n  }\n\n  copy(source) {\n    this.colorNode = source.colorNode;\n    this.opacityNode = source.opacityNode;\n    this.alphaTestNode = source.alphaTestNode;\n    this.lightNode = source.lightNode;\n    this.sizeNode = source.sizeNode;\n    this.positionNode = source.positionNode;\n    return super.copy(source);\n  }\n\n}\n\nPointsNodeMaterial.prototype.isPointsNodeMaterial = true;\n\nexport default PointsNodeMaterial;\n"],
  "mappings": "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IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,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AAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,G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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqOA;AAAA;AAAA,IAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgKF;;;AC7aA,IAAM,SAAS,IAAI,QAAQ;A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",
  "names": ["exports", "module", "equal", "a", "b", "length", "i", "exports", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "Symbol", "exports", "module", "Symbol", "exports", "module", "exports", "module", "Symbol", "exports", "module", "type", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "DataView", "exports", "module", "Map", "exports", "module", "Promise", "exports", "module", "Set", "exports", "module", "WeakMap", "exports", "module", "DataView", "Map", "Promise", "Set", "WeakMap", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "Map", "exports", "module", "type", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "size", "exports", "module", "length", "exports", "module", "Map", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "length", "exports", "module", "exports", "module", "bitmask", "othValue", "exports", "module", "Uint8Array", "exports", "module", "exports", "module", "exports", "module", "Symbol", "Uint8Array", "bitmask", "exports", "module", "length", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "length", "type", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "bitmask", "exports", "module", "bitmask", "exports", "module", "bitmask", "exports", "module", "length", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "type", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "Symbol", "INFINITY", "exports", "module", "exports", "module", "exports", "module", "INFINITY", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "collection", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "buffer", "length", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "Uint8Array", "exports", "module", "buffer", "exports", "module", "exports", "module", "Symbol", "exports", "module", "buffer", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "bitmask", "key", "exports", "module", "exports", "exports", "exports", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "INFINITY", "sign", "exports", "module", "remainder", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "type", "exports", "module", "length", "exports", "module", "assign", "tokenLabel", "AbstractProduction", "exports", "NonTerminal", "Rule", "Alternative", "Option", "RepetitionMandatory", "RepetitionMandatoryWithSeparator", "Repetition", "RepetitionWithSeparator", "Alternation", "Terminal", "serializeGrammar", "serializeProduction", "GAstVisitor", "exports", "exports", "module", "collection", "exports", "module", "exports", "module", "length", "exports", "module", "collection", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "length", "exports", "exports", "RestWalker", "exports", "exports", "module", "Symbol", "exports", "module", "length", "exports", "module", "length", "exports", "module", "length", "exports", "module", "length", "exports", "module", "exports", "module", "Set", "INFINITY", "exports", "module", "length", "exports", "module", "exports", "exports", "ResyncFollowsWalker", "exports", "exports", "module", "exports", "module", "type", "i", "exports", "module", "require_first", "exports", "module", "exports", "module", "length", "exports", "module", "collection", "exports", "module", "negate", "exports", "module", "negate", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "length", "exports", "module", "length", "exports", "module", "collection", "exports", "module", "exports", "exports", "i", "CharCodeFinder", "exports", "type", "charCode", "EndAnchorFinder", "StartAnchorFinder", "_a", "i", "exports", "module", "length", "exports", "exports", "length", "LexerDefinitionErrorType", "exports", "Lexer", "_a", "i", "j", "length", "tokenLabel", "exports", "tokenName", "createToken", "createTokenInstance", "tokenMatcher", "exports", "_a", "exports", "GastRefResolverVisitor", "exports", "module", "length", "exports", "module", "collection", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "length", "AbstractNextPossibleTokensWalker", "exports", "NextAfterTokenWalker", "AbstractNextTerminalAfterProductionWalker", "NextTerminalAfterManyWalker", "NextTerminalAfterManySepWalker", "NextTerminalAfterAtLeastOneWalker", "NextTerminalAfterAtLeastOneSepWalker", "i", "PROD_TYPE", "exports", "getLookaheadPaths", "type", "tokenMatcher", "currAlt", "t", "j", "i", "RestDefinitionFinderWalker", "InsideDefinitionFinderVisitor", "size", "altIdx", "prefixKeys", "exports", "OccurrenceValidationCollector", "or", "OrCollector", "RepetitionCollector", "exports", "isRecognitionException", "exports", "RecognitionException", "MismatchedTokenException", "NoViableAltException", "NotAllInputParsedException", "EarlyExitException", "exports", "InRuleRecoveryException", "Recoverable", "exports", "LLkLookaheadStrategy", "_a", "exports", "LooksAhead", "_a", "exports", "DslMethodsCollectorVisitor", "or", "exports", "exports", "i", "j", "exports", "CstVisitorDefinitionError", "TreeBuilder", "exports", "LexerAdapter", "exports", "RecognizerApi", "exports", "RecognizerEngine", "invokeRuleWithTry", "exports", "ErrorHandler", "i", "exports", "ContentAssist", "exports", "GastRecorder", "i", "exports", "PerformanceTracer", "_a", "exports", "exports", "exports", "ParserDefinitionErrorType", "EMPTY_ALT", "Parser", "_b", "_a", "CstParser", "EmbeddedActionsParser", "exports", "CstNodeDefinitionGenerator", "definition", "exports", "module", "length", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "type", "t", "generateCstDts", "exports", "createSyntaxDiagramsCode", "_a", "_b", "exports", "exports", "clearCache", "Parser", "entry", "deepEqual", "deepEqual", "i", "name", "mix", "i", "attribute", "t", "distance", "min", "max", "j", "v1", "a", "b", "i", "i", "j", "v1", "i", "label", "step", "i", "vector", "color", "j", "vector2", "offset", "jl", "fromPoint", "toPoint", "size", "o", "j", "i", "label", "color", "type", "i", "j", "length", "min", "max", "element", "i", "j", "attribute", "buffer", "type", "Node", "type", "data", "type", "type", "attribute", "type", "type", "type", "type", "type", "type", "type", "type", "type", "texture", "type", "i", "type", "i", "type", "a", "b", "type", "a", "b", "type", "type", "nodeObject", "i", "bool", "uint", "int", "float", "texture", "a", "b", "type", "uv", "roughness", "uv", "i", "j", "options", "attribute", "texture", "buffer", "a", "color", "jl", "nodeIndex", "element", "matrix", "faces", "i", "length", "i", "i", "j", "jl", "MMDPhysics", "i", "world", "RigidBody", "t", "a", "v1", "t2", "vector", "MMDAnimationHelper", "i", "vector", "j", "jl", "max", "buffer", "color", "rotationMatrix", "color", "rotationMatrix", "visible", "updateRefractorPlane", "updateVirtualCamera", "dot", "positionView", "element", "size", "i", "uniforms", "invAspect", "texture", "distance", "color", "rotationMatrix", "resolution", "a", "b", "t", "i", "sign", "size", "size2", "i", "j", "t", "t2", "i2", "j2", "i", "uv", "length", "i", "color", "yAxis", "rotationMatrix", "color", "quat", "i", "j", "a", "b", "MeshSurfaceSampler", "i", "targetPosition", "matrix", "obb", "i", "j", "_v1", "_v2", "Capsule", "a", "b", "color", "b", "_v1", "_v2", "_plane", "_sphere", "Octree", "i", "j", "distance", "v1", "min", "max", "step", "i", "j", "color", "STATE", "_vector", "STATE", "i", "size", "i", "stdDev", "i", "i", "i", "j", "sigma", "i", "element", "_vector", "i", "j", "a", "b", "t", "a", "b", "i", "SphereGeometry", "size", "u", "v", "PlaneGeometry", "i", "j", "SelectionHelper", "SelectionBox", "frustum", "size", "i", "i", "XboneInf", "XAnimationInfo", "XAnimationObj", "XKeyFrameInfo", "XLoader", "_start", "FileLoader", "_end", "_obj", "b", "mod", "i", "resolve", "msg", "FileLoader", "jsContent", "binaryContent", "buffer", "texture", "type", "i", "a", "b", "FileLoader", "buffer", "matrix", "time", "j", "i", "a", "b", "t", "path", "v1", "length", "i2", "size", "bool", "uv", "_taskCache", "FileLoader", "texture", "buffer", "i", "jsContent", "binaryContent", "worker", "a", "b", "IFFParser", "length", "IFFParser", "length", "buffer", "length", "type", "texture", "i", "j", "size", "a", "i", "j", "type", "R", "Q", "b", "a", "_vector", "_start", "_end", "_closestPoint", "_box", "_v1", "_v1", "_v2", "matrix", "i", "j", "jl", "vector", "color", "uv", "uv2", "a", "b", "cb", "ab", "length", "attribute", "data", "defaultValues", "defaultValues", "defaultValues", "_defineProperty", "i", "_vector3", "type", "cb", "React", "world", "a", "size", "step", "t", "vec3", "matrix", "index"]
}
